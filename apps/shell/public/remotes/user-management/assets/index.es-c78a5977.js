function gs(i, e) {
  const t = new Set(i.split(","));
  return e ? (n) => t.has(n.toLowerCase()) : (n) => t.has(n);
}
const it = {}, Ja = [], yt = () => {
}, rS = () => !1, Ml = (i) => i.charCodeAt(0) === 111 && i.charCodeAt(1) === 110 && // uppercase letter
(i.charCodeAt(2) > 122 || i.charCodeAt(2) < 97), zu = (i) => i.startsWith("onUpdate:"), xt = Object.assign, af = (i, e) => {
  const t = i.indexOf(e);
  t > -1 && i.splice(t, 1);
}, hM = Object.prototype.hasOwnProperty, ke = (i, e) => hM.call(i, e), ve = Array.isArray, Wr = (i) => Fc(i) === "[object Map]", pM = (i) => Fc(i) === "[object Set]", be = (i) => typeof i == "function", St = (i) => typeof i == "string", Rc = (i) => typeof i == "symbol", at = (i) => i !== null && typeof i == "object", lf = (i) => (at(i) || be(i)) && be(i.then) && be(i.catch), gM = Object.prototype.toString, Fc = (i) => gM.call(i), df = (i) => Fc(i).slice(8, -1), mM = (i) => Fc(i) === "[object Object]", uf = (i) => St(i) && i !== "NaN" && i[0] !== "-" && "" + parseInt(i, 10) === i, pu = /* @__PURE__ */ gs(
  // the leading comma is intentional so empty string "" is also included
  ",key,ref,ref_for,ref_key,onVnodeBeforeMount,onVnodeMounted,onVnodeBeforeUpdate,onVnodeUpdated,onVnodeBeforeUnmount,onVnodeUnmounted"
), kc = (i) => {
  const e = /* @__PURE__ */ Object.create(null);
  return (t) => e[t] || (e[t] = i(t));
}, _M = /-(\w)/g, Yr = kc((i) => i.replace(_M, (e, t) => t ? t.toUpperCase() : "")), CM = /\B([A-Z])/g, Ks = kc(
  (i) => i.replace(CM, "-$1").toLowerCase()
), Vc = kc((i) => i.charAt(0).toUpperCase() + i.slice(1)), Co = kc((i) => i ? `on${Vc(i)}` : ""), Ko = (i, e) => !Object.is(i, e), va = (i, e) => {
  for (let t = 0; t < i.length; t++)
    i[t](e);
}, Ku = (i, e, t) => {
  Object.defineProperty(i, e, {
    configurable: !0,
    enumerable: !1,
    value: t
  });
}, vM = (i) => {
  const e = parseFloat(i);
  return isNaN(e) ? i : e;
};
let gv;
const cf = () => gv || (gv = typeof globalThis < "u" ? globalThis : typeof self < "u" ? self : typeof window < "u" ? window : typeof global < "u" ? global : {}), Sd = {
  TEXT: 1,
  1: "TEXT",
  CLASS: 2,
  2: "CLASS",
  STYLE: 4,
  4: "STYLE",
  PROPS: 8,
  8: "PROPS",
  FULL_PROPS: 16,
  16: "FULL_PROPS",
  NEED_HYDRATION: 32,
  32: "NEED_HYDRATION",
  STABLE_FRAGMENT: 64,
  64: "STABLE_FRAGMENT",
  KEYED_FRAGMENT: 128,
  128: "KEYED_FRAGMENT",
  UNKEYED_FRAGMENT: 256,
  256: "UNKEYED_FRAGMENT",
  NEED_PATCH: 512,
  512: "NEED_PATCH",
  DYNAMIC_SLOTS: 1024,
  1024: "DYNAMIC_SLOTS",
  DEV_ROOT_FRAGMENT: 2048,
  2048: "DEV_ROOT_FRAGMENT",
  HOISTED: -1,
  "-1": "HOISTED",
  BAIL: -2,
  "-2": "BAIL"
};
function hf(i) {
  if (ve(i)) {
    const e = {};
    for (let t = 0; t < i.length; t++) {
      const n = i[t], s = St(n) ? wM(n) : hf(n);
      if (s)
        for (const o in s)
          e[o] = s[o];
    }
    return e;
  } else if (St(i) || at(i))
    return i;
}
const xM = /;(?![^(]*\))/g, yM = /:([^]+)/, bM = /\/\*[^]*?\*\//g;
function wM(i) {
  const e = {};
  return i.replace(bM, "").split(xM).forEach((t) => {
    if (t) {
      const n = t.split(yM);
      n.length > 1 && (e[n[0].trim()] = n[1].trim());
    }
  }), e;
}
function pf(i) {
  let e = "";
  if (St(i))
    e = i;
  else if (ve(i))
    for (let t = 0; t < i.length; t++) {
      const n = pf(i[t]);
      n && (e += n + " ");
    }
  else if (at(i))
    for (const t in i)
      i[t] && (e += t + " ");
  return e.trim();
}
const AM = "itemscope,allowfullscreen,formnovalidate,ismap,nomodule,novalidate,readonly", RM = /* @__PURE__ */ gs(AM);
function aS(i) {
  return !!i || i === "";
}
let ti;
class FM {
  constructor(e = !1) {
    this.detached = e, this._active = !0, this.effects = [], this.cleanups = [], this.parent = ti, !e && ti && (this.index = (ti.scopes || (ti.scopes = [])).push(
      this
    ) - 1);
  }
  get active() {
    return this._active;
  }
  run(e) {
    if (this._active) {
      const t = ti;
      try {
        return ti = this, e();
      } finally {
        ti = t;
      }
    }
  }
  /**
   * This should only be called on non-detached scopes
   * @internal
   */
  on() {
    ti = this;
  }
  /**
   * This should only be called on non-detached scopes
   * @internal
   */
  off() {
    ti = this.parent;
  }
  stop(e) {
    if (this._active) {
      let t, n;
      for (t = 0, n = this.effects.length; t < n; t++)
        this.effects[t].stop();
      for (t = 0, n = this.cleanups.length; t < n; t++)
        this.cleanups[t]();
      if (this.scopes)
        for (t = 0, n = this.scopes.length; t < n; t++)
          this.scopes[t].stop(!0);
      if (!this.detached && this.parent && !e) {
        const s = this.parent.scopes.pop();
        s && s !== this && (this.parent.scopes[this.index] = s, s.index = this.index);
      }
      this.parent = void 0, this._active = !1;
    }
  }
}
function kM(i, e = ti) {
  e && e.active && e.effects.push(i);
}
function VM() {
  return ti;
}
let To;
class gf {
  constructor(e, t, n, s) {
    this.fn = e, this.trigger = t, this.scheduler = n, this.active = !0, this.deps = [], this._dirtyLevel = 3, this._trackId = 0, this._runnings = 0, this._queryings = 0, this._depsLength = 0, kM(this, s);
  }
  get dirty() {
    if (this._dirtyLevel === 1) {
      this._dirtyLevel = 0, this._queryings++, eo();
      for (const e of this.deps)
        if (e.computed && (PM(e.computed), this._dirtyLevel >= 2))
          break;
      to(), this._queryings--;
    }
    return this._dirtyLevel >= 2;
  }
  set dirty(e) {
    this._dirtyLevel = e ? 3 : 0;
  }
  run() {
    if (this._dirtyLevel = 0, !this.active)
      return this.fn();
    let e = Ls, t = To;
    try {
      return Ls = !0, To = this, this._runnings++, mv(this), this.fn();
    } finally {
      fv(this), this._runnings--, To = t, Ls = e;
    }
  }
  stop() {
    var e;
    this.active && (mv(this), fv(this), (e = this.onStop) == null || e.call(this), this.active = !1);
  }
}
function PM(i) {
  return i.value;
}
function mv(i) {
  i._trackId++, i._depsLength = 0;
}
function fv(i) {
  if (i.deps && i.deps.length > i._depsLength) {
    for (let e = i._depsLength; e < i.deps.length; e++)
      lS(i.deps[e], i);
    i.deps.length = i._depsLength;
  }
}
function lS(i, e) {
  const t = i.get(e);
  t !== void 0 && e._trackId !== t && (i.delete(e), i.size === 0 && i.cleanup());
}
let Ls = !0, _g = 0;
const dS = [];
function eo() {
  dS.push(Ls), Ls = !1;
}
function to() {
  const i = dS.pop();
  Ls = i === void 0 ? !0 : i;
}
function mf() {
  _g++;
}
function ff() {
  for (_g--; !_g && Cg.length; )
    Cg.shift()();
}
function uS(i, e, t) {
  if (e.get(i) !== i._trackId) {
    e.set(i, i._trackId);
    const s = i.deps[i._depsLength];
    s !== e ? (s && lS(s, i), i.deps[i._depsLength++] = e) : i._depsLength++;
  }
}
const Cg = [];
function cS(i, e, t) {
  mf();
  for (const s of i.keys())
    if (!(!s.allowRecurse && s._runnings) && s._dirtyLevel < e && (!s._runnings || e !== 2)) {
      const o = s._dirtyLevel;
      s._dirtyLevel = e, o === 0 && (!s._queryings || e !== 2) && (s.trigger(), s.scheduler && Cg.push(s.scheduler));
    }
  ff();
}
const hS = (i, e) => {
  const t = /* @__PURE__ */ new Map();
  return t.cleanup = i, t.computed = e, t;
}, vg = /* @__PURE__ */ new WeakMap(), Oo = Symbol(""), xg = Symbol("");
function zt(i, e, t) {
  if (Ls && To) {
    let n = vg.get(i);
    n || vg.set(i, n = /* @__PURE__ */ new Map());
    let s = n.get(t);
    s || n.set(t, s = hS(() => n.delete(t))), uS(
      To,
      s);
  }
}
function Ti(i, e, t, n, s, o) {
  const r = vg.get(i);
  if (!r)
    return;
  let a = [];
  if (e === "clear")
    a = [...r.values()];
  else if (t === "length" && ve(i)) {
    const l = Number(n);
    r.forEach((d, u) => {
      (u === "length" || !Rc(u) && u >= l) && a.push(d);
    });
  } else
    switch (t !== void 0 && a.push(r.get(t)), e) {
      case "add":
        ve(i) ? uf(t) && a.push(r.get("length")) : (a.push(r.get(Oo)), Wr(i) && a.push(r.get(xg)));
        break;
      case "delete":
        ve(i) || (a.push(r.get(Oo)), Wr(i) && a.push(r.get(xg)));
        break;
      case "set":
        Wr(i) && a.push(r.get(Oo));
        break;
    }
  mf();
  for (const l of a)
    l && cS(
      l,
      3);
  ff();
}
const MM = /* @__PURE__ */ gs("__proto__,__v_isRef,__isVue"), pS = new Set(
  /* @__PURE__ */ Object.getOwnPropertyNames(Symbol).filter((i) => i !== "arguments" && i !== "caller").map((i) => Symbol[i]).filter(Rc)
), _v = /* @__PURE__ */ BM();
function BM() {
  const i = {};
  return ["includes", "indexOf", "lastIndexOf"].forEach((e) => {
    i[e] = function(...t) {
      const n = De(this);
      for (let o = 0, r = this.length; o < r; o++)
        zt(n, "get", o + "");
      const s = n[e](...t);
      return s === -1 || s === !1 ? n[e](...t.map(De)) : s;
    };
  }), ["push", "pop", "shift", "unshift", "splice"].forEach((e) => {
    i[e] = function(...t) {
      eo(), mf();
      const n = De(this)[e].apply(this, t);
      return ff(), to(), n;
    };
  }), i;
}
function $M(i) {
  const e = De(this);
  return zt(e, "has", i), e.hasOwnProperty(i);
}
class gS {
  constructor(e = !1, t = !1) {
    this._isReadonly = e, this._shallow = t;
  }
  get(e, t, n) {
    const s = this._isReadonly, o = this._shallow;
    if (t === "__v_isReactive")
      return !s;
    if (t === "__v_isReadonly")
      return s;
    if (t === "__v_isShallow")
      return o;
    if (t === "__v_raw")
      return n === (s ? o ? yS : xS : o ? vS : CS).get(e) || // receiver is not the reactive proxy, but has the same prototype
      // this means the reciever is a user proxy of the reactive proxy
      Object.getPrototypeOf(e) === Object.getPrototypeOf(n) ? e : void 0;
    const r = ve(e);
    if (!s) {
      if (r && ke(_v, t))
        return Reflect.get(_v, t, n);
      if (t === "hasOwnProperty")
        return $M;
    }
    const a = Reflect.get(e, t, n);
    return (Rc(t) ? pS.has(t) : MM(t)) || (s || zt(e, "get", t), o) ? a : Jt(a) ? r && uf(t) ? a : a.value : at(a) ? s ? bS(a) : Cf(a) : a;
  }
}
class mS extends gS {
  constructor(e = !1) {
    super(!1, e);
  }
  set(e, t, n, s) {
    let o = e[t];
    if (!this._shallow) {
      const l = Go(o);
      if (!yg(n) && !Go(n) && (o = De(o), n = De(n)), !ve(e) && Jt(o) && !Jt(n))
        return l ? !1 : (o.value = n, !0);
    }
    const r = ve(e) && uf(t) ? Number(t) < e.length : ke(e, t), a = Reflect.set(e, t, n, s);
    return e === De(s) && (r ? Ko(n, o) && Ti(e, "set", t, n) : Ti(e, "add", t, n)), a;
  }
  deleteProperty(e, t) {
    const n = ke(e, t); e[t]; const o = Reflect.deleteProperty(e, t);
    return o && n && Ti(e, "delete", t, void 0), o;
  }
  has(e, t) {
    const n = Reflect.has(e, t);
    return (!Rc(t) || !pS.has(t)) && zt(e, "has", t), n;
  }
  ownKeys(e) {
    return zt(
      e,
      "iterate",
      ve(e) ? "length" : Oo
    ), Reflect.ownKeys(e);
  }
}
class fS extends gS {
  constructor(e = !1) {
    super(!0, e);
  }
  set(e, t) {
    return !0;
  }
  deleteProperty(e, t) {
    return !0;
  }
}
const NM = /* @__PURE__ */ new mS(), LM = /* @__PURE__ */ new fS(), HM = /* @__PURE__ */ new mS(
  !0
), _f = (i) => i, Pc = (i) => Reflect.getPrototypeOf(i);
function Ed(i, e, t = !1, n = !1) {
  i = i.__v_raw;
  const s = De(i), o = De(e);
  t || (Ko(e, o) && zt(s, "get", e), zt(s, "get", o));
  const { has: r } = Pc(s), a = n ? _f : t ? xf : vf;
  if (r.call(s, e))
    return a(i.get(e));
  if (r.call(s, o))
    return a(i.get(o));
  i !== s && i.get(e);
}
function Id(i, e = !1) {
  const t = this.__v_raw, n = De(t), s = De(i);
  return e || (Ko(i, s) && zt(n, "has", i), zt(n, "has", s)), i === s ? t.has(i) : t.has(i) || t.has(s);
}
function Dd(i, e = !1) {
  return i = i.__v_raw, !e && zt(De(i), "iterate", Oo), Reflect.get(i, "size", i);
}
function Cv(i) {
  i = De(i);
  const e = De(this);
  return Pc(e).has.call(e, i) || (e.add(i), Ti(e, "add", i, i)), this;
}
function vv(i, e) {
  e = De(e);
  const t = De(this), { has: n, get: s } = Pc(t);
  let o = n.call(t, i);
  o ? "production" !== "production"  : (i = De(i), o = n.call(t, i));
  const r = s.call(t, i);
  return t.set(i, e), o ? Ko(e, r) && Ti(t, "set", i, e) : Ti(t, "add", i, e), this;
}
function xv(i) {
  const e = De(this), { has: t, get: n } = Pc(e);
  let s = t.call(e, i);
  s ? "production" !== "production"  : (i = De(i), s = t.call(e, i));
  n ? n.call(e, i) : void 0; const r = e.delete(i);
  return s && Ti(e, "delete", i, void 0), r;
}
function yv() {
  const i = De(this), e = i.size !== 0, n = i.clear();
  return e && Ti(i, "clear", void 0, void 0), n;
}
function Td(i, e) {
  return function(n, s) {
    const o = this, r = o.__v_raw, a = De(r), l = e ? _f : i ? xf : vf;
    return !i && zt(a, "iterate", Oo), r.forEach((d, u) => n.call(s, l(d), l(u), o));
  };
}
function Od(i, e, t) {
  return function(...n) {
    const s = this.__v_raw, o = De(s), r = Wr(o), a = i === "entries" || i === Symbol.iterator && r, l = i === "keys" && r, d = s[i](...n), u = t ? _f : e ? xf : vf;
    return !e && zt(
      o,
      "iterate",
      l ? xg : Oo
    ), {
      // iterator protocol
      next() {
        const { value: c, done: h } = d.next();
        return h ? { value: c, done: h } : {
          value: a ? [u(c[0]), u(c[1])] : u(c),
          done: h
        };
      },
      // iterable protocol
      [Symbol.iterator]() {
        return this;
      }
    };
  };
}
function bs(i) {
  return function(...e) {
    return i === "delete" ? !1 : i === "clear" ? void 0 : this;
  };
}
function zM() {
  const i = {
    get(o) {
      return Ed(this, o);
    },
    get size() {
      return Dd(this);
    },
    has: Id,
    add: Cv,
    set: vv,
    delete: xv,
    clear: yv,
    forEach: Td(!1, !1)
  }, e = {
    get(o) {
      return Ed(this, o, !1, !0);
    },
    get size() {
      return Dd(this);
    },
    has: Id,
    add: Cv,
    set: vv,
    delete: xv,
    clear: yv,
    forEach: Td(!1, !0)
  }, t = {
    get(o) {
      return Ed(this, o, !0);
    },
    get size() {
      return Dd(this, !0);
    },
    has(o) {
      return Id.call(this, o, !0);
    },
    add: bs("add"),
    set: bs("set"),
    delete: bs("delete"),
    clear: bs("clear"),
    forEach: Td(!0, !1)
  }, n = {
    get(o) {
      return Ed(this, o, !0, !0);
    },
    get size() {
      return Dd(this, !0);
    },
    has(o) {
      return Id.call(this, o, !0);
    },
    add: bs("add"),
    set: bs("set"),
    delete: bs("delete"),
    clear: bs("clear"),
    forEach: Td(!0, !0)
  };
  return ["keys", "values", "entries", Symbol.iterator].forEach((o) => {
    i[o] = Od(
      o,
      !1,
      !1
    ), t[o] = Od(
      o,
      !0,
      !1
    ), e[o] = Od(
      o,
      !1,
      !0
    ), n[o] = Od(
      o,
      !0,
      !0
    );
  }), [
    i,
    t,
    e,
    n
  ];
}
const [
  KM,
  GM,
  UM,
  jM
] = /* @__PURE__ */ zM();
function Mc(i, e) {
  const t = e ? i ? jM : UM : i ? GM : KM;
  return (n, s, o) => s === "__v_isReactive" ? !i : s === "__v_isReadonly" ? i : s === "__v_raw" ? n : Reflect.get(
    ke(t, s) && s in n ? t : n,
    s,
    o
  );
}
const qM = {
  get: /* @__PURE__ */ Mc(!1, !1)
}, YM = {
  get: /* @__PURE__ */ Mc(!1, !0)
}, XM = {
  get: /* @__PURE__ */ Mc(!0, !1)
};
const CS = /* @__PURE__ */ new WeakMap(), vS = /* @__PURE__ */ new WeakMap(), xS = /* @__PURE__ */ new WeakMap(), yS = /* @__PURE__ */ new WeakMap();
function QM(i) {
  switch (i) {
    case "Object":
    case "Array":
      return 1;
    case "Map":
    case "Set":
    case "WeakMap":
    case "WeakSet":
      return 2;
    default:
      return 0;
  }
}
function JM(i) {
  return i.__v_skip || !Object.isExtensible(i) ? 0 : QM(df(i));
}
function Cf(i) {
  return Go(i) ? i : Bc(
    i,
    !1,
    NM,
    qM,
    CS
  );
}
function eB(i) {
  return Bc(
    i,
    !1,
    HM,
    YM,
    vS
  );
}
function bS(i) {
  return Bc(
    i,
    !0,
    LM,
    XM,
    xS
  );
}
function Bc(i, e, t, n, s) {
  if (!at(i))
    return i;
  if (i.__v_raw && !(e && i.__v_isReactive))
    return i;
  const o = s.get(i);
  if (o)
    return o;
  const r = JM(i);
  if (r === 0)
    return i;
  const a = new Proxy(
    i,
    r === 2 ? n : t
  );
  return s.set(i, a), a;
}
function Ao(i) {
  return Go(i) ? Ao(i.__v_raw) : !!(i && i.__v_isReactive);
}
function Go(i) {
  return !!(i && i.__v_isReadonly);
}
function yg(i) {
  return !!(i && i.__v_isShallow);
}
function bg(i) {
  return Ao(i) || Go(i);
}
function De(i) {
  const e = i && i.__v_raw;
  return e ? De(e) : i;
}
function wS(i) {
  return Ku(i, "__v_skip", !0), i;
}
const vf = (i) => at(i) ? Cf(i) : i, xf = (i) => at(i) ? bS(i) : i;
class SS {
  constructor(e, t, n, s) {
    this._setter = t, this.dep = void 0, this.__v_isRef = !0, this.__v_isReadonly = !1, this.effect = new gf(
      () => e(this._value),
      () => bv(this, 1)
    ), this.effect.computed = this, this.effect.active = this._cacheable = !s, this.__v_isReadonly = n;
  }
  get value() {
    const e = De(this);
    return nB(e), (!e._cacheable || e.effect.dirty) && Ko(e._value, e._value = e.effect.run()) && bv(e, 2), e._value;
  }
  set value(e) {
    this._setter(e);
  }
  // #region polyfill _dirty for backward compatibility third party code for Vue <= 3.3.x
  get _dirty() {
    return this.effect.dirty;
  }
  set _dirty(e) {
    this.effect.dirty = e;
  }
  // #endregion
}
function tB(i, e, t = !1) {
  let n, s;
  const o = be(i);
  o ? (n = i, s = yt) : (n = i.get, s = i.set);
  const r = new SS(n, s, o || !s, t);
  return r;
}
function nB(i) {
  Ls && To && (i = De(i), uS(
    To,
    i.dep || (i.dep = hS(
      () => i.dep = void 0,
      i instanceof SS ? i : void 0
    ))));
}
function bv(i, e = 3, t) {
  i = De(i);
  const n = i.dep;
  n && cS(
    n,
    e);
}
function Jt(i) {
  return !!(i && i.__v_isRef === !0);
}
function iB(i) {
  return Jt(i) ? i.value : i;
}
const sB = {
  get: (i, e, t) => iB(Reflect.get(i, e, t)),
  set: (i, e, t, n) => {
    const s = i[e];
    return Jt(s) && !Jt(t) ? (s.value = t, !0) : Reflect.set(i, e, t, n);
  }
};
function ES(i) {
  return Ao(i) ? i : new Proxy(i, sB);
}
const Ro = [];
function Q(i, ...e) {
  eo();
  const t = Ro.length ? Ro[Ro.length - 1].component : null, n = t && t.appContext.config.warnHandler, s = oB();
  if (n)
    ts(
      n,
      t,
      11,
      [
        i + e.join(""),
        t && t.proxy,
        s.map(
          ({ vnode: o }) => `at <${zc(t, o.type)}>`
        ).join(`
`),
        s
      ]
    );
  else {
    const o = [`[Vue warn]: ${i}`, ...e];
    s.length && o.push(`
`, ...rB(s)), console.warn(...o);
  }
  to();
}
function oB() {
  let i = Ro[Ro.length - 1];
  if (!i)
    return [];
  const e = [];
  for (; i; ) {
    const t = e[0];
    t && t.vnode === i ? t.recurseCount++ : e.push({
      vnode: i,
      recurseCount: 0
    });
    const n = i.component && i.component.parent;
    i = n && n.vnode;
  }
  return e;
}
function rB(i) {
  const e = [];
  return i.forEach((t, n) => {
    e.push(...n === 0 ? [] : [`
`], ...aB(t));
  }), e;
}
function aB({ vnode: i, recurseCount: e }) {
  const t = e > 0 ? `... (${e} recursive calls)` : "", n = i.component ? i.component.parent == null : !1, s = ` at <${zc(
    i.component,
    i.type,
    n
  )}`, o = ">" + t;
  return i.props ? [s, ...lB(i.props), o] : [s + o];
}
function lB(i) {
  const e = [], t = Object.keys(i);
  return t.slice(0, 3).forEach((n) => {
    e.push(...IS(n, i[n]));
  }), t.length > 3 && e.push(" ..."), e;
}
function IS(i, e, t) {
  return St(e) ? (e = JSON.stringify(e), t ? e : [`${i}=${e}`]) : typeof e == "number" || typeof e == "boolean" || e == null ? t ? e : [`${i}=${e}`] : Jt(e) ? (e = IS(i, De(e.value), !0), t ? e : [`${i}=Ref<`, e, ">"]) : be(e) ? [`${i}=fn${e.name ? `<${e.name}>` : ""}`] : (e = De(e), t ? e : [`${i}=`, e]);
}
function ts(i, e, t, n) {
  let s;
  try {
    s = n ? i(...n) : i();
  } catch (o) {
    Bl(o, e, t);
  }
  return s;
}
function di(i, e, t, n) {
  if (be(i)) {
    const o = ts(i, e, t, n);
    return o && lf(o) && o.catch((r) => {
      Bl(r, e, t);
    }), o;
  }
  const s = [];
  for (let o = 0; o < i.length; o++)
    s.push(di(i[o], e, t, n));
  return s;
}
function Bl(i, e, t, n = !0) {
  const s = e ? e.vnode : null;
  if (e) {
    let o = e.parent;
    const r = e.proxy, a = `https://vuejs.org/errors/#runtime-${t}`;
    for (; o; ) {
      const d = o.ec;
      if (d) {
        for (let u = 0; u < d.length; u++)
          if (d[u](i, r, a) === !1)
            return;
      }
      o = o.parent;
    }
    const l = e.appContext.config.errorHandler;
    if (l) {
      ts(
        l,
        null,
        10,
        [i, r, a]
      );
      return;
    }
  }
  dB(i, t, s, n);
}
function dB(i, e, t, n = !0) {
  console.error(i);
}
let ml = !1, wg = !1;
const Yt = [];
let Si = 0;
const zr = [];
let yi = null, Ts = 0;
const DS = /* @__PURE__ */ Promise.resolve();
let bf = null;
function cB(i) {
  const e = bf || DS;
  return i ? e.then(this ? i.bind(this) : i) : e;
}
function hB(i) {
  let e = Si + 1, t = Yt.length;
  for (; e < t; ) {
    const n = e + t >>> 1, s = Yt[n], o = fl(s);
    o < i || o === i && s.pre ? e = n + 1 : t = n;
  }
  return e;
}
function $c(i) {
  (!Yt.length || !Yt.includes(
    i,
    ml && i.allowRecurse ? Si + 1 : Si
  )) && (i.id == null ? Yt.push(i) : Yt.splice(hB(i.id), 0, i), TS());
}
function TS() {
  !ml && !wg && (wg = !0, bf = DS.then(RS));
}
function pB(i) {
  const e = Yt.indexOf(i);
  e > Si && Yt.splice(e, 1);
}
function OS(i) {
  ve(i) ? zr.push(...i) : (!yi || !yi.includes(
    i,
    i.allowRecurse ? Ts + 1 : Ts
  )) && zr.push(i), TS();
}
function wv(i, e, t = ml ? Si + 1 : 0) {
  for ("production" !== "production" ; t < Yt.length; t++) {
    const n = Yt[t];
    if (n && n.pre) {
      if (i && n.id !== i.uid || "production" !== "production" )
        continue;
      Yt.splice(t, 1), t--, n();
    }
  }
}
function AS(i) {
  if (zr.length) {
    const e = [...new Set(zr)];
    if (zr.length = 0, yi) {
      yi.push(...e);
      return;
    }
    for (yi = e, yi.sort((t, n) => fl(t) - fl(n)), Ts = 0; Ts < yi.length; Ts++)
      yi[Ts]();
    yi = null, Ts = 0;
  }
}
const fl = (i) => i.id == null ? 1 / 0 : i.id, gB = (i, e) => {
  const t = fl(i) - fl(e);
  if (t === 0) {
    if (i.pre && !e.pre)
      return -1;
    if (e.pre && !i.pre)
      return 1;
  }
  return t;
};
function RS(i) {
  wg = !1, ml = !0, Yt.sort(gB);
  const e = yt;
  try {
    for (Si = 0; Si < Yt.length; Si++) {
      const t = Yt[Si];
      if (t && t.active !== !1) {
        if ("production" !== "production" && e(t))
          ;
        ts(t, null, 14);
      }
    }
  } finally {
    Si = 0, Yt.length = 0, AS(), ml = !1, bf = null, (Yt.length || zr.length) && RS();
  }
}
function DB(i, e, ...t) {
  if (i.isUnmounted)
    return;
  const n = i.vnode.props || it;
  let s = t;
  const o = e.startsWith("update:"), r = o && e.slice(7);
  if (r && r in n) {
    const u = `${r === "modelValue" ? "model" : r}Modifiers`, { number: c, trim: h } = n[u] || it;
    h && (s = t.map((g) => St(g) ? g.trim() : g)), c && (s = t.map(vM));
  }
  let a, l = n[a = Co(e)] || // also try camelCase event handler (#2249)
  n[a = Co(Yr(e))];
  !l && o && (l = n[a = Co(Ks(e))]), l && di(
    l,
    i,
    6,
    s
  );
  const d = n[a + "Once"];
  if (d) {
    if (!i.emitted)
      i.emitted = {};
    else if (i.emitted[a])
      return;
    i.emitted[a] = !0, di(
      d,
      i,
      6,
      s
    );
  }
}
function PS(i, e, t = !1) {
  const n = e.emitsCache, s = n.get(i);
  if (s !== void 0)
    return s;
  const o = i.emits;
  let r = {}, a = !1;
  if (!be(i)) {
    const l = (d) => {
      const u = PS(d, e, !0);
      u && (a = !0, xt(r, u));
    };
    !t && e.mixins.length && e.mixins.forEach(l), i.extends && l(i.extends), i.mixins && i.mixins.forEach(l);
  }
  return !o && !a ? (at(i) && n.set(i, null), null) : (ve(o) ? o.forEach((l) => r[l] = null) : xt(r, o), at(i) && n.set(i, r), r);
}
function Nc(i, e) {
  return !i || !Ml(e) ? !1 : (e = e.slice(2).replace(/Once$/, ""), ke(i, e[0].toLowerCase() + e.slice(1)) || ke(i, Ks(e)) || ke(i, e));
}
let $n = null, MS = null;
function Gu(i) {
  const e = $n;
  return $n = i, MS = i && i.type.__scopeId || null, e;
}
function TB(i, e = $n, t) {
  if (!e || i._n)
    return i;
  const n = (...s) => {
    n._d && Mv(-1);
    const o = Gu(e);
    let r;
    try {
      r = i(...s);
    } finally {
      Gu(o), n._d && Mv(1);
    }
    return r;
  };
  return n._n = !0, n._c = !0, n._d = !0, n;
}
function Uu() {
}
function $h(i) {
  const {
    type: e,
    vnode: t,
    proxy: n,
    withProxy: s,
    props: o,
    propsOptions: [r],
    slots: a,
    attrs: l,
    emit: d,
    render: u,
    renderCache: c,
    data: h,
    setupState: g,
    ctx: m,
    inheritAttrs: C
  } = i;
  let v, E;
  const T = Gu(i);
  try {
    if (t.shapeFlag & 4) {
      const G = s || n, H = "production" !== "production" && g.__isScriptSetup ? new Proxy(G, {
        get(ce, re, me) {
          return Q(
            `Property '${String(
              re
            )}' was accessed via 'this'. Avoid using 'this' in templates.`
          ), Reflect.get(ce, re, me);
        }
      }) : G;
      v = ii(
        u.call(
          H,
          G,
          c,
          o,
          g,
          h,
          m
        )
      ), E = l;
    } else {
      const G = e;
      "production" !== "production" && l === o && Uu(), v = ii(
        G.length > 1 ? G(
          o,
          "production" !== "production" ? {
            get attrs() {
              return Uu(), l;
            },
            slots: a,
            emit: d
          } : { attrs: l, slots: a, emit: d }
        ) : G(
          o,
          null
          /* we know it doesn't need it */
        )
      ), E = e.props ? l : AB(l);
    }
  } catch (G) {
    Bl(G, i, 1), v = ai(Ln);
  }
  let V = v;
  if (E && C !== !1) {
    const G = Object.keys(E), { shapeFlag: H } = V;
    if (G.length) {
      if (H & 7)
        r && G.some(zu) && (E = RB(
          E,
          r
        )), V = Gs(V, E);
    }
  }
  return t.dirs && (V = Gs(V), V.dirs = V.dirs ? V.dirs.concat(t.dirs) : t.dirs), t.transition && (V.transition = t.transition), v = V, Gu(T), v;
}
const AB = (i) => {
  let e;
  for (const t in i)
    (t === "class" || t === "style" || Ml(t)) && ((e || (e = {}))[t] = i[t]);
  return e;
}, RB = (i, e) => {
  const t = {};
  for (const n in i)
    (!zu(n) || !(n.slice(9) in e)) && (t[n] = i[n]);
  return t;
};
function FB(i, e, t) {
  const { props: n, children: s, component: o } = i, { props: r, children: a, patchFlag: l } = e, d = o.emitsOptions;
  if (e.dirs || e.transition)
    return !0;
  if (t && l >= 0) {
    if (l & 1024)
      return !0;
    if (l & 16)
      return n ? Iv(n, r, d) : !!r;
    if (l & 8) {
      const u = e.dynamicProps;
      for (let c = 0; c < u.length; c++) {
        const h = u[c];
        if (r[h] !== n[h] && !Nc(d, h))
          return !0;
      }
    }
  } else
    return (s || a) && (!a || !a.$stable) ? !0 : n === r ? !1 : n ? r ? Iv(n, r, d) : !0 : !!r;
  return !1;
}
function Iv(i, e, t) {
  const n = Object.keys(e);
  if (n.length !== Object.keys(i).length)
    return !0;
  for (let s = 0; s < n.length; s++) {
    const o = n[s];
    if (e[o] !== i[o] && !Nc(t, o))
      return !0;
  }
  return !1;
}
function kB({ vnode: i, parent: e }, t) {
  if (t)
    for (; e; ) {
      const n = e.subTree;
      if (n.suspense && n.suspense.activeBranch === i && (n.el = i.el), n === i)
        (i = e.vnode).el = t, e = e.parent;
      else
        break;
    }
}
const VB = Symbol.for("v-ndc"), PB = (i) => i.__isSuspense;
function MB(i, e) {
  e && e.pendingBranch ? ve(i) ? e.effects.push(...i) : e.effects.push(i) : OS(i);
}
const Ad = {};
function Nh(i, e, t) {
  return $S(i, e, t);
}
function $S(i, e, {
  immediate: t,
  deep: n,
  flush: s,
  once: o,
  onTrack: r,
  onTrigger: a
} = it) {
  var l;
  if (e && o) {
    const H = e;
    e = (...ce) => {
      H(...ce), G();
    };
  }
  const u = VM() === ((l = Ht) == null ? void 0 : l.scope) ? Ht : null;
  let c, h = !1, g = !1;
  if (Jt(i) ? (c = () => i.value, h = yg(i)) : Ao(i) ? (c = () => i, n = !0) : ve(i) ? (g = !0, h = i.some((H) => Ao(H) || yg(H)), c = () => i.map((H) => {
    if (Jt(H))
      return H.value;
    if (Ao(H))
      return kr(H);
    if (be(H))
      return ts(H, u, 2);
  })) : be(i) ? e ? c = () => ts(i, u, 2) : c = () => {
    if (!(u && u.isUnmounted))
      return m && m(), di(
        i,
        u,
        3,
        [C]
      );
  } : (c = yt, "production" !== "production" ), e && n) {
    const H = c;
    c = () => kr(H());
  }
  let m, C = (H) => {
    m = $.onStop = () => {
      ts(H, u, 4), m = $.onStop = void 0;
    };
  }, v;
  if (Wc)
    if (C = yt, e ? t && di(e, u, 3, [
      c(),
      g ? [] : void 0,
      C
    ]) : c(), s === "sync") {
      const H = z$();
      v = H.__watcherHandles || (H.__watcherHandles = []);
    } else
      return yt;
  let E = g ? new Array(i.length).fill(Ad) : Ad;
  const T = () => {
    if (!(!$.active || !$.dirty))
      if (e) {
        const H = $.run();
        (n || h || (g ? H.some((ce, re) => Ko(ce, E[re])) : Ko(H, E))) && (m && m(), di(e, u, 3, [
          H,
          // pass undefined as the old value when it's changed for the first time
          E === Ad ? void 0 : g && E[0] === Ad ? [] : E,
          C
        ]), E = H);
      } else
        $.run();
  };
  T.allowRecurse = !!e;
  let V;
  s === "sync" ? V = T : s === "post" ? V = () => fn(T, u && u.suspense) : (T.pre = !0, u && (T.id = u.uid), V = () => $c(T));
  const $ = new gf(c, yt, V), G = () => {
    $.stop(), u && u.scope && af(u.scope.effects, $);
  };
  return e ? t ? T() : E = $.run() : s === "post" ? fn(
    $.run.bind($),
    u && u.suspense
  ) : $.run(), v && v.push(G), G;
}
function BB(i, e, t) {
  const n = this.proxy, s = St(i) ? i.includes(".") ? NS(n, i) : () => n[i] : i.bind(n, n);
  let o;
  be(e) ? o = e : (o = e.handler, t = e);
  const r = Ht;
  Xr(this);
  const a = $S(s, o.bind(n), t);
  return r ? Xr(r) : Vo(), a;
}
function NS(i, e) {
  const t = e.split(".");
  return () => {
    let n = i;
    for (let s = 0; s < t.length && n; s++)
      n = n[t[s]];
    return n;
  };
}
function kr(i, e) {
  if (!at(i) || i.__v_skip || (e = e || /* @__PURE__ */ new Set(), e.has(i)))
    return i;
  if (e.add(i), Jt(i))
    kr(i.value, e);
  else if (ve(i))
    for (let t = 0; t < i.length; t++)
      kr(i[t], e);
  else if (pM(i) || Wr(i))
    i.forEach((t) => {
      kr(t, e);
    });
  else if (mM(i))
    for (const t in i)
      kr(i[t], e);
  return i;
}
function ho(i, e, t, n) {
  const s = i.dirs, o = e && e.dirs;
  for (let r = 0; r < s.length; r++) {
    const a = s[r];
    o && (a.oldValue = o[r].value);
    let l = a.dir[n];
    l && (eo(), di(l, t, 8, [
      i.el,
      a,
      i,
      e
    ]), to());
  }
}
/*! #__NO_SIDE_EFFECTS__ */
// @__NO_SIDE_EFFECTS__
function A(i, e) {
  return be(i) ? (
    // #8326: extend call and options.name access are considered side-effects
    // by Rollup, so we have to wrap it in a pure-annotated IIFE.
    /* @__PURE__ */ (() => xt({ name: i.name }, e, { setup: i }))()
  ) : i;
}
const fu = (i) => !!i.type.__asyncLoader, If = (i) => i.type.__isKeepAlive;
function $B(i, e) {
  HS(i, "a", e);
}
function NB(i, e) {
  HS(i, "da", e);
}
function HS(i, e, t = Ht) {
  const n = i.__wdc || (i.__wdc = () => {
    let s = t;
    for (; s; ) {
      if (s.isDeactivated)
        return;
      s = s.parent;
    }
    return i();
  });
  if (Lc(e, n, t), t) {
    let s = t.parent;
    for (; s && s.parent; )
      If(s.parent.vnode) && LB(n, e, t, s), s = s.parent;
  }
}
function LB(i, e, t, n) {
  const s = Lc(
    e,
    i,
    n,
    !0
    /* prepend */
  );
  WS(() => {
    af(n[e], s);
  }, t);
}
function Lc(i, e, t = Ht, n = !1) {
  if (t) {
    const s = t[i] || (t[i] = []), o = e.__weh || (e.__weh = (...r) => {
      if (t.isUnmounted)
        return;
      eo(), Xr(t);
      const a = di(e, t, i, r);
      return Vo(), to(), a;
    });
    return n ? s.unshift(o) : s.push(o), o;
  }
}
const ms = (i) => (e, t = Ht) => (
  // post-create lifecycle registrations are noops during SSR (except for serverPrefetch)
  (!Wc || i === "sp") && Lc(i, (...n) => e(...n), t)
), HB = ms("bm"), WB = ms("m"), zB = ms("bu"), KB = ms("u"), GB = ms("bum"), WS = ms("um"), UB = ms("sp"), jB = ms(
  "rtg"
), qB = ms(
  "rtc"
);
function YB(i, e = Ht) {
  Lc("ec", i, e);
}
const Ig = (i) => i ? nE(i) ? kf(i) || i.proxy : Ig(i.parent) : null, ko = (
  // Move PURE marker to new line to workaround compiler discarding it
  // due to type annotation
  /* @__PURE__ */ xt(/* @__PURE__ */ Object.create(null), {
    $: (i) => i,
    $el: (i) => i.vnode.el,
    $data: (i) => i.data,
    $props: (i) => i.props,
    $attrs: (i) => i.attrs,
    $slots: (i) => i.slots,
    $refs: (i) => i.refs,
    $parent: (i) => Ig(i.parent),
    $root: (i) => Ig(i.root),
    $emit: (i) => i.emit,
    $options: (i) => Tf(i),
    $forceUpdate: (i) => i.f || (i.f = () => {
      i.effect.dirty = !0, $c(i.update);
    }),
    $nextTick: (i) => i.n || (i.n = cB.bind(i.proxy)),
    $watch: (i) => BB.bind(i)
  })
), Lh = (i, e) => i !== it && !i.__isScriptSetup && ke(i, e), zS = {
  get({ _: i }, e) {
    const { ctx: t, setupState: n, data: s, props: o, accessCache: r, type: a, appContext: l } = i;
    let d;
    if (e[0] !== "$") {
      const g = r[e];
      if (g !== void 0)
        switch (g) {
          case 1:
            return n[e];
          case 2:
            return s[e];
          case 4:
            return t[e];
          case 3:
            return o[e];
        }
      else {
        if (Lh(n, e))
          return r[e] = 1, n[e];
        if (s !== it && ke(s, e))
          return r[e] = 2, s[e];
        if (
          // only cache other properties when instance has declared (thus stable)
          // props
          (d = i.propsOptions[0]) && ke(d, e)
        )
          return r[e] = 3, o[e];
        if (t !== it && ke(t, e))
          return r[e] = 4, t[e];
        Dg && (r[e] = 0);
      }
    }
    const u = ko[e];
    let c, h;
    if (u)
      return e === "$attrs" ? (zt(i, "get", e), "production" !== "production" ) : "production" !== "production"  , u(i);
    if (
      // css module (injected by vue-loader)
      (c = a.__cssModules) && (c = c[e])
    )
      return c;
    if (t !== it && ke(t, e))
      return r[e] = 4, t[e];
    if (
      // global properties
      h = l.config.globalProperties, ke(h, e)
    )
      return h[e];
  },
  set({ _: i }, e, t) {
    const { data: n, setupState: s, ctx: o } = i;
    return Lh(s, e) ? (s[e] = t, !0) : n !== it && ke(n, e) ? (n[e] = t, !0) : ke(i.props, e) ? (!1) : e[0] === "$" && e.slice(1) in i ? (!1) : (o[e] = t, !0);
  },
  has({
    _: { data: i, setupState: e, accessCache: t, ctx: n, appContext: s, propsOptions: o }
  }, r) {
    let a;
    return !!t[r] || i !== it && ke(i, r) || Lh(e, r) || (a = o[0]) && ke(a, r) || ke(n, r) || ke(ko, r) || ke(s.config.globalProperties, r);
  },
  defineProperty(i, e, t) {
    return t.get != null ? i._.accessCache[e] = 0 : ke(t, "value") && this.set(i, e, t.value, null), Reflect.defineProperty(i, e, t);
  }
};
function Dv(i) {
  return ve(i) ? i.reduce(
    (e, t) => (e[t] = null, e),
    {}
  ) : i;
}
let Dg = !0;
function e$(i) {
  const e = Tf(i), t = i.proxy, n = i.ctx;
  Dg = !1, e.beforeCreate && Tv(e.beforeCreate, i, "bc");
  const {
    // state
    data: s,
    computed: o,
    methods: r,
    watch: a,
    provide: l,
    inject: d,
    // lifecycle
    created: u,
    beforeMount: c,
    mounted: h,
    beforeUpdate: g,
    updated: m,
    activated: C,
    deactivated: v,
    beforeDestroy: E,
    beforeUnmount: T,
    destroyed: V,
    unmounted: $,
    render: G,
    renderTracked: H,
    renderTriggered: ce,
    errorCaptured: re,
    serverPrefetch: me,
    // public API
    expose: dt,
    inheritAttrs: Ke,
    // assets
    components: ut,
    directives: gn,
    filters: kt
  } = e, Kt = null;
  if (d && t$(d, n, Kt), r)
    for (const Re in r) {
      const Fe = r[Re];
      be(Fe) ? (n[Re] = Fe.bind(t), "production" !== "production" ) : "production" !== "production" ;
    }
  if (s) {
    const Re = s.call(t, t);
    if (!at(Re))
      ;
    else if (i.data = Cf(Re), "production" !== "production")
      ;
  }
  if (Dg = !0, o)
    for (const Re in o) {
      const Fe = o[Re], gi = be(Fe) ? Fe.bind(t, t) : be(Fe.get) ? Fe.get.bind(t, t) : yt;
      const kh = !be(Fe) && be(Fe.set) ? Fe.set.bind(t) : yt, _a = H$({
        get: gi,
        set: kh
      });
      Object.defineProperty(n, Re, {
        enumerable: !0,
        configurable: !0,
        get: () => _a.value,
        set: (ur) => _a.value = ur
      });
    }
  if (a)
    for (const Re in a)
      KS(a[Re], n, t, Re);
  if (l) {
    const Re = be(l) ? l.call(t) : l;
    Reflect.ownKeys(Re).forEach((Fe) => {
      a$(Fe, Re[Fe]);
    });
  }
  u && Tv(u, i, "c");
  function Et(Re, Fe) {
    ve(Fe) ? Fe.forEach((gi) => Re(gi.bind(t))) : Fe && Re(Fe.bind(t));
  }
  if (Et(HB, c), Et(WB, h), Et(zB, g), Et(KB, m), Et($B, C), Et(NB, v), Et(YB, re), Et(qB, H), Et(jB, ce), Et(GB, T), Et(WS, $), Et(UB, me), ve(dt))
    if (dt.length) {
      const Re = i.exposed || (i.exposed = {});
      dt.forEach((Fe) => {
        Object.defineProperty(Re, Fe, {
          get: () => t[Fe],
          set: (gi) => t[Fe] = gi
        });
      });
    } else
      i.exposed || (i.exposed = {});
  G && i.render === yt && (i.render = G), Ke != null && (i.inheritAttrs = Ke), ut && (i.components = ut), gn && (i.directives = gn);
}
function t$(i, e, t = yt) {
  ve(i) && (i = Tg(i));
  for (const n in i) {
    const s = i[n];
    let o;
    at(s) ? "default" in s ? o = _u(
      s.from || n,
      s.default,
      !0
    ) : o = _u(s.from || n) : o = _u(s), Jt(o) ? Object.defineProperty(e, n, {
      enumerable: !0,
      configurable: !0,
      get: () => o.value,
      set: (r) => o.value = r
    }) : e[n] = o;
  }
}
function Tv(i, e, t) {
  di(
    ve(i) ? i.map((n) => n.bind(e.proxy)) : i.bind(e.proxy),
    e,
    t
  );
}
function KS(i, e, t, n) {
  const s = n.includes(".") ? NS(t, n) : () => t[n];
  if (St(i)) {
    const o = e[i];
    be(o) ? Nh(s, o) : "production" !== "production" ;
  } else if (be(i))
    Nh(s, i.bind(t));
  else if (at(i))
    if (ve(i))
      i.forEach((o) => KS(o, e, t, n));
    else {
      const o = be(i.handler) ? i.handler.bind(t) : e[i.handler];
      be(o) ? Nh(s, o, i) : "production" !== "production" ;
    }
  else
    ;
}
function Tf(i) {
  const e = i.type, { mixins: t, extends: n } = e, {
    mixins: s,
    optionsCache: o,
    config: { optionMergeStrategies: r }
  } = i.appContext, a = o.get(e);
  let l;
  return a ? l = a : !s.length && !t && !n ? l = e : (l = {}, s.length && s.forEach(
    (d) => ju(l, d, r, !0)
  ), ju(l, e, r)), at(e) && o.set(e, l), l;
}
function ju(i, e, t, n = !1) {
  const { mixins: s, extends: o } = e;
  o && ju(i, o, t, !0), s && s.forEach(
    (r) => ju(i, r, t, !0)
  );
  for (const r in e)
    if (n && r === "expose")
      ;
    else {
      const a = n$[r] || t && t[r];
      i[r] = a ? a(i[r], e[r]) : e[r];
    }
  return i;
}
const n$ = {
  data: Ov,
  props: Av,
  emits: Av,
  // objects
  methods: Ua,
  computed: Ua,
  // lifecycle
  beforeCreate: on,
  created: on,
  beforeMount: on,
  mounted: on,
  beforeUpdate: on,
  updated: on,
  beforeDestroy: on,
  beforeUnmount: on,
  destroyed: on,
  unmounted: on,
  activated: on,
  deactivated: on,
  errorCaptured: on,
  serverPrefetch: on,
  // assets
  components: Ua,
  directives: Ua,
  // watch
  watch: s$,
  // provide / inject
  provide: Ov,
  inject: i$
};
function Ov(i, e) {
  return e ? i ? function() {
    return xt(
      be(i) ? i.call(this, this) : i,
      be(e) ? e.call(this, this) : e
    );
  } : e : i;
}
function i$(i, e) {
  return Ua(Tg(i), Tg(e));
}
function Tg(i) {
  if (ve(i)) {
    const e = {};
    for (let t = 0; t < i.length; t++)
      e[i[t]] = i[t];
    return e;
  }
  return i;
}
function on(i, e) {
  return i ? [...new Set([].concat(i, e))] : e;
}
function Ua(i, e) {
  return i ? xt(/* @__PURE__ */ Object.create(null), i, e) : e;
}
function Av(i, e) {
  return i ? ve(i) && ve(e) ? [.../* @__PURE__ */ new Set([...i, ...e])] : xt(
    /* @__PURE__ */ Object.create(null),
    Dv(i),
    Dv(e ?? {})
  ) : e;
}
function s$(i, e) {
  if (!i)
    return e;
  if (!e)
    return i;
  const t = xt(/* @__PURE__ */ Object.create(null), i);
  for (const n in e)
    t[n] = on(i[n], e[n]);
  return t;
}
function GS() {
  return {
    app: null,
    config: {
      isNativeTag: rS,
      performance: !1,
      globalProperties: {},
      optionMergeStrategies: {},
      errorHandler: void 0,
      warnHandler: void 0,
      compilerOptions: {}
    },
    mixins: [],
    components: {},
    directives: {},
    provides: /* @__PURE__ */ Object.create(null),
    optionsCache: /* @__PURE__ */ new WeakMap(),
    propsCache: /* @__PURE__ */ new WeakMap(),
    emitsCache: /* @__PURE__ */ new WeakMap()
  };
}
let o$ = 0;
function r$(i, e) {
  return function(n, s = null) {
    be(n) || (n = xt({}, n)), s != null && !at(s) && (s = null);
    const o = GS(), r = /* @__PURE__ */ new WeakSet();
    let a = !1;
    const l = o.app = {
      _uid: o$++,
      _component: n,
      _props: s,
      _container: null,
      _context: o,
      _instance: null,
      version: Nv,
      get config() {
        return o.config;
      },
      set config(d) {
      },
      use(d, ...u) {
        return r.has(d) ? "production" !== "production"  : d && be(d.install) ? (r.add(d), d.install(l, ...u)) : be(d) ? (r.add(d), d(l, ...u)) : "production" !== "production" , l;
      },
      mixin(d) {
        return o.mixins.includes(d) ? "production" !== "production"  : o.mixins.push(d), l;
      },
      component(d, u) {
        return u ? (o.components[d] = u, l) : o.components[d];
      },
      directive(d, u) {
        return u ? (o.directives[d] = u, l) : o.directives[d];
      },
      mount(d, u, c) {
        if (a)
          ;
        else {
          const h = ai(n, s);
          return h.appContext = o, c === !0 ? c = "svg" : c === !1 && (c = void 0), u && e ? e(h, d) : i(h, d, c), a = !0, l._container = d, d.__vue_app__ = l, kf(h.component) || h.component.proxy;
        }
      },
      unmount() {
        a ? (i(null, l._container), delete l._container.__vue_app__) : "production" !== "production" ;
      },
      provide(d, u) {
        return o.provides[d] = u, l;
      },
      runWithContext(d) {
        qu = l;
        try {
          return d();
        } finally {
          qu = null;
        }
      }
    };
    return l;
  };
}
let qu = null;
function a$(i, e) {
  if (!Ht)
    ;
  else {
    let t = Ht.provides;
    const n = Ht.parent && Ht.parent.provides;
    n === t && (t = Ht.provides = Object.create(n)), t[i] = e;
  }
}
function _u(i, e, t = !1) {
  const n = Ht || $n;
  if (n || qu) {
    const s = n ? n.parent == null ? n.vnode.appContext && n.vnode.appContext.provides : n.parent.provides : qu._context.provides;
    if (s && i in s)
      return s[i];
    if (arguments.length > 1)
      return t && be(e) ? e.call(n && n.proxy) : e;
  }
}
function l$(i, e, t, n = !1) {
  const s = {}, o = {};
  Ku(o, Hc, 1), i.propsDefaults = /* @__PURE__ */ Object.create(null), US(i, e, s, o);
  for (const r in i.propsOptions[0])
    r in s || (s[r] = void 0);
  t ? i.props = n ? s : eB(s) : i.type.props ? i.props = s : i.props = o, i.attrs = o;
}
function u$(i, e, t, n) {
  const {
    props: s,
    attrs: o,
    vnode: { patchFlag: r }
  } = i, a = De(s), [l] = i.propsOptions;
  let d = !1;
  if (
    // always force full diff in dev
    // - #1942 if hmr is enabled with sfc component
    // - vite#872 non-sfc component used by sfc component
    (n || r > 0) && !(r & 16)
  ) {
    if (r & 8) {
      const u = i.vnode.dynamicProps;
      for (let c = 0; c < u.length; c++) {
        let h = u[c];
        if (Nc(i.emitsOptions, h))
          continue;
        const g = e[h];
        if (l)
          if (ke(o, h))
            g !== o[h] && (o[h] = g, d = !0);
          else {
            const m = Yr(h);
            s[m] = Og(
              l,
              a,
              m,
              g,
              i,
              !1
            );
          }
        else
          g !== o[h] && (o[h] = g, d = !0);
      }
    }
  } else {
    US(i, e, s, o) && (d = !0);
    let u;
    for (const c in a)
      (!e || // for camelCase
      !ke(e, c) && // it's possible the original props was passed in as kebab-case
      // and converted to camelCase (#955)
      ((u = Ks(c)) === c || !ke(e, u))) && (l ? t && // for camelCase
      (t[c] !== void 0 || // for kebab-case
      t[u] !== void 0) && (s[c] = Og(
        l,
        a,
        c,
        void 0,
        i,
        !0
      )) : delete s[c]);
    if (o !== a)
      for (const c in o)
        (!e || !ke(e, c)) && (delete o[c], d = !0);
  }
  d && Ti(i, "set", "$attrs");
}
function US(i, e, t, n) {
  const [s, o] = i.propsOptions;
  let r = !1, a;
  if (e)
    for (let l in e) {
      if (pu(l))
        continue;
      const d = e[l];
      let u;
      s && ke(s, u = Yr(l)) ? !o || !o.includes(u) ? t[u] = d : (a || (a = {}))[u] = d : Nc(i.emitsOptions, l) || (!(l in n) || d !== n[l]) && (n[l] = d, r = !0);
    }
  if (o) {
    const l = De(t), d = a || it;
    for (let u = 0; u < o.length; u++) {
      const c = o[u];
      t[c] = Og(
        s,
        l,
        c,
        d[c],
        i,
        !ke(d, c)
      );
    }
  }
  return r;
}
function Og(i, e, t, n, s, o) {
  const r = i[t];
  if (r != null) {
    const a = ke(r, "default");
    if (a && n === void 0) {
      const l = r.default;
      if (r.type !== Function && !r.skipFactory && be(l)) {
        const { propsDefaults: d } = s;
        t in d ? n = d[t] : (Xr(s), n = d[t] = l.call(
          null,
          e
        ), Vo());
      } else
        n = l;
    }
    r[
      0
      /* shouldCast */
    ] && (o && !a ? n = !1 : r[
      1
      /* shouldCastTrue */
    ] && (n === "" || n === Ks(t)) && (n = !0));
  }
  return n;
}
function jS(i, e, t = !1) {
  const n = e.propsCache, s = n.get(i);
  if (s)
    return s;
  const o = i.props, r = {}, a = [];
  let l = !1;
  if (!be(i)) {
    const u = (c) => {
      l = !0;
      const [h, g] = jS(c, e, !0);
      xt(r, h), g && a.push(...g);
    };
    !t && e.mixins.length && e.mixins.forEach(u), i.extends && u(i.extends), i.mixins && i.mixins.forEach(u);
  }
  if (!o && !l)
    return at(i) && n.set(i, Ja), Ja;
  if (ve(o))
    for (let u = 0; u < o.length; u++) {
      const c = Yr(o[u]);
      Rv(c) && (r[c] = it);
    }
  else if (o) {
    for (const u in o) {
      const c = Yr(u);
      if (Rv(c)) {
        const h = o[u], g = r[c] = ve(h) || be(h) ? { type: h } : xt({}, h);
        if (g) {
          const m = kv(Boolean, g.type), C = kv(String, g.type);
          g[
            0
            /* shouldCast */
          ] = m > -1, g[
            1
            /* shouldCastTrue */
          ] = C < 0 || m < C, (m > -1 || ke(g, "default")) && a.push(c);
        }
      }
    }
  }
  const d = [r, a];
  return at(i) && n.set(i, d), d;
}
function Rv(i) {
  return i[0] !== "$" ? !0 : (!1);
}
function Ag(i) {
  const e = i && i.toString().match(/^\s*(function|class) (\w+)/);
  return e ? e[2] : i === null ? "null" : "";
}
function Fv(i, e) {
  return Ag(i) === Ag(e);
}
function kv(i, e) {
  return ve(e) ? e.findIndex((t) => Fv(t, i)) : be(e) && Fv(e, i) ? 0 : -1;
}
const YS = (i) => i[0] === "_" || i === "$stable", Of = (i) => ve(i) ? i.map(ii) : [ii(i)], f$ = (i, e, t) => {
  if (e._n)
    return e;
  const n = TB((...s) => ("production" !== "production" && Ht && Q(
    `Slot "${i}" invoked outside of the render function: this will not track dependencies used in the slot. Invoke the slot function inside the render function instead.`
  ), Of(e(...s))), t);
  return n._c = !1, n;
}, XS = (i, e, t) => {
  const n = i._ctx;
  for (const s in i) {
    if (YS(s))
      continue;
    const o = i[s];
    if (be(o))
      e[s] = f$(s, o, n);
    else if (o != null) {
      const r = Of(o);
      e[s] = () => r;
    }
  }
}, ZS = (i, e) => {
  const t = Of(e);
  i.slots.default = () => t;
}, _$ = (i, e) => {
  if (i.vnode.shapeFlag & 32) {
    const t = e._;
    t ? (i.slots = De(e), Ku(e, "_", t)) : XS(
      e,
      i.slots = {}
    );
  } else
    i.slots = {}, e && ZS(i, e);
  Ku(i.slots, Hc, 1);
}, C$ = (i, e, t) => {
  const { vnode: n, slots: s } = i;
  let o = !0, r = it;
  if (n.shapeFlag & 32) {
    const a = e._;
    a ? t && a === 1 ? o = !1 : (xt(s, e), !t && a === 1 && delete s._) : (o = !e.$stable, XS(e, s)), r = e;
  } else
    e && (ZS(i, e), r = { default: 1 });
  if (o)
    for (const a in s)
      !YS(a) && r[a] == null && delete s[a];
};
function Rg(i, e, t, n, s = !1) {
  if (ve(i)) {
    i.forEach(
      (h, g) => Rg(
        h,
        e && (ve(e) ? e[g] : e),
        t,
        n,
        s
      )
    );
    return;
  }
  if (fu(n) && !s)
    return;
  const o = n.shapeFlag & 4 ? kf(n.component) || n.component.proxy : n.el, r = s ? null : o, { i: a, r: l } = i;
  const d = e && e.r, u = a.refs === it ? a.refs = {} : a.refs, c = a.setupState;
  if (d != null && d !== l && (St(d) ? (u[d] = null, ke(c, d) && (c[d] = null)) : Jt(d) && (d.value = null)), be(l))
    ts(l, a, 12, [r, u]);
  else {
    const h = St(l), g = Jt(l);
    if (h || g) {
      const m = () => {
        if (i.f) {
          const C = h ? ke(c, l) ? c[l] : u[l] : l.value;
          s ? ve(C) && af(C, o) : ve(C) ? C.includes(o) || C.push(o) : h ? (u[l] = [o], ke(c, l) && (c[l] = u[l])) : (l.value = [o], i.k && (u[i.k] = l.value));
        } else
          h ? (u[l] = r, ke(c, l) && (c[l] = r)) : g ? (l.value = r, i.k && (u[i.k] = r)) : "production" !== "production" ;
      };
      r ? (m.id = -1, fn(m, t)) : m();
    }
  }
}
const fn = MB;
function x$(i) {
  return y$(i);
}
function y$(i, e) {
  const t = cf();
  t.__VUE__ = !0;
  const {
    insert: n,
    remove: s,
    patchProp: o,
    createElement: r,
    createText: a,
    createComment: l,
    setText: d,
    setElementText: u,
    parentNode: c,
    nextSibling: h,
    setScopeId: g = yt,
    insertStaticContent: m
  } = i, C = (b, D, P, N = null, L = null, q = null, Z = void 0, U = null, Y = !!D.dynamicChildren) => {
    if (b === D)
      return;
    b && !ya(b, D) && (N = wd(b), ys(b, L, q, !0), b = null), D.patchFlag === -2 && (Y = !1, D.dynamicChildren = null);
    const { type: K, ref: ie, shapeFlag: ge } = D;
    switch (K) {
      case Nl:
        v(b, D, P, N);
        break;
      case Ln:
        E(b, D, P, N);
        break;
      case vu:
        b == null ? T(D, P, N, Z) : "production" !== "production" ;
        break;
      case wi:
        gn(
          b,
          D,
          P,
          N,
          L,
          q,
          Z,
          U,
          Y
        );
        break;
      default:
        ge & 1 ? H(
          b,
          D,
          P,
          N,
          L,
          q,
          Z,
          U,
          Y
        ) : ge & 6 ? kt(
          b,
          D,
          P,
          N,
          L,
          q,
          Z,
          U,
          Y
        ) : ge & 64 || ge & 128 ? K.process(
          b,
          D,
          P,
          N,
          L,
          q,
          Z,
          U,
          Y,
          cr
        ) : "production" !== "production" ;
    }
    ie != null && L && Rg(ie, b && b.ref, q, D || b, !D);
  }, v = (b, D, P, N) => {
    if (b == null)
      n(
        D.el = a(D.children),
        P,
        N
      );
    else {
      const L = D.el = b.el;
      D.children !== b.children && d(L, D.children);
    }
  }, E = (b, D, P, N) => {
    b == null ? n(
      D.el = l(D.children || ""),
      P,
      N
    ) : D.el = b.el;
  }, T = (b, D, P, N) => {
    [b.el, b.anchor] = m(
      b.children,
      D,
      P,
      N,
      b.el,
      b.anchor
    );
  }, $ = ({ el: b, anchor: D }, P, N) => {
    let L;
    for (; b && b !== D; )
      L = h(b), n(b, P, N), b = L;
    n(D, P, N);
  }, G = ({ el: b, anchor: D }) => {
    let P;
    for (; b && b !== D; )
      P = h(b), s(b), b = P;
    s(D);
  }, H = (b, D, P, N, L, q, Z, U, Y) => {
    D.type === "svg" ? Z = "svg" : D.type === "math" && (Z = "mathml"), b == null ? ce(
      D,
      P,
      N,
      L,
      q,
      Z,
      U,
      Y
    ) : dt(
      b,
      D,
      L,
      q,
      Z,
      U,
      Y
    );
  }, ce = (b, D, P, N, L, q, Z, U) => {
    let Y, K;
    const { props: ie, shapeFlag: ge, transition: de, dirs: Se } = b;
    if (Y = b.el = r(
      b.type,
      q,
      ie && ie.is,
      ie
    ), ge & 8 ? u(Y, b.children) : ge & 16 && me(
      b.children,
      Y,
      null,
      N,
      L,
      Hh(b, q),
      Z,
      U
    ), Se && ho(b, null, N, "created"), re(Y, b, b.scopeId, Z, N), ie) {
      for (const Ze in ie)
        Ze !== "value" && !pu(Ze) && o(
          Y,
          Ze,
          null,
          ie[Ze],
          q,
          b.children,
          N,
          L,
          $i
        );
      "value" in ie && o(Y, "value", null, ie.value, q), (K = ie.onVnodeBeforeMount) && fi(K, N, b);
    }
    Se && ho(b, null, N, "beforeMount");
    const Ne = b$(L, de);
    Ne && de.beforeEnter(Y), n(Y, D, P), ((K = ie && ie.onVnodeMounted) || Ne || Se) && fn(() => {
      K && fi(K, N, b), Ne && de.enter(Y), Se && ho(b, null, N, "mounted");
    }, L);
  }, re = (b, D, P, N, L) => {
    if (P && g(b, P), N)
      for (let q = 0; q < N.length; q++)
        g(b, N[q]);
    if (L) {
      let q = L.subTree;
      if (D === q) {
        const Z = L.vnode;
        re(
          b,
          Z,
          Z.scopeId,
          Z.slotScopeIds,
          L.parent
        );
      }
    }
  }, me = (b, D, P, N, L, q, Z, U, Y = 0) => {
    for (let K = Y; K < b.length; K++) {
      const ie = b[K] = U ? Os(b[K]) : ii(b[K]);
      C(
        null,
        ie,
        D,
        P,
        N,
        L,
        q,
        Z,
        U
      );
    }
  }, dt = (b, D, P, N, L, q, Z) => {
    const U = D.el = b.el;
    let { patchFlag: Y, dynamicChildren: K, dirs: ie } = D;
    Y |= b.patchFlag & 16;
    const ge = b.props || it, de = D.props || it;
    let Se;
    if (P && po(P, !1), (Se = de.onVnodeBeforeUpdate) && fi(Se, P, D, b), ie && ho(D, b, P, "beforeUpdate"), P && po(P, !0), K ? (Ke(
      b.dynamicChildren,
      K,
      U,
      P,
      N,
      Hh(D, L),
      q
    ), "production" !== "production" ) : Z || gi(
      b,
      D,
      U,
      null,
      P,
      N,
      Hh(D, L),
      q,
      !1
    ), Y > 0) {
      if (Y & 16)
        ut(
          U,
          D,
          ge,
          de,
          P,
          N,
          L
        );
      else if (Y & 2 && ge.class !== de.class && o(U, "class", null, de.class, L), Y & 4 && o(U, "style", ge.style, de.style, L), Y & 8) {
        const Ne = D.dynamicProps;
        for (let Ze = 0; Ze < Ne.length; Ze++) {
          const ht = Ne[Ze], Vt = ge[ht], Xn = de[ht];
          (Xn !== Vt || ht === "value") && o(
            U,
            ht,
            Vt,
            Xn,
            L,
            b.children,
            P,
            N,
            $i
          );
        }
      }
      Y & 1 && b.children !== D.children && u(U, D.children);
    } else
      !Z && K == null && ut(
        U,
        D,
        ge,
        de,
        P,
        N,
        L
      );
    ((Se = de.onVnodeUpdated) || ie) && fn(() => {
      Se && fi(Se, P, D, b), ie && ho(D, b, P, "updated");
    }, N);
  }, Ke = (b, D, P, N, L, q, Z) => {
    for (let U = 0; U < D.length; U++) {
      const Y = b[U], K = D[U], ie = (
        // oldVNode may be an errored async setup() component inside Suspense
        // which will not have a mounted element
        Y.el && // - In the case of a Fragment, we need to provide the actual parent
        // of the Fragment itself so it can move its children.
        (Y.type === wi || // - In the case of different nodes, there is going to be a replacement
        // which also requires the correct parent container
        !ya(Y, K) || // - In the case of a component, it could contain anything.
        Y.shapeFlag & 70) ? c(Y.el) : (
          // In other cases, the parent container is not actually used so we
          // just pass the block element here to avoid a DOM parentNode call.
          P
        )
      );
      C(
        Y,
        K,
        ie,
        null,
        N,
        L,
        q,
        Z,
        !0
      );
    }
  }, ut = (b, D, P, N, L, q, Z) => {
    if (P !== N) {
      if (P !== it)
        for (const U in P)
          !pu(U) && !(U in N) && o(
            b,
            U,
            P[U],
            null,
            Z,
            D.children,
            L,
            q,
            $i
          );
      for (const U in N) {
        if (pu(U))
          continue;
        const Y = N[U], K = P[U];
        Y !== K && U !== "value" && o(
          b,
          U,
          K,
          Y,
          Z,
          D.children,
          L,
          q,
          $i
        );
      }
      "value" in N && o(b, "value", P.value, N.value, Z);
    }
  }, gn = (b, D, P, N, L, q, Z, U, Y) => {
    const K = D.el = b ? b.el : a(""), ie = D.anchor = b ? b.anchor : a("");
    let { patchFlag: ge, dynamicChildren: de, slotScopeIds: Se } = D;
    Se && (U = U ? U.concat(Se) : Se), b == null ? (n(K, P, N), n(ie, P, N), me(
      D.children,
      P,
      ie,
      L,
      q,
      Z,
      U,
      Y
    )) : ge > 0 && ge & 64 && de && // #2715 the previous fragment could've been a BAILed one as a result
    // of renderSlot() with no valid children
    b.dynamicChildren ? (Ke(
      b.dynamicChildren,
      de,
      P,
      L,
      q,
      Z,
      U
    ), (
      // #2080 if the stable fragment has a key, it's a <template v-for> that may
      //  get moved around. Make sure all root level vnodes inherit el.
      // #2134 or if it's a component root, it may also get moved around
      // as the component is being moved.
      (D.key != null || L && D === L.subTree) && Cu(
        b,
        D,
        !0
        /* shallow */
      )
    )) : gi(
      b,
      D,
      P,
      ie,
      L,
      q,
      Z,
      U,
      Y
    );
  }, kt = (b, D, P, N, L, q, Z, U, Y) => {
    D.slotScopeIds = U, b == null ? D.shapeFlag & 512 ? L.ctx.activate(
      D,
      P,
      N,
      Z,
      Y
    ) : Kt(
      D,
      P,
      N,
      L,
      q,
      Z,
      Y
    ) : Et(b, D, Y);
  }, Kt = (b, D, P, N, L, q, Z) => {
    const U = b.component = F$(
      b,
      N,
      L
    );
    if (If(b) && (U.ctx.renderer = cr), V$(U), U.asyncDep) {
      if (L && L.registerDep(U, Re), !b.el) {
        const Y = U.subTree = ai(Ln);
        E(null, Y, D, P);
      }
    } else
      Re(
        U,
        b,
        D,
        P,
        L,
        q,
        Z
      );
  }, Et = (b, D, P) => {
    const N = D.component = b.component;
    if (FB(b, D, P))
      if (N.asyncDep && !N.asyncResolved) {
        Fe(N, D, P);
        return;
      } else
        N.next = D, pB(N.update), N.effect.dirty = !0, N.update();
    else
      D.el = b.el, N.vnode = D;
  }, Re = (b, D, P, N, L, q, Z) => {
    const U = () => {
      if (b.isMounted) {
        let { next: ie, bu: ge, u: de, parent: Se, vnode: Ne } = b;
        {
          const hr = QS(b);
          if (hr) {
            ie && (ie.el = Ne.el, Fe(b, ie, Z)), hr.asyncDep.then(() => {
              b.isUnmounted || U();
            });
            return;
          }
        }
        let Ze = ie, ht;
        po(b, !1), ie ? (ie.el = Ne.el, Fe(b, ie, Z)) : ie = Ne, ge && va(ge), (ht = ie.props && ie.props.onVnodeBeforeUpdate) && fi(ht, Se, ie, Ne), po(b, !0);
        const Vt = $h(b);
        const Xn = b.subTree;
        b.subTree = Vt, C(
          Xn,
          Vt,
          // parent may have changed if it's in a teleport
          c(Xn.el),
          // anchor may have changed if it's in a fragment
          wd(Xn),
          b,
          L,
          q
        ), ie.el = Vt.el, Ze === null && kB(b, Vt.el), de && fn(de, L), (ht = ie.props && ie.props.onVnodeUpdated) && fn(
          () => fi(ht, Se, ie, Ne),
          L
        );
      } else {
        let ie;
        const { el: ge, props: de } = D, { bm: Se, m: Ne, parent: Ze } = b, ht = fu(D);
        if (po(b, !1), Se && va(Se), !ht && (ie = de && de.onVnodeBeforeMount) && fi(ie, Ze, D), po(b, !0), ge && Mh) {
          const Vt = () => {
            b.subTree = $h(b), Mh(
              ge,
              b.subTree,
              b,
              L,
              null
            );
          };
          ht ? D.type.__asyncLoader().then(
            // note: we are moving the render call into an async callback,
            // which means it won't track dependencies - but it's ok because
            // a server-rendered async wrapper is already in resolved state
            // and it will never need to change.
            () => !b.isUnmounted && Vt()
          ) : Vt();
        } else {
          const Vt = b.subTree = $h(b);
          C(
            null,
            Vt,
            P,
            N,
            b,
            L,
            q
          ), D.el = Vt.el;
        }
        if (Ne && fn(Ne, L), !ht && (ie = de && de.onVnodeMounted)) {
          const Vt = D;
          fn(
            () => fi(ie, Ze, Vt),
            L
          );
        }
        (D.shapeFlag & 256 || Ze && fu(Ze.vnode) && Ze.vnode.shapeFlag & 256) && b.a && fn(b.a, L), b.isMounted = !0, D = P = N = null;
      }
    }, Y = b.effect = new gf(
      U,
      yt,
      () => $c(K),
      b.scope
      // track it in component's effect scope
    ), K = b.update = () => {
      Y.dirty && Y.run();
    };
    K.id = b.uid, po(b, !0), K();
  }, Fe = (b, D, P) => {
    D.component = b;
    const N = b.vnode.props;
    b.vnode = D, b.next = null, u$(b, D.props, N, P), C$(b, D.children, P), eo(), wv(b), to();
  }, gi = (b, D, P, N, L, q, Z, U, Y = !1) => {
    const K = b && b.children, ie = b ? b.shapeFlag : 0, ge = D.children, { patchFlag: de, shapeFlag: Se } = D;
    if (de > 0) {
      if (de & 128) {
        _a(
          K,
          ge,
          P,
          N,
          L,
          q,
          Z,
          U,
          Y
        );
        return;
      } else if (de & 256) {
        kh(
          K,
          ge,
          P,
          N,
          L,
          q,
          Z,
          U,
          Y
        );
        return;
      }
    }
    Se & 8 ? (ie & 16 && $i(K, L, q), ge !== K && u(P, ge)) : ie & 16 ? Se & 16 ? _a(
      K,
      ge,
      P,
      N,
      L,
      q,
      Z,
      U,
      Y
    ) : $i(K, L, q, !0) : (ie & 8 && u(P, ""), Se & 16 && me(
      ge,
      P,
      N,
      L,
      q,
      Z,
      U,
      Y
    ));
  }, kh = (b, D, P, N, L, q, Z, U, Y) => {
    b = b || Ja, D = D || Ja;
    const K = b.length, ie = D.length, ge = Math.min(K, ie);
    let de;
    for (de = 0; de < ge; de++) {
      const Se = D[de] = Y ? Os(D[de]) : ii(D[de]);
      C(
        b[de],
        Se,
        P,
        null,
        L,
        q,
        Z,
        U,
        Y
      );
    }
    K > ie ? $i(
      b,
      L,
      q,
      !0,
      !1,
      ge
    ) : me(
      D,
      P,
      N,
      L,
      q,
      Z,
      U,
      Y,
      ge
    );
  }, _a = (b, D, P, N, L, q, Z, U, Y) => {
    let K = 0;
    const ie = D.length;
    let ge = b.length - 1, de = ie - 1;
    for (; K <= ge && K <= de; ) {
      const Se = b[K], Ne = D[K] = Y ? Os(D[K]) : ii(D[K]);
      if (ya(Se, Ne))
        C(
          Se,
          Ne,
          P,
          null,
          L,
          q,
          Z,
          U,
          Y
        );
      else
        break;
      K++;
    }
    for (; K <= ge && K <= de; ) {
      const Se = b[ge], Ne = D[de] = Y ? Os(D[de]) : ii(D[de]);
      if (ya(Se, Ne))
        C(
          Se,
          Ne,
          P,
          null,
          L,
          q,
          Z,
          U,
          Y
        );
      else
        break;
      ge--, de--;
    }
    if (K > ge) {
      if (K <= de) {
        const Se = de + 1, Ne = Se < ie ? D[Se].el : N;
        for (; K <= de; )
          C(
            null,
            D[K] = Y ? Os(D[K]) : ii(D[K]),
            P,
            Ne,
            L,
            q,
            Z,
            U,
            Y
          ), K++;
      }
    } else if (K > de)
      for (; K <= ge; )
        ys(b[K], L, q, !0), K++;
    else {
      const Se = K, Ne = K, Ze = /* @__PURE__ */ new Map();
      for (K = Ne; K <= de; K++) {
        const sn = D[K] = Y ? Os(D[K]) : ii(D[K]);
        sn.key != null && (Ze.set(sn.key, K));
      }
      let ht, Vt = 0;
      const Xn = de - Ne + 1;
      let hr = !1, cv = 0;
      const Ca = new Array(Xn);
      for (K = 0; K < Xn; K++)
        Ca[K] = 0;
      for (K = Se; K <= ge; K++) {
        const sn = b[K];
        if (Vt >= Xn) {
          ys(sn, L, q, !0);
          continue;
        }
        let mi;
        if (sn.key != null)
          mi = Ze.get(sn.key);
        else
          for (ht = Ne; ht <= de; ht++)
            if (Ca[ht - Ne] === 0 && ya(sn, D[ht])) {
              mi = ht;
              break;
            }
        mi === void 0 ? ys(sn, L, q, !0) : (Ca[mi - Ne] = K + 1, mi >= cv ? cv = mi : hr = !0, C(
          sn,
          D[mi],
          P,
          null,
          L,
          q,
          Z,
          U,
          Y
        ), Vt++);
      }
      const hv = hr ? w$(Ca) : Ja;
      for (ht = hv.length - 1, K = Xn - 1; K >= 0; K--) {
        const sn = Ne + K, mi = D[sn], pv = sn + 1 < ie ? D[sn + 1].el : N;
        Ca[K] === 0 ? C(
          null,
          mi,
          P,
          pv,
          L,
          q,
          Z,
          U,
          Y
        ) : hr && (ht < 0 || K !== hv[ht] ? ur(mi, P, pv, 2) : ht--);
      }
    }
  }, ur = (b, D, P, N, L = null) => {
    const { el: q, type: Z, transition: U, children: Y, shapeFlag: K } = b;
    if (K & 6) {
      ur(b.component.subTree, D, P, N);
      return;
    }
    if (K & 128) {
      b.suspense.move(D, P, N);
      return;
    }
    if (K & 64) {
      Z.move(b, D, P, cr);
      return;
    }
    if (Z === wi) {
      n(q, D, P);
      for (let ge = 0; ge < Y.length; ge++)
        ur(Y[ge], D, P, N);
      n(b.anchor, D, P);
      return;
    }
    if (Z === vu) {
      $(b, D, P);
      return;
    }
    if (N !== 2 && K & 1 && U)
      if (N === 0)
        U.beforeEnter(q), n(q, D, P), fn(() => U.enter(q), L);
      else {
        const { leave: ge, delayLeave: de, afterLeave: Se } = U, Ne = () => n(q, D, P), Ze = () => {
          ge(q, () => {
            Ne(), Se && Se();
          });
        };
        de ? de(q, Ne, Ze) : Ze();
      }
    else
      n(q, D, P);
  }, ys = (b, D, P, N = !1, L = !1) => {
    const {
      type: q,
      props: Z,
      ref: U,
      children: Y,
      dynamicChildren: K,
      shapeFlag: ie,
      patchFlag: ge,
      dirs: de
    } = b;
    if (U != null && Rg(U, null, P, b, !0), ie & 256) {
      D.ctx.deactivate(b);
      return;
    }
    const Se = ie & 1 && de, Ne = !fu(b);
    let Ze;
    if (Ne && (Ze = Z && Z.onVnodeBeforeUnmount) && fi(Ze, D, b), ie & 6)
      cM(b.component, P, N);
    else {
      if (ie & 128) {
        b.suspense.unmount(P, N);
        return;
      }
      Se && ho(b, null, D, "beforeUnmount"), ie & 64 ? b.type.remove(
        b,
        D,
        P,
        L,
        cr,
        N
      ) : K && // #1153: fast path should not be taken for non-stable (v-for) fragments
      (q !== wi || ge > 0 && ge & 64) ? $i(
        K,
        D,
        P,
        !1,
        !0
      ) : (q === wi && ge & 384 || !L && ie & 16) && $i(Y, D, P), N && Vh(b);
    }
    (Ne && (Ze = Z && Z.onVnodeUnmounted) || Se) && fn(() => {
      Ze && fi(Ze, D, b), Se && ho(b, null, D, "unmounted");
    }, P);
  }, Vh = (b) => {
    const { type: D, el: P, anchor: N, transition: L } = b;
    if (D === wi) {
      uM(P, N);
      return;
    }
    if (D === vu) {
      G(b);
      return;
    }
    const q = () => {
      s(P), L && !L.persisted && L.afterLeave && L.afterLeave();
    };
    if (b.shapeFlag & 1 && L && !L.persisted) {
      const { leave: Z, delayLeave: U } = L, Y = () => Z(P, q);
      U ? U(b.el, q, Y) : Y();
    } else
      q();
  }, uM = (b, D) => {
    let P;
    for (; b !== D; )
      P = h(b), s(b), b = P;
    s(D);
  }, cM = (b, D, P) => {
    const { bum: N, scope: L, update: q, subTree: Z, um: U } = b;
    N && va(N), L.stop(), q && (q.active = !1, ys(Z, b, D, P)), U && fn(U, D), fn(() => {
      b.isUnmounted = !0;
    }, D), D && D.pendingBranch && !D.isUnmounted && b.asyncDep && !b.asyncResolved && b.suspenseId === D.pendingId && (D.deps--, D.deps === 0 && D.resolve());
  }, $i = (b, D, P, N = !1, L = !1, q = 0) => {
    for (let Z = q; Z < b.length; Z++)
      ys(b[Z], D, P, N, L);
  }, wd = (b) => b.shapeFlag & 6 ? wd(b.component.subTree) : b.shapeFlag & 128 ? b.suspense.next() : h(b.anchor || b.el), uv = (b, D, P) => {
    b == null ? D._vnode && ys(D._vnode, null, null, !0) : C(
      D._vnode || null,
      b,
      D,
      null,
      null,
      null,
      P
    ), wv(), AS(), D._vnode = b;
  }, cr = {
    p: C,
    um: ys,
    m: ur,
    r: Vh,
    mt: Kt,
    mc: me,
    pc: gi,
    pbc: Ke,
    n: wd,
    o: i
  };
  let Ph, Mh;
  return e && ([Ph, Mh] = e(
    cr
  )), {
    render: uv,
    hydrate: Ph,
    createApp: r$(uv, Ph)
  };
}
function Hh({ type: i, props: e }, t) {
  return t === "svg" && i === "foreignObject" || t === "mathml" && i === "annotation-xml" && e && e.encoding && e.encoding.includes("html") ? void 0 : t;
}
function po({ effect: i, update: e }, t) {
  i.allowRecurse = e.allowRecurse = t;
}
function b$(i, e) {
  return (!i || i && !i.pendingBranch) && e && !e.persisted;
}
function Cu(i, e, t = !1) {
  const n = i.children, s = e.children;
  if (ve(n) && ve(s))
    for (let o = 0; o < n.length; o++) {
      const r = n[o];
      let a = s[o];
      a.shapeFlag & 1 && !a.dynamicChildren && ((a.patchFlag <= 0 || a.patchFlag === 32) && (a = s[o] = Os(s[o]), a.el = r.el), t || Cu(r, a)), a.type === Nl && (a.el = r.el);
    }
}
function w$(i) {
  const e = i.slice(), t = [0];
  let n, s, o, r, a;
  const l = i.length;
  for (n = 0; n < l; n++) {
    const d = i[n];
    if (d !== 0) {
      if (s = t[t.length - 1], i[s] < d) {
        e[n] = s, t.push(n);
        continue;
      }
      for (o = 0, r = t.length - 1; o < r; )
        a = o + r >> 1, i[t[a]] < d ? o = a + 1 : r = a;
      d < i[t[o]] && (o > 0 && (e[n] = t[o - 1]), t[o] = n);
    }
  }
  for (o = t.length, r = t[o - 1]; o-- > 0; )
    t[o] = r, r = e[r];
  return t;
}
function QS(i) {
  const e = i.subTree.component;
  if (e)
    return e.asyncDep && !e.asyncResolved ? e : QS(e);
}
const S$ = (i) => i.__isTeleport, wi = Symbol.for("v-fgt"), Nl = Symbol.for("v-txt"), Ln = Symbol.for("v-cmt"), vu = Symbol.for("v-stc");
let Vr = null, Af = 1;
function Mv(i) {
  Af += i;
}
function _l(i) {
  return i ? i.__v_isVNode === !0 : !1;
}
function ya(i, e) {
  return i.type === e.type && i.key === e.key;
}
const Hc = "__vInternal", JS = ({ key: i }) => i ?? null, xu = ({
  ref: i,
  ref_key: e,
  ref_for: t
}) => (typeof i == "number" && (i = "" + i), i != null ? St(i) || Jt(i) || be(i) ? { i: $n, r: i, k: e, f: !!t } : i : null);
function I$(i, e = null, t = null, n = 0, s = null, o = i === wi ? 0 : 1, r = !1, a = !1) {
  const l = {
    __v_isVNode: !0,
    __v_skip: !0,
    type: i,
    props: e,
    key: e && JS(e),
    ref: e && xu(e),
    scopeId: MS,
    slotScopeIds: null,
    children: t,
    component: null,
    suspense: null,
    ssContent: null,
    ssFallback: null,
    dirs: null,
    transition: null,
    el: null,
    anchor: null,
    target: null,
    targetAnchor: null,
    staticCount: 0,
    shapeFlag: o,
    patchFlag: n,
    dynamicProps: s,
    dynamicChildren: null,
    appContext: null,
    ctx: $n
  };
  return a ? (Rf(l, t), o & 128 && i.normalize(l)) : t && (l.shapeFlag |= St(t) ? 8 : 16), Af > 0 && // avoid a block node from tracking itself
  !r && // has current parent block
  Vr && // presence of a patch flag indicates this node needs patching on updates.
  // component nodes also should always be patched, because even if the
  // component doesn't need to update, it needs to persist the instance on to
  // the next vnode so that it can be properly unmounted later.
  (l.patchFlag > 0 || o & 6) && // the EVENTS flag is only for hydration and if it is the only flag, the
  // vnode should not be considered dynamic due to handler caching.
  l.patchFlag !== 32 && Vr.push(l), l;
}
const ai = eE;
function eE(i, e = null, t = null, n = 0, s = null, o = !1) {
  if ((!i || i === VB) && (i = Ln), _l(i)) {
    const a = Gs(
      i,
      e,
      !0
      /* mergeRef: true */
    );
    return t && Rf(a, t), Af > 0 && !o && Vr && (a.shapeFlag & 6 ? Vr[Vr.indexOf(i)] = a : Vr.push(a)), a.patchFlag |= -2, a;
  }
  if (oE(i) && (i = i.__vccOpts), e) {
    e = D$(e);
    let { class: a, style: l } = e;
    a && !St(a) && (e.class = pf(a)), at(l) && (bg(l) && !ve(l) && (l = xt({}, l)), e.style = hf(l));
  }
  const r = St(i) ? 1 : PB(i) ? 128 : S$(i) ? 64 : at(i) ? 4 : be(i) ? 2 : 0;
  return I$(
    i,
    e,
    t,
    n,
    s,
    r,
    o,
    !0
  );
}
function D$(i) {
  return i ? bg(i) || Hc in i ? xt({}, i) : i : null;
}
function Gs(i, e, t = !1) {
  const { props: n, ref: s, patchFlag: o, children: r } = i, a = e ? O$(n || {}, e) : n;
  return {
    __v_isVNode: !0,
    __v_skip: !0,
    type: i.type,
    props: a,
    key: a && JS(a),
    ref: e && e.ref ? (
      // #2078 in the case of <component :is="vnode" ref="extra"/>
      // if the vnode itself already has a ref, cloneVNode will need to merge
      // the refs so the single vnode can be set on multiple refs
      t && s ? ve(s) ? s.concat(xu(e)) : [s, xu(e)] : xu(e)
    ) : s,
    scopeId: i.scopeId,
    slotScopeIds: i.slotScopeIds,
    children: r,
    target: i.target,
    targetAnchor: i.targetAnchor,
    staticCount: i.staticCount,
    shapeFlag: i.shapeFlag,
    // if the vnode is cloned with extra props, we can no longer assume its
    // existing patch flag to be reliable and need to add the FULL_PROPS flag.
    // note: preserve flag for fragments since they use the flag for children
    // fast paths only.
    patchFlag: e && i.type !== wi ? o === -1 ? 16 : o | 16 : o,
    dynamicProps: i.dynamicProps,
    dynamicChildren: i.dynamicChildren,
    appContext: i.appContext,
    dirs: i.dirs,
    transition: i.transition,
    // These should technically only be non-null on mounted VNodes. However,
    // they *should* be copied for kept-alive vnodes. So we just always copy
    // them since them being non-null during a mount doesn't affect the logic as
    // they will simply be overwritten.
    component: i.component,
    suspense: i.suspense,
    ssContent: i.ssContent && Gs(i.ssContent),
    ssFallback: i.ssFallback && Gs(i.ssFallback),
    el: i.el,
    anchor: i.anchor,
    ctx: i.ctx,
    ce: i.ce
  };
}
function T$(i = " ", e = 0) {
  return ai(Nl, null, i, e);
}
function ii(i) {
  return i == null || typeof i == "boolean" ? ai(Ln) : ve(i) ? ai(
    wi,
    null,
    // #3666, avoid reference pollution when reusing vnode
    i.slice()
  ) : typeof i == "object" ? Os(i) : ai(Nl, null, String(i));
}
function Os(i) {
  return i.el === null && i.patchFlag !== -1 || i.memo ? i : Gs(i);
}
function Rf(i, e) {
  let t = 0;
  const { shapeFlag: n } = i;
  if (e == null)
    e = null;
  else if (ve(e))
    t = 16;
  else if (typeof e == "object")
    if (n & 65) {
      const s = e.default;
      s && (s._c && (s._d = !1), Rf(i, s()), s._c && (s._d = !0));
      return;
    } else {
      t = 32;
      const s = e._;
      !s && !(Hc in e) ? e._ctx = $n : s === 3 && $n && ($n.slots._ === 1 ? e._ = 1 : (e._ = 2, i.patchFlag |= 1024));
    }
  else
    be(e) ? (e = { default: e, _ctx: $n }, t = 32) : (e = String(e), n & 64 ? (t = 16, e = [T$(e)]) : t = 8);
  i.children = e, i.shapeFlag |= t;
}
function O$(...i) {
  const e = {};
  for (let t = 0; t < i.length; t++) {
    const n = i[t];
    for (const s in n)
      if (s === "class")
        e.class !== n.class && (e.class = pf([e.class, n.class]));
      else if (s === "style")
        e.style = hf([e.style, n.style]);
      else if (Ml(s)) {
        const o = e[s], r = n[s];
        r && o !== r && !(ve(o) && o.includes(r)) && (e[s] = o ? [].concat(o, r) : r);
      } else
        s !== "" && (e[s] = n[s]);
  }
  return e;
}
function fi(i, e, t, n = null) {
  di(i, e, 7, [
    t,
    n
  ]);
}
const A$ = GS();
let R$ = 0;
function F$(i, e, t) {
  const n = i.type, s = (e ? e.appContext : i.appContext) || A$, o = {
    uid: R$++,
    vnode: i,
    type: n,
    parent: e,
    appContext: s,
    root: null,
    // to be immediately set
    next: null,
    subTree: null,
    // will be set synchronously right after creation
    effect: null,
    update: null,
    // will be set synchronously right after creation
    scope: new FM(
      !0
      /* detached */
    ),
    render: null,
    proxy: null,
    exposed: null,
    exposeProxy: null,
    withProxy: null,
    provides: e ? e.provides : Object.create(s.provides),
    accessCache: null,
    renderCache: [],
    // local resolved assets
    components: null,
    directives: null,
    // resolved props and emits options
    propsOptions: jS(n, s),
    emitsOptions: PS(n, s),
    // emit
    emit: null,
    // to be set immediately
    emitted: null,
    // props default value
    propsDefaults: it,
    // inheritAttrs
    inheritAttrs: n.inheritAttrs,
    // state
    ctx: it,
    data: it,
    props: it,
    attrs: it,
    slots: it,
    refs: it,
    setupState: it,
    setupContext: null,
    attrsProxy: null,
    slotsProxy: null,
    // suspense related
    suspense: t,
    suspenseId: t ? t.pendingId : 0,
    asyncDep: null,
    asyncResolved: !1,
    // lifecycle hooks
    // not using enums here because it results in computed properties
    isMounted: !1,
    isUnmounted: !1,
    isDeactivated: !1,
    bc: null,
    c: null,
    bm: null,
    m: null,
    bu: null,
    u: null,
    um: null,
    bum: null,
    da: null,
    a: null,
    rtg: null,
    rtc: null,
    ec: null,
    sp: null
  };
  return o.ctx = { _: o }, o.root = e ? e.root : o, o.emit = DB.bind(null, o), i.ce && i.ce(o), o;
}
let Ht = null, Ff, Fg;
{
  const i = cf(), e = (t, n) => {
    let s;
    return (s = i[t]) || (s = i[t] = []), s.push(n), (o) => {
      s.length > 1 ? s.forEach((r) => r(o)) : s[0](o);
    };
  };
  Ff = e(
    "__VUE_INSTANCE_SETTERS__",
    (t) => Ht = t
  ), Fg = e(
    "__VUE_SSR_SETTERS__",
    (t) => Wc = t
  );
}
const Xr = (i) => {
  Ff(i), i.scope.on();
}, Vo = () => {
  Ht && Ht.scope.off(), Ff(null);
};
function nE(i) {
  return i.vnode.shapeFlag & 4;
}
let Wc = !1;
function V$(i, e = !1) {
  e && Fg(e);
  const { props: t, children: n } = i.vnode, s = nE(i);
  l$(i, t, s, e), _$(i, n);
  const o = s ? P$(i, e) : void 0;
  return e && Fg(!1), o;
}
function P$(i, e) {
  const n = i.type;
  i.accessCache = /* @__PURE__ */ Object.create(null), i.proxy = wS(new Proxy(i.ctx, zS));
  const { setup: s } = n;
  if (s) {
    const o = i.setupContext = s.length > 1 ? $$(i) : null;
    Xr(i), eo();
    const r = ts(
      s,
      i,
      0,
      [
        i.props,
        o
      ]
    );
    if (to(), Vo(), lf(r)) {
      if (r.then(Vo, Vo), e)
        return r.then((a) => {
          Bv(i, a, e);
        }).catch((a) => {
          Bl(a, i, 0);
        });
      if (i.asyncDep = r, "production" !== "production" ) ;
    } else
      Bv(i, r, e);
  } else
    iE(i, e);
}
function Bv(i, e, t) {
  be(e) ? i.type.__ssrInlineRender ? i.ssrRender = e : i.render = e : at(e) ? (i.setupState = ES(e), "production" !== "production" ) : "production" !== "production"  , iE(i, t);
}
let Vg;
function iE(i, e, t) {
  const n = i.type;
  if (!i.render) {
    if (!e && Vg && !n.render) {
      const s = n.template || Tf(i).template;
      if (s) {
        const { isCustomElement: o, compilerOptions: r } = i.appContext.config, { delimiters: a, compilerOptions: l } = n, d = xt(
          xt(
            {
              isCustomElement: o,
              delimiters: a
            },
            r
          ),
          l
        );
        n.render = Vg(s, d);
      }
    }
    i.render = n.render || yt;
  }
  {
    Xr(i), eo();
    try {
      e$(i);
    } finally {
      to(), Vo();
    }
  }
}
function $v(i) {
  return i.attrsProxy || (i.attrsProxy = new Proxy(
    i.attrs,
    {
      get(e, t) {
        return zt(i, "get", "$attrs"), e[t];
      }
    }
  ));
}
function $$(i) {
  const e = (t) => {
    i.exposed = t || {};
  };
  return {
    get attrs() {
      return $v(i);
    },
    slots: i.slots,
    emit: i.emit,
    expose: e
  };
}
function kf(i) {
  if (i.exposed)
    return i.exposeProxy || (i.exposeProxy = new Proxy(ES(wS(i.exposed)), {
      get(e, t) {
        if (t in e)
          return e[t];
        if (t in ko)
          return ko[t](i);
      },
      has(e, t) {
        return t in e || t in ko;
      }
    }));
}
const N$ = /(?:^|[-_])(\w)/g, L$ = (i) => i.replace(N$, (e) => e.toUpperCase()).replace(/[-_]/g, "");
function sE(i, e = !0) {
  return be(i) ? i.displayName || i.name : i.name || e && i.__name;
}
function zc(i, e, t = !1) {
  let n = sE(e);
  if (!n && e.__file) {
    const s = e.__file.match(/([^/\\]+)\.\w+$/);
    s && (n = s[1]);
  }
  if (!n && i && i.parent) {
    const s = (o) => {
      for (const r in o)
        if (o[r] === e)
          return r;
    };
    n = s(
      i.components || i.parent.type.components
    ) || s(i.appContext.components);
  }
  return n ? L$(n) : t ? "App" : "Anonymous";
}
function oE(i) {
  return be(i) && "__vccOpts" in i;
}
const H$ = (i, e) => tB(i, e, Wc);
function rE(i, e, t) {
  const n = arguments.length;
  return n === 2 ? at(e) && !ve(e) ? _l(e) ? ai(i, null, [e]) : ai(i, e) : ai(i, null, e) : (n > 3 ? t = Array.prototype.slice.call(arguments, 2) : n === 3 && _l(t) && (t = [t]), ai(i, e, t));
}
const W$ = Symbol.for("v-scx"), z$ = () => {
  {
    const i = _u(W$);
    return i;
  }
};
const Nv = "3.4.0";
const G$ = "http://www.w3.org/2000/svg", U$ = "http://www.w3.org/1998/Math/MathML", As = typeof document < "u" ? document : null, Lv = As && /* @__PURE__ */ As.createElement("template"), j$ = {
  insert: (i, e, t) => {
    e.insertBefore(i, t || null);
  },
  remove: (i) => {
    const e = i.parentNode;
    e && e.removeChild(i);
  },
  createElement: (i, e, t, n) => {
    const s = e === "svg" ? As.createElementNS(G$, i) : e === "mathml" ? As.createElementNS(U$, i) : As.createElement(i, t ? { is: t } : void 0);
    return i === "select" && n && n.multiple != null && s.setAttribute("multiple", n.multiple), s;
  },
  createText: (i) => As.createTextNode(i),
  createComment: (i) => As.createComment(i),
  setText: (i, e) => {
    i.nodeValue = e;
  },
  setElementText: (i, e) => {
    i.textContent = e;
  },
  parentNode: (i) => i.parentNode,
  nextSibling: (i) => i.nextSibling,
  querySelector: (i) => As.querySelector(i),
  setScopeId(i, e) {
    i.setAttribute(e, "");
  },
  // __UNSAFE__
  // Reason: innerHTML.
  // Static content here can only come from compiled templates.
  // As long as the user only uses trusted templates, this is safe.
  insertStaticContent(i, e, t, n, s, o) {
    const r = t ? t.previousSibling : e.lastChild;
    if (s && (s === o || s.nextSibling))
      for (; e.insertBefore(s.cloneNode(!0), t), !(s === o || !(s = s.nextSibling)); )
        ;
    else {
      Lv.innerHTML = n === "svg" ? `<svg>${i}</svg>` : n === "mathml" ? `<math>${i}</math>` : i;
      const a = Lv.content;
      if (n === "svg" || n === "mathml") {
        const l = a.firstChild;
        for (; l.firstChild; )
          a.appendChild(l.firstChild);
        a.removeChild(l);
      }
      e.insertBefore(a, t);
    }
    return [
      // first
      r ? r.nextSibling : e.firstChild,
      // last
      t ? t.previousSibling : e.lastChild
    ];
  }
}, q$ = Symbol("_vtc");
function Y$(i, e, t) {
  const n = i[q$];
  n && (e = (e ? [e, ...n] : [...n]).join(" ")), e == null ? i.removeAttribute("class") : t ? i.setAttribute("class", e) : i.className = e;
}
const X$ = Symbol("_vod"), Z$ = Symbol("");
function Q$(i, e, t) {
  const n = i.style, s = St(t);
  if (t && !s) {
    if (e && !St(e))
      for (const o in e)
        t[o] == null && Pg(n, o, "");
    for (const o in t)
      Pg(n, o, t[o]);
  } else {
    const o = n.display;
    if (s) {
      if (e !== t) {
        const r = n[Z$];
        r && (t += ";" + r), n.cssText = t;
      }
    } else
      e && i.removeAttribute("style");
    X$ in i && (n.display = o);
  }
}
const Hv = /\s*!important$/;
function Pg(i, e, t) {
  if (ve(t))
    t.forEach((n) => Pg(i, e, n));
  else if (t == null && (t = ""), e.startsWith("--"))
    i.setProperty(e, t);
  else {
    const n = eN(i, e);
    Hv.test(t) ? i.setProperty(
      Ks(n),
      t.replace(Hv, ""),
      "important"
    ) : i[n] = t;
  }
}
const Wv = ["Webkit", "Moz", "ms"], zh = {};
function eN(i, e) {
  const t = zh[e];
  if (t)
    return t;
  let n = Yr(e);
  if (n !== "filter" && n in i)
    return zh[e] = n;
  n = Vc(n);
  for (let s = 0; s < Wv.length; s++) {
    const o = Wv[s] + n;
    if (o in i)
      return zh[e] = o;
  }
  return e;
}
const zv = "http://www.w3.org/1999/xlink";
function tN(i, e, t, n, s) {
  if (n && e.startsWith("xlink:"))
    t == null ? i.removeAttributeNS(zv, e.slice(6, e.length)) : i.setAttributeNS(zv, e, t);
  else {
    const o = RM(e);
    t == null || o && !aS(t) ? i.removeAttribute(e) : i.setAttribute(e, o ? "" : t);
  }
}
function nN(i, e, t, n, s, o, r) {
  if (e === "innerHTML" || e === "textContent") {
    n && r(n, s, o), i[e] = t ?? "";
    return;
  }
  const a = i.tagName;
  if (e === "value" && a !== "PROGRESS" && // custom elements may use _value internally
  !a.includes("-")) {
    i._value = t;
    const d = a === "OPTION" ? i.getAttribute("value") : i.value, u = t ?? "";
    d !== u && (i.value = u), t == null && i.removeAttribute(e);
    return;
  }
  let l = !1;
  if (t === "" || t == null) {
    const d = typeof i[e];
    d === "boolean" ? t = aS(t) : t == null && d === "string" ? (t = "", l = !0) : d === "number" && (t = 0, l = !0);
  }
  try {
    i[e] = t;
  } catch (d) {
  }
  l && i.removeAttribute(e);
}
function iN(i, e, t, n) {
  i.addEventListener(e, t, n);
}
function sN(i, e, t, n) {
  i.removeEventListener(e, t, n);
}
const Kv = Symbol("_vei");
function oN(i, e, t, n, s = null) {
  const o = i[Kv] || (i[Kv] = {}), r = o[e];
  if (n && r)
    r.value = n;
  else {
    const [a, l] = rN(e);
    if (n) {
      const d = o[e] = dN(n, s);
      iN(i, a, d, l);
    } else
      r && (sN(i, a, r, l), o[e] = void 0);
  }
}
const Gv = /(?:Once|Passive|Capture)$/;
function rN(i) {
  let e;
  if (Gv.test(i)) {
    e = {};
    let n;
    for (; n = i.match(Gv); )
      i = i.slice(0, i.length - n[0].length), e[n[0].toLowerCase()] = !0;
  }
  return [i[2] === ":" ? i.slice(3) : Ks(i.slice(2)), e];
}
let Kh = 0;
const aN = /* @__PURE__ */ Promise.resolve(), lN = () => Kh || (aN.then(() => Kh = 0), Kh = Date.now());
function dN(i, e) {
  const t = (n) => {
    if (!n._vts)
      n._vts = Date.now();
    else if (n._vts <= t.attached)
      return;
    di(
      uN(n, t.value),
      e,
      5,
      [n]
    );
  };
  return t.value = i, t.attached = lN(), t;
}
function uN(i, e) {
  if (ve(e)) {
    const t = i.stopImmediatePropagation;
    return i.stopImmediatePropagation = () => {
      t.call(i), i._stopped = !0;
    }, e.map((n) => (s) => !s._stopped && n && n(s));
  } else
    return e;
}
const Uv = (i) => i.charCodeAt(0) === 111 && i.charCodeAt(1) === 110 && // lowercase letter
i.charCodeAt(2) > 96 && i.charCodeAt(2) < 123, cN = (i, e, t, n, s, o, r, a, l) => {
  const d = s === "svg";
  e === "class" ? Y$(i, n, d) : e === "style" ? Q$(i, t, n) : Ml(e) ? zu(e) || oN(i, e, t, n, r) : (e[0] === "." ? (e = e.slice(1), !0) : e[0] === "^" ? (e = e.slice(1), !1) : hN(i, e, n, d)) ? nN(
    i,
    e,
    n,
    o,
    r,
    a,
    l
  ) : (e === "true-value" ? i._trueValue = n : e === "false-value" && (i._falseValue = n), tN(i, e, n, d));
};
function hN(i, e, t, n) {
  if (n)
    return !!(e === "innerHTML" || e === "textContent" || e in i && Uv(e) && be(t));
  if (e === "spellcheck" || e === "draggable" || e === "translate" || e === "form" || e === "list" && i.tagName === "INPUT" || e === "type" && i.tagName === "TEXTAREA")
    return !1;
  if (e === "width" || e === "height") {
    const s = i.tagName;
    if (s === "IMG" || s === "VIDEO" || s === "CANVAS" || s === "SOURCE")
      return !1;
  }
  return Uv(e) && St(t) ? !1 : e in i;
}
const pN = /* @__PURE__ */ xt({ patchProp: cN }, j$);
let jv;
function gN() {
  return jv || (jv = x$(pN));
}
const mN = (...i) => {
  const e = gN().createApp(...i);
  const { mount: t } = e;
  return e.mount = (n) => {
    const s = vN(n);
    if (!s)
      return;
    const o = e._component;
    !be(o) && !o.render && !o.template && (o.template = s.innerHTML), s.innerHTML = "";
    const r = t(s, !1, fN(s));
    return s instanceof Element && (s.removeAttribute("v-cloak"), s.setAttribute("data-v-app", "")), r;
  }, e;
};
function fN(i) {
  if (i instanceof SVGElement)
    return "svg";
  if (typeof MathMLElement == "function" && i instanceof MathMLElement)
    return "mathml";
}
function vN(i) {
  if (St(i)) {
    const e = document.querySelector(i);
    return e;
  }
  return i;
}
const fs = function(i) {
  this._options = i || {}, this._list = [], this._queue = [], this._firing = !1, this._fired = !1, this._firingIndexes = [];
};
fs.prototype._fireCore = function(i, e) {
  const t = this._firingIndexes, n = this._list, {
    stopOnFalse: s
  } = this._options, o = t.length;
  for (t[o] = 0; t[o] < n.length && !(n[t[o]].apply(i, e) === !1 && s); t[o]++)
    ;
  t.pop();
};
fs.prototype.add = function(i) {
  return typeof i == "function" && (!this._options.unique || !this.has(i)) && this._list.push(i), this;
};
fs.prototype.remove = function(i) {
  const e = this._list, t = this._firingIndexes, n = e.indexOf(i);
  if (n > -1 && (e.splice(n, 1), this._firing && t.length))
    for (let s = 0; s < t.length; s++)
      n <= t[s] && t[s]--;
  return this;
};
fs.prototype.has = function(i) {
  const e = this._list;
  return i ? e.indexOf(i) > -1 : !!e.length;
};
fs.prototype.empty = function(i) {
  return this._list = [], this;
};
fs.prototype.fireWith = function(i, e) {
  const t = this._queue;
  if (e = e || [], e = e.slice ? e.slice() : e, this._options.syncStrategy)
    this._firing = !0, this._fireCore(i, e);
  else {
    if (t.push([i, e]), this._firing)
      return;
    for (this._firing = !0; t.length; ) {
      const n = t.shift();
      this._fireCore(n[0], n[1]);
    }
  }
  return this._firing = !1, this._fired = !0, this;
};
fs.prototype.fire = function() {
  this.fireWith(this, arguments);
};
fs.prototype.fired = function() {
  return this._fired;
};
const Ie = function(i) {
  return new fs(i);
}, mt = (i, e) => {
  if (Array.isArray(i))
    return i.map(e);
  const t = [];
  for (const n in i)
    t.push(e(i[n], n));
  return t;
}, y = (i, e) => {
  if (i) {
    if ("length" in i)
      for (let t = 0; t < i.length && e.call(i[t], t, i[t]) !== !1; t++)
        ;
    else
      for (const t in i)
        if (e.call(i[t], t, i[t]) === !1)
          break;
    return i;
  }
};
class Vf {
  constructor() {
    this.memory = [], this.callbacks = Ie();
  }
  add(e) {
    y(this.memory, (t, n) => e.apply(e, n)), this.callbacks.add(e);
  }
  remove(e) {
    this.callbacks.remove(e);
  }
  fire() {
    for (var e = arguments.length, t = new Array(e), n = 0; n < e; n++)
      t[n] = arguments[n];
    this.memory.push(t), this.callbacks.fire.apply(this.callbacks, t);
  }
}
const Pf = new Vf(), yN = ["pageX", "pageY", "screenX", "screenY", "clientX", "clientY"], bN = function(i, e) {
  if (e[i] && !e.touches || !e.touches)
    return e[i];
  const t = e.touches.length ? e.touches : e.changedTouches;
  if (t.length)
    return t[0][i];
};
function wN(i) {
  yN.forEach((e) => {
    i(e, (t) => bN(e, t));
  }, this);
}
const Mf = (i) => {
  var e, t;
  const {
    originalEvent: n
  } = i;
  if (!n)
    return i.target;
  if (!!!(!((e = n.target) === null || e === void 0) && e.shadowRoot))
    return n.target;
  const o = n.path ?? ((t = n.composedPath) === null || t === void 0 ? void 0 : t.call(n));
  return o?.[0] ?? i.target;
};
function I() {
  return I = Object.assign ? Object.assign.bind() : function(i) {
    for (var e = 1; e < arguments.length; e++) {
      var t = arguments[e];
      for (var n in t)
        ({}).hasOwnProperty.call(t, n) && (i[n] = t[n]);
    }
    return i;
  }, I.apply(null, arguments);
}
const SN = {
  "[object Array]": "array",
  "[object Date]": "date",
  "[object Object]": "object",
  "[object String]": "string"
}, yn = function(i) {
  if (i === null)
    return "null";
  const e = Object.prototype.toString.call(i);
  return typeof i == "object" ? SN[e] || "object" : typeof i;
}, Zr = function(i) {
  return typeof i == "boolean";
}, Mg = function(i) {
  return $e(i) && i.toString().indexOf("e") !== -1;
}, cn = function(i) {
  return yn(i) === "date";
}, f = function(i) {
  return i != null;
}, B = function(i) {
  return typeof i == "function";
}, te = function(i) {
  return typeof i == "string";
}, $e = function(i) {
  return typeof i == "number" && isFinite(i) || !isNaN(i - parseFloat(i));
}, X = function(i) {
  return yn(i) === "object";
}, en = function(i) {
  let e;
  for (e in i)
    return !1;
  return !0;
}, pe = function(i) {
  if (!i || yn(i) !== "object")
    return !1;
  const e = Object.getPrototypeOf(i);
  if (!e)
    return !0;
  const t = Object.hasOwnProperty.call(e, "constructor") && e.constructor;
  return typeof t == "function" && Object.toString.call(t) === Object.toString.call(Object);
}, Kr = function(i) {
  return !["object", "array", "function"].includes(yn(i));
}, lt = function(i) {
  return i != null && i === i.window;
}, zn = function(i) {
  return !!i && !!(i.jquery || i.dxRenderer);
}, no = function(i) {
  return !!i && B(i.then);
}, da = function(i) {
  return !!i && B(i.done) && B(i.fail);
}, aE = function(i) {
  return !!(i && i.preventDefault);
}, tl = {
  isBoolean: Zr,
  isDate: cn,
  isDeferred: da,
  isDefined: f,
  isEmptyObject: en,
  isEvent: aE,
  isExponential: Mg,
  isFunction: B,
  isNumeric: $e,
  isObject: X,
  isPlainObject: pe,
  isPrimitive: Kr,
  isPromise: no,
  isRenderer: zn,
  isString: te,
  isWindow: lt,
  type: yn
}, EN = function(i, e, t) {
  i = i || {};
  for (const n in e)
    if (Object.prototype.hasOwnProperty.call(e, n)) {
      const s = e[n];
      (!(n in i) || t) && (i[n] = s);
    }
  return i;
}, x = function(i) {
  i = i || {};
  let e = 1, t = !1;
  for (typeof i == "boolean" && (t = i, i = arguments[1] || {}, e++); e < arguments.length; e++) {
    const n = arguments[e];
    if (n != null)
      for (const s in n) {
        const o = i[s], r = n[s];
        let a = !1, l;
        s === "__proto__" || s === "constructor" || i === r || (t && r && (pe(r) || (a = Array.isArray(r))) ? (a ? l = o && Array.isArray(o) ? o : [] : l = o && pe(o) ? o : {}, i[s] = x(t, l, r)) : r !== void 0 && (i[s] = r));
      }
  }
  return i;
}, lE = function() {
  const i = [new RegExp("&", "g"), new RegExp('"', "g"), new RegExp("'", "g"), new RegExp("<", "g"), new RegExp(">", "g")];
  return function(e) {
    return String(e).replace(i[0], "&amp;").replace(i[1], "&quot;").replace(i[2], "&#39;").replace(i[3], "&lt;").replace(i[4], "&gt;");
  };
}(), IN = function(i) {
  switch (typeof i) {
    case "string":
      return i.split(/\s+/, 4);
    case "object":
      return [i.x || i.h || i.left, i.y || i.v || i.top, i.x || i.h || i.right, i.y || i.v || i.bottom];
    case "number":
      return [i];
    default:
      return i;
  }
}, DN = function(i) {
  const e = IN(i);
  let t = parseInt(e && e[0], 10), n = parseInt(e && e[1], 10), s = parseInt(e && e[2], 10), o = parseInt(e && e[3], 10);
  return isFinite(t) || (t = 0), isFinite(n) || (n = t), isFinite(s) || (s = t), isFinite(o) || (o = n), {
    top: n,
    right: s,
    bottom: o,
    left: t
  };
};
function Fi(i) {
  for (var e = arguments.length, t = new Array(e > 1 ? e - 1 : 0), n = 1; n < e; n++)
    t[n - 1] = arguments[n];
  return B(i) ? i(...t) : (t.forEach((s, o) => {
    te(s) && (s = s.replace(/\$/g, "$$$$"));
    const r = new RegExp(`\\{${o}\\}`, "gm");
    i = i.replace(r, s);
  }), i);
}
const yu = function() {
  const i = /\s/g;
  return function(e) {
    return !e || !e.replace(i, "");
  };
}(), TN = "24.2.7", qv = "24.2.7", ON = function() {
}, Rd = function(i) {
  return typeof console > "u" || !B(console[i]) ? ON : console[i].bind(console);
}, Kc = {
  log: Rd("log"),
  info: Rd("info"),
  warn: Rd("warn"),
  error: Rd("error")
}, AN = function() {
  function i(e, t) {
    if (!e)
      throw new Error(t);
  }
  return {
    assert: i,
    assertParam: function(e, t) {
      i(e != null, t);
    }
  };
}(), RN = {
  logger: Kc,
  debug: AN
}, FN = `https://js.devexpress.com/error/${TN.split(".").slice(0, 2).join("_")}/`;
function Bf(i, e) {
  const t = {
    ERROR_MESSAGES: x(e, i),
    Error: function() {
      for (var r = arguments.length, a = new Array(r), l = 0; l < r; l++)
        a[l] = arguments[l];
      return function(d) {
        const u = d[0];
        d = d.slice(1);
        const c = n(u, d), h = o(u), g = s(u, c);
        return x(new Error(g), {
          __id: u,
          __details: c,
          url: h
        });
      }(a);
    },
    log() {
      for (var r = arguments.length, a = new Array(r), l = 0; l < r; l++)
        a[l] = arguments[l];
      const d = a[0];
      let u = "log";
      /^E\d+$/.test(d) ? u = "error" : /^W\d+$/.test(d) && (u = "warn"), RN.logger[u](u === "log" ? d : function(c) {
        const h = c[0];
        return c = c.slice(1), s(h, n(h, c));
      }(a));
    }
  };
  function n(r, a) {
    return a = [t.ERROR_MESSAGES[r]].concat(a), Fi.apply(this, a).replace(/\.*\s*?$/, "");
  }
  function s(r, a) {
    const l = r != null && r.startsWith("W") ? "warning" : "error";
    return Fi.apply(this, [`{0} - {1}.

For additional information on this {2} message, see: {3}`, r, a, l, o(r)]);
  }
  function o(r) {
    return FN + r;
  }
  return t;
}
const Ae = Bf({
  E0001: "Method is not implemented",
  E0002: "Member name collision: {0}",
  E0003: "A class must be instantiated using the 'new' keyword",
  E0004: "The NAME property of the component is not specified",
  E0005: "Unknown device",
  E0006: "Unknown endpoint key is requested",
  E0007: "'Invalidate' method is called outside the update transaction",
  E0008: "Type of the option name is not appropriate to create an action",
  E0009: "Component '{0}' has not been initialized for an element",
  E0010: "Animation configuration with the '{0}' type requires '{1}' configuration as {2}",
  E0011: "Unknown animation type '{0}'",
  E0012: "jQuery version is too old. Please upgrade jQuery to 1.10.0 or later",
  E0013: "KnockoutJS version is too old. Please upgrade KnockoutJS to 2.3.0 or later",
  E0014: "The 'release' method shouldn't be called for an unlocked Lock object",
  E0015: "Queued task returned an unexpected result",
  E0017: "Event namespace is not defined",
  E0018: "DevExpress.ui.DevExpressPopup widget is required",
  E0020: "Template engine '{0}' is not supported",
  E0021: "Unknown theme is set: {0}",
  E0022: "LINK[rel=DevExpress-theme] tags must go before DevExpress included scripts",
  E0023: "Template name is not specified",
  E0024: "DevExtreme bundle already included",
  E0025: "Unexpected argument type",
  E0100: "Unknown validation type is detected",
  E0101: "Misconfigured range validation rule is detected",
  E0102: "Misconfigured comparison validation rule is detected",
  E0103: "validationCallback of an asynchronous rule should return a jQuery or a native promise",
  E0110: "Unknown validation group is detected",
  E0120: "Adapter for a DevExpressValidator component cannot be configured",
  E0121: "The 'customItem' parameter of the 'onCustomItemCreating' function is empty or contains invalid data. Assign a custom object or a Promise that is resolved after the item is created.",
  W0000: "'{0}' is deprecated in {1}. {2}",
  W0001: "{0} - '{1}' option is deprecated in {2}. {3}",
  W0002: "{0} - '{1}' method is deprecated in {2}. {3}",
  W0003: "{0} - '{1}' property is deprecated in {2}. {3}",
  W0004: "Timeout for theme loading is over: {0}",
  W0005: "'{0}' event is deprecated in {1}. {2}",
  W0006: "Invalid recurrence rule: '{0}'",
  W0007: "'{0}' Globalize culture is not defined",
  W0008: "Invalid view name: '{0}'",
  W0009: "Invalid time zone name: '{0}'",
  W0010: "{0} is deprecated in {1}. {2}",
  W0011: "Number parsing is invoked while the parser is not defined",
  W0012: "Date parsing is invoked while the parser is not defined",
  W0013: "'{0}' file is deprecated in {1}. {2}",
  W0014: "{0} - '{1}' type is deprecated in {2}. {3}",
  W0015: "Instead of returning a value from the '{0}' function, write it into the '{1}' field of the function's parameter.",
  W0016: 'The "{0}" option does not accept the "{1}" value since v{2}. {3}.',
  W0017: 'Setting the "{0}" property with a function is deprecated since v21.2',
  W0018: 'Setting the "position" property with a function is deprecated since v21.2',
  W0019: `DevExtreme: Unable to Locate a Valid License Key.

Detailed license/registration related information and instructions: https://js.devexpress.com/Documentation/Licensing/.

If you are using a 30-day trial version of DevExtreme, you must uninstall all copies of DevExtreme once your 30-day trial period expires. For terms and conditions that govern use of DevExtreme UI components/libraries, please refer to the DevExtreme End User License Agreement: https://js.devexpress.com/EULAs/DevExtremeComplete.

To use DevExtreme in a commercial project, you must purchase a license. For pricing/licensing options, please visit: https://js.devexpress.com/Buy.

If you have licensing-related questions or need help with a purchase, please email clientservices@devexpress.com.

`,
  W0020: `DevExtreme: License Key Has Expired.

Detailed license/registration related information and instructions: https://js.devexpress.com/Documentation/Licensing/.

A mismatch exists between the license key used and the DevExtreme version referenced in this project.

To proceed, you can:
• use a version of DevExtreme linked to your license key: https://www.devexpress.com/ClientCenter/DownloadManager
• renew your DevExpress Subscription: https://www.devexpress.com/buy/renew (once you renew your subscription, you will be entitled to product updates and support service as defined in the DevExtreme End User License Agreement)

If you have licensing-related questions or need help with a renewal, please email clientservices@devexpress.com.

`,
  W0021: `DevExtreme: License Key Verification Has Failed.

Detailed license/registration related information and instructions: https://js.devexpress.com/Documentation/Licensing/.

To verify your DevExtreme license, make certain to specify a correct key in the GlobalConfig. If you continue to encounter this error, please visit https://www.devexpress.com/ClientCenter/DownloadManager to obtain a valid license key.

If you have a valid license and this problem persists, please submit a support ticket via the DevExpress Support Center. We will be happy to follow-up: https://supportcenter.devexpress.com/ticket/create.

`,
  W0022: `DevExtreme: Pre-release software. Not suitable for commercial use.

Detailed license/registration related information and instructions: https://js.devexpress.com/Documentation/Licensing/.

Pre-release software may contain deficiencies and as such, should not be considered for use or integrated in any mission critical application.

`,
  W0023: `DevExtreme: the following 'devextreme' package version does not match versions of other DevExpress products used in this application:

{0}

Interoperability between different versions of the products listed herein cannot be guaranteed.

`
}), Yv = {
  rtlEnabled: !1,
  defaultCurrency: "USD",
  defaultUseCurrencyAccountingStyle: !0,
  oDataFilterToLower: !0,
  serverDecimalSeparator: ".",
  decimalSeparator: ".",
  thousandsSeparator: ",",
  forceIsoDateParsing: !0,
  wrapActionsBeforeExecute: !0,
  useLegacyStoreResult: !1,
  useJQuery: void 0,
  editorStylingMode: void 0,
  useLegacyVisibleIndex: !1,
  floatingActionButtonConfig: {
    icon: "add",
    closeIcon: "close",
    label: "",
    position: {
      at: "right bottom",
      my: "right bottom",
      offset: {
        x: -16,
        y: -16
      }
    },
    maxSpeedDialActionCount: 5,
    shading: !1,
    direction: "auto"
  },
  optionsParser: (i) => {
    i.trim().charAt(0) !== "{" && (i = `{${i}}`);
    try {
      return JSON.parse(i);
    } catch (e) {
      try {
        return JSON.parse(kN(i));
      } catch {
        throw Ae.Error("E3018", e, i);
      }
    }
  }
}, kN = (i) => i.replace(/'/g, '"').replace(/,\s*([\]}])/g, "$1").replace(/([{,])\s*([^":\s]+)\s*:/g, '$1"$2":'), VN = ["decimalSeparator", "thousandsSeparator"], Pe = function() {
  if (!arguments.length)
    return Yv;
  const i = arguments.length <= 0 ? void 0 : arguments[0];
  VN.forEach((e) => {
    if (i[e]) {
      const t = `Now, the ${e} is selected based on the specified locale.`;
      Ae.log("W0003", "config", e, "19.2", t);
    }
  }), x(Yv, i);
};
typeof DevExpress < "u" && DevExpress.config && Pe(DevExpress.config);
const PN = function(i, e, t) {
  return function() {
    const n = this.callBase;
    this.callBase = i[e];
    try {
      return t.apply(this, arguments);
    } finally {
      this.callBase = n;
    }
  };
}, MN = function(i) {
  const e = function() {
  };
  return e.prototype = i.prototype, new e();
}, BN = function(i) {
  const e = this;
  let t, n, s;
  if (!i)
    return e;
  for (n in i)
    s = i[n], t = typeof e.prototype[n] == "function" && typeof s == "function", e.prototype[n] = t ? PN(e.parent.prototype, n, s) : s;
  return e;
}, $N = function() {
  const i = this;
  let e, t, n;
  const s = Object.prototype.hasOwnProperty.bind(i);
  !s("_includedCtors") && !s("_includedPostCtors") && (i._includedCtors = i._includedCtors.slice(0), i._includedPostCtors = i._includedPostCtors.slice(0));
  for (var r = arguments.length, a = new Array(r), l = 0; l < r; l++)
    a[l] = arguments[l];
  for (n = 0; n < a.length; n++) {
    e = a[n], e.ctor && i._includedCtors.push(e.ctor), e.postCtor && i._includedPostCtors.push(e.postCtor);
    for (t in e)
      t === "ctor" || t === "postCtor" || t === "default" || (i.prototype[t] = e[t]);
  }
  return i;
}, NN = function(i) {
  if (!Object.prototype.hasOwnProperty.bind(this)("parent") && this.parent) {
    const n = Object.getPrototypeOf(this);
    return n === i || n.subclassOf(i);
  }
  return this.parent === i ? !0 : !this.parent || !this.parent.subclassOf ? !1 : this.parent.subclassOf(i);
}, dE = function() {
  throw Ae.Error("E0001");
}, se = function() {
};
se.inherit = function(i) {
  const e = function() {
    if (!this || lt(this) || typeof this.constructor != "function")
      throw Ae.Error("E0003");
    const t = this, {
      ctor: n
    } = t, s = t.constructor._includedCtors, o = t.constructor._includedPostCtors;
    let r;
    for (r = 0; r < s.length; r++)
      s[r].call(t);
    if (n) {
      for (var a = arguments.length, l = new Array(a), d = 0; d < a; d++)
        l[d] = arguments[d];
      n.apply(t, l);
    }
    for (r = 0; r < o.length; r++)
      o[r].call(t);
  };
  return e.prototype = MN(this), Object.setPrototypeOf(e, this), e.inherit = this.inherit, e.abstract = dE, e.redefine = BN, e.include = $N, e.subclassOf = NN, e.parent = this, e._includedCtors = this._includedCtors ? this._includedCtors.slice(0) : [], e._includedPostCtors = this._includedPostCtors ? this._includedPostCtors.slice(0) : [], e.prototype.constructor = e, e.redefine(i), e;
};
se.abstract = dE;
const Xe = se.inherit({
  ctor: function(i) {
    i && (i = String(i)), this._value = this._normalize(i || this._generate());
  },
  _normalize: function(i) {
    for (i = i.replace(/[^a-f0-9]/gi, "").toLowerCase(); i.length < 32; )
      i += "0";
    return [i.substr(0, 8), i.substr(8, 4), i.substr(12, 4), i.substr(16, 4), i.substr(20, 12)].join("-");
  },
  _generate: function() {
    let i = "";
    for (let e = 0; e < 32; e++)
      i += Math.round(15 * Math.random()).toString(16);
    return i;
  },
  toString: function() {
    return this._value;
  },
  valueOf: function() {
    return this._value;
  },
  toJSON: function() {
    return this._value;
  }
}), uE = {};
let bu;
function LN(i, e) {
  uE[i] = e;
}
function HN(i) {
  if (te(i)) {
    if (bu = uE[i], !bu)
      throw Ae.Error("E0020", i);
  } else
    bu = i;
}
function Xv() {
  return bu;
}
function qn(i) {
  const e = se.inherit(i);
  let t = e, n = new t(i);
  const s = {}, o = function(r, a) {
    y(r, function(l) {
      B(n[l]) ? (a || !i[l]) && (i[l] = function() {
        return n[l].apply(i, arguments);
      }) : (a && (s[l] = i[l]), i[l] = n[l]);
    });
  };
  return o(i, !0), i.inject = function(r) {
    t = t.inherit(r), n = new t(), o(r);
  }, i.resetInjection = function() {
    x(i, s), t = e, n = new e();
  }, i;
}
const Bt = qn({
  isWrapped: function() {
    return !1;
  },
  isWritableWrapped: function() {
    return !1;
  },
  wrap: function(i) {
    return i;
  },
  unwrap: function(i) {
    return i;
  },
  assign: function() {
    Kc.error("Method 'assign' should not be used for not wrapped variables. Use 'isWrapped' method for ensuring.");
  }
}), Bg = function(i, e) {
  const t = [];
  let n, s;
  for (n in i)
    Object.prototype.hasOwnProperty.call(i, n) && t.push(n);
  for (t.sort(function(o, r) {
    const a = $e(o), l = $e(r);
    return a && l ? o - r : a && !l ? -1 : !a && l ? 1 : o < r ? -1 : o > r ? 1 : 0;
  }), s = 0; s < t.length; s++)
    n = t[s], e(n, i[n]);
}, Zv = (i) => X(i) ? Array.isArray(i) ? [] : {} : i, WN = function(i, e, t, n, s, o) {
  !s && Bt.isWrapped(i[e]) ? Bt.assign(i[e], t) : i[e] = t;
}, cE = function(i, e, t, n, s, o) {
  const r = n ? X(i) : pe(i);
  !s && Bt.isWrapped(i[e]) ? Bt.assign(i[e], t) : !s && Array.isArray(t) ? i[e] = t.map((a) => an(Zv(a), a, n, s, o)) : !s && r ? i[e] = an(Zv(t), t, n, s, o, cE) : i[e] = t;
}, an = function(i, e, t, n, s, o) {
  let r, a;
  const l = o ? cE : WN;
  for (const d in e) {
    if (r = i[d], a = e[d], d === "__proto__" || d === "constructor" || i === a)
      continue;
    if (pe(a)) {
      const h = t ? X(r) : pe(r);
      a = an(h ? r : {}, a, t, n, s);
    }
    (Array.isArray(a) && !n || ((s || a !== void 0) && r !== a || s && r === void 0)) && l(i, d, a, t, n, s);
  }
  return i;
}, zN = Bt.unwrap, {
  isWrapped: hE
} = Bt, {
  assign: KN
} = Bt, GN = function(i) {
  return i.replace(/\[/g, ".").replace(/\]/g, "");
}, Jo = function(i) {
  return GN(i).split(".");
}, UN = function(i, e, t) {
  return t = t || {}, Cl(e === "this" ? i : i[e], t);
}, pE = function(i, e, t, n) {
  if (e === "this")
    throw new Ae.Error("E4016");
  const s = i[e];
  n.unwrapObservables && hE(s) ? KN(s, t) : i[e] = t;
}, gE = function(i) {
  return i = i || {}, i.unwrapObservables = i.unwrapObservables !== void 0 ? i.unwrapObservables : !0, i;
};
function Cl(i, e) {
  return e.unwrapObservables ? zN(i) : i;
}
const Be = function(i) {
  if (arguments.length > 1 && (i = [].slice.call(arguments)), !i || i === "this")
    return function(e) {
      return e;
    };
  if (typeof i == "string") {
    const e = Jo(i);
    return function(t, n) {
      n = gE(n);
      const s = n.functionsAsIs, o = "defaultValue" in n;
      let r = Cl(t, n);
      for (let a = 0; a < e.length; a++) {
        if (!r) {
          if (r == null && o)
            return n.defaultValue;
          break;
        }
        const l = e[a];
        if (o && X(r) && !(l in r))
          return n.defaultValue;
        let d = Cl(r[l], n);
        !s && B(d) && (d = d.call(r)), r = d;
      }
      return r;
    };
  }
  if (Array.isArray(i))
    return jN(i);
  if (B(i))
    return i;
};
function jN(i) {
  const e = {};
  for (let t = 0, n = i.length; t < n; t++) {
    const s = i[t];
    e[s] = Be(s);
  }
  return function(t, n) {
    let s;
    return y(e, function(o) {
      const r = this(t, n);
      if (r === void 0)
        return;
      let a = s || (s = {});
      const l = o.split("."), d = l.length - 1;
      for (let u = 0; u < d; u++) {
        const c = l[u];
        c in a || (a[c] = {}), a = a[c];
      }
      a[l[d]] = r;
    }), s;
  };
}
function Qv(i, e) {
  return e != null && e.locale ? i.toLocaleLowerCase(e.locale) : i.toLowerCase();
}
function qN(i, e) {
  return e != null && e.locale ? i.toLocaleUpperCase(e.locale) : i.toUpperCase();
}
const Jv = function(i, e, t, n) {
  if (f(t))
    return t;
  const s = {};
  return pE(i, e, s, n), s;
}, $f = function(i) {
  i = Jo(i || "this");
  const e = i.length - 1;
  return function(t, n, s) {
    s = gE(s);
    let o = Cl(t, s);
    i.forEach(function(r, a) {
      let l = UN(o, r, s);
      const d = !s.functionsAsIs && B(l) && !hE(l);
      a === e ? s.merge && pe(n) && (!f(l) || pe(l)) ? (l = Jv(o, r, l, s), an(l, n, !1, !0)) : d ? o[r](n) : pE(o, r, n, s) : (l = Jv(o, r, l, s), d && (l = l.call(o)), o = l);
    });
  };
}, Mt = function(i, e) {
  var t;
  let n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  if (i instanceof Date)
    return i.getTime();
  const s = n == null || (t = n.collatorOptions) === null || t === void 0 ? void 0 : t.sensitivity;
  if (i && i instanceof se && i.valueOf)
    i = i.valueOf();
  else if (typeof i == "string" && (s === "base" || s === "case")) {
    const a = /[\u0300-\u036f]/g;
    s === "base" && (i = Qv(i, n)), i = i.normalize("NFD").replace(a, "");
  }
  if (typeof i == "string" && !(e || s === "case" || s === "variant")) {
    var r;
    const a = n == null || (r = n.locale) === null || r === void 0 ? void 0 : r.toLowerCase();
    return (a && !!["hy", "el"].find((d) => a === d || a.startsWith(`${d}-`)) ? qN : Qv)(i, n);
  }
  return i;
}, mE = [{
  method: "resolve",
  handler: "done",
  state: "resolved"
}, {
  method: "reject",
  handler: "fail",
  state: "rejected"
}, {
  method: "notify",
  handler: "progress"
}];
let Qr = function() {
  const i = this;
  this._state = "pending", this._promise = {}, mE.forEach(function(e) {
    const t = e.method;
    this[`${t}Callbacks`] = Ie(), this[t] = function() {
      return this[`${t}With`](this._promise, arguments);
    }.bind(this), this._promise[e.handler] = function(n) {
      if (!n)
        return this;
      const s = i[`${t}Callbacks`];
      return s.fired() ? n.apply(i[`${t}Context`], i[`${t}Args`]) : s.add(function(o, r) {
        n.apply(o, r);
      }), this;
    };
  }.bind(this)), this._promise.always = function(e) {
    return this.done(e).fail(e);
  }, this._promise.catch = function(e) {
    return this.then(null, e);
  }, this._promise.then = function(e, t) {
    const n = new Qr();
    return ["done", "fail"].forEach(function(s) {
      const o = s === "done" ? e : t;
      this[s](function() {
        if (!o) {
          n[s === "done" ? "resolve" : "reject"].apply(this, arguments);
          return;
        }
        const r = o && o.apply(this, arguments);
        da(r) ? r.done(n.resolve).fail(n.reject) : no(r) ? r.then(n.resolve, n.reject) : n.resolve.apply(this, f(r) ? [r] : arguments);
      });
    }.bind(this)), n.promise();
  }, this._promise.state = function() {
    return i._state;
  }, this._promise.promise = function(e) {
    return e ? x(e, i._promise) : i._promise;
  }, this._promise.promise(this);
};
mE.forEach(function(i) {
  const e = i.method, {
    state: t
  } = i;
  Qr.prototype[`${e}With`] = function(n, s) {
    const o = this[`${e}Callbacks`];
    return this.state() === "pending" && (this[`${e}Args`] = s, this[`${e}Context`] = n, t && (this._state = t), o.fire(n, s), t !== "pending" && (this.resolveCallbacks.empty(), this.rejectCallbacks.empty())), this;
  };
});
function It(i, e) {
  if (da(i))
    return i;
  if (no(i)) {
    const t = new Qr();
    return i.then(function() {
      t.resolveWith.apply(t, [e].concat([
        [].slice.call(arguments)
      ]));
    }, function() {
      t.rejectWith.apply(t, [e].concat([
        [].slice.call(arguments)
      ]));
    }), t;
  }
  return new Qr().resolveWith(e, [i]);
}
let YN = function() {
  if (arguments.length === 1)
    return It(arguments[0]);
  const i = [].slice.call(arguments), e = [];
  let t = 0;
  const n = new Qr(), s = function(o) {
    return function(r) {
      e[o] = this, i[o] = arguments.length > 1 ? [].slice.call(arguments) : r, t++, t === i.length && n.resolveWith(e, i);
    };
  };
  for (let o = 0; o < i.length; o++)
    da(i[o]) ? i[o].promise().done(s(o)).fail(n.reject) : t++;
  return t === i.length && n.resolveWith(e, i), n.promise();
};
function w() {
  return new Qr();
}
function W() {
  return YN.apply(this, arguments);
}
const Gc = new w(), Qe = function(i, e) {
  return f(i) ? i : e;
}, fE = function(i, e) {
  const t = new w(), n = e || this, s = {
    promise: t.promise(),
    abort() {
      clearTimeout(o), t.rejectWith(n);
    }
  }, o = (arguments[2] || setTimeout)(function() {
    const r = i.call(n);
    r && r.done && B(r.done) ? r.done(function() {
      t.resolveWith(n);
    }) : t.resolveWith(n);
  }, typeof e == "number" ? e : 0);
  return s;
}, Gh = [], ex = [], ba = [];
let pr;
const Uc = function(i, e, t) {
  if (pr && pr !== i)
    return Gh.push(e), ex.push(i), t = t || new w(), ba.push(t), t;
  const n = pr, s = ba.length;
  pr = i;
  let o = e();
  return o || (ba.length > s ? o = W.apply(this, ba.slice(s)) : t && t.resolve()), pr = n, t && o && o.done && o.done(t.resolve).fail(t.reject), !pr && Gh.length && (ex.shift() === "render" ? ft : qt)(Gh.shift(), ba.shift()), o || W();
}, ft = function(i, e) {
  return Uc("render", i, e);
}, qt = function(i, e) {
  return Uc("update", i, e);
}, Gr = function(i) {
  return function() {
    const e = this;
    return Uc("render", function() {
      return i.call(e);
    });
  };
}, $g = function(i) {
  return function() {
    const e = this;
    return Uc("update", function() {
      return i.call(e);
    });
  };
}, Nf = (i, e, t) => {
  const n = [];
  let s = 0;
  return y(e, (o, r) => {
    let a = 0;
    const l = t ? t(r) : r;
    y(i, (d, u) => {
      const c = l[d];
      if (c !== void 0) {
        if (XN(c, u)) {
          a++;
          return;
        }
        return a = -1, !1;
      }
    }), !(a < s) && (a > s && (n.length = 0, s = a), n.push(r));
  }), n;
}, XN = function(i, e) {
  if (Array.isArray(i) && Array.isArray(e)) {
    let t = !1;
    return y(i, (n, s) => {
      if (s !== e[n])
        return t = !0, !1;
    }), !t;
  }
  return i === e;
}, er = function(i) {
  switch (yn(i)) {
    case "string":
      return i.split(/\s+/, 2);
    case "object":
      return [i.x ?? i.h, i.y ?? i.v];
    case "number":
      return [i];
    case "array":
      return i;
    default:
      return null;
  }
}, ZN = function(i) {
  let e = te(i) ? i : i.toString();
  const t = e.match(/[^a-zA-Z0-9_]/g);
  return t && y(t, (n, s) => {
    e = e.replace(s, `__${s.charCodeAt()}__`);
  }), e;
}, QN = function(i) {
  const e = i.match(/__\d+__/g);
  return e && e.forEach((t) => {
    const n = parseInt(t.replace("__", ""));
    i = i.replace(t, String.fromCharCode(n));
  }), i;
}, Lf = function(i, e) {
  const t = er(i);
  let n = e ? parseFloat(t && t[0]) : parseInt(t && t[0], 10), s = e ? parseFloat(t && t[1]) : parseInt(t && t[1], 10);
  return isFinite(n) || (n = 0), isFinite(s) || (s = n), {
    h: n,
    v: s
  };
}, xn = function(i) {
  if (i instanceof Xe)
    return i.toString();
  if (X(i) || Array.isArray(i))
    try {
      const e = JSON.stringify(i);
      return e === "{}" ? i : e;
    } catch {
      return i;
    }
  return i;
}, ns = function(i) {
  return i.replace(/[[\]{}\-()*+?.\\^$|\s]/g, "\\$&");
}, _E = function(i) {
  const e = Pe().serverDecimalSeparator;
  return f(i) && (i = i.toString().replace(".", e)), i;
}, M = function() {
}, CE = function() {
  return new w().resolve().promise();
}, Wt = function(i, e, t) {
  const n = [];
  let s;
  const o = !t;
  for (let r = 0; r < i.length; r++)
    s = !!e(i[r], r), s === o && n.push(i[r]);
  return n;
}, JN = (i, e, t, n) => i.length !== e.length ? !1 : !i.some((s, o) => !Hf(s, e[o], t + 1, I({}, n, {
  strict: !0
}))), eL = (i, e, t, n) => {
  const s = Object.keys(i), o = Object.keys(e);
  if (s.length !== o.length)
    return !1;
  const r = new Set(o);
  return !s.some((a) => !r.has(a) || !Hf(i[a], e[a], t + 1, n));
}, tx = {
  maxDepth: 3,
  strict: !0
}, Hf = (i, e, t, n) => {
  const {
    strict: s,
    maxDepth: o
  } = n, r = Mt(i, !0), a = Mt(e, !0), l = s ? r === a : r == a;
  switch (!0) {
    case l:
    case t >= o:
      return !0;
    case (X(r) && X(a)):
      return eL(r, a, t, n);
    case (Array.isArray(r) && Array.isArray(a)):
      return JN(r, a, t, n);
    default:
      return !1;
  }
}, He = function(i, e) {
  let t = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : tx;
  const n = I({}, tx, t);
  return Hf(i, e, 0, n);
}, Wf = {
  ensureDefined: Qe,
  executeAsync: fE,
  deferRender: ft,
  deferUpdate: qt,
  deferRenderer: Gr,
  deferUpdater: $g,
  findBestMatches: Nf,
  splitPair: er,
  normalizeKey: ZN,
  denormalizeKey: QN,
  pairToObject: Lf,
  getKeyHash: xn,
  escapeRegExp: ns,
  applyServerDecimalSeparator: _E,
  noop: M,
  asyncNoop: CE,
  grep: Wt,
  equalByValue: He
};
let Fd = null;
function nx(i) {
  try {
    return new CSSStyleSheet();
  } catch {
    const t = i.ownerDocument.createElement("style");
    return i.appendChild(t), t.sheet;
  }
}
function ix(i, e, t) {
  for (let n = 0; n < e.length; n++) {
    const s = e[n];
    try {
      for (let o = 0; o < s.cssRules.length; o++)
        tL(i, s.cssRules[o], t);
    } catch {
    }
  }
}
function tL(i, e, t) {
  var n, s, o, r;
  (t || ((n = e.selectorText) === null || n === void 0 ? void 0 : n.includes("dx-")) || ((s = e.cssRules) === null || s === void 0 || (s = s[0]) === null || s === void 0 || (s = s.selectorText) === null || s === void 0 ? void 0 : s.includes("dx-")) || ((o = e.name) === null || o === void 0 ? void 0 : o.startsWith("dx-")) || ((r = e.style) === null || r === void 0 ? void 0 : r.fontFamily) === "DXIcons") && i.insertRule(e.cssText, i.cssRules.length);
}
function nL(i) {
  var e;
  const t = i.get(0), n = (e = t.getRootNode) === null || e === void 0 ? void 0 : e.call(t);
  if (!(n != null && n.host))
    return;
  Fd || (Fd = nx(n), ix(Fd, t.ownerDocument.styleSheets, !1));
  const s = nx(n);
  ix(s, n.styleSheets, !0), n.adoptedStyleSheets = [Fd, s];
}
function iL(i, e, t) {
  var n;
  const s = (n = i.getBoundingClientRect) === null || n === void 0 ? void 0 : n.call(i);
  return s && e >= s.left && e < s.right && t >= s.top && t < s.bottom;
}
function sL() {
  let i = 0;
  const e = [];
  return {
    push(t) {
      return e.push(t), this;
    },
    shift() {
      return i++, e[i - 1];
    },
    get length() {
      return e.length - i;
    },
    get items() {
      return e;
    }
  };
}
function oL(i, e, t) {
  const n = sL().push(t);
  for (; n.length; ) {
    const o = n.shift();
    for (let r = 0; r < o.childNodes.length; r++) {
      const a = o.childNodes[r];
      a.nodeType === Node.ELEMENT_NODE && iL(a, i, e) && getComputedStyle(a).pointerEvents !== "none" && n.push(a);
    }
  }
  const s = n.items.reverse();
  return s.pop(), s;
}
const rL = {
  querySelectorAll: (i, e) => i.querySelectorAll(e),
  elementMatches(i, e) {
    return (i.matches || i.matchesSelector || i.mozMatchesSelector || i.msMatchesSelector || i.oMatchesSelector || i.webkitMatchesSelector || ((n) => {
      const s = i.document || i.ownerDocument;
      if (!s)
        return !1;
      const o = this.querySelectorAll(s, n);
      for (let r = 0; r < o.length; r++)
        if (o[r] === i)
          return !0;
    })).call(i, e);
  },
  createElement(i, e) {
    return e = e ?? this._document, e.createElement(i);
  },
  createElementNS(i, e, t) {
    return t = t || this._document, t.createElementNS(i, e);
  },
  createTextNode(i, e) {
    return e = e || this._document, e.createTextNode(i);
  },
  createAttribute(i, e) {
    return e = e || this._document, e.createAttribute(i);
  },
  isNode: (i) => !!i && typeof i == "object" && "nodeType" in i && "nodeName" in i,
  isElementNode: (i) => !!i && i.nodeType === 1,
  isTextNode: (i) => i && i.nodeType === 3,
  isDocument: (i) => i && i.nodeType === 9,
  isDocumentFragment: (i) => i && i.nodeType === 11,
  removeElement(i) {
    const e = i && i.parentNode;
    e && e.removeChild(i);
  },
  insertElement(i, e, t) {
    i && e && i !== e && (t ? i.insertBefore(e, t) : i.appendChild(e));
  },
  getAttribute: (i, e) => i.getAttribute(e),
  setAttribute(i, e, t) {
    e === "style" ? i.style.cssText = t : i.setAttribute(e, t);
  },
  removeAttribute(i, e) {
    i.removeAttribute(e);
  },
  setProperty(i, e, t) {
    i[e] = t;
  },
  setText(i, e) {
    i && (i.textContent = e);
  },
  setClass(i, e, t) {
    i.nodeType === 1 && e && (t ? i.classList.add(e) : i.classList.remove(e));
  },
  setStyle(i, e, t) {
    i.style[e] = t || "";
  },
  _document: typeof document > "u" ? void 0 : document,
  getDocument() {
    return this._document;
  },
  getActiveElement(i) {
    return this.getRootNode(i).activeElement;
  },
  getRootNode(i) {
    var e;
    return (i == null || (e = i.getRootNode) === null || e === void 0 ? void 0 : e.call(i)) ?? this._document;
  },
  getBody() {
    return this._document.body;
  },
  createDocumentFragment() {
    return this._document.createDocumentFragment();
  },
  getDocumentElement() {
    return this._document.documentElement;
  },
  getLocation() {
    return this._document.location;
  },
  getSelection() {
    return this._document.selection;
  },
  getReadyState() {
    return this._document.readyState;
  },
  getHead() {
    return this._document.head;
  },
  hasDocumentProperty(i) {
    return i in this._document;
  },
  listen(i, e, t, n) {
    return !i || !("addEventListener" in i) ? M : (i.addEventListener(e, t, n), () => {
      i.removeEventListener(e, t);
    });
  },
  elementsFromPoint(i, e, t) {
    const n = this.getRootNode(t);
    return n.host ? oL(i, e, n) : n.elementsFromPoint(i, e);
  }
}, O = qn(rL), _s = function(i) {
  let e, t = function() {
    return e = i.apply(this, arguments), t = function() {
      return e;
    }, e;
  };
  return function() {
    return t.apply(this, arguments);
  };
};
let Ng = typeof window < "u";
const ae = () => Ng;
let Bs = ae() ? window : void 0;
Bs || (Bs = {}, Bs.window = Bs);
const fe = () => Bs, aL = (i, e) => {
  e === void 0 ? Ng = typeof window < "u" && window === i : Ng = e, Bs = i;
}, zf = (i) => ae() && i in Bs, jc = (i) => i < 768 ? "xs" : i < 992 ? "sm" : i < 1200 ? "md" : "lg", Kf = (i) => {
  const e = i || jc, t = O.getDocumentElement().clientWidth;
  return e(t);
}, ua = () => {
  var i;
  return ae() ? (i = Bs) === null || i === void 0 ? void 0 : i.navigator : {
    userAgent: ""
  };
}, $t = {
  defaultScreenFactorFunc: jc,
  getCurrentScreenFactor: Kf,
  getNavigator: ua,
  getWindow: fe,
  hasProperty: zf,
  hasWindow: ae,
  setWindow: aL
}, Gf = fe(), kd = "dxEmptyEventType", sx = {
  mouseenter: "mouseover",
  mouseleave: "mouseout",
  pointerenter: "pointerover",
  pointerleave: "pointerout"
}, lL = {
  focusin: "focus",
  focusout: "blur"
}, dL = ["blur", "focus", "load"], vE = ["touchmove", "wheel", "mousewheel", "touchstart"], uL = ["target", "relatedTarget", "delegateTarget", "altKey", "bubbles", "cancelable", "changedTouches", "ctrlKey", "detail", "eventPhase", "metaKey", "shiftKey", "view", "char", "code", "charCode", "key", "keyCode", "button", "buttons", "offsetX", "offsetY", "pointerId", "pointerType", "targetTouches", "toElement", "touches"];
function cL(i, e) {
  return !lt(i) && i.nodeName !== "#document" && O.elementMatches(i, e);
}
const Uh = /* @__PURE__ */ new WeakMap();
let xE = 0, Xu;
const Vs = function() {
  const i = {};
  return Pf.add((e, t) => {
    i[e] = t;
  }), {
    getField: (e, t) => i[e] && i[e][t],
    callMethod: (e, t, n, s) => i[e] && i[e][t] && i[e][t].apply(n, s)
  };
}(), _ = qn({
  on: wa(Lg(ax((i, e, t, n, s) => {
    Dr(i, e).addHandler(s, t, n);
  }))),
  one: wa(Lg((i, e, t, n, s) => {
    const o = function() {
      _.off(i, e, t, o), s.apply(this, arguments);
    };
    _.on(i, e, t, n, o);
  })),
  off: wa(gL(ax((i, e, t, n) => {
    Dr(i, e).removeHandler(n, t);
  }))),
  trigger: wa(rx((i, e, t) => {
    const n = e.type, s = Dr(i, e.type);
    if (Vs.callMethod(n, "trigger", i, [e, t]), s.callHandlers(e, t), !(Vs.getField(n, "noBubble") || e.isPropagationStopped() || dL.includes(n))) {
      const r = [], a = function(d) {
        const u = d.parentNode ?? (X(d.host) ? d.host : null);
        u && (r.push(u), a(u));
      };
      a(i), r.push(Gf);
      let l = 0;
      for (; r[l] && !e.isPropagationStopped(); )
        Dr(r[l], e.type).callHandlers(x(e, {
          currentTarget: r[l]
        }), t), l++;
    }
    (i.nodeType || lt(i)) && (Vs.callMethod(n, "_default", i, [e, t]), fL(n, i));
  })),
  triggerHandler: wa(rx((i, e, t) => {
    Dr(i, e.type).callHandlers(e, t);
  }))
});
function Uf(i, e) {
  const t = i[0];
  if (t)
    if (O.isNode(t) || lt(t))
      e.apply(_, i);
    else if (!te(t) && "length" in t) {
      const n = Array.prototype.slice.call(i, 0);
      Array.prototype.forEach.call(t, (s) => {
        n[0] = s, Uf(n, e);
      });
    } else
      throw Ae.Error("E0025");
}
function wa(i) {
  return function() {
    Uf(arguments, i);
  };
}
function hL() {
  let i = !1;
  try {
    const e = Object.defineProperty({}, "passive", {
      get() {
        return i = !0, !0;
      }
    });
    Gf.addEventListener("test", null, e);
  } catch {
  }
  return i;
}
const yE = _s(hL), bE = (i, e) => lt(i) ? bE(i.document, e) : i.contains ? i.contains(e) : !!(e.compareDocumentPosition(i) & e.DOCUMENT_POSITION_CONTAINS);
function Dr(i, e) {
  let t = Uh.get(i);
  e = e || "";
  const n = e.split("."), s = n.slice(1), o = !!n[0];
  e = n[0] || kd, t || (t = {}, Uh.set(i, t)), t[e] || (t[e] = {
    handleObjects: [],
    nativeHandler: null
  });
  const r = t[e];
  return {
    addHandler(a, l, d) {
      const u = function(C, v) {
        const E = [C], T = C.currentTarget, {
          relatedTarget: V
        } = C;
        let $, G;
        e in sx && ($ = V && T && (V === T || bE(T, V))), v !== void 0 && E.push(v), Vs.callMethod(e, "handle", i, [C, d]), $ || (G = a.apply(T, E)), G === !1 && (C.preventDefault(), C.stopPropagation());
      }, c = {
        handler: a,
        wrappedHandler: function(C, v) {
          if (!(Xu && C.type === Xu))
            if (C.data = d, C.delegateTarget = i, l) {
              let T = C.target;
              for (; T && T !== i; )
                cL(T, l) && (C.currentTarget = T, u(C, v)), T = T.parentNode;
            } else {
              var E;
              if (C.currentTarget = C.delegateTarget || C.target, !!(!((E = C.target) === null || E === void 0) && E.shadowRoot)) {
                const V = Mf(C);
                C.target = V;
              }
              u(C, v);
            }
        },
        selector: l,
        type: e,
        data: d,
        namespace: s.join("."),
        namespaces: s,
        guid: ++xE
      };
      r.handleObjects.push(c);
      let g = r.handleObjects.length === 1 && o, m;
      g && (g = !Vs.callMethod(e, "setup", i, [d, s, a])), g && (r.nativeHandler = pL(e), yE() && vE.includes(e) && (m = {
        passive: !1
      }), r.removeListener = O.listen(i, sx[e] || e, r.nativeHandler, m)), Vs.callMethod(e, "add", i, [c]);
    },
    removeHandler(a, l) {
      const d = function(c) {
        const h = t[c];
        if (!h.handleObjects.length) {
          delete t[c];
          return;
        }
        let g;
        h.handleObjects = h.handleObjects.filter((v) => {
          const E = s.length && !ox(v.namespaces, s) || a && v.handler !== a || l && v.selector !== l;
          return E || (g = v.handler, Vs.callMethod(c, "remove", i, [v])), E;
        }), !h.handleObjects.length && c !== kd && (Vs.callMethod(c, "teardown", i, [s, g]), h.nativeHandler && h.removeListener(), delete t[c]);
      };
      if (o)
        d(e);
      else
        for (const c in t)
          d(c);
      Object.keys(t).length === 0 && Uh.delete(i);
    },
    callHandlers(a, l) {
      let d = !1;
      const u = function(c) {
        d || (!s.length || ox(c.namespaces, s)) && (c.wrappedHandler(a, l), d = a.isImmediatePropagationStopped());
      };
      r.handleObjects.forEach(u), s.length && t[kd] && t[kd].handleObjects.forEach(u);
    }
  };
}
function pL(i) {
  return function(e, t) {
    const n = Dr(this, i);
    e = _.Event(e), n.callHandlers(e, t);
  };
}
function ox(i, e) {
  for (let t = 0; t < e.length; t++)
    if (i.indexOf(e[t]) < 0)
      return !1;
  return !0;
}
function Lg(i) {
  return function(e, t, n, s, o) {
    o || (o = s, s = void 0), typeof n != "string" && (s = n, n = void 0), !o && typeof t == "string" && (o = s || n, n = void 0, s = void 0), i(e, t, n, s, o);
  };
}
function gL(i) {
  return function(e, t, n, s) {
    typeof n == "function" && (s = n, n = void 0), i(e, t, n, s);
  };
}
function rx(i) {
  return function(e, t, n) {
    typeof t == "string" && (t = {
      type: t
    }), t.target || (t.target = e), t.currentTarget = e, t.delegateTarget || (t.delegateTarget = e), !t.type && t.originalEvent && (t.type = t.originalEvent.type), i(e, t instanceof _.Event ? t : _.Event(t), n);
  };
}
function mL(i) {
  return _.Event = function(e, t) {
    if (!(this instanceof _.Event))
      return new _.Event(e, t);
    e || (e = {}), typeof e == "string" && (e = {
      type: e
    }), t || (t = {}), i.call(this, e, t);
  }, Object.assign(_.Event.prototype, {
    _propagationStopped: !1,
    _immediatePropagationStopped: !1,
    _defaultPrevented: !1,
    isPropagationStopped() {
      return !!(this._propagationStopped || this.originalEvent && this.originalEvent.propagationStopped);
    },
    stopPropagation() {
      this._propagationStopped = !0, this.originalEvent && this.originalEvent.stopPropagation();
    },
    isImmediatePropagationStopped() {
      return this._immediatePropagationStopped;
    },
    stopImmediatePropagation() {
      this.stopPropagation(), this._immediatePropagationStopped = !0, this.originalEvent && this.originalEvent.stopImmediatePropagation();
    },
    isDefaultPrevented() {
      return !!(this._defaultPrevented || this.originalEvent && this.originalEvent.defaultPrevented);
    },
    preventDefault() {
      this._defaultPrevented = !0, this.originalEvent && this.originalEvent.preventDefault();
    }
  }), _.Event;
}
function ax(i) {
  const e = function(t, n) {
    if (n && n.indexOf(" ") > -1) {
      const s = Array.prototype.slice.call(arguments, 0);
      n.split(" ").forEach(function(o) {
        s[1] = o, i.apply(this, s);
      });
    } else
      i.apply(this, arguments);
  };
  return function(t, n) {
    if (typeof n == "object") {
      const s = Array.prototype.slice.call(arguments, 0);
      for (const o in n)
        s[1] = o, s[s.length - 1] = n[o], e.apply(this, s);
    } else
      e.apply(this, arguments);
  };
}
function fL(i, e) {
  const t = lL[i] || i;
  (function(n, s) {
    return n === "click" && s.localName === "a";
  })(i, e) || B(e[t]) && (Xu = i, e[t](), Xu = void 0);
}
function _L(i) {
  return function(e) {
    return e.which == null && e.type.indexOf("key") === 0;
  }(i) ? i.charCode != null ? i.charCode : i.keyCode : function(e) {
    return !e.which && e.button !== void 0 && /^(?:mouse|pointer|contextmenu|drag|drop)|click/.test(e.type);
  }(i) ? {
    1: 1,
    2: 3,
    3: 1,
    4: 2
  }[i.button] : i.which;
}
function wE(i) {
  i && (_.Event = i, _.Event.prototype = i.prototype);
}
wE(mL(function(i, e) {
  var t;
  i instanceof _.Event || ae() && i instanceof Gf.Event || ((t = i.view) === null || t === void 0 ? void 0 : t.Event) && i instanceof i.view.Event ? (this.originalEvent = i, this.type = i.type, this.currentTarget = void 0, Object.prototype.hasOwnProperty.call(i, "isTrusted") && (this.isTrusted = i.isTrusted), this.timeStamp = i.timeStamp || Date.now()) : Object.assign(this, i), jf("which", _L, this), i.type.indexOf("touch") === 0 && (delete e.pageX, delete e.pageY), Object.assign(this, e), this.guid = ++xE;
}));
function jf(i, e, t) {
  Object.defineProperty(t || _.Event.prototype, i, {
    enumerable: !0,
    configurable: !0,
    get() {
      return this.originalEvent && e(this.originalEvent);
    },
    set(n) {
      Object.defineProperty(this, i, {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: n
      });
    }
  });
}
uL.forEach((i) => jf(i, (e) => e[i]));
wN(jf);
const SE = Ie(), EE = Ie();
_.set = function(i) {
  SE.fire(), _.inject(i), wE(i.Event), EE.fire();
};
_.subscribeGlobal = function() {
  Uf(arguments, Lg(function() {
    const i = arguments;
    _.on.apply(this, i), SE.add(function() {
      const e = Array.prototype.slice.call(i, 0);
      e.splice(3, 1), _.off.apply(this, e);
    }), EE.add(function() {
      _.on.apply(this, i);
    });
  }));
};
_.forcePassiveFalseEventNames = vE;
_.passiveEventHandlersSupported = yE;
_.on;
const lx = _.one;
_.off;
_.trigger;
_.Event;
const CL = _.triggerHandler;
/*!
 * devextreme-vue
 * Version: 24.2.7
 * Build date: Mon Apr 28 2025
 *
 * Copyright (c) 2012 - 2025 Developer Express Inc. ALL RIGHTS RESERVED
 *
 * This software may be modified and distributed under the terms
 * of the MIT license. See the LICENSE file in the root of the project for details.
 *
 * https://github.com/DevExpress/devextreme-vue
 */
function dx(i, e) {
  for (const t in i)
    if (i[t] === e)
      return t;
  return e;
}
function vL(i) {
  return i[0].toUpperCase() + i.substr(1);
}
function xL(i) {
  return i[0].toLowerCase() + i.substr(1);
}
function IE(i) {
  return xL(i.split("-").map((e) => vL(e)).join(""));
}
function Zu(i) {
  return i instanceof Date ? i.getTime() : i;
}
function DE(i, e) {
  return Zu(i) === Zu(e) ? !0 : Array.isArray(i) && Array.isArray(e) ? i.length === 0 && e.length === 0 : !1;
}
function yL(i, e) {
  Array.prototype.slice.call(i.childNodes).forEach(e);
}
function bL(i, e) {
  const t = Object.keys(i);
  if (t.length !== Object.keys(e).length)
    return !1;
  for (const n of t)
    if (!e.hasOwnProperty(n))
      return !1;
  return !0;
}
function wL(i, e) {
  let t = i;
  return e.split(".").forEach((n) => {
    const s = TE(n);
    t && (t = s.isCollection ? t[s.name] && t[s.name][s.index] : t[s.name]);
  }), t;
}
function TE(i) {
  const e = i.split("[");
  return e.length === 1 ? {
    isCollection: !1,
    name: i,
    fullName: i
  } : {
    isCollection: !0,
    name: e[0],
    fullName: i,
    index: Number(e[1].slice(0, -1))
  };
}
/*!
 * devextreme-vue
 * Version: 24.2.7
 * Build date: Mon Apr 28 2025
 *
 * Copyright (c) 2012 - 2025 Developer Express Inc. ALL RIGHTS RESERVED
 *
 * This software may be modified and distributed under the terms
 * of the MIT license. See the LICENSE file in the root of the project for details.
 *
 * https://github.com/DevExpress/devextreme-vue
 */
function SL(i, e, t) {
  !i || i.length === 0 || Hg(i, e, t);
}
function vl(i) {
  const { patchFlag: e } = i;
  return e === Sd.KEYED_FRAGMENT || e === Sd.UNKEYED_FRAGMENT || e === Sd.STABLE_FRAGMENT || e === Sd.BAIL;
}
function Hg(i, e, t) {
  i.forEach((n) => {
    if (vl(n) && Array.isArray(n.children) && Hg(n.children, e, t), vl(n) || e.push(n), !n)
      return;
    const s = EL(n);
    if (!s || !s.$_optionName)
      return;
    const o = IL(n), r = {
      ...s.$_predefinedProps,
      ...OE(n.props || {})
    }, a = t.createNested(s.$_optionName, r, s.$_isCollectionItem, s.$_expectedChildren);
    n.$_config = a, n.$_innerChanges = {}, o && Hg(o, e, a);
  });
}
/*!
 * devextreme-vue
 * Version: 24.2.7
 * Build date: Mon Apr 28 2025
 *
 * Copyright (c) 2012 - 2025 Developer Express Inc. ALL RIGHTS RESERVED
 *
 * This software may be modified and distributed under the terms
 * of the MIT license. See the LICENSE file in the root of the project for details.
 *
 * https://github.com/DevExpress/devextreme-vue
 */
const Us = "modelValue";
function qf(i) {
  if (!$L(i) || !i.$_config)
    return [];
  const e = i.$.subTree && i.$.subTree.children;
  return Array.isArray(e) ? e.filter((t) => {
    if (!vl(t))
      return t;
  }) : [];
}
function EL(i) {
  return VE(i);
}
function OE(i) {
  const e = {};
  for (const t in i)
    i.hasOwnProperty(t) && (e[IE(t)] = i[t]);
  return e;
}
function IL(i) {
  return !i.children || !i.children.default ? [] : kE(i.children.default());
}
function AE(i) {
  if (!(!i.children || i.children === "object" || !i.children.default))
    return PL(i.children.default()) ? i.children.default : void 0;
}
function DL(i) {
  return AE(i);
}
function RE(i) {
  return i.$slots;
}
function TL(i) {
  const e = RE(i);
  return e.default ? e.default() : [];
}
function OL(i, e, t) {
  const n = mN(i);
  return n.provide("eventBus", e.eventBus), VL(n, e), n.mount(t);
}
function ux(i) {
  const e = i.$.vnode.props || {};
  return OE(e);
}
function FE(i) {
  return i.$ ? i.$.vnode : i;
}
function AL(i) {
  return i.$.vnode.type;
}
function RL(i) {
  return i[Us];
}
function FL(i) {
  const e = `update:${Us}`;
  i.model.prop = Us, i.model.event = e, i.props.modelValue = {}, i.emits = { ...i.emits, [`${e}`]: null };
}
function kL(i, e) {
  for (const t in e)
    !i.hasOwnProperty(t) && e.hasOwnProperty(t) && (i[t] = e[t]);
}
function VL(i, e) {
  i._context.components = Object.assign(e.$.appContext.components, i._context.components), Object.setPrototypeOf(i._context.provides, Object.getPrototypeOf(e.$.provides)), Object.assign(i._context.provides, e.$.appContext.provides), i._context.config = e.$.appContext.config, i._context.directives = e.$.appContext.directives, i._context.mixins = e.$.appContext.mixins, kL(i._context.app, e.$.appContext.app);
}
function kE(i) {
  return i.filter((e) => {
    if (vl(e))
      return kE(e.children || []);
    const t = e.type;
    if (t && typeof t == "object" && t.$_optionName)
      return delete e.$_config, delete e.$_innerChanges, e;
  });
}
function PL(i) {
  let e = !1;
  return i.forEach((t) => {
    !BL(t) && !vl(t) && !ML(t) && (e = !0);
  }), e;
}
function ML(i) {
  return i.type === Ln || i.type.toString() === "Symbol()" && !i.children;
}
function BL(i) {
  return i.type && typeof i.type == "object" && i.type.$_optionName;
}
function VE(i) {
  return i.type;
}
function $L(i) {
  return i.$.vnode && i.$.vnode.children && i.$.vnode.children.default;
}
/*!
 * devextreme-vue
 * Version: 24.2.7
 * Build date: Mon Apr 28 2025
 *
 * Copyright (c) 2012 - 2025 Developer Express Inc. ALL RIGHTS RESERVED
 *
 * This software may be modified and distributed under the terms
 * of the MIT license. See the LICENSE file in the root of the project for details.
 *
 * https://github.com/DevExpress/devextreme-vue
 */
let NL = {
  deepWatch: !1
};
function LL(i) {
  return NL[i];
}
/*!
 * devextreme-vue
 * Version: 24.2.7
 * Build date: Mon Apr 28 2025
 *
 * Copyright (c) 2012 - 2025 Developer Express Inc. ALL RIGHTS RESERVED
 *
 * This software may be modified and distributed under the terms
 * of the MIT license. See the LICENSE file in the root of the project for details.
 *
 * https://github.com/DevExpress/devextreme-vue
 */
class Yf {
  constructor(e, t, n, s, o, r, a) {
    this._updateFunc = e, this._name = t, this._initialValues = n || {}, this._nestedConfigurations = [], this._isCollectionItem = !!o, this._collectionItemIndex = r, this._expectedChildren = s || {}, this._ownerConfig = a, this._componentChanges = [], this.updateValue = this.updateValue.bind(this);
  }
  get name() {
    return this._name;
  }
  get fullName() {
    return this._name && this._isCollectionItem ? `${this._name}[${this._collectionItemIndex}]` : this._name;
  }
  get componentsCountChanged() {
    return this._componentChanges;
  }
  cleanComponentsCountChanged() {
    this._componentChanges = [];
  }
  get fullPath() {
    return this._ownerConfig && this._ownerConfig.fullPath ? `${this._ownerConfig.fullPath}.${this.fullName}` : this.fullName;
  }
  get ownerConfig() {
    return this._ownerConfig;
  }
  get options() {
    return this._options;
  }
  get initialValues() {
    return this._initialValues;
  }
  get expectedChildren() {
    return this._expectedChildren;
  }
  get nested() {
    return this._nestedConfigurations;
  }
  get prevNestedOptions() {
    return this._prevNestedConfigOptions;
  }
  get collectionItemIndex() {
    return this._collectionItemIndex;
  }
  get isCollectionItem() {
    return this._isCollectionItem;
  }
  get updateFunc() {
    return this._updateFunc;
  }
  init(e) {
    this._options = e || [];
  }
  set emitOptionChanged(e) {
    this._emitOptionChanged = e;
  }
  setPrevNestedOptions(e) {
    this._prevNestedConfigOptions = e;
  }
  onOptionChanged(e) {
    DE(e.value, e.previousValue) || this._onOptionChanged(e.fullName.split("."), e);
  }
  cleanNested() {
    this._nestedConfigurations = [];
  }
  createNested(e, t, n, s) {
    const o = this._expectedChildren[e];
    let r = e, a = n;
    o && (a = o.isCollectionItem, o.optionName && (r = o.optionName));
    let l = -1;
    a && r && (l = this._nestedConfigurations.filter((u) => u._name && u._name === r).length);
    const d = new Yf(this._updateFunc, r, t, s, a, l, this);
    return this._nestedConfigurations.push(d), d;
  }
  updateValue(e, t) {
    const n = [this.fullPath, e].filter((s) => s).join(".");
    this._updateFunc(n, t);
  }
  getNestedOptionValues() {
    const e = {};
    return this._nestedConfigurations.forEach((t) => {
      if (!t._name)
        return;
      const n = { ...t.initialValues, ...t.getNestedOptionValues() };
      if (n)
        if (!t._isCollectionItem)
          e[t._name] = n;
        else {
          let s = e[t._name];
          (!s || !Array.isArray(s)) && (s = [], e[t._name] = s), s.push(n);
        }
    }), e;
  }
  getOptionsToWatch() {
    const e = {};
    return this._nestedConfigurations.forEach((t) => t._name && (e[t._name] = !0)), this._options.filter((t) => !e[t]);
  }
  _onOptionChanged(e, t) {
    if (e.length === 0)
      return;
    const n = TE(e[0]);
    if (n.isCollection || e.length > 1) {
      const s = this._getNestedConfig(n.fullName);
      if (s) {
        s._onOptionChanged(e.slice(1), t);
        return;
      }
      this._tryEmitOptionChanged(n.name, t.component.option(this.fullPath ? `${this.fullPath}.${n.name}` : n.name));
    } else
      this._tryEmitOptionChanged(n.name, t.value);
  }
  _getNestedConfig(e) {
    for (const t of this._nestedConfigurations)
      if (t.fullName === e)
        return t;
  }
  _tryEmitOptionChanged(e, t) {
    this._emitOptionChanged && this._emitOptionChanged(e, t);
  }
}
function PE(i, e, t) {
  const n = i && i.getOptionsToWatch();
  n && n.forEach((s) => {
    e.$watch(s, (o) => {
      const r = De(o);
      (!t.hasOwnProperty(s) || t[s] !== r) && i.updateValue(s, o), delete t[s];
    }, { deep: LL("deepWatch") });
  });
}
function HL(i, e) {
  const { props: t } = i.$options;
  return t && t.hasOwnProperty(e);
}
function WL(i, e, t) {
  return i.model && e.hasOwnProperty(Us) && t?.props?.hasOwnProperty(Us);
}
function ME(i, e, t) {
  i.emitOptionChanged = (n, s) => {
    const o = e.$props, r = e?.$?.vnode, a = n === "value" && WL(e.$options, o, r) ? Us : n, l = `update:${a}`;
    HL(e, n) && !DE(s, o[a]) && e.$emit && (t[a] = De(s), e.$emit(l, s));
  };
}
/*!
 * devextreme-vue
 * Version: 24.2.7
 * Build date: Mon Apr 28 2025
 *
 * Copyright (c) 2012 - 2025 Developer Express Inc. ALL RIGHTS RESERVED
 *
 * This software may be modified and distributed under the terms
 * of the MIT license. See the LICENSE file in the root of the project for details.
 *
 * https://github.com/DevExpress/devextreme-vue
 */
function jh(i) {
  const e = FE(i);
  if (e)
    return e.$_config || i.$_config;
}
function zL(i) {
  const e = FE(i);
  if (e)
    return e.$_innerChanges || i.$_innerChanges;
}
function BE(i, e, t, n) {
  i && (i.init(Object.keys(e)), t && ME(i, t, n));
}
function cx({ name: i, isCollectionItem: e, ownerConfig: t }, n) {
  const s = t && t.fullPath;
  return {
    optionPath: i && s ? `${s}.${i}` : i || "",
    isCollection: e,
    removed: n
  };
}
function KL() {
  return /* @__PURE__ */ A({
    beforeMount() {
      const i = this, e = jh(i), t = zL(i);
      BE(e, AL(i).props, i, t), PE(e, this, t);
    },
    mounted() {
      this.$parent.$_instance && this.$parent.$_config.componentsCountChanged.push(cx(jh(this)));
    },
    beforeUnmount() {
      const i = jh(this);
      i && this.$parent.$_config.componentsCountChanged.push(cx(i, !0));
    },
    render() {
      return null;
    }
  });
}
/*!
 * devextreme-vue
 * Version: 24.2.7
 * Build date: Mon Apr 28 2025
 *
 * Copyright (c) 2012 - 2025 Developer Express Inc. ALL RIGHTS RESERVED
 *
 * This software may be modified and distributed under the terms
 * of the MIT license. See the LICENSE file in the root of the project for details.
 *
 * https://github.com/DevExpress/devextreme-vue
 */
const GL = "dx-template-wrapper", Wg = "dxremove";
/*!
 * devextreme-vue
 * Version: 24.2.7
 * Build date: Mon Apr 28 2025
 *
 * Copyright (c) 2012 - 2025 Developer Express Inc. ALL RIGHTS RESERVED
 *
 * This software may be modified and distributed under the terms
 * of the MIT license. See the LICENSE file in the root of the project for details.
 *
 * https://github.com/DevExpress/devextreme-vue
 */
const $E = "template";
function UL(i) {
  const e = i;
  if (e && !(!e.$_config || !e.$_config.name))
    return e;
}
function jL(i) {
  return $E in i.type.props && DL(i);
}
function qL(i) {
  const e = {}, t = RE(i);
  for (const s in t) {
    if (s === "default" && i.$slots.default)
      continue;
    const o = t[s];
    o && (e[s] = o);
  }
  const n = qf(i);
  for (const s of n) {
    const o = UL(s);
    if (!o)
      continue;
    const r = AE(s);
    if (!r || !jL(s))
      continue;
    const a = `${o.$_config.fullPath}.${$E}`;
    e[a] = r;
  }
  return e;
}
function YL(i) {
  const e = [];
  return i.forEach((t) => {
    const n = VE(t);
    (!n || !n.$_optionName) && e.push(t);
  }), e;
}
function XL(i, e, t, n, s) {
  return OL({
    name: n,
    inject: ["eventBus"],
    created() {
      this.eventBus.add(this.$_updatedHandler);
    },
    mounted() {
      t.onRendered();
    },
    unmounted() {
      this.eventBus.remove(this.$_updatedHandler);
    },
    methods: {
      $_updatedHandler() {
        this.$forceUpdate();
      }
    },
    render: () => {
      const o = YL(i()(t));
      return o ? o.length > 1 ? o : o[0] : rE("div");
    }
  }, e, s);
}
/*!
 * devextreme-vue
 * Version: 24.2.7
 * Build date: Mon Apr 28 2025
 *
 * Copyright (c) 2012 - 2025 Developer Express Inc. ALL RIGHTS RESERVED
 *
 * This software may be modified and distributed under the terms
 * of the MIT license. See the LICENSE file in the root of the project for details.
 *
 * https://github.com/DevExpress/devextreme-vue
 */
class ZL {
  constructor(e) {
    this._slots = {}, this._templates = {}, this._isDirty = !1, this._component = e, this.discover();
  }
  discover() {
    this._slots = {
      ...qL(this._component)
    }, bL(this._templates, this._slots) || this._prepareTemplates();
  }
  get templates() {
    return this._templates;
  }
  get isDirty() {
    return this._isDirty;
  }
  resetDirtyFlag() {
    this._isDirty = !1;
  }
  _prepareTemplates() {
    this._templates = {};
    for (const e of Object.keys(this._slots))
      this._templates[e] = this.createDxTemplate(e);
    this._isDirty = !0;
  }
  createDxTemplate(e) {
    return {
      render: (t) => {
        const n = ((d, u = 0) => () => {
          u === 1 && d && d(), u++;
        })(t.onRendered), s = { data: t.model, index: t.index, onRendered: n }, o = document.createElement("div"), r = t.container.get ? t.container.get(0) : t.container;
        r.appendChild(o);
        const a = XL(() => this._slots[e], this._component, s, e, o), l = a.$el;
        for (r.removeChild(o); o.firstChild; )
          r.appendChild(o.firstChild);
        if (O.setClass(l, GL, !0), l.nodeType === Node.TEXT_NODE) {
          const d = document.createElement(r.nodeName === "TABLE" ? "tbody" : "span");
          d.style.display = "none", r.insertBefore(d, r.firstChild), lx(d, Wg, () => {
            a.$.appContext.app.unmount.bind(a)(), d.remove();
          });
        } else
          lx(l, Wg, a.$.appContext.app.unmount.bind(a));
        return n(), l;
      }
    };
  }
}
/*!
 * devextreme-vue
 * Version: 24.2.7
 * Build date: Mon Apr 28 2025
 *
 * Copyright (c) 2012 - 2025 Developer Express Inc. ALL RIGHTS RESERVED
 *
 * This software may be modified and distributed under the terms
 * of the MIT license. See the LICENSE file in the root of the project for details.
 *
 * https://github.com/DevExpress/devextreme-vue
 */
const QL = ["id", "class", "style"], NE = "dx-";
Pe({
  buyNowLink: "https://go.devexpress.com/Licensing_Installer_Watermark_DevExtremeVue.aspx",
  licensingDocLink: "https://go.devexpress.com/Licensing_Documentation_DevExtremeVue.aspx"
});
function hx(i) {
  return i.trim().split(/\s+/);
}
function JL(i, e) {
  const t = {};
  return QL.forEach((n) => {
    const s = i[n];
    if (s != null)
      if (n === "class") {
        const o = s.split(" ").filter((r) => !r.startsWith(NE) && !e.includes(r)).join(" ");
        t[n] = [o, e].filter((r) => r !== "").join(" ");
      } else
        t[n] = s;
  }), t;
}
function e1() {
  return /* @__PURE__ */ A({
    inheritAttrs: !1,
    data() {
      return {
        eventBus: Ie(),
        prevClassAttr: ""
      };
    },
    provide() {
      return {
        eventBus: this.eventBus
      };
    },
    render() {
      const i = this, e = [], t = t1(this.$el) || [];
      return i.$_config.cleanNested && i.$_config.cleanNested(), SL(TL(this), e, i.$_config), this.$_processChildren(e), rE("div", {
        ...JL(this.$attrs, t.join(" "))
      }, e);
    },
    beforeUpdate() {
      const i = this;
      i.$_config.setPrevNestedOptions(i.$_config.getNestedOptionValues()), this.$_syncElementClassesWithClassAttr();
    },
    updated() {
      const i = this, e = LE(this.$el);
      if (qf(i).forEach((t) => {
        BE(t.$_config, t.type.props || {}, t?.component?.proxy, t.$_innerChanges);
      }), i.$_templatesManager.discover(), i.$_instance.beginUpdate(), this.$_applyConfigurationChanges(), i.$_templatesManager.isDirty) {
        i.$_instance.option("integrationOptions.templates", i.$_templatesManager.templates);
        const { props: t } = i.$.vnode;
        for (const n of Object.keys(i.$_templatesManager.templates))
          i.$_instance.option(dx(t, n), n);
        i.$_templatesManager.resetDirtyFlag();
      }
      for (const t of Object.keys(i.$_pendingOptions))
        i.$_instance.option(t, i.$_pendingOptions[t]);
      i.$_pendingOptions = {}, i.$_instance.endUpdate(), HE(this.$el, e), this.eventBus.fire();
    },
    beforeUnmount() {
      const e = this.$_instance;
      e && (CL(this.$el, Wg), e.dispose());
    },
    created() {
      const i = this, e = ux(this);
      i.$_config = new Yf((t, n) => {
        Array.isArray(n) ? i.$_instance.option(t, n) : i.$_pendingOptions[t === Us ? "value" : t] = n;
      }, null, e && { ...e }, i.$_expectedChildren), i.$_innerChanges = {}, i.$_config.init(this.$props && Object.keys(this.$props));
    },
    methods: {
      $_syncElementClassesWithClassAttr() {
        const i = typeof this.$attrs?.class == "string" ? this.$attrs?.class : "";
        this.prevClassAttr !== i && (this.prevClassAttr.length && this.$el.classList.remove(...hx(this.prevClassAttr)), i.length && this.$el.classList.add(...hx(i)), this.prevClassAttr = i);
      },
      $_applyConfigurationChanges() {
        const i = this;
        i.$_config.componentsCountChanged.forEach(({ optionPath: e, isCollection: t, removed: n }) => {
          const s = i.$_config.getNestedOptionValues();
          !t && n ? i.$_instance.resetOption(e) : i.$_instance.option(e, wL(s, e));
        }), i.$_config.cleanComponentsCountChanged();
      },
      $_createWidget(i) {
        const e = this;
        e.$_pendingOptions = {}, e.$_templatesManager = new ZL(this);
        const t = e.$_config;
        t.initialValues.hasOwnProperty(Us) && (t.initialValues.value = RL(t.initialValues));
        const n = {
          templatesRenderAsynchronously: e.$_hasAsyncTemplate,
          ...ux(e),
          ...t.initialValues,
          ...t.getNestedOptionValues(),
          ...this.$_getIntegrationOptions()
        }, s = new e.$_WidgetClass(i, n);
        e.$_instance = s, s.on("optionChanged", (o) => t.onOptionChanged(o)), ME(t, e, e.$_innerChanges), PE(t, e, e.$_innerChanges), this.$_createEmitters(s);
      },
      $_getIntegrationOptions() {
        const i = this, e = {
          integrationOptions: {
            watchMethod: this.$_getWatchMethod()
          },
          ...this.$_getExtraIntegrationOptions()
        };
        if (i.$_templatesManager.isDirty) {
          const { templates: t } = i.$_templatesManager;
          e.integrationOptions.templates = t;
          const { props: n } = i.$.vnode;
          for (const s of Object.keys(t))
            e[dx(n, s)] = s;
          i.$_templatesManager.resetDirtyFlag();
        }
        return e;
      },
      $_getWatchMethod() {
        return (i, e, t) => (t = t || {}, t.skipImmediate || e(i()), this.$watch(() => i(), (n, s) => {
          (Zu(s) !== Zu(n) || t.deep) && e(n);
        }, {
          deep: t.deep
        }));
      },
      $_getExtraIntegrationOptions() {
        return {};
      },
      $_processChildren(i) {
      },
      $_createEmitters(i) {
        this.$attrs && Object.keys(this.$attrs).forEach((e) => {
          const t = IE(e);
          i.on(t, (n) => {
            this.$emit(e, n);
          });
        });
      }
    }
  });
}
function LE(i) {
  const e = [];
  return yL(i, (t) => {
    const n = t.parentNode, s = t.hasAttribute && t.hasAttribute("isExtension");
    (t.nodeName === "#comment" || s) && n && (e.push(t), n.removeChild(t));
  }), e;
}
function t1(i) {
  return i && Array.from(i.classList).filter((e) => e.startsWith(NE));
}
function HE(i, e) {
  e.forEach((t) => {
    i.appendChild(t);
  });
}
function n1() {
  return /* @__PURE__ */ A({
    extends: e1(),
    methods: {
      $_getExtraIntegrationOptions() {
        return {
          onInitializing() {
            this.beginUpdate();
          }
        };
      },
      $_processChildren(i) {
        i.forEach((e) => {
          !e || typeof e != "object" || (e.$_hasOwner = !0);
        });
      }
    },
    mounted() {
      const i = LE(this.$el), e = this;
      this.$_createWidget(this.$el), this.$_syncElementClassesWithClassAttr(), e.$_instance.endUpdate(), HE(this.$el, i), this.$slots && this.$slots.default && qf(e).forEach((t) => {
        const n = t;
        n && n.$_isExtension && n.$_attachTo(this.$el);
      });
    }
  });
}
/*!
 * devextreme-vue
 * Version: 24.2.7
 * Build date: Mon Apr 28 2025
 *
 * Copyright (c) 2012 - 2025 Developer Express Inc. ALL RIGHTS RESERVED
 *
 * This software may be modified and distributed under the terms
 * of the MIT license. See the LICENSE file in the root of the project for details.
 *
 * https://github.com/DevExpress/devextreme-vue
 */
function io(i) {
  i.extends = n1(), i.model && FL(i);
}
function k(i) {
  i.extends = KL();
}
const WE = new Vf(), Sa = /* @__PURE__ */ new WeakMap();
let Mo;
const i1 = new Vf();
let zE = function() {
};
const s1 = function(i) {
  i1.fire(i), Mo = i;
  const {
    cleanData: e
  } = Mo;
  Mo.cleanData = function(t) {
    return zE(t), e.call(this, t);
  };
};
s1({
  data: function() {
    const i = arguments.length <= 0 ? void 0 : arguments[0], e = arguments.length <= 1 ? void 0 : arguments[1], t = arguments.length <= 2 ? void 0 : arguments[2];
    if (!i)
      return;
    let n = Sa.get(i);
    return n || (n = {}, Sa.set(i, n)), e === void 0 ? n : arguments.length === 2 ? n[e] : (n[e] = t, t);
  },
  removeData: function(i, e) {
    if (i)
      if (e === void 0)
        Sa.delete(i);
      else {
        const t = Sa.get(i);
        t && delete t[e];
      }
  },
  cleanData: function(i) {
    for (let e = 0; e < i.length; e++)
      _.off(i[e]), Sa.delete(i[e]);
  }
});
function tt() {
  for (var i = arguments.length, e = new Array(i), t = 0; t < i; t++)
    e[t] = arguments[t];
  return Mo.data.apply(this, e);
}
function o1(i) {
  zE = i;
}
function qc(i, e) {
  return Mo.removeData.call(this, i, e);
}
function Ll(i, e) {
  if (!O.isElementNode(i))
    return;
  const t = i.getElementsByTagName("*");
  Mo.cleanData(t), e && Mo.cleanData([i]);
}
const KE = /<([a-z][^/\0>\x20\t\r\n\f]+)/i, Ei = {
  default: {
    tagsCount: 0,
    startTags: "",
    endTags: ""
  },
  thead: {
    tagsCount: 1,
    startTags: "<table>",
    endTags: "</table>"
  },
  td: {
    tagsCount: 3,
    startTags: "<table><tbody><tr>",
    endTags: "</tr></tbody></table>"
  },
  col: {
    tagsCount: 2,
    startTags: "<table><colgroup>",
    endTags: "</colgroup></table>"
  },
  tr: {
    tagsCount: 2,
    startTags: "<table><tbody>",
    endTags: "</tbody></table>"
  }
};
Ei.tbody = Ei.colgroup = Ei.caption = Ei.tfoot = Ei.thead;
Ei.th = Ei.td;
const Xf = function(i) {
  if (typeof i != "string")
    return null;
  let t = O.createDocumentFragment().appendChild(O.createElement("div"));
  const n = KE.exec(i), s = n?.[1].toLowerCase(), o = Ei[s] || Ei.default;
  t.innerHTML = o.startTags + i + o.endTags;
  for (let r = 0; r < o.tagsCount; r++)
    t = t.lastChild;
  return [...t.childNodes];
}, r1 = function(i) {
  const e = KE.exec(i);
  return e && e[1] in Ei;
}, Qu = fe(), a1 = ["auto", "none", "inherit", "initial"], qh = function(i, e) {
  let t = 0;
  return e.forEach(function(n) {
    t += parseFloat(i[n]) || 0;
  }), t;
}, GE = function(i, e) {
  const t = i === "width" ? "Left" : "Top", n = i === "width" ? "Right" : "Bottom";
  return {
    padding: qh(e, [`padding${t}`, `padding${n}`]),
    border: qh(e, [`border${t}Width`, `border${n}Width`]),
    margin: qh(e, [`margin${t}`, `margin${n}`])
  };
}, UE = function(i) {
  var e;
  const t = (i == null || (e = i.ownerDocument) === null || e === void 0 ? void 0 : e.defaultView) || Qu;
  return t.getComputedStyle && t.getComputedStyle(i);
}, zg = function(i, e, t, n) {
  var s;
  return e?.[t] || ((s = i.style) === null || s === void 0 ? void 0 : s[t]) || n;
}, gr = {
  content: 0,
  padding: 1,
  border: 2,
  margin: 3,
  "content-box": 0,
  "border-box": 2
}, px = {
  width: ["left", "right"],
  height: ["top", "bottom"]
};
function Ea(i, e, t, n) {
  const s = (r, a, l) => parseFloat(zg(r, a, l, "0")) || 0, o = t === "border" ? "-width" : "";
  return s(i, n, `${t}-${px[e][0]}${o}`) + s(i, n, `${t}-${px[e][1]}${o}`);
}
const l1 = function(i, e, t) {
  const n = e === "width" ? "offsetWidth" : "offsetHeight", s = UE(i);
  let o = zg(i, s, e);
  (o === "" || o === "auto") && (o = i[n]), o = parseFloat(o) || 0;
  const r = zg(i, s, "boxSizing", "content-box");
  let l = gr[t || r], d = gr[r];
  if (l === void 0 || d === void 0)
    throw new Error();
  if (d === l)
    return o;
  const u = Math.sign(l - d);
  let c = !1, h = !1, g = !1, m = !1;
  u === 1 && (l += 1, d += 1);
  for (let C = d; C !== l; C += u)
    switch (C) {
      case gr.content:
        break;
      case gr.padding:
        c = u * Ea(i, e, "padding", s);
        break;
      case gr.border:
        h = u * Ea(i, e, "border", s);
        break;
      case gr.margin:
        g = u * Ea(i, e, "margin", s);
    }
  if (c || h) {
    const C = (c === !1 ? u * Ea(i, e, "padding", s) : c) + (h === !1 ? u * Ea(i, e, "border", s) : h);
    m = u * Math.max(0, Math.floor(i[n] - o - u * C)) || 0;
  }
  return o + g + c + h + m;
}, d1 = function(i) {
  return lt(i) ? i.innerHeight : i.offsetHeight;
}, u1 = function(i, e, t) {
  return i.indexOf("px") > 0 ? i = parseInt(i.replace("px", "")) : i.indexOf("%") > 0 ? i = parseInt(i.replace("%", "")) * d1(e) / 100 : isNaN(i) ? i.indexOf("vh") > 0 ? i = Qu.innerHeight / 100 * parseInt(i.replace("vh", "")) : t && i.indexOf("em") > 0 && (i = parseFloat(i.replace("em", "")) * parseFloat(Qu.getComputedStyle(t).fontSize)) : i = parseInt(i), i;
}, jE = function(i, e, t) {
  if (!i)
    return null;
  if (a1.includes(i))
    return e ? null : i;
  if (te(i) && (i = u1(i, t)), $e(i))
    return Math.max(0, i + e);
  const n = e < 0 ? " - " : " ";
  return `calc(${i}${n}${Math.abs(e)}px)`;
}, c1 = function(i, e, t) {
  const n = jE(i, e, t);
  return n !== null ? n : "none";
}, h1 = function(i, e, t) {
  const n = jE(i, e, t);
  return n !== null ? n : 0;
}, Yh = function(i, e) {
  if (!i)
    return 0;
  const t = GE("height", Qu.getComputedStyle(i));
  return t.padding + t.border + (e ? t.margin : 0);
}, gx = function(i) {
  if (i) {
    var e;
    const t = (e = i.getBoundingClientRect) === null || e === void 0 ? void 0 : e.call(i);
    if (t != null && t.height)
      return t.height;
  }
  return 0;
}, Mi = {
  getWidth: function() {
    for (var i = arguments.length, e = new Array(i), t = 0; t < i; t++)
      e[t] = arguments[t];
    return Rn("width", ...e);
  },
  setWidth: function() {
    for (var i = arguments.length, e = new Array(i), t = 0; t < i; t++)
      e[t] = arguments[t];
    return Rn("width", ...e);
  },
  getHeight: function() {
    for (var i = arguments.length, e = new Array(i), t = 0; t < i; t++)
      e[t] = arguments[t];
    return Rn("height", ...e);
  },
  setHeight: function() {
    for (var i = arguments.length, e = new Array(i), t = 0; t < i; t++)
      e[t] = arguments[t];
    return Rn("height", ...e);
  },
  getOuterWidth: function() {
    for (var i = arguments.length, e = new Array(i), t = 0; t < i; t++)
      e[t] = arguments[t];
    return Rn("outerWidth", ...e);
  },
  setOuterWidth: function() {
    for (var i = arguments.length, e = new Array(i), t = 0; t < i; t++)
      e[t] = arguments[t];
    return Rn("outerWidth", ...e);
  },
  getOuterHeight: function() {
    for (var i = arguments.length, e = new Array(i), t = 0; t < i; t++)
      e[t] = arguments[t];
    return Rn("outerHeight", ...e);
  },
  setOuterHeight: function() {
    for (var i = arguments.length, e = new Array(i), t = 0; t < i; t++)
      e[t] = arguments[t];
    return Rn("outerHeight", ...e);
  },
  getInnerWidth: function() {
    for (var i = arguments.length, e = new Array(i), t = 0; t < i; t++)
      e[t] = arguments[t];
    return Rn("innerWidth", ...e);
  },
  setInnerWidth: function() {
    for (var i = arguments.length, e = new Array(i), t = 0; t < i; t++)
      e[t] = arguments[t];
    return Rn("innerWidth", ...e);
  },
  getInnerHeight: function() {
    for (var i = arguments.length, e = new Array(i), t = 0; t < i; t++)
      e[t] = arguments[t];
    return Rn("innerHeight", ...e);
  },
  setInnerHeight: function() {
    for (var i = arguments.length, e = new Array(i), t = 0; t < i; t++)
      e[t] = arguments[t];
    return Rn("innerHeight", ...e);
  }
};
function Rn(i, e, t) {
  return arguments.length === 2 ? Gg(e, i) : Gg(e, i, t);
}
const ne = (i) => Mi.getWidth(i), xl = (i, e) => Mi.setWidth(i, e), le = (i) => Mi.getHeight(i), js = (i, e) => Mi.setHeight(i, e), Ee = (i, e) => Mi.getOuterWidth(i, e || !1), mx = (i, e) => Mi.setOuterWidth(i, e), he = (i, e) => Mi.getOuterHeight(i, e || !1), fx = (i, e) => Mi.setOuterHeight(i, e), Kg = (i) => Mi.getInnerWidth(i), Ju = (i) => Mi.getInnerHeight(i), Gg = function(i, e, t) {
  const n = e.toLowerCase().indexOf("width") >= 0 ? "Width" : "Height", s = n.toLowerCase(), o = e.indexOf("outer") === 0, r = e.indexOf("inner") === 0, a = arguments.length === 2 || typeof t == "boolean";
  if (zn(i)) {
    if (i.length > 1 && !a) {
      for (let l = 0; l < i.length; l++)
        Gg(i[l], e, t);
      return;
    }
    i = i[0];
  }
  if (i) {
    if (lt(i))
      return o ? i[`inner${n}`] : O.getDocumentElement()[`client${n}`];
    if (O.isDocument(i)) {
      const l = O.getDocumentElement(), d = O.getBody();
      return Math.max(d[`scroll${n}`], d[`offset${n}`], l[`scroll${n}`], l[`offset${n}`], l[`client${n}`]);
    }
    if (a) {
      let l = "content";
      return o && (l = t ? "margin" : "border"), r && (l = "padding"), l1(i, s, l);
    }
    if ($e(t)) {
      const l = UE(i), d = GE(s, l), u = l.boxSizing === "border-box";
      t = Number(t), o ? t -= u ? 0 : d.border + d.padding : r ? t += u ? d.border : -d.padding : u && (t += d.border + d.padding);
    }
    return t += $e(t) ? "px" : "", O.setStyle(i, s, t), null;
  }
}, qE = (i) => lt(i) ? i : i.defaultView, Ug = (i) => {
  if (!i.getClientRects().length)
    return {
      top: 0,
      left: 0
    };
  const e = i.getBoundingClientRect(), t = qE(i.ownerDocument), n = i.ownerDocument.documentElement;
  return {
    top: e.top + t.pageYOffset - n.clientTop,
    left: e.left + t.pageXOffset - n.clientLeft
  };
}, YE = function(i) {
  return i == null ? "" : String(i);
}, Zf = function(i) {
  return YE(i).charAt(0).toUpperCase() + i.substr(1);
}, Qf = function(i) {
  return YE(i).replace(/([a-z\d])([A-Z])/g, "$1 $2").split(/[\s_-]+/);
}, Hl = function(i) {
  return mt(Qf(i), function(e) {
    return e.toLowerCase();
  }).join("-");
}, p1 = function(i) {
  return Hl(i).replace(/-/g, "_");
}, Jr = function(i, e) {
  return mt(Qf(i), function(t, n) {
    return t = t.toLowerCase(), (e || n > 0) && (t = Zf(t)), t;
  }).join("");
}, XE = function(i) {
  return Zf(Hl(i).replace(/-/g, " "));
}, ea = function(i) {
  return mt(Qf(i), function(e) {
    return Zf(e.toLowerCase());
  }).join(" ");
}, g1 = ["0", "1", "2", "3", "4", "5", "6", "7", "8", "9"], ta = function(i) {
  const e = [];
  let t, n, s = !1, o = !1;
  for (t = 0; t < i.length; t++)
    n = i.charAt(t), o = n === n.toUpperCase() && n !== "-" && n !== ")" && n !== "/" || n in g1, n === "_" || n === "." ? (n = " ", o = !0) : t === 0 ? (n = n.toUpperCase(), o = !0) : !s && o && e.length > 0 && e.push(" "), e.push(n), s = o;
  return e.join("");
}, ZE = {
  dasherize: Hl,
  underscore: p1,
  camelize: Jr,
  humanize: XE,
  titleize: ea,
  captionize: ta
}, ec = ["", "Webkit", "Moz", "O", "Ms"], m1 = {
  "": "",
  Webkit: "-webkit-",
  Moz: "-moz-",
  O: "-o-",
  ms: "-ms-"
}, jg = _s(function() {
  return O.createElement("dx").style;
}), f1 = function(i, e) {
  i = Jr(i, !0);
  let t;
  for (let n = 0, s = ec.length; n < s; n++) {
    const o = ec[n], r = o + i, a = Jr(r);
    if (t = e(a, o), t === void 0 && (t = e(r, o)), t !== void 0)
      break;
  }
  return t || "";
}, tr = function(i) {
  if (i in jg())
    return i;
  const e = i;
  i = i.charAt(0).toUpperCase() + i.substr(1);
  for (let t = 1; t < ec.length; t++) {
    const n = ec[t].toLowerCase() + i;
    if (n in jg())
      return n;
  }
  return e;
}, wu = function(i) {
  return f1(i, function(e, t) {
    if (e in jg())
      return m1[t];
  });
}, _1 = ["fillOpacity", "columnCount", "flexGrow", "flexShrink", "fontWeight", "lineHeight", "opacity", "zIndex", "zoom"], yl = function(i, e) {
  return $e(e) && !_1.includes(i) && (e += "px"), e;
}, QE = function(i, e, t) {
  if (i) {
    t = $e(t) ? t += "px" : t;
    for (let n = 0; n < i.length; ++n)
      i[n].style[e] = t;
  }
}, qg = function(i, e) {
  QE(i, "width", e);
}, Xh = function(i, e) {
  QE(i, "height", e);
}, JE = function(i, e) {
  (arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : !0) && [].slice.call(i.style).forEach((s) => {
    i.style.removeProperty(s);
  }), e.split(";").forEach((n) => {
    const s = n.split(":").map((o) => o.trim());
    if (s.length === 2) {
      const [o, r] = s;
      i.style[o] = r;
    }
  });
}, C1 = fe();
let we;
const oe = function(i, e) {
  return i ? typeof i == "string" ? i === "body" ? (this[0] = e ? e.body : O.getBody(), this.length = 1, this) : (e = e || O.getDocument(), i.startsWith("<") ? (this[0] = O.createElement(i.slice(1, -1), e), this.length = 1, this) : ([].push.apply(this, O.querySelectorAll(e, i)), this)) : O.isNode(i) || lt(i) ? (this[0] = i, this.length = 1, this) : Array.isArray(i) ? ([].push.apply(this, i), this) : we(i.toArray ? i.toArray() : [i]) : (this.length = 0, this);
};
we = function(i, e) {
  return new oe(i, e);
};
we.fn = {
  dxRenderer: !0
};
oe.prototype = we.fn;
const ca = function(i, e) {
  for (let t = 0; t < this.length; t++) {
    const n = we(this[t]);
    n[i].apply(n, e);
  }
  return this;
}, Yg = function(i, e, t) {
  t != null && t !== !1 ? O.setAttribute(i, e, t) : O.removeAttribute(i, e);
};
oe.prototype.show = function() {
  return this.toggle(!0);
};
oe.prototype.hide = function() {
  return this.toggle(!1);
};
oe.prototype.toggle = function(i) {
  return this[0] && this.toggleClass("dx-state-invisible", !i), this;
};
oe.prototype.attr = function(i, e) {
  if (this.length > 1 && arguments.length > 1)
    return ca.call(this, "attr", arguments);
  if (!this[0])
    return X(i) || e !== void 0 ? this : void 0;
  if (!this[0].getAttribute)
    return this.prop(i, e);
  if (typeof i == "string" && arguments.length === 1) {
    const t = this[0].getAttribute(i);
    return t ?? void 0;
  }
  if (pe(i))
    for (const t in i)
      this.attr(t, i[t]);
  else
    Yg(this[0], i, e);
  return this;
};
oe.prototype.removeAttr = function(i) {
  return this.each(function(e, t) {
    O.removeAttribute(t, i);
  }), this;
};
oe.prototype.prop = function(i, e) {
  if (!this[0])
    return this;
  if (typeof i == "string" && arguments.length === 1)
    return this[0][i];
  if (pe(i))
    for (const t in i)
      this.prop(t, i[t]);
  else
    O.setProperty(this[0], i, e);
  return this;
};
oe.prototype.addClass = function(i) {
  return this.toggleClass(i, !0);
};
oe.prototype.removeClass = function(i) {
  return this.toggleClass(i, !1);
};
oe.prototype.hasClass = function(i) {
  if (!this[0] || this[0].className === void 0)
    return !1;
  const e = i.split(" ");
  for (let t = 0; t < e.length; t++)
    if (this[0].classList) {
      if (this[0].classList.contains(e[t]))
        return !0;
    } else if (((te(this[0].className) ? this[0].className : O.getAttribute(this[0], "class")) || "").split(" ").indexOf(e[t]) >= 0)
      return !0;
  return !1;
};
oe.prototype.toggleClass = function(i, e) {
  if (this.length > 1)
    return ca.call(this, "toggleClass", arguments);
  if (!this[0] || !i)
    return this;
  e = e === void 0 ? !this.hasClass(i) : e;
  const t = i.split(" ");
  for (let n = 0; n < t.length; n++)
    O.setClass(this[0], t[n], e);
  return this;
};
oe.prototype.html = function(i) {
  return arguments.length ? (this.empty(), typeof i == "string" && !r1(i) || typeof i == "number" ? (this[0].innerHTML = i, this) : this.append(Xf(i))) : this[0].innerHTML;
};
const eI = function(i, e) {
  if (!(!this[0] || !i)) {
    typeof i == "string" ? i = Xf(i) : i.nodeType ? i = [i] : $e(i) && (i = [O.createTextNode(i)]);
    for (let t = 0; t < i.length; t++) {
      const n = i[t];
      let s = this[0];
      s.tagName === "TABLE" && n.tagName === "TR" && s.tBodies && s.tBodies.length && (s = s.tBodies[0]), O.insertElement(s, n.nodeType ? n : n[0], e);
    }
  }
}, _x = function(i, e) {
  if (!(!this[0] || !this[0].style) && !(e === null || typeof e == "number" && isNaN(e))) {
    i = tr(i);
    for (let t = 0; t < this.length; t++)
      this[t].style[i] = yl(i, e);
  }
};
oe.prototype.css = function(i, e) {
  if (te(i))
    if (arguments.length === 2)
      _x.call(this, i, e);
    else {
      if (!this[0])
        return;
      i = tr(i);
      const t = C1.getComputedStyle(this[0])[i] || this[0].style[i];
      return $e(t) ? t.toString() : t;
    }
  else if (pe(i))
    for (const t in i)
      _x.call(this, t, i[t]);
  return this;
};
oe.prototype.prepend = function(i) {
  if (arguments.length > 1) {
    for (let e = 0; e < arguments.length; e++)
      this.prepend(arguments[e]);
    return this;
  }
  return eI.apply(this, [i, this[0].firstChild]), this;
};
oe.prototype.append = function(i) {
  if (arguments.length > 1) {
    for (let e = 0; e < arguments.length; e++)
      this.append(arguments[e]);
    return this;
  }
  return eI.apply(this, [i]), this;
};
oe.prototype.prependTo = function(i) {
  if (this.length > 1) {
    for (let e = this.length - 1; e >= 0; e--)
      we(this[e]).prependTo(i);
    return this;
  }
  return i = we(i), i[0] && O.insertElement(i[0], this[0], i[0].firstChild), this;
};
oe.prototype.appendTo = function(i) {
  return this.length > 1 ? ca.call(this, "appendTo", arguments) : (O.insertElement(we(i)[0], this[0]), this);
};
oe.prototype.insertBefore = function(i) {
  return i && i[0] && O.insertElement(i[0].parentNode, this[0], i[0]), this;
};
oe.prototype.insertAfter = function(i) {
  return i && i[0] && O.insertElement(i[0].parentNode, this[0], i[0].nextSibling), this;
};
oe.prototype.before = function(i) {
  return this[0] && O.insertElement(this[0].parentNode, i[0], this[0]), this;
};
oe.prototype.after = function(i) {
  return this[0] && O.insertElement(this[0].parentNode, i[0], this[0].nextSibling), this;
};
oe.prototype.wrap = function(i) {
  if (this[0]) {
    const e = we(i);
    e.insertBefore(this), e.append(this);
  }
  return this;
};
oe.prototype.wrapInner = function(i) {
  const e = this.contents();
  return e.length ? e.wrap(i) : this.append(i), this;
};
oe.prototype.replaceWith = function(i) {
  if (i && i[0])
    return i.is(this) ? this : (i.insertBefore(this), this.remove(), i);
};
oe.prototype.remove = function() {
  return this.length > 1 ? ca.call(this, "remove", arguments) : (Ll(this[0], !0), O.removeElement(this[0]), this);
};
oe.prototype.detach = function() {
  return this.length > 1 ? ca.call(this, "detach", arguments) : (O.removeElement(this[0]), this);
};
oe.prototype.empty = function() {
  return this.length > 1 ? ca.call(this, "empty", arguments) : (Ll(this[0]), O.setText(this[0], ""), this);
};
oe.prototype.clone = function() {
  const i = [];
  for (let e = 0; e < this.length; e++)
    i.push(this[e].cloneNode(!0));
  return we(i);
};
oe.prototype.text = function(i) {
  if (!arguments.length) {
    let t = "";
    for (let n = 0; n < this.length; n++)
      t += this[n] && this[n].textContent || "";
    return t;
  }
  const e = B(i) ? i() : i;
  return Ll(this[0], !1), O.setText(this[0], f(e) ? e : ""), this;
};
oe.prototype.val = function(i) {
  return arguments.length === 1 ? this.prop("value", f(i) ? i : "") : this.prop("value");
};
oe.prototype.contents = function() {
  if (!this[0])
    return we();
  const i = [];
  return i.push.apply(i, this[0].childNodes), we(i);
};
oe.prototype.find = function(i) {
  const e = we();
  if (!i)
    return e;
  const t = [];
  let n;
  if (typeof i == "string")
    for (i = i.trim(), n = 0; n < this.length; n++) {
      const s = this[n];
      if (O.isElementNode(s)) {
        const o = s.getAttribute("id");
        let r = o || "dx-query-children";
        o || Yg(s, "id", r), r = `[id='${r}'] `;
        const a = r + i.replace(/([^\\])(,)/g, `$1, ${r}`);
        t.push.apply(t, O.querySelectorAll(s, a)), Yg(s, "id", o);
      } else
        (O.isDocument(s) || O.isDocumentFragment(s)) && t.push.apply(t, O.querySelectorAll(s, i));
    }
  else
    for (n = 0; n < this.length; n++)
      i = O.isNode(i) ? i : i[0], this[n] !== i && this[n].contains(i) && t.push(i);
  return e.add(t);
};
const Cx = function(i, e) {
  var t, n;
  return e = e.host ?? e, e.nodeType ? !!(e.offsetWidth || e.offsetHeight || (t = (n = e).getClientRects) !== null && t !== void 0 && t.call(n).length) : !0;
};
oe.prototype.filter = function(i) {
  if (!i)
    return we();
  if (i === ":visible")
    return this.filter(Cx);
  if (i === ":hidden")
    return this.filter(function(t, n) {
      return !Cx(0, n);
    });
  const e = [];
  for (let t = 0; t < this.length; t++) {
    const n = this[t];
    if (O.isElementNode(n) && yn(i) === "string")
      O.elementMatches(n, i) && e.push(n);
    else if (O.isNode(i) || lt(i))
      i === n && e.push(n);
    else if (B(i))
      i.call(n, t, n) && e.push(n);
    else
      for (let s = 0; s < i.length; s++)
        i[s] === n && e.push(n);
  }
  return we(e);
};
oe.prototype.not = function(i) {
  const e = [], t = this.filter(i).toArray();
  for (let n = 0; n < this.length; n++)
    t.indexOf(this[n]) === -1 && e.push(this[n]);
  return we(e);
};
oe.prototype.is = function(i) {
  return !!this.filter(i).length;
};
oe.prototype.children = function(i) {
  let e = [];
  for (let t = 0; t < this.length; t++) {
    const n = this[t] ? this[t].childNodes : [];
    for (let s = 0; s < n.length; s++)
      O.isElementNode(n[s]) && e.push(n[s]);
  }
  return e = we(e), i ? e.filter(i) : e;
};
oe.prototype.siblings = function() {
  const i = this[0];
  if (!i || !i.parentNode)
    return we();
  const e = [], t = i.parentNode.childNodes || [];
  for (let n = 0; n < t.length; n++) {
    const s = t[n];
    O.isElementNode(s) && s !== i && e.push(s);
  }
  return we(e);
};
oe.prototype.each = function(i) {
  for (let e = 0; e < this.length && i.call(this[e], e, this[e]) !== !1; e++)
    ;
};
oe.prototype.index = function(i) {
  return i ? (i = we(i), this.toArray().indexOf(i[0])) : this.parent().children().index(this);
};
oe.prototype.get = function(i) {
  return this[i < 0 ? this.length + i : i];
};
oe.prototype.eq = function(i) {
  return i = i < 0 ? this.length + i : i, we(this[i]);
};
oe.prototype.first = function() {
  return this.eq(0);
};
oe.prototype.last = function() {
  return this.eq(-1);
};
oe.prototype.select = function() {
  for (let i = 0; i < this.length; i += 1)
    this[i].select && this[i].select();
  return this;
};
oe.prototype.parent = function(i) {
  if (!this[0])
    return we();
  const e = we(this[0].parentNode);
  return !i || e.is(i) ? e : we();
};
oe.prototype.parents = function(i) {
  const e = [];
  let t = this.parent();
  for (; t && t[0] && !O.isDocument(t[0]); )
    O.isElementNode(t[0]) && (!i || t.is(i)) && e.push(t.get(0)), t = t.parent();
  return we(e);
};
oe.prototype.closest = function(i) {
  if (this.is(i))
    return this;
  let e = this.parent();
  for (; e && e.length; ) {
    if (e.is(i))
      return e;
    e = e.parent();
  }
  return we();
};
oe.prototype.next = function(i) {
  if (!this[0])
    return we();
  let e = we(this[0].nextSibling);
  if (!arguments.length)
    return e;
  for (; e && e.length; ) {
    if (e.is(i))
      return e;
    e = e.next();
  }
  return we();
};
oe.prototype.prev = function() {
  return this[0] ? we(this[0].previousSibling) : we();
};
oe.prototype.add = function(i) {
  const e = we(i), t = this.toArray();
  for (let n = 0; n < e.length; n++) {
    const s = e[n];
    t.indexOf(s) === -1 && t.push(s);
  }
  return we(t);
};
const Jf = [];
oe.prototype.splice = function() {
  return we(Jf.splice.apply(this, arguments));
};
oe.prototype.slice = function() {
  return we(Jf.slice.apply(this, arguments));
};
oe.prototype.toArray = function() {
  return Jf.slice.call(this);
};
oe.prototype.offset = function() {
  if (this[0])
    return Ug(this[0]);
};
oe.prototype.offsetParent = function() {
  if (!this[0])
    return we();
  let i = we(this[0].offsetParent);
  for (; i[0] && i.css("position") === "static"; )
    i = we(i[0].offsetParent);
  return i = i[0] ? i : we(O.getDocumentElement()), i;
};
oe.prototype.position = function() {
  if (!this[0])
    return;
  let i;
  const e = parseFloat(this.css("marginTop")), t = parseFloat(this.css("marginLeft"));
  if (this.css("position") === "fixed")
    return i = this[0].getBoundingClientRect(), {
      top: i.top - e,
      left: i.left - t
    };
  i = this.offset();
  const n = this.offsetParent();
  let s = {
    top: 0,
    left: 0
  };
  return n[0].nodeName !== "HTML" && (s = n.offset()), s = {
    top: s.top + parseFloat(n.css("borderTopWidth")),
    left: s.left + parseFloat(n.css("borderLeftWidth"))
  }, {
    top: i.top - s.top - e,
    left: i.left - s.left - t
  };
};
[{
  name: "scrollLeft",
  offsetProp: "pageXOffset",
  scrollWindow: function(i, e) {
    i.scrollTo(e, i.pageYOffset);
  }
}, {
  name: "scrollTop",
  offsetProp: "pageYOffset",
  scrollWindow: function(i, e) {
    i.scrollTo(i.pageXOffset, e);
  }
}].forEach(function(i) {
  const e = i.name;
  oe.prototype[e] = function(t) {
    if (!this[0])
      return;
    const n = qE(this[0]);
    return t === void 0 ? n ? n[i.offsetProp] : this[0][e] : (n ? i.scrollWindow(n, t) : this[0][e] = t, this);
  };
});
oe.prototype.data = function(i, e) {
  if (this[0])
    return arguments.length < 2 ? tt.call(we, this[0], i) : (tt.call(we, this[0], i, e), this);
};
oe.prototype.removeData = function(i) {
  return this[0] && qc(this[0], i), this;
};
const tI = function() {
  return we.apply(this, arguments);
};
Object.defineProperty(tI, "fn", {
  enumerable: !0,
  configurable: !0,
  get: function() {
    return we.fn;
  },
  set: function(i) {
    we.fn = i;
  }
});
const v1 = {
  set: function(i) {
    we = i;
  },
  get: function() {
    return tI;
  }
}, p = v1.get(), Yn = function(i, e) {
  const t = {};
  "noBubble" in e && (t.noBubble = e.noBubble), "bindType" in e && (t.bindType = e.bindType), "delegateType" in e && (t.delegateType = e.delegateType), y(["setup", "teardown", "add", "remove", "trigger", "handle", "_default", "dispose"], (n, s) => {
    e[s] && (t[s] = function() {
      const o = [].slice.call(arguments);
      return o.unshift(this), e[s].apply(e, o);
    });
  }), Pf.fire(i, t);
};
Yn.callbacks = Pf;
const On = "dxremove", Xg = "dxRemoveEvent";
o1((i) => {
  i = [].slice.call(i);
  for (let e = 0; e < i.length; e++) {
    const t = p(i[e]);
    t.prop(Xg) && (t[0][Xg] = null, _.triggerHandler(t, "dxremove"));
  }
});
Yn("dxremove", {
  noBubble: !0,
  setup(i) {
    p(i).prop(Xg, !0);
  }
});
const Vd = /* @__PURE__ */ new WeakMap();
let x1 = 0;
const Wl = function(i, e) {
  if (f(e)) {
    Vd.set(i, e);
    return;
  }
  if (!Vd.has(i)) {
    const t = "dxPrivateComponent" + x1++;
    return Vd.set(i, t), t;
  }
  return Vd.get(i);
};
function nI(i, e, t) {
  const n = tt(i.get(0)), s = Wl(e.constructor);
  n[s] = e, t && _.one(i, On, function() {
    t.call(e);
  }), n.dxComponents || (n.dxComponents = []), n.dxComponents.push(s);
}
function iI(i, e) {
  const t = Wl(e);
  return tt(i.get(0), t);
}
const xe = function(i, e, t) {
  t ? e[i] = t : t = e, Wl(t, i), WE.fire(i, t);
}, y1 = function(i, e) {
  p.fn[i] = function(t) {
    const n = typeof t == "string";
    let s;
    if (n) {
      const o = t, r = [].slice.call(arguments).slice(1);
      this.each(function() {
        const a = e.getInstance(this);
        if (!a)
          throw Ae.Error("E0009", i);
        const d = a[o].apply(a, r);
        s === void 0 && (s = d);
      });
    } else
      this.each(function() {
        const o = e.getInstance(this);
        o ? o.option(t) : new e(this, t);
      }), s = this;
    return s;
  };
};
WE.add(y1);
var bl = Array.isArray;
function tc(i) {
  var e = typeof i;
  return e === "string" || e === "number";
}
function Me(i) {
  return i == null;
}
function wl(i) {
  return i === null || i === !1 || i === !0 || i === void 0;
}
function rt(i) {
  return typeof i == "function";
}
function Sl(i) {
  return typeof i == "string";
}
function b1(i) {
  return typeof i == "number";
}
function hn(i) {
  return i === null;
}
function w1(i) {
  return i === void 0;
}
function so(i, e) {
  var t = {};
  if (i)
    for (var n in i)
      t[n] = i[n];
  if (e)
    for (var s in e)
      t[s] = e[s];
  return t;
}
function e_(i) {
  return !hn(i) && typeof i == "object";
}
var Dt = {}, S1 = "$F";
function t_(i) {
  return i.substr(2).toLowerCase();
}
function sI(i, e) {
  i.appendChild(e);
}
function n_(i, e, t) {
  hn(t) ? sI(i, e) : i.insertBefore(e, t);
}
function E1(i, e) {
  return e ? document.createElementNS("http://www.w3.org/2000/svg", i) : document.createElement(i);
}
function I1(i, e, t) {
  i.replaceChild(e, t);
}
function oI(i, e) {
  i.removeChild(e);
}
function rI(i) {
  for (var e = 0; e < i.length; e++)
    i[e]();
}
function D1(i, e, t) {
  var n = i.children;
  return t & 4 ? n.$LI : t & 8192 ? i.childFlags === 2 ? n : n[e ? 0 : n.length - 1] : n;
}
function Hn(i, e) {
  for (var t; i; ) {
    if (t = i.flags, t & 2033)
      return i.dom;
    i = D1(i, e, t);
  }
  return null;
}
function zl(i, e) {
  do {
    var t = i.flags;
    if (t & 2033) {
      oI(e, i.dom);
      return;
    }
    var n = i.children;
    if (t & 4 && (i = n.$LI), t & 8 && (i = n), t & 8192)
      if (i.childFlags === 2)
        i = n;
      else {
        for (var s = 0, o = n.length; s < o; ++s)
          zl(n[s], e);
        return;
      }
  } while (i);
}
function aI(i, e, t) {
  do {
    var n = i.flags;
    if (n & 2033) {
      n_(e, i.dom, t);
      return;
    }
    var s = i.children;
    if (n & 4 && (i = s.$LI), n & 8 && (i = s), n & 8192)
      if (i.childFlags === 2)
        i = s;
      else {
        for (var o = 0, r = s.length; o < r; ++o)
          aI(s[o], e, t);
        return;
      }
  } while (i);
}
function lI(i, e, t) {
  return i.constructor.getDerivedStateFromProps ? so(t, i.constructor.getDerivedStateFromProps(e, t)) : t;
}
var El = {
  v: !1
}, vx = {
  componentComparator: null,
  createVNode: null,
  renderComplete: null
};
function nl(i, e) {
  i.textContent = e;
}
function dI(i, e) {
  return e_(i) && i.event === e.event && i.data === e.data;
}
function uI(i, e) {
  for (var t in e)
    w1(i[t]) && (i[t] = e[t]);
  return i;
}
function i_(i, e) {
  return !!rt(i) && (i(e), !0);
}
var il = "$";
function Yc(i, e, t, n, s, o, r, a) {
  this.childFlags = i, this.children = e, this.className = t, this.dom = null, this.flags = n, this.key = s === void 0 ? null : s, this.props = o === void 0 ? null : o, this.ref = r === void 0 ? null : r, this.type = a;
}
function gt(i, e, t, n, s, o, r, a) {
  var l = s === void 0 ? 1 : s, d = new Yc(l, n, t, i, r, o, a, e);
  return l === 0 && hI(d, d.children), d;
}
function T1(i, e, t) {
  if (i & 4)
    return t;
  var n = (i & 32768 ? e.render : e).defaultHooks;
  return Me(n) ? t : Me(t) ? n : uI(t, n);
}
function O1(i, e, t) {
  var n = (i & 32768 ? e.render : e).defaultProps;
  return Me(n) ? t : Me(t) ? so(n, null) : uI(t, n);
}
function A1(i, e) {
  return i & 12 ? i : e.prototype && e.prototype.render ? 4 : e.render ? 32776 : 8;
}
function qe(i, e, t, n, s) {
  i = A1(i, e);
  var o = new Yc(1, null, null, i, n, O1(i, e, t), T1(i, e, s), e);
  return o;
}
function Kl(i, e) {
  return new Yc(1, Me(i) || i === !0 || i === !1 ? "" : i, null, 16, e, null, null, null);
}
function Cs(i, e, t) {
  var n = gt(8192, 8192, null, i, e, null, t, null);
  switch (n.childFlags) {
    case 1:
      n.children = Xc(), n.childFlags = 2;
      break;
    case 16:
      n.children = [Kl(i)], n.childFlags = 4;
      break;
  }
  return n;
}
function ki(i) {
  var e = i.props;
  if (e) {
    var t = i.flags;
    t & 481 && (e.children !== void 0 && Me(i.children) && hI(i, e.children), e.className !== void 0 && (Me(i.className) && (i.className = e.className || null), e.className = void 0)), e.key !== void 0 && (i.key = e.key, e.key = void 0), e.ref !== void 0 && (t & 8 ? i.ref = so(i.ref, e.ref) : i.ref = e.ref, e.ref = void 0);
  }
  return i;
}
function R1(i) {
  var e = i.children, t = i.childFlags;
  return Cs(t === 2 ? Tt(e) : e.map(Tt), t, i.key);
}
function Tt(i) {
  var e = i.flags & -16385, t = i.props;
  if (e & 14 && !hn(t)) {
    var n = t;
    t = {};
    for (var s in n)
      t[s] = n[s];
  }
  return e & 8192 ? R1(i) : new Yc(i.childFlags, i.children, i.className, e, i.key, t, i.ref, i.type);
}
function Xc() {
  return Kl("", null);
}
function cI(i, e, t, n) {
  for (var s = i.length; t < s; t++) {
    var o = i[t];
    if (!wl(o)) {
      var r = n + il + t;
      if (bl(o))
        cI(o, e, 0, r);
      else {
        if (tc(o))
          o = Kl(o, r);
        else {
          var a = o.key, l = Sl(a) && a[0] === il;
          (o.flags & 81920 || l) && (o = Tt(o)), o.flags |= 65536, l ? a.substring(0, n.length) !== n && (o.key = n + a) : hn(a) ? o.key = r : o.key = n + a;
        }
        e.push(o);
      }
    }
  }
}
function F1(i) {
  switch (i) {
    case "svg":
      return 32;
    case "input":
      return 64;
    case "select":
      return 256;
    case "textarea":
      return 128;
    case S1:
      return 8192;
    default:
      return 1;
  }
}
function hI(i, e) {
  var t, n = 1;
  if (wl(e))
    t = e;
  else if (tc(e))
    n = 16, t = e;
  else if (bl(e)) {
    for (var s = e.length, o = 0; o < s; ++o) {
      var r = e[o];
      if (wl(r) || bl(r)) {
        t = t || e.slice(0, o), cI(e, t, o, "");
        break;
      } else if (tc(r))
        t = t || e.slice(0, o), t.push(Kl(r, il + o));
      else {
        var a = r.key, l = (r.flags & 81920) > 0, d = hn(a), u = Sl(a) && a[0] === il;
        l || d || u ? (t = t || e.slice(0, o), (l || u) && (r = Tt(r)), (d || u) && (r.key = il + o), t.push(r)) : t && t.push(r), r.flags |= 65536;
      }
    }
    t = t || e, t.length === 0 ? n = 1 : n = 8;
  } else
    t = e, t.flags |= 65536, e.flags & 81920 && (t = Tt(e)), n = 2;
  return i.children = t, i.childFlags = n, i;
}
function Zc(i) {
  return wl(i) || tc(i) ? Kl(i, null) : bl(i) ? Cs(i, 0, null) : i.flags & 16384 ? Tt(i) : i;
}
var go = "http://www.w3.org/1999/xlink", Zh = "http://www.w3.org/XML/1998/namespace", xx = {
  "xlink:actuate": go,
  "xlink:arcrole": go,
  "xlink:href": go,
  "xlink:role": go,
  "xlink:show": go,
  "xlink:title": go,
  "xlink:type": go,
  "xml:base": Zh,
  "xml:lang": Zh,
  "xml:space": Zh
};
function Qc(i) {
  return {
    onClick: i,
    onDblClick: i,
    onFocusIn: i,
    onFocusOut: i,
    onKeyDown: i,
    onKeyPress: i,
    onKeyUp: i,
    onMouseDown: i,
    onMouseMove: i,
    onMouseUp: i,
    onTouchEnd: i,
    onTouchMove: i,
    onTouchStart: i
  };
}
var pI = Qc(0), Zg = Qc(null), gI = Qc(!0);
function yx(i, e) {
  var t = e.$EV;
  return t || (t = e.$EV = Qc(null)), t[i] || ++pI[i] === 1 && (Zg[i] = L1(i)), t;
}
function mI(i, e) {
  var t = e.$EV;
  t && t[i] && (--pI[i] === 0 && (document.removeEventListener(t_(i), Zg[i]), Zg[i] = null), t[i] = null);
}
function k1(i, e, t, n) {
  if (rt(t))
    yx(i, n)[i] = t;
  else if (e_(t)) {
    if (dI(e, t))
      return;
    yx(i, n)[i] = t;
  } else
    mI(i, n);
}
function V1(i) {
  return rt(i.composedPath) ? i.composedPath()[0] : i.target;
}
function fI(i, e, t, n) {
  var s = V1(i);
  do {
    if (e && s.disabled)
      return;
    var o = s.$EV;
    if (o) {
      var r = o[t];
      if (r && (n.dom = s, r.event ? r.event(r.data, i) : r(i), i.cancelBubble))
        return;
    }
    s = s.parentNode;
  } while (!hn(s));
}
function P1() {
  this.cancelBubble = !0, this.immediatePropagationStopped || this.stopImmediatePropagation();
}
function M1() {
  return this.defaultPrevented;
}
function B1() {
  return this.cancelBubble;
}
function _I(i) {
  var e = {
    dom: document
  };
  return i.isDefaultPrevented = M1, i.isPropagationStopped = B1, i.stopPropagation = P1, Object.defineProperty(i, "currentTarget", {
    configurable: !0,
    get: function() {
      return e.dom;
    }
  }), e;
}
function $1(i) {
  return function(e) {
    if (e.button !== 0) {
      e.stopPropagation();
      return;
    }
    fI(e, !0, i, _I(e));
  };
}
function N1(i) {
  return function(e) {
    fI(e, !1, i, _I(e));
  };
}
function L1(i) {
  var e = i === "onClick" || i === "onDblClick" ? $1(i) : N1(i);
  return document.addEventListener(t_(i), e), e;
}
function H1(i, e) {
  var t = document.createElement("i");
  return t.innerHTML = e, t.innerHTML === i.innerHTML;
}
function bx(i, e, t) {
  if (i[e]) {
    var n = i[e];
    n.event ? n.event(n.data, t) : n(t);
  } else {
    var s = e.toLowerCase();
    i[s] && i[s](t);
  }
}
function Gl(i, e) {
  var t = function(n) {
    var s = this.$V;
    if (s) {
      var o = s.props || Dt, r = s.dom;
      if (Sl(i))
        bx(o, i, n);
      else
        for (var a = 0; a < i.length; ++a)
          bx(o, i[a], n);
      if (rt(e)) {
        var l = this.$V, d = l.props || Dt;
        e(d, r, !1, l);
      }
    }
  };
  return Object.defineProperty(t, "wrapped", {
    configurable: !1,
    enumerable: !1,
    value: !0,
    writable: !1
  }), t;
}
function Bo(i, e, t) {
  var n = "$" + e, s = i[n];
  if (s) {
    if (s[1].wrapped)
      return;
    i.removeEventListener(s[0], s[1]), i[n] = null;
  }
  rt(t) && (i.addEventListener(e, t), i[n] = [e, t]);
}
function s_(i) {
  return i === "checkbox" || i === "radio";
}
var W1 = Gl("onInput", o_), z1 = Gl(["onClick", "onChange"], o_);
function CI(i) {
  i.stopPropagation();
}
CI.wrapped = !0;
function K1(i, e) {
  s_(e.type) ? (Bo(i, "change", z1), Bo(i, "click", CI)) : Bo(i, "input", W1);
}
function o_(i, e) {
  var t = i.type, n = i.value, s = i.checked, o = i.multiple, r = i.defaultValue, a = !Me(n);
  t && t !== e.type && e.setAttribute("type", t), !Me(o) && o !== e.multiple && (e.multiple = o), !Me(r) && !a && (e.defaultValue = r + ""), s_(t) ? (a && (e.value = n), Me(s) || (e.checked = s)) : a && e.value !== n ? (e.defaultValue = n, e.value = n) : Me(s) || (e.checked = s);
}
function ja(i, e) {
  if (i.type === "option")
    G1(i, e);
  else {
    var t = i.children, n = i.flags;
    if (n & 4)
      ja(t.$LI, e);
    else if (n & 8)
      ja(t, e);
    else if (i.childFlags === 2)
      ja(t, e);
    else if (i.childFlags & 12)
      for (var s = 0, o = t.length; s < o; ++s)
        ja(t[s], e);
  }
}
function G1(i, e) {
  var t = i.props || Dt, n = i.dom;
  n.value = t.value, t.value === e || bl(e) && e.indexOf(t.value) !== -1 ? n.selected = !0 : (!Me(e) || !Me(t.selected)) && (n.selected = t.selected || !1);
}
var U1 = Gl("onChange", vI);
function j1(i) {
  Bo(i, "change", U1);
}
function vI(i, e, t, n) {
  var s = !!i.multiple;
  !Me(i.multiple) && s !== e.multiple && (e.multiple = s);
  var o = i.selectedIndex;
  o === -1 && (e.selectedIndex = -1);
  var r = n.childFlags;
  if (r !== 1) {
    var a = i.value;
    b1(o) && o > -1 && e.options[o] && (a = e.options[o].value), t && Me(a) && (a = i.defaultValue), ja(n, a);
  }
}
var q1 = Gl("onInput", xI), Y1 = Gl("onChange");
function X1(i, e) {
  Bo(i, "input", q1), e.onChange && Bo(i, "change", Y1);
}
function xI(i, e, t) {
  var n = i.value, s = e.value;
  if (Me(n)) {
    if (t) {
      var o = i.defaultValue;
      !Me(o) && o !== s && (e.defaultValue = o, e.value = o);
    }
  } else
    s !== n && (e.defaultValue = n, e.value = n);
}
function yI(i, e, t, n, s, o) {
  i & 64 ? o_(n, t) : i & 256 ? vI(n, t, s, e) : i & 128 && xI(n, t, s), o && (t.$V = e);
}
function Z1(i, e, t) {
  i & 64 ? K1(e, t) : i & 256 ? j1(e) : i & 128 && X1(e, t);
}
function bI(i) {
  return i.type && s_(i.type) ? !Me(i.checked) : !Me(i.value);
}
function ct() {
  return {
    current: null
  };
}
function nc(i) {
  i && !i_(i, null) && i.current && (i.current = null);
}
function Ul(i, e, t) {
  i && (rt(i) || i.current !== void 0) && t.push(function() {
    !i_(i, e) && i.current !== void 0 && (i.current = e);
  });
}
function si(i, e) {
  is(i), zl(i, e);
}
function is(i) {
  var e = i.flags, t = i.children, n;
  if (e & 481) {
    n = i.ref;
    var s = i.props;
    nc(n);
    var o = i.childFlags;
    if (!hn(s))
      for (var r = Object.keys(s), a = 0, l = r.length; a < l; a++) {
        var d = r[a];
        gI[d] && mI(d, i.dom);
      }
    o & 12 ? Il(t) : o === 2 && is(t);
  } else
    t && (e & 4 ? (rt(t.componentWillUnmount) && t.componentWillUnmount(), nc(i.ref), t.$UN = !0, is(t.$LI)) : e & 8 ? (n = i.ref, !Me(n) && rt(n.onComponentWillUnmount) && n.onComponentWillUnmount(Hn(i, !0), i.props || Dt), is(t)) : e & 1024 ? si(t, i.ref) : e & 8192 && i.childFlags & 12 && Il(t));
}
function Il(i) {
  for (var e = 0, t = i.length; e < t; ++e)
    is(i[e]);
}
function Su(i) {
  i.textContent = "";
}
function Eu(i, e, t) {
  Il(t), e.flags & 8192 ? zl(e, i) : Su(i);
}
function Q1(i) {
  var e = i.event;
  return function(t) {
    e(i.data, t);
  };
}
function J1(i, e, t, n) {
  if (e_(t)) {
    if (dI(e, t))
      return;
    t = Q1(t);
  }
  Bo(n, t_(i), t);
}
function eH(i, e, t) {
  if (Me(e)) {
    t.removeAttribute("style");
    return;
  }
  var n = t.style, s, o;
  if (Sl(e)) {
    n.cssText = e;
    return;
  }
  if (!Me(i) && !Sl(i)) {
    for (s in e)
      o = e[s], o !== i[s] && n.setProperty(s, o);
    for (s in i)
      Me(e[s]) && n.removeProperty(s);
  } else
    for (s in e)
      o = e[s], n.setProperty(s, o);
}
function tH(i, e, t, n) {
  var s = i && i.__html || "", o = e && e.__html || "";
  s !== o && !Me(o) && !H1(n, o) && (hn(t) || (t.childFlags & 12 ? Il(t.children) : t.childFlags === 2 && is(t.children), t.children = null, t.childFlags = 1), n.innerHTML = o);
}
function Qg(i, e, t, n, s, o, r) {
  switch (i) {
    case "children":
    case "childrenType":
    case "className":
    case "defaultValue":
    case "key":
    case "multiple":
    case "ref":
    case "selectedIndex":
      break;
    case "autoFocus":
      n.autofocus = !!t;
      break;
    case "allowfullscreen":
    case "autoplay":
    case "capture":
    case "checked":
    case "controls":
    case "default":
    case "disabled":
    case "hidden":
    case "indeterminate":
    case "loop":
    case "muted":
    case "novalidate":
    case "open":
    case "readOnly":
    case "required":
    case "reversed":
    case "scoped":
    case "seamless":
    case "selected":
      n[i] = !!t;
      break;
    case "defaultChecked":
    case "value":
    case "volume":
      if (o && i === "value")
        break;
      var a = Me(t) ? "" : t;
      n[i] !== a && (n[i] = a);
      break;
    case "style":
      eH(e, t, n);
      break;
    case "dangerouslySetInnerHTML":
      tH(e, t, r, n);
      break;
    default:
      gI[i] ? k1(i, e, t, n) : i.charCodeAt(0) === 111 && i.charCodeAt(1) === 110 ? J1(i, e, t, n) : Me(t) ? n.removeAttribute(i) : s && xx[i] ? n.setAttributeNS(xx[i], i, t) : n.setAttribute(i, t);
      break;
  }
}
function wI(i, e, t, n, s) {
  var o = !1, r = (e & 448) > 0;
  r && (o = bI(t), o && Z1(e, n, t));
  for (var a in t)
    Qg(a, null, t[a], n, s, o, null);
  r && yI(e, i, n, t, !0, o);
}
function SI(i, e, t) {
  var n = Zc(i.render(e, i.state, t)), s = t;
  return rt(i.getChildContext) && (s = so(t, i.getChildContext())), i.$CX = s, n;
}
function EI(i, e, t, n, s, o) {
  var r = new e(t, n), a = r.$N = !!(e.getDerivedStateFromProps || r.getSnapshotBeforeUpdate);
  if (r.$SVG = s, r.$L = o, i.children = r, r.$BS = !1, r.context = n, r.props === Dt && (r.props = t), a)
    r.state = lI(r, t, r.state);
  else if (rt(r.componentWillMount)) {
    r.$BR = !0, r.componentWillMount();
    var l = r.$PS;
    if (!hn(l)) {
      var d = r.state;
      if (hn(d))
        r.state = l;
      else
        for (var u in l)
          d[u] = l[u];
      r.$PS = null;
    }
    r.$BR = !1;
  }
  return r.$LI = SI(r, t, n), r;
}
function r_(i, e) {
  var t = i.props || Dt;
  return i.flags & 32768 ? i.type.render(t, i.ref, e) : i.type(t, e);
}
function At(i, e, t, n, s, o) {
  var r = i.flags |= 16384;
  r & 481 ? DI(i, e, t, n, s, o) : r & 4 ? sH(i, e, t, n, s, o) : r & 8 ? (oH(i, e, t, n, s, o), OI(i, o)) : r & 512 || r & 16 ? II(i, e, s) : r & 8192 ? iH(i, t, e, n, s, o) : r & 1024 && nH(i, t, e, s, o);
}
function nH(i, e, t, n, s) {
  At(i.children, i.ref, e, !1, null, s);
  var o = Xc();
  II(o, t, n), i.dom = o.dom;
}
function iH(i, e, t, n, s, o) {
  var r = i.children, a = i.childFlags;
  a & 12 && r.length === 0 && (a = i.childFlags = 2, r = i.children = Xc()), a === 2 ? At(r, t, e, n, s, o) : $o(r, t, e, n, s, o);
}
function II(i, e, t) {
  var n = i.dom = document.createTextNode(i.children);
  hn(e) || n_(e, n, t);
}
function DI(i, e, t, n, s, o) {
  var r = i.flags, a = i.props, l = i.className, d = i.childFlags, u = i.dom = E1(i.type, n = n || (r & 32) > 0), c = i.children;
  if (!Me(l) && l !== "" && (n ? u.setAttribute("class", l) : u.className = l), d === 16)
    nl(u, c);
  else if (d !== 1) {
    var h = n && i.type !== "foreignObject";
    d === 2 ? (c.flags & 16384 && (i.children = c = Tt(c)), At(c, u, t, h, null, o)) : (d === 8 || d === 4) && $o(c, u, t, h, null, o);
  }
  hn(e) || n_(e, u, s), hn(a) || wI(i, r, a, u, n), Ul(i.ref, u, o);
}
function $o(i, e, t, n, s, o) {
  for (var r = 0; r < i.length; ++r) {
    var a = i[r];
    a.flags & 16384 && (i[r] = a = Tt(a)), At(a, e, t, n, s, o);
  }
}
function sH(i, e, t, n, s, o) {
  var r = EI(i, i.type, i.props || Dt, t, n, o);
  At(r.$LI, e, r.$CX, n, s, o), TI(i.ref, r, o);
}
function oH(i, e, t, n, s, o) {
  At(i.children = Zc(r_(i, t)), e, t, n, s, o);
}
function rH(i) {
  return function() {
    i.componentDidMount();
  };
}
function TI(i, e, t) {
  Ul(i, e, t), rt(e.componentDidMount) && t.push(rH(e));
}
function aH(i, e) {
  return function() {
    i.onComponentDidMount(Hn(e, !0), e.props || Dt);
  };
}
function OI(i, e) {
  var t = i.ref;
  Me(t) || (i_(t.onComponentWillMount, i.props || Dt), rt(t.onComponentDidMount) && e.push(aH(t, i)));
}
function lH(i, e, t, n, s, o) {
  is(i), e.flags & i.flags & 2033 ? (At(e, null, n, s, null, o), I1(t, e.dom, i.dom)) : (At(e, t, n, s, Hn(i, !0), o), zl(i, t));
}
function us(i, e, t, n, s, o, r) {
  var a = e.flags |= 16384;
  i.flags !== a || i.type !== e.type || i.key !== e.key || a & 2048 ? i.flags & 16384 ? lH(i, e, t, n, s, r) : At(e, t, n, s, o, r) : a & 481 ? pH(i, e, n, s, a, r) : a & 4 ? fH(i, e, t, n, s, o, r) : a & 8 ? _H(i, e, t, n, s, o, r) : a & 16 ? CH(i, e) : a & 512 ? e.dom = i.dom : a & 8192 ? cH(i, e, t, n, s, r) : hH(i, e, n, r);
}
function dH(i, e, t) {
  i !== e && (i !== "" ? t.firstChild.nodeValue = e : nl(t, e));
}
function uH(i, e) {
  i.textContent !== e && (i.textContent = e);
}
function cH(i, e, t, n, s, o) {
  var r = i.children, a = e.children, l = i.childFlags, d = e.childFlags, u = null;
  d & 12 && a.length === 0 && (d = e.childFlags = 2, a = e.children = Xc());
  var c = (d & 2) !== 0;
  if (l & 12) {
    var h = r.length;
    // It uses keyed algorithm
    (l & 8 && d & 8 || // It transforms from many to single
    c || // It will append more nodes
    !c && a.length > h) && (u = Hn(r[h - 1], !1).nextSibling);
  }
  a_(l, d, r, a, t, n, s, u, i, o);
}
function hH(i, e, t, n) {
  var s = i.ref, o = e.ref, r = e.children;
  if (a_(i.childFlags, e.childFlags, i.children, r, s, t, !1, null, i, n), e.dom = i.dom, s !== o && !wl(r)) {
    var a = r.dom;
    oI(s, a), sI(o, a);
  }
}
function pH(i, e, t, n, s, o) {
  var r = e.dom = i.dom, a = i.props, l = e.props, d = !1, u = !1, c;
  if (n = n || (s & 32) > 0, a !== l) {
    var h = a || Dt;
    if (c = l || Dt, c !== Dt) {
      d = (s & 448) > 0, d && (u = bI(c));
      for (var g in c) {
        var m = h[g], C = c[g];
        m !== C && Qg(g, m, C, r, n, u, i);
      }
    }
    if (h !== Dt)
      for (var v in h)
        Me(c[v]) && !Me(h[v]) && Qg(v, h[v], null, r, n, u, i);
  }
  var E = e.children, T = e.className;
  i.className !== T && (Me(T) ? r.removeAttribute("class") : n ? r.setAttribute("class", T) : r.className = T), s & 4096 ? uH(r, E) : a_(i.childFlags, e.childFlags, i.children, E, r, t, n && e.type !== "foreignObject", null, i, o), d && yI(s, e, r, c, !1, u);
  var V = e.ref, $ = i.ref;
  $ !== V && (nc($), Ul(V, r, o));
}
function gH(i, e, t, n, s, o) {
  is(i), $o(e, t, n, s, Hn(i, !0), o), zl(i, t);
}
function a_(i, e, t, n, s, o, r, a, l, d) {
  switch (i) {
    case 2:
      switch (e) {
        case 2:
          us(t, n, s, o, r, a, d);
          break;
        case 1:
          si(t, s);
          break;
        case 16:
          is(t), nl(s, n);
          break;
        default:
          gH(t, n, s, o, r, d);
          break;
      }
      break;
    case 1:
      switch (e) {
        case 2:
          At(n, s, o, r, a, d);
          break;
        case 1:
          break;
        case 16:
          nl(s, n);
          break;
        default:
          $o(n, s, o, r, a, d);
          break;
      }
      break;
    case 16:
      switch (e) {
        case 16:
          dH(t, n, s);
          break;
        case 2:
          Su(s), At(n, s, o, r, a, d);
          break;
        case 1:
          Su(s);
          break;
        default:
          Su(s), $o(n, s, o, r, a, d);
          break;
      }
      break;
    default:
      switch (e) {
        case 16:
          Il(t), nl(s, n);
          break;
        case 2:
          Eu(s, l, t), At(n, s, o, r, a, d);
          break;
        case 1:
          Eu(s, l, t);
          break;
        default:
          var u = t.length | 0, c = n.length | 0;
          u === 0 ? c > 0 && $o(n, s, o, r, a, d) : c === 0 ? Eu(s, l, t) : e === 8 && i === 8 ? xH(t, n, s, o, r, u, c, a, l, d) : vH(t, n, s, o, r, u, c, a, d);
          break;
      }
      break;
  }
}
function mH(i, e, t, n, s) {
  s.push(function() {
    i.componentDidUpdate(e, t, n);
  });
}
function AI(i, e, t, n, s, o, r, a, l) {
  var d = i.state, u = i.props, c = !!i.$N, h = rt(i.shouldComponentUpdate);
  if (c && (e = lI(i, t, e !== d ? so(d, e) : e)), r || !h || h && i.shouldComponentUpdate(t, e, s)) {
    !c && rt(i.componentWillUpdate) && i.componentWillUpdate(t, e, s), i.props = t, i.state = e, i.context = s;
    var g = null, m = SI(i, t, s);
    c && rt(i.getSnapshotBeforeUpdate) && (g = i.getSnapshotBeforeUpdate(u, d)), us(i.$LI, m, n, i.$CX, o, a, l), i.$LI = m, rt(i.componentDidUpdate) && mH(i, u, d, g, l);
  } else
    i.props = t, i.state = e, i.context = s;
}
function fH(i, e, t, n, s, o, r) {
  var a = e.children = i.children;
  if (!hn(a)) {
    a.$L = r;
    var l = e.props || Dt, d = e.ref, u = i.ref, c = a.state;
    if (!a.$N) {
      if (rt(a.componentWillReceiveProps)) {
        if (a.$BR = !0, a.componentWillReceiveProps(l, n), a.$UN)
          return;
        a.$BR = !1;
      }
      hn(a.$PS) || (c = so(c, a.$PS), a.$PS = null);
    }
    AI(a, c, l, t, n, s, !1, o, r), u !== d && (nc(u), Ul(d, a, r));
  }
}
function _H(i, e, t, n, s, o, r) {
  var a = !0, l = e.props || Dt, d = e.ref, u = i.props, c = !Me(d), h = i.children;
  if (c && rt(d.onComponentShouldUpdate) && (a = d.onComponentShouldUpdate(u, l)), a !== !1) {
    c && rt(d.onComponentWillUpdate) && d.onComponentWillUpdate(u, l);
    var g = Zc(r_(e, n));
    us(h, g, t, n, s, o, r), e.children = g, c && rt(d.onComponentDidUpdate) && d.onComponentDidUpdate(u, l);
  } else
    e.children = h;
}
function CH(i, e) {
  var t = e.children, n = e.dom = i.dom;
  t !== i.children && (n.nodeValue = t);
}
function vH(i, e, t, n, s, o, r, a, l) {
  for (var d = o > r ? r : o, u = 0, c, h; u < d; ++u)
    c = e[u], h = i[u], c.flags & 16384 && (c = e[u] = Tt(c)), us(h, c, t, n, s, a, l), i[u] = c;
  if (o < r)
    for (u = d; u < r; ++u)
      c = e[u], c.flags & 16384 && (c = e[u] = Tt(c)), At(c, t, n, s, a, l);
  else if (o > r)
    for (u = d; u < o; ++u)
      si(i[u], t);
}
function xH(i, e, t, n, s, o, r, a, l, d) {
  var u = o - 1, c = r - 1, h = 0, g = i[h], m = e[h], C, v;
  e: {
    for (; g.key === m.key; ) {
      if (m.flags & 16384 && (e[h] = m = Tt(m)), us(g, m, t, n, s, a, d), i[h] = m, ++h, h > u || h > c)
        break e;
      g = i[h], m = e[h];
    }
    for (g = i[u], m = e[c]; g.key === m.key; ) {
      if (m.flags & 16384 && (e[c] = m = Tt(m)), us(g, m, t, n, s, a, d), i[u] = m, u--, c--, h > u || h > c)
        break e;
      g = i[u], m = e[c];
    }
  }
  if (h > u) {
    if (h <= c)
      for (C = c + 1, v = C < r ? Hn(e[C], !0) : a; h <= c; )
        m = e[h], m.flags & 16384 && (e[h] = m = Tt(m)), ++h, At(m, t, n, s, v, d);
  } else if (h > c)
    for (; h <= u; )
      si(i[h++], t);
  else
    yH(i, e, n, o, r, u, c, h, t, s, a, l, d);
}
function yH(i, e, t, n, s, o, r, a, l, d, u, c, h) {
  var g, m, C, v = 0, E = a, T = a, V = o - a + 1, $ = r - a + 1, G = new Int32Array($ + 1), H = V === n, ce = !1, re = 0, me = 0;
  if (s < 4 || (V | $) < 32)
    for (v = E; v <= o; ++v)
      if (g = i[v], me < $) {
        for (a = T; a <= r; a++)
          if (m = e[a], g.key === m.key) {
            if (G[a - T] = v + 1, H)
              for (H = !1; E < v; )
                si(i[E++], l);
            re > a ? ce = !0 : re = a, m.flags & 16384 && (e[a] = m = Tt(m)), us(g, m, l, t, d, u, h), ++me;
            break;
          }
        !H && a > r && si(g, l);
      } else
        H || si(g, l);
  else {
    var dt = {};
    for (v = T; v <= r; ++v)
      dt[e[v].key] = v;
    for (v = E; v <= o; ++v)
      if (g = i[v], me < $)
        if (a = dt[g.key], a !== void 0) {
          if (H)
            for (H = !1; v > E; )
              si(i[E++], l);
          G[a - T] = v + 1, re > a ? ce = !0 : re = a, m = e[a], m.flags & 16384 && (e[a] = m = Tt(m)), us(g, m, l, t, d, u, h), ++me;
        } else
          H || si(g, l);
      else
        H || si(g, l);
  }
  if (H)
    Eu(l, c, i), $o(e, l, t, d, u, h);
  else if (ce) {
    var Ke = bH(G);
    for (a = Ke.length - 1, v = $ - 1; v >= 0; v--)
      G[v] === 0 ? (re = v + T, m = e[re], m.flags & 16384 && (e[re] = m = Tt(m)), C = re + 1, At(m, l, t, d, C < s ? Hn(e[C], !0) : u, h)) : a < 0 || v !== Ke[a] ? (re = v + T, m = e[re], C = re + 1, aI(m, l, C < s ? Hn(e[C], !0) : u)) : a--;
  } else if (me !== $)
    for (v = $ - 1; v >= 0; v--)
      G[v] === 0 && (re = v + T, m = e[re], m.flags & 16384 && (e[re] = m = Tt(m)), C = re + 1, At(m, l, t, d, C < s ? Hn(e[C], !0) : u, h));
}
var Ni, Pd, wx = 0;
function bH(i) {
  var e = 0, t = 0, n = 0, s = 0, o = 0, r = 0, a = 0, l = i.length;
  for (l > wx && (wx = l, Ni = new Int32Array(l), Pd = new Int32Array(l)); t < l; ++t)
    if (e = i[t], e !== 0) {
      if (n = Ni[s], i[n] < e) {
        Pd[t] = n, Ni[++s] = t;
        continue;
      }
      for (o = 0, r = s; o < r; )
        a = o + r >> 1, i[Ni[a]] < e ? o = a + 1 : r = a;
      e < i[Ni[o]] && (o > 0 && (Pd[t] = Ni[o - 1]), Ni[o] = t);
    }
  o = s + 1;
  var d = new Int32Array(o);
  for (r = Ni[o - 1]; o-- > 0; )
    d[o] = r, r = Pd[r], Ni[o] = 0;
  return d;
}
var wH = typeof document < "u";
wH && window.Node && (Node.prototype.$EV = null, Node.prototype.$V = null);
function SH(i, e, t, n) {
  var s = [], o = e.$V;
  El.v = !0, Me(o) ? Me(i) || (i.flags & 16384 && (i = Tt(i)), At(i, e, n, !1, null, s), e.$V = i, o = i) : Me(i) ? (si(o, e), e.$V = null) : (i.flags & 16384 && (i = Tt(i)), us(o, i, e, n, !1, null, s), o = e.$V = i), rI(s), El.v = !1, rt(t) && t(), rt(vx.renderComplete) && vx.renderComplete(o, e);
}
function Jc(i, e, t, n) {
  t === void 0 && (t = null), n === void 0 && (n = Dt), SH(i, e, t, n);
}
var Iu = [], EH = typeof Promise < "u" ? Promise.resolve().then.bind(Promise.resolve()) : function(i) {
  window.setTimeout(i, 0);
}, Jg = !1;
function RI(i, e, t, n) {
  var s = i.$PS;
  if (rt(e) && (e = e(s ? so(i.state, s) : i.state, i.props, i.context)), Me(s))
    i.$PS = e;
  else
    for (var o in e)
      s[o] = e[o];
  if (i.$BR)
    rt(t) && i.$L.push(t.bind(i));
  else {
    if (!El.v && Iu.length === 0) {
      kI(i, n), rt(t) && t.call(i);
      return;
    }
    if (Iu.indexOf(i) === -1 && Iu.push(i), n && (i.$F = !0), Jg || (Jg = !0, EH(FI)), rt(t)) {
      var r = i.$QU;
      r || (r = i.$QU = []), r.push(t);
    }
  }
}
function IH(i) {
  for (var e = i.$QU, t = 0; t < e.length; ++t)
    e[t].call(i);
  i.$QU = null;
}
function FI() {
  var i;
  for (Jg = !1; i = Iu.shift(); )
    if (!i.$UN) {
      var e = i.$F;
      i.$F = !1, kI(i, e), i.$QU && IH(i);
    }
}
function kI(i, e) {
  if (e || !i.$BR) {
    var t = i.$PS;
    i.$PS = null;
    var n = [];
    El.v = !0, AI(i, so(i.state, t), i.props, Hn(i.$LI, !0).parentNode, i.context, i.$SVG, e, null, n), rI(n), El.v = !1;
  } else
    i.state = i.$PS, i.$PS = null;
}
var jl = function(e, t) {
  this.state = null, this.$BR = !1, this.$BS = !0, this.$PS = null, this.$LI = null, this.$UN = !1, this.$CX = null, this.$QU = null, this.$N = !1, this.$L = null, this.$SVG = !1, this.$F = !1, this.props = e || Dt, this.context = t || Dt;
};
jl.prototype.forceUpdate = function(e) {
  this.$UN || RI(this, {}, e, !0);
};
jl.prototype.setState = function(e, t) {
  this.$UN || this.$BS || RI(this, e, t, !1);
};
jl.prototype.render = function(e, t, n) {
  return null;
};
const Rs = {
  lockCount: 0,
  lock() {
    this.lockCount++;
  },
  callbacks: [],
  callEffects() {
    if (this.lockCount--, this.lockCount < 0)
      throw new Error("Unexpected Effect Call");
    if (this.lockCount === 0) {
      const i = this.callbacks;
      this.callbacks = [], i.forEach((e) => e());
    }
  }
}, Qh = (i, e) => {
  if (!(i instanceof Object && e instanceof Object))
    return i === e;
  const n = Object.keys(i), s = Object.keys(e);
  return n.length !== s.length ? !1 : !n.some((r) => i[r] !== e[r]);
};
class bn extends jl {
  constructor() {
    super(...arguments), this._pendingContext = this.context;
  }
  componentWillReceiveProps(e, t) {
    this._pendingContext = t ?? {};
  }
  shouldComponentUpdate(e, t) {
    return !Qh(this.props, e) || !Qh(this.state, t) || !Qh(this.context, this._pendingContext);
  }
}
class vs extends bn {
  constructor() {
    super(...arguments), this._effects = [];
  }
  createEffects() {
    return [];
  }
  updateEffects() {
  }
  componentWillMount() {
    Rs.lock();
  }
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  componentWillUpdate(e, t, n) {
    Rs.lock();
  }
  componentDidMount() {
    Rs.callbacks.push(() => {
      this._effects = this.createEffects();
    }), Rs.callEffects();
  }
  componentDidUpdate() {
    Rs.callbacks.push(() => this.updateEffects()), Rs.callEffects();
  }
  destroyEffects() {
    this._effects.forEach((e) => e.dispose());
  }
  componentWillUnmount() {
    this.destroyEffects();
  }
}
class ql extends vs {
  constructor() {
    super(...arguments), this.vDomElement = null;
  }
  vDomUpdateClasses() {
    const e = this.vDomElement, t = e.className.length ? e.className.split(" ") : [], n = t.filter((o) => e.dxClasses.previous.indexOf(o) < 0), s = e.dxClasses.previous.filter((o) => t.indexOf(o) < 0);
    n.forEach((o) => {
      const r = e.dxClasses.removed.indexOf(o);
      r > -1 ? e.dxClasses.removed.splice(r, 1) : e.dxClasses.added.includes(o) || e.dxClasses.added.push(o);
    }), s.forEach((o) => {
      const r = e.dxClasses.added.indexOf(o);
      r > -1 ? e.dxClasses.added.splice(r, 1) : e.dxClasses.removed.includes(o) || e.dxClasses.removed.push(o);
    });
  }
  componentDidMount() {
    const e = Hn(this.$LI, !0);
    this.vDomElement = e, super.componentDidMount(), e.dxClasses = e.dxClasses || {
      removed: [],
      added: [],
      previous: []
    }, e.dxClasses.previous = e?.className.length ? e.className.split(" ") : [];
  }
  componentDidUpdate() {
    super.componentDidUpdate();
    const e = this.vDomElement;
    e !== null && (e.dxClasses.added.forEach((t) => e.classList.add(t)), e.dxClasses.removed.forEach((t) => e.classList.remove(t)), e.dxClasses.previous = e.className.length ? e.className.split(" ") : []);
  }
  shouldComponentUpdate(e, t) {
    const n = super.shouldComponentUpdate(e, t);
    return n && this.vDomUpdateClasses(), n;
  }
}
let DH = 0;
const l_ = function(i) {
  const e = DH++;
  return {
    id: e,
    defaultValue: i,
    Provider: class extends jl {
      getChildContext() {
        return Object.assign(Object.assign({}, this.context), { [e]: this.props.value || i });
      }
      render() {
        return this.props.children;
      }
    }
  };
};
class et {
  constructor(e, t) {
    this.dependency = t, this.effect = e, this.destroy = e();
  }
  update(e) {
    const t = this.dependency;
    e && (this.dependency = e), (!e || e.some((n, s) => t[s] !== n)) && (this.dispose(), this.destroy = this.effect());
  }
  dispose() {
    this.destroy && this.destroy();
  }
}
const Yl = () => new et(() => {
  FI();
}, []), TH = "a runtime error occured! Use Inferno in development environment to find the error.";
function OH(i) {
  return i == null;
}
function AH(i) {
  return i === null || i === !1 || i === !0 || i === void 0;
}
function RH(i) {
  return typeof i == "function";
}
function Pr(i) {
  return i === null;
}
function FH(i) {
  throw i || (i = TH), new Error(`Inferno Error: ${i}`);
}
function kH(i, e) {
  const t = document.createElement("i");
  return t.innerHTML = e, t.innerHTML === i.innerHTML;
}
function VH(i) {
  let e, t;
  for (; i; ) {
    if (e = i.flags, e & 2033)
      return i.dom;
    t = i.children, e & 8192 ? i = i.childFlags === 2 ? t : t[t.length - 1] : e & 4 ? i = t.$LI : i = t;
  }
  return null;
}
function PH(i, e) {
  return !!(e && e.dangerouslySetInnerHTML && e.dangerouslySetInnerHTML.__html && kH(i, e.dangerouslySetInnerHTML.__html));
}
function MH(i, e, t, n, s, o, r) {
  const a = i.type, l = i.ref, d = i.props || Dt;
  let u;
  if (o) {
    const c = EI(i, a, d, n, s, r), h = c.$LI;
    u = Dl(h, e, t, c.$CX, s, r), TI(l, c, r);
  } else {
    const c = Zc(r_(i, n));
    u = Dl(c, e, t, n, s, r), i.children = c, OI(i, r);
  }
  return u;
}
function VI(i, e, t, n, s, o) {
  const r = i.childFlags, a = i.children, l = i.props, d = i.flags;
  if (r !== 1) {
    if (r === 2)
      Pr(t) ? At(a, e, n, s, null, o) : (t = Dl(a, e, t, n, s, o), t = t ? t.nextSibling : null);
    else if (r === 16)
      Pr(t) ? e.appendChild(document.createTextNode(a)) : e.childNodes.length !== 1 || t.nodeType !== 3 ? e.textContent = a : t.nodeValue !== a && (t.nodeValue = a), t = null;
    else if (r & 12) {
      let u = !1;
      for (let c = 0, h = a.length; c < h; ++c) {
        const g = a[c];
        Pr(t) || u && (g.flags & 16) > 0 ? At(g, e, n, s, t, o) : (t = Dl(g, e, t, n, s, o), t = t ? t.nextSibling : null), u = (g.flags & 16) > 0;
      }
    }
    if (!(d & 8192)) {
      let u = null;
      for (; t; )
        u = t.nextSibling, e.removeChild(t), t = u;
    }
  } else
    !Pr(e.firstChild) && !PH(e, l) && (e.textContent = "", d & 448 && (e.defaultValue = ""));
}
function BH(i, e, t, n, s, o) {
  const r = i.props, a = i.className, l = i.flags, d = i.ref;
  return s = s || (l & 32) > 0, t.nodeType !== 1 ? (DI(i, null, n, s, null, o), e.replaceChild(i.dom, t)) : (i.dom = t, VI(i, t, t.firstChild, n, s, o), Pr(r) || wI(i, l, r, t, s), OH(a) ? t.className !== "" && t.removeAttribute("class") : s ? t.setAttribute("class", a) : t.className = a, Ul(d, t, o)), i.dom;
}
function PI(i, e, t) {
  if (t.nodeType !== 3)
    e.replaceChild(i.dom = document.createTextNode(i.children), t);
  else {
    const n = i.children;
    t.nodeValue !== n && (t.nodeValue = n), i.dom = t;
  }
  return i.dom;
}
function $H(i, e, t, n, s, o) {
  const r = i.children;
  return i.childFlags === 2 ? (PI(r, e, t), r.dom) : (VI(i, e, t, n, s, o), VH(r[r.length - 1]));
}
function Dl(i, e, t, n, s, o) {
  const r = i.flags |= 16384;
  return r & 14 ? MH(i, e, t, n, s, (r & 4) > 0, o) : r & 481 ? BH(i, e, t, n, s, o) : r & 16 ? PI(i, e, t) : r & 512 ? i.dom = t : r & 8192 ? $H(i, e, t, n, s, o) : (FH(), null);
}
function NH(i, e, t) {
  let n = e.firstChild;
  if (Pr(n))
    Jc(i, e, t);
  else {
    const s = [];
    for (AH(i) || (n = Dl(i, e, n, {}, !1, s)); n && (n = n.nextSibling); )
      e.removeChild(n);
    if (s.length > 0) {
      let o;
      for (; (o = s.shift()) !== void 0; )
        o();
    }
  }
  e.$V = i, RH(t) && t();
}
function Sx(i) {
  return i == null;
}
function LH(i) {
  return typeof i == "string";
}
function Ex(i) {
  return i === void 0;
}
var HH = {
  onComponentDidMount: 1,
  onComponentDidUpdate: 1,
  onComponentShouldUpdate: 1,
  onComponentWillMount: 1,
  onComponentWillUnmount: 1,
  onComponentWillUpdate: 1
};
function Du(i, e, t) {
  var n = arguments, s, o = null, r = null, a = null, l = 0, d, u = arguments.length - 2;
  if (u === 1)
    s = t;
  else if (u > 1)
    for (s = []; u-- > 0; )
      s[u] = n[u + 2];
  if (LH(i)) {
    if (l = F1(i), !Sx(e)) {
      d = {};
      for (var c in e)
        c === "className" || c === "class" ? a = e[c] : c === "key" ? r = e.key : c === "children" && Ex(s) ? s = e.children : c === "ref" ? o = e.ref : (c === "contenteditable" && (l |= 4096), d[c] = e[c]);
    }
  } else {
    if (l = 2, Ex(s) || (e || (e = {}), e.children = s), !Sx(e)) {
      d = {};
      for (var h in e)
        h === "key" ? r = e.key : h === "ref" ? o = e.ref : HH[h] === 1 ? (o || (o = {}), o[h] = e[h]) : d[h] = e[h];
    }
    return qe(l, i, d, r, o);
  }
  return l & 8192 ? Cs(u === 1 ? [s] : s, 0, r) : gt(l, i, a, s, 0, d, r, o);
}
const WH = (i) => {
  var e, t;
  return ((e = i.container) === null || e === void 0 ? void 0 : e.get(0)) || ((t = i.item) === null || t === void 0 ? void 0 : t.get(0));
};
function zH(i, e, t) {
  setTimeout(() => {
    Jc(Du(i, e), WH(e));
  }, 0);
}
const KH = (i, e, t) => {
  const n = e[i];
  return !!n && typeof n != "string";
}, GH = /* @__PURE__ */ new Set([
  "animationIterationCount",
  "borderImageOutset",
  "borderImageSlice",
  "border-imageWidth",
  "boxFlex",
  "boxFlexGroup",
  "boxOrdinalGroup",
  "columnCount",
  "fillOpacity",
  "flex",
  "flexGrow",
  "flexNegative",
  "flexOrder",
  "flexPositive",
  "flexShrink",
  "floodOpacity",
  "fontWeight",
  "gridColumn",
  "gridRow",
  "lineClamp",
  "lineHeight",
  "opacity",
  "order",
  "orphans",
  "stopOpacity",
  "strokeDasharray",
  "strokeDashoffset",
  "strokeMiterlimit",
  "strokeOpacity",
  "strokeWidth",
  "tabSize",
  "widows",
  "zIndex",
  "zoom"
]), UH = (i) => typeof i == "number" ? !0 : !Number.isNaN(Number(i)), jH = (i, e) => GH.has(i) ? e : `${e}px`, qH = /[A-Z]/g, YH = (i) => i.replace(qH, "-$&").toLowerCase();
function XH(i) {
  if (i instanceof Object)
    return Object.entries(i).reduce((e, [t, n]) => (e[YH(t)] = UH(n) ? jH(t, n) : n, e), {});
}
const MI = function(i, e) {
  if (!ZH(i))
    return !1;
  const t = i.nodeName.toLowerCase(), n = !isNaN(e), s = i.disabled, o = /^(input|select|textarea|button|object|iframe)$/.test(t), r = t === "a";
  let a;
  const l = i.isContentEditable;
  return o || l ? a = !s : r ? a = i.href || n : a = n, a;
};
function ZH(i) {
  const e = p(i);
  return e.is(":visible") && e.css("visibility") !== "hidden" && e.parents().css("visibility") !== "hidden";
}
const em = function(i, e) {
  return MI(e, p(e).attr("tabIndex"));
}, tm = function(i, e) {
  const t = p(e).attr("tabIndex");
  return (isNaN(t) || t >= 0) && MI(e, t);
}, qs = function(i) {
  const e = p(i).get(0);
  return O.getActiveElement(e) === e;
}, nm = (i, e) => {
  if (!e)
    throw Ae.Error("E0017");
  return Array.isArray(i) ? i.map((t) => nm(t, e)).join(" ") : i.indexOf(" ") !== -1 ? nm(i.split(/\s+/g), e) : `${i}.${e}`;
}, QH = {
  backspace: "backspace",
  tab: "tab",
  enter: "enter",
  escape: "escape",
  pageup: "pageUp",
  pagedown: "pageDown",
  end: "end",
  home: "home",
  arrowleft: "leftArrow",
  arrowup: "upArrow",
  arrowright: "rightArrow",
  arrowdown: "downArrow",
  delete: "del",
  " ": "space",
  f: "F",
  a: "A",
  "*": "asterisk",
  "-": "minus",
  alt: "alt",
  control: "control",
  shift: "shift"
}, JH = {
  8: "backspace",
  9: "tab",
  13: "enter",
  27: "escape",
  33: "pageUp",
  34: "pageDown",
  35: "end",
  36: "home",
  37: "leftArrow",
  38: "upArrow",
  39: "rightArrow",
  40: "downArrow",
  46: "del",
  32: "space",
  70: "F",
  65: "A",
  106: "asterisk",
  109: "minus",
  189: "minus",
  173: "minus",
  16: "shift",
  17: "control",
  18: "alt"
}, eW = {
  dx: /^dx/i,
  mouse: /(mouse|wheel)/i,
  touch: /^touch/i,
  keyboard: /^key/i,
  pointer: /^(ms)?pointer/i
}, Xl = (i) => {
  let {
    type: e
  } = i, t = "other";
  return y(eW, function(n) {
    if (this.test(e))
      return t = n, !1;
  }), t;
};
let tW = (i) => i;
const nW = (i) => _.Event(i, i), iW = (i) => tW(nW(i)), d_ = (i) => Xl(i) === "dx", sW = (i) => Xl(i) === "mouse", BI = (i) => Xl(i) === "touch", $I = (i) => Xl(i) === "pointer", jo = (i) => sW(i) || ($I(i) || d_(i)) && i.pointerType === "mouse", ln = (i) => i && i.type === "dxmousewheel", Zl = (i) => BI(i) || ($I(i) || d_(i)) && i.pointerType === "touch", st = (i) => {
  let {
    pageX: e,
    pageY: t,
    timeStamp: n
  } = i;
  return {
    x: e,
    y: t,
    time: n
  };
}, So = (i, e) => ({
  x: e.x - i.x,
  y: e.y - i.y,
  time: e.time - i.time || 1
}), oW = (i) => {
  const {
    originalEvent: e,
    pointers: t
  } = i;
  return BI(i) ? (e.touches || []).length : d_(i) ? (t || []).length : 0;
}, NI = (i) => {
  const {
    target: e
  } = i, t = p(e), n = e?.isContentEditable || e?.hasAttribute("contenteditable"), s = t.is("input, textarea, select") || n;
  if (ln(i))
    return t.is("textarea") && t.hasClass("dx-texteditor-input") || n ? !1 : t.is("input[type='number'], textarea, select") && t.is(":focus");
  if (jo(i))
    return s || i.which > 1;
  if (Zl(i))
    return s && qs(t);
}, $s = (i, e) => {
  const t = iW(i);
  return e && x(t, e), t;
}, oo = (i) => {
  const {
    originalEvent: e,
    delegateTarget: t
  } = i, n = $s(e, i);
  return _.trigger(t || n.target, n), n;
}, Ye = (i) => {
  let {
    key: e,
    which: t
  } = i;
  const n = QH[e?.toLowerCase()] || e, s = JH[t];
  return s && n === e ? s : !n && t ? String.fromCharCode(t) : n;
}, im = (i) => {
  let {
    key: e,
    which: t
  } = i;
  return e || String.fromCharCode(t);
}, R = nm, bt = (i) => {
  let {
    ctrlKey: e,
    metaKey: t
  } = i;
  return e || t;
}, Jh = "KeyboardProcessor", LI = (i) => ({
  keyName: Ye(i),
  key: i.key,
  code: i.code,
  ctrl: i.ctrlKey,
  location: i.location,
  metaKey: i.metaKey,
  shift: i.shiftKey,
  alt: i.altKey,
  which: i.which,
  originalEvent: i
}), u_ = se.inherit({
  _keydown: R("keydown", Jh),
  _compositionStart: R("compositionstart", Jh),
  _compositionEnd: R("compositionend", Jh),
  ctor(i) {
    i = i || {}, i.element && (this._element = p(i.element)), i.focusTarget && (this._focusTarget = i.focusTarget), this._handler = i.handler, this._element && (this._processFunction = (e) => {
      const t = p(this._focusTarget).toArray(), n = this._focusTarget && this._focusTarget !== e.target && !t.includes(e.target), s = this._isComposingJustFinished && e.which === 229 || this._isComposing || n;
      this._isComposingJustFinished = !1, s || this.process(e);
    }, this._toggleProcessingWithContext = this.toggleProcessing.bind(this), _.on(this._element, this._keydown, this._processFunction), _.on(this._element, this._compositionStart, this._toggleProcessingWithContext), _.on(this._element, this._compositionEnd, this._toggleProcessingWithContext));
  },
  dispose() {
    this._element && (_.off(this._element, this._keydown, this._processFunction), _.off(this._element, this._compositionStart, this._toggleProcessingWithContext), _.off(this._element, this._compositionEnd, this._toggleProcessingWithContext)), this._element = void 0, this._handler = void 0;
  },
  process(i) {
    this._handler(LI(i));
  },
  toggleProcessing(i) {
    let {
      type: e
    } = i;
    this._isComposing = e === "compositionstart", this._isComposingJustFinished = !this._isComposing;
  }
});
u_.createKeyDownOptions = LI;
function Ct(i, e) {
  return e ? R(i, e) : i;
}
function sm(i, e) {
  return typeof i == "function" ? i(e) : i.execute(e);
}
const Ix = {
  on: (i, e, t, n) => {
    const {
      selector: s,
      showTimeout: o,
      hideTimeout: r,
      namespace: a
    } = n;
    _.on(i, Ct("dxactive", a), s, {
      timeout: o
    }, (l) => sm(e, {
      event: l,
      element: l.currentTarget
    })), _.on(i, Ct("dxinactive", a), s, {
      timeout: r
    }, (l) => sm(t, {
      event: l,
      element: l.currentTarget
    }));
  },
  off: (i, e) => {
    let {
      namespace: t,
      selector: n
    } = e;
    _.off(i, Ct("dxactive", t), n), _.off(i, Ct("dxinactive", t), n);
  }
}, ic = {
  on: function(i, e) {
    let {
      namespace: t
    } = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    _.on(i, Ct("dxresize", t), e);
  },
  off: function(i) {
    let {
      namespace: e
    } = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    _.off(i, Ct("dxresize", e));
  }
}, Dx = {
  on: (i, e, t, n) => {
    let {
      selector: s,
      namespace: o
    } = n;
    _.on(i, Ct("dxhoverend", o), s, (r) => t(r)), _.on(i, Ct("dxhoverstart", o), s, (r) => sm(e, {
      element: r.target,
      event: r
    }));
  },
  off: (i, e) => {
    let {
      selector: t,
      namespace: n
    } = e;
    _.off(i, Ct("dxhoverstart", n), t), _.off(i, Ct("dxhoverend", n), t);
  }
}, sc = {
  on: (i, e, t, n) => {
    let {
      namespace: s
    } = n;
    _.on(i, Ct("dxhiding", s), t), _.on(i, Ct("dxshown", s), e);
  },
  off: (i, e) => {
    let {
      namespace: t
    } = e;
    _.off(i, Ct("dxhiding", t)), _.off(i, Ct("dxshown", t));
  }
}, Tu = {
  on: (i, e, t, n) => {
    let {
      namespace: s
    } = n;
    _.on(i, Ct("focusin", s), e), _.on(i, Ct("focusout", s), t);
  },
  off: (i, e) => {
    let {
      namespace: t
    } = e;
    _.off(i, Ct("focusin", t)), _.off(i, Ct("focusout", t));
  },
  trigger: (i) => _.trigger(i, "focus")
}, Tx = {
  on: function(i, e) {
    let {
      namespace: t
    } = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    _.on(i, Ct("dxclick", t), e);
  },
  off: function(i) {
    let {
      namespace: e
    } = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    _.off(i, Ct("dxclick", e));
  }
}, Ox = {
  on: function(i, e) {
    let {
      namespace: t
    } = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    _.on(i, Ct("click", t), e);
  },
  off: function(i) {
    let {
      namespace: e
    } = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    _.off(i, Ct("click", e));
  }
};
let rW = 0;
const Ia = {}, aW = () => "keyboardProcessorId" + rW++, oi = {
  on: (i, e, t) => {
    const n = aW();
    return Ia[n] = new u_({
      element: i,
      focusTarget: e,
      handler: t
    }), n;
  },
  off: (i) => {
    i && Ia[i] && (Ia[i].dispose(), delete Ia[i]);
  },
  _getProcessor: (i) => Ia[i]
}, lW = {
  "en-150": "en-001",
  "en-AG": "en-001",
  "en-AI": "en-001",
  "en-AU": "en-001",
  "en-BB": "en-001",
  "en-BM": "en-001",
  "en-BS": "en-001",
  "en-BW": "en-001",
  "en-BZ": "en-001",
  "en-CC": "en-001",
  "en-CK": "en-001",
  "en-CM": "en-001",
  "en-CX": "en-001",
  "en-CY": "en-001",
  "en-DG": "en-001",
  "en-DM": "en-001",
  "en-ER": "en-001",
  "en-FJ": "en-001",
  "en-FK": "en-001",
  "en-FM": "en-001",
  "en-GB": "en-001",
  "en-GD": "en-001",
  "en-GG": "en-001",
  "en-GH": "en-001",
  "en-GI": "en-001",
  "en-GM": "en-001",
  "en-GY": "en-001",
  "en-HK": "en-001",
  "en-IE": "en-001",
  "en-IL": "en-001",
  "en-IM": "en-001",
  "en-IN": "en-001",
  "en-IO": "en-001",
  "en-JE": "en-001",
  "en-JM": "en-001",
  "en-KE": "en-001",
  "en-KI": "en-001",
  "en-KN": "en-001",
  "en-KY": "en-001",
  "en-LC": "en-001",
  "en-LR": "en-001",
  "en-LS": "en-001",
  "en-MG": "en-001",
  "en-MO": "en-001",
  "en-MS": "en-001",
  "en-MT": "en-001",
  "en-MU": "en-001",
  "en-MV": "en-001",
  "en-MW": "en-001",
  "en-MY": "en-001",
  "en-NA": "en-001",
  "en-NF": "en-001",
  "en-NG": "en-001",
  "en-NR": "en-001",
  "en-NU": "en-001",
  "en-NZ": "en-001",
  "en-PG": "en-001",
  "en-PK": "en-001",
  "en-PN": "en-001",
  "en-PW": "en-001",
  "en-RW": "en-001",
  "en-SB": "en-001",
  "en-SC": "en-001",
  "en-SD": "en-001",
  "en-SG": "en-001",
  "en-SH": "en-001",
  "en-SL": "en-001",
  "en-SS": "en-001",
  "en-SX": "en-001",
  "en-SZ": "en-001",
  "en-TC": "en-001",
  "en-TK": "en-001",
  "en-TO": "en-001",
  "en-TT": "en-001",
  "en-TV": "en-001",
  "en-TZ": "en-001",
  "en-UG": "en-001",
  "en-VC": "en-001",
  "en-VG": "en-001",
  "en-VU": "en-001",
  "en-WS": "en-001",
  "en-ZA": "en-001",
  "en-ZM": "en-001",
  "en-ZW": "en-001",
  "en-AT": "en-150",
  "en-BE": "en-150",
  "en-CH": "en-150",
  "en-DE": "en-150",
  "en-DK": "en-150",
  "en-FI": "en-150",
  "en-NL": "en-150",
  "en-SE": "en-150",
  "en-SI": "en-150",
  "hi-Latn": "en-IN",
  "es-AR": "es-419",
  "es-BO": "es-419",
  "es-BR": "es-419",
  "es-BZ": "es-419",
  "es-CL": "es-419",
  "es-CO": "es-419",
  "es-CR": "es-419",
  "es-CU": "es-419",
  "es-DO": "es-419",
  "es-EC": "es-419",
  "es-GT": "es-419",
  "es-HN": "es-419",
  "es-MX": "es-419",
  "es-NI": "es-419",
  "es-PA": "es-419",
  "es-PE": "es-419",
  "es-PR": "es-419",
  "es-PY": "es-419",
  "es-SV": "es-419",
  "es-US": "es-419",
  "es-UY": "es-419",
  "es-VE": "es-419",
  nb: "no",
  nn: "no",
  "pt-AO": "pt-PT",
  "pt-CH": "pt-PT",
  "pt-CV": "pt-PT",
  "pt-FR": "pt-PT",
  "pt-GQ": "pt-PT",
  "pt-GW": "pt-PT",
  "pt-LU": "pt-PT",
  "pt-MO": "pt-PT",
  "pt-MZ": "pt-PT",
  "pt-ST": "pt-PT",
  "pt-TL": "pt-PT",
  "az-Arab": "und",
  "az-Cyrl": "und",
  "bal-Latn": "und",
  "blt-Latn": "und",
  "bm-Nkoo": "und",
  "bs-Cyrl": "und",
  "byn-Latn": "und",
  "cu-Glag": "und",
  "dje-Arab": "und",
  "dyo-Arab": "und",
  "en-Dsrt": "und",
  "en-Shaw": "und",
  "ff-Adlm": "und",
  "ff-Arab": "und",
  "ha-Arab": "und",
  "iu-Latn": "und",
  "kk-Arab": "und",
  "ks-Deva": "und",
  "ku-Arab": "und",
  "ky-Arab": "und",
  "ky-Latn": "und",
  "ml-Arab": "und",
  "mn-Mong": "und",
  "mni-Mtei": "und",
  "ms-Arab": "und",
  "pa-Arab": "und",
  "sat-Deva": "und",
  "sd-Deva": "und",
  "sd-Khoj": "und",
  "sd-Sind": "und",
  "shi-Latn": "und",
  "so-Arab": "und",
  "sr-Latn": "und",
  "sw-Arab": "und",
  "tg-Arab": "und",
  "ug-Cyrl": "und",
  "uz-Arab": "und",
  "uz-Cyrl": "und",
  "vai-Latn": "und",
  "wo-Arab": "und",
  "yo-Arab": "und",
  "yue-Hans": "und",
  "zh-Hant": "und",
  "zh-Hant-MO": "zh-Hant-HK"
}, dW = (i, e) => {
  const t = i[e];
  return t ? t !== "root" && t : e.substr(0, e.lastIndexOf("-"));
}, Kn = qn({
  locale: (() => {
    let i = "en";
    return (e) => {
      if (!e)
        return i;
      i = e;
    };
  })(),
  getValueByClosestLocale: function(i) {
    let e = this.locale(), t = i(e), n;
    for (; !t && !n; )
      e = dW(lW, e), e ? t = i(e) : n = !0;
    return t === void 0 && e !== "en" ? i("en") : t;
  }
}), uW = {
  en: {
    Yes: "Yes",
    No: "No",
    Cancel: "Cancel",
    CheckState: "Check state",
    Close: "Close",
    Clear: "Clear",
    Done: "Done",
    Loading: "Loading...",
    Select: "Select...",
    Search: "Search",
    Back: "Back",
    OK: "OK",
    Today: "Today",
    Yesterday: "Yesterday",
    "dxCollectionWidget-noDataText": "No data to display",
    "dxDropDownEditor-selectLabel": "Select",
    "validation-required": "Required",
    "validation-required-formatted": "{0} is required",
    "validation-numeric": "Value must be a number",
    "validation-numeric-formatted": "{0} must be a number",
    "validation-range": "Value is out of range",
    "validation-range-formatted": "{0} is out of range",
    "validation-stringLength": "The length of the value is not correct",
    "validation-stringLength-formatted": "The length of {0} is not correct",
    "validation-custom": "Value is invalid",
    "validation-custom-formatted": "{0} is invalid",
    "validation-async": "Value is invalid",
    "validation-async-formatted": "{0} is invalid",
    "validation-compare": "Values do not match",
    "validation-compare-formatted": "{0} does not match",
    "validation-pattern": "Value does not match pattern",
    "validation-pattern-formatted": "{0} does not match pattern",
    "validation-email": "Email is invalid",
    "validation-email-formatted": "{0} is invalid",
    "validation-mask": "Value is invalid",
    "dxLookup-searchPlaceholder": "Minimum character number: {0}",
    "dxList-pullingDownText": "Pull down to refresh...",
    "dxList-pulledDownText": "Release to refresh...",
    "dxList-refreshingText": "Refreshing...",
    "dxList-pageLoadingText": "Loading...",
    "dxList-nextButtonText": "More",
    "dxList-selectAll": "Select All",
    "dxList-listAriaLabel": "Items",
    "dxList-listAriaLabel-deletable": "Deletable items",
    "dxListEditDecorator-delete": "Delete",
    "dxListEditDecorator-more": "More",
    "dxList-selectAll-indeterminate": "Half-checked",
    "dxList-selectAll-checked": "Checked",
    "dxList-selectAll-notChecked": "Not checked",
    "dxList-ariaRoleDescription": "List",
    "dxList-listAriaLabel-itemContent": "List item content",
    "dxScrollView-pullingDownText": "Pull down to refresh...",
    "dxScrollView-pulledDownText": "Release to refresh...",
    "dxScrollView-refreshingText": "Refreshing...",
    "dxScrollView-reachBottomText": "Loading...",
    "dxDateBox-simulatedDataPickerTitleTime": "Select time",
    "dxDateBox-simulatedDataPickerTitleDate": "Select date",
    "dxDateBox-simulatedDataPickerTitleDateTime": "Select date and time",
    "dxDateBox-validation-datetime": "Value must be a date or time",
    "dxDateRangeBox-invalidStartDateMessage": "Start value must be a date",
    "dxDateRangeBox-invalidEndDateMessage": "End value must be a date",
    "dxDateRangeBox-startDateOutOfRangeMessage": "Start date is out of range",
    "dxDateRangeBox-endDateOutOfRangeMessage": "End date is out of range",
    "dxDateRangeBox-startDateLabel": "Start Date",
    "dxDateRangeBox-endDateLabel": "End Date",
    "dxFileUploader-selectFile": "Select a file",
    "dxFileUploader-dropFile": "or Drop a file here",
    "dxFileUploader-bytes": "bytes",
    "dxFileUploader-kb": "KB",
    "dxFileUploader-Mb": "MB",
    "dxFileUploader-Gb": "GB",
    "dxFileUploader-upload": "Upload",
    "dxFileUploader-uploaded": "Uploaded",
    "dxFileUploader-readyToUpload": "Ready to upload",
    "dxFileUploader-uploadAbortedMessage": "Upload cancelled",
    "dxFileUploader-uploadFailedMessage": "Upload failed",
    "dxFileUploader-invalidFileExtension": "File type is not allowed",
    "dxFileUploader-invalidMaxFileSize": "File is too large",
    "dxFileUploader-invalidMinFileSize": "File is too small",
    "dxRangeSlider-ariaFrom": "From",
    "dxRangeSlider-ariaTill": "Till",
    "dxSwitch-switchedOnText": "ON",
    "dxSwitch-switchedOffText": "OFF",
    "dxForm-optionalMark": "optional",
    "dxForm-requiredMessage": "{0} is required",
    "dxNumberBox-invalidValueMessage": "Value must be a number",
    "dxNumberBox-noDataText": "No data",
    "dxDataGrid-emptyHeaderWithColumnChooserText": "Use {0} to display columns",
    "dxDataGrid-emptyHeaderWithGroupPanelText": "Drag a column from the group panel here",
    "dxDataGrid-emptyHeaderWithColumnChooserAndGroupPanelText": "Use {0} or drag a column from the group panel",
    "dxDataGrid-emptyHeaderColumnChooserText": "column chooser",
    "dxDataGrid-columnChooserTitle": "Column Chooser",
    "dxDataGrid-columnChooserEmptyText": "Drag a column here to hide it",
    "dxDataGrid-groupContinuesMessage": "Continues on the next page",
    "dxDataGrid-groupContinuedMessage": "Continued from the previous page",
    "dxDataGrid-groupHeaderText": "Group by This Column",
    "dxDataGrid-ungroupHeaderText": "Ungroup",
    "dxDataGrid-ungroupAllText": "Ungroup All",
    "dxDataGrid-editingEditRow": "Edit",
    "dxDataGrid-editingSaveRowChanges": "Save",
    "dxDataGrid-editingCancelRowChanges": "Cancel",
    "dxDataGrid-editingDeleteRow": "Delete",
    "dxDataGrid-editingUndeleteRow": "Undelete",
    "dxDataGrid-editingConfirmDeleteMessage": "Are you sure you want to delete this record?",
    "dxDataGrid-validationCancelChanges": "Cancel changes",
    "dxDataGrid-groupPanelEmptyText": "Drag a column header here to group by that column",
    "dxDataGrid-noDataText": "No data",
    "dxDataGrid-searchPanelPlaceholder": "Search...",
    "dxDataGrid-filterRowShowAllText": "(All)",
    "dxDataGrid-filterRowResetOperationText": "Reset",
    "dxDataGrid-filterRowOperationEquals": "Equals",
    "dxDataGrid-filterRowOperationNotEquals": "Does not equal",
    "dxDataGrid-filterRowOperationLess": "Less than",
    "dxDataGrid-filterRowOperationLessOrEquals": "Less than or equal to",
    "dxDataGrid-filterRowOperationGreater": "Greater than",
    "dxDataGrid-filterRowOperationGreaterOrEquals": "Greater than or equal to",
    "dxDataGrid-filterRowOperationStartsWith": "Starts with",
    "dxDataGrid-filterRowOperationContains": "Contains",
    "dxDataGrid-filterRowOperationNotContains": "Does not contain",
    "dxDataGrid-filterRowOperationEndsWith": "Ends with",
    "dxDataGrid-filterRowOperationBetween": "Between",
    "dxDataGrid-filterRowOperationBetweenStartText": "Start",
    "dxDataGrid-filterRowOperationBetweenEndText": "End",
    "dxDataGrid-ariaSearchBox": "Search box",
    "dxDataGrid-applyFilterText": "Apply filter",
    "dxDataGrid-trueText": "true",
    "dxDataGrid-falseText": "false",
    "dxDataGrid-sortingAscendingText": "Sort Ascending",
    "dxDataGrid-sortingDescendingText": "Sort Descending",
    "dxDataGrid-sortingClearText": "Clear Sorting",
    "dxDataGrid-ariaNotSortedColumn": "Not sorted column",
    "dxDataGrid-ariaSortedAscendingColumn": "Column sorted in ascending order",
    "dxDataGrid-ariaSortedDescendingColumn": "Column sorted in descending order",
    "dxDataGrid-ariaSortIndex": "Sort index {0}",
    "dxDataGrid-editingSaveAllChanges": "Save changes",
    "dxDataGrid-editingCancelAllChanges": "Discard changes",
    "dxDataGrid-editingAddRow": "Add a row",
    "dxDataGrid-summaryMin": "Min: {0}",
    "dxDataGrid-summaryMinOtherColumn": "Min of {1} is {0}",
    "dxDataGrid-summaryMax": "Max: {0}",
    "dxDataGrid-summaryMaxOtherColumn": "Max of {1} is {0}",
    "dxDataGrid-summaryAvg": "Avg: {0}",
    "dxDataGrid-summaryAvgOtherColumn": "Avg of {1} is {0}",
    "dxDataGrid-summarySum": "Sum: {0}",
    "dxDataGrid-summarySumOtherColumn": "Sum of {1} is {0}",
    "dxDataGrid-summaryCount": "Count: {0}",
    "dxDataGrid-columnFixingFix": "Set Fixed Position",
    "dxDataGrid-columnFixingUnfix": "Unfix",
    "dxDataGrid-columnFixingLeftPosition": "Left",
    "dxDataGrid-columnFixingRightPosition": "Right",
    "dxDataGrid-columnFixingStickyPosition": "Sticky",
    "dxDataGrid-exportTo": "Export",
    "dxDataGrid-exportToExcel": "Export to Excel file",
    "dxDataGrid-exporting": "Exporting...",
    "dxDataGrid-excelFormat": "Excel file",
    "dxDataGrid-selectedRows": "Selected rows",
    "dxDataGrid-exportSelectedRows": "Export selected rows to {0}",
    "dxDataGrid-exportAll": "Export all data to {0}",
    "dxDataGrid-headerFilterLabel": "Filter options",
    "dxDataGrid-headerFilterIndicatorLabel": "Show filter options for column '{0}'",
    "dxDataGrid-headerFilterEmptyValue": "(Blanks)",
    "dxDataGrid-headerFilterOK": "OK",
    "dxDataGrid-headerFilterCancel": "Cancel",
    "dxDataGrid-ariaAdaptiveCollapse": "Hide additional data",
    "dxDataGrid-ariaAdaptiveExpand": "Display additional data",
    "dxDataGrid-ariaColumn": "Column",
    "dxDataGrid-ariaColumnHeader": "Column header",
    "dxDataGrid-ariaValue": "Value",
    "dxDataGrid-ariaError": "Error",
    "dxDataGrid-ariaRevertButton": "Press Escape to discard the changes",
    "dxDataGrid-ariaFilterCell": "Filter cell",
    "dxDataGrid-ariaCollapse": "Collapse",
    "dxDataGrid-ariaModifiedCell": "Modified",
    "dxDataGrid-ariaDeletedCell": "Deleted",
    "dxDataGrid-ariaEditableCell": "Editable",
    "dxDataGrid-ariaExpand": "Expand",
    "dxDataGrid-ariaCollapsedRow": "Collapsed row",
    "dxDataGrid-ariaExpandedRow": "Expanded row",
    "dxDataGrid-ariaDataGrid": "Data grid with {0} rows and {1} columns",
    "dxDataGrid-ariaSearchInGrid": "Search in the data grid",
    "dxDataGrid-ariaSelectAll": "Select all",
    "dxDataGrid-ariaSelectRow": "Select row",
    "dxDataGrid-ariaToolbar": "Data grid toolbar",
    "dxDataGrid-ariaEditForm": "Edit form",
    "dxDataGrid-filterBuilderPopupTitle": "Filter Builder",
    "dxDataGrid-filterPanelCreateFilter": "Create Filter",
    "dxDataGrid-filterPanelClearFilter": "Clear",
    "dxDataGrid-filterPanelFilterEnabledHint": "Enable the filter",
    "dxDataGrid-masterDetail": "Cell with details",
    "dxTreeList-ariaTreeList": "Tree list with {0} rows and {1} columns",
    "dxTreeList-ariaExpandableInstruction": "Press Ctrl + right arrow to expand the focused node and Ctrl + left arrow to collapse it",
    "dxTreeList-ariaSearchInGrid": "Search in the tree list",
    "dxTreeList-ariaToolbar": "Tree list toolbar",
    "dxTreeList-editingAddRowToNode": "Add",
    "dxPager-infoText": "Page {0} of {1} ({2} items)",
    "dxPager-pagesCountText": "of",
    "dxPager-pageSize": "Items per page: {0}",
    "dxPager-pageSizesAllText": "All",
    "dxPager-page": "Page {0}",
    "dxPager-prevPage": "Previous page",
    "dxPager-nextPage": "Next page",
    "dxPager-ariaLabel": "Page navigation",
    "dxPager-ariaPageSize": "Page size",
    "dxPager-ariaPageNumber": "Page number",
    "dxPagination-infoText": "Page {0} of {1} ({2} items)",
    "dxPagination-pagesCountText": "of",
    "dxPagination-pageSize": "Items per page: {0}",
    "dxPagination-pageSizesAllText": "All",
    "dxPagination-page": "Page {0}",
    "dxPagination-prevPage": "Previous page",
    "dxPagination-nextPage": "Next page",
    "dxPagination-ariaLabel": "Page navigation",
    "dxPagination-ariaPageSize": "Page size",
    "dxPagination-ariaPageNumber": "Page number",
    "dxPivotGrid-grandTotal": "Grand Total",
    "dxPivotGrid-total": "{0} Total",
    "dxPivotGrid-fieldChooserTitle": "Field Chooser",
    "dxPivotGrid-showFieldChooser": "Show Field Chooser",
    "dxPivotGrid-expandAll": "Expand All",
    "dxPivotGrid-collapseAll": "Collapse All",
    "dxPivotGrid-sortColumnBySummary": 'Sort "{0}" by This Column',
    "dxPivotGrid-sortRowBySummary": 'Sort "{0}" by This Row',
    "dxPivotGrid-removeAllSorting": "Remove All Sorting",
    "dxPivotGrid-dataNotAvailable": "N/A",
    "dxPivotGrid-rowFields": "Row Fields",
    "dxPivotGrid-columnFields": "Column Fields",
    "dxPivotGrid-dataFields": "Data Fields",
    "dxPivotGrid-filterFields": "Filter Fields",
    "dxPivotGrid-allFields": "All Fields",
    "dxPivotGrid-columnFieldArea": "Drop Column Fields Here",
    "dxPivotGrid-dataFieldArea": "Drop Data Fields Here",
    "dxPivotGrid-rowFieldArea": "Drop Row Fields Here",
    "dxPivotGrid-filterFieldArea": "Drop Filter Fields Here",
    "dxScheduler-ariaLabel": "Scheduler. {0} view",
    "dxScheduler-appointmentAriaLabel-group": "Group: {0}",
    "dxScheduler-appointmentAriaLabel-recurring": "Recurring appointment",
    "dxScheduler-appointmentListAriaLabel": "Appointment list",
    "dxScheduler-editorLabelTitle": "Subject",
    "dxScheduler-editorLabelStartDate": "Start Date",
    "dxScheduler-editorLabelEndDate": "End Date",
    "dxScheduler-editorLabelDescription": "Description",
    "dxScheduler-editorLabelRecurrence": "Repeat",
    "dxScheduler-navigationPrevious": "Previous page",
    "dxScheduler-navigationNext": "Next page",
    "dxScheduler-openAppointment": "Open appointment",
    "dxScheduler-recurrenceNever": "Never",
    "dxScheduler-recurrenceMinutely": "Every minute",
    "dxScheduler-recurrenceHourly": "Hourly",
    "dxScheduler-recurrenceDaily": "Daily",
    "dxScheduler-recurrenceWeekly": "Weekly",
    "dxScheduler-recurrenceMonthly": "Monthly",
    "dxScheduler-recurrenceYearly": "Yearly",
    "dxScheduler-recurrenceRepeatEvery": "Repeat Every",
    "dxScheduler-recurrenceRepeatOn": "Repeat On",
    "dxScheduler-recurrenceEnd": "End repeat",
    "dxScheduler-recurrenceAfter": "After",
    "dxScheduler-recurrenceOn": "On",
    "dxScheduler-recurrenceRepeatMinutely": "minute(s)",
    "dxScheduler-recurrenceRepeatHourly": "hour(s)",
    "dxScheduler-recurrenceRepeatDaily": "day(s)",
    "dxScheduler-recurrenceRepeatWeekly": "week(s)",
    "dxScheduler-recurrenceRepeatMonthly": "month(s)",
    "dxScheduler-recurrenceRepeatYearly": "year(s)",
    "dxScheduler-switcherDay": "Day",
    "dxScheduler-switcherWeek": "Week",
    "dxScheduler-switcherWorkWeek": "Work Week",
    "dxScheduler-switcherMonth": "Month",
    "dxScheduler-switcherAgenda": "Agenda",
    "dxScheduler-switcherTimelineDay": "Timeline Day",
    "dxScheduler-switcherTimelineWeek": "Timeline Week",
    "dxScheduler-switcherTimelineWorkWeek": "Timeline Work Week",
    "dxScheduler-switcherTimelineMonth": "Timeline Month",
    "dxScheduler-recurrenceRepeatOnDate": "on date",
    "dxScheduler-recurrenceRepeatCount": "occurrence(s)",
    "dxScheduler-allDay": "All day",
    "dxScheduler-ariaEditForm": "Edit form",
    "dxScheduler-confirmRecurrenceEditTitle": "Edit Recurring Appointment",
    "dxScheduler-confirmRecurrenceDeleteTitle": "Delete Recurring Appointment",
    "dxScheduler-confirmRecurrenceEditMessage": "Do you want to edit only this appointment or the whole series?",
    "dxScheduler-confirmRecurrenceDeleteMessage": "Do you want to delete only this appointment or the whole series?",
    "dxScheduler-confirmRecurrenceEditSeries": "Edit series",
    "dxScheduler-confirmRecurrenceDeleteSeries": "Delete series",
    "dxScheduler-confirmRecurrenceEditOccurrence": "Edit appointment",
    "dxScheduler-confirmRecurrenceDeleteOccurrence": "Delete appointment",
    "dxScheduler-noTimezoneTitle": "No timezone",
    "dxScheduler-moreAppointments": "{0} more",
    "dxCalendar-currentDay": "Today",
    "dxCalendar-currentMonth": "Current month",
    "dxCalendar-currentYear": "Current year",
    "dxCalendar-currentYearRange": "Current year range",
    "dxCalendar-todayButtonText": "Today",
    "dxCalendar-ariaWidgetName": "Calendar",
    "dxCalendar-previousMonthButtonLabel": "Previous month",
    "dxCalendar-previousYearButtonLabel": "Previous year",
    "dxCalendar-previousDecadeButtonLabel": "Previous decade",
    "dxCalendar-previousCenturyButtonLabel": "Previous century",
    "dxCalendar-nextMonthButtonLabel": "Next month",
    "dxCalendar-nextYearButtonLabel": "Next year",
    "dxCalendar-nextDecadeButtonLabel": "Next decade",
    "dxCalendar-nextCenturyButtonLabel": "Next century",
    "dxCalendar-captionMonthLabel": "Month selection",
    "dxCalendar-captionYearLabel": "Year selection",
    "dxCalendar-captionDecadeLabel": "Decade selection",
    "dxCalendar-captionCenturyLabel": "Century selection",
    "dxCalendar-selectedDate": "The selected date is {0}",
    "dxCalendar-selectedDates": "The selected dates",
    "dxCalendar-selectedDateRange": "The selected date range is from {0} to {1}",
    "dxCalendar-selectedMultipleDateRange": "from {0} to {1}",
    "dxCalendar-selectedDateRangeCount": "There are {0} selected date ranges",
    "dxCalendar-readOnlyLabel": "Read-only calendar",
    "dxAvatar-defaultImageAlt": "Avatar",
    "dxChat-elementAriaLabel": "Chat",
    "dxChat-textareaPlaceholder": "Type a message",
    "dxChat-sendButtonAriaLabel": "Send",
    "dxChat-defaultUserName": "Unknown User",
    "dxChat-messageListAriaLabel": "Message list",
    "dxChat-alertListAriaLabel": "Error list",
    "dxChat-emptyListMessage": "There are no messages in this chat",
    "dxChat-emptyListPrompt": "Write your first message",
    "dxChat-typingMessageSingleUser": "{0} is typing...",
    "dxChat-typingMessageTwoUsers": "{0} and {1} are typing...",
    "dxChat-typingMessageThreeUsers": "{0}, {1} and {2} are typing...",
    "dxChat-typingMessageMultipleUsers": "{0} and others are typing...",
    "dxColorView-ariaRed": "Red",
    "dxColorView-ariaGreen": "Green",
    "dxColorView-ariaBlue": "Blue",
    "dxColorView-ariaAlpha": "Transparency",
    "dxColorView-ariaHex": "Color code",
    "dxTagBox-selected": "{0} selected",
    "dxTagBox-allSelected": "All selected ({0})",
    "dxTagBox-moreSelected": "{0} more",
    "dxTagBox-tagRoleDescription": "Tag. Press the delete button to remove this tag",
    "dxTagBox-ariaRoleDescription": "Tag box",
    "vizExport-printingButtonText": "Print",
    "vizExport-titleMenuText": "Exporting/Printing",
    "vizExport-exportButtonText": "{0} file",
    "dxFilterBuilder-and": "And",
    "dxFilterBuilder-or": "Or",
    "dxFilterBuilder-notAnd": "Not And",
    "dxFilterBuilder-notOr": "Not Or",
    "dxFilterBuilder-addCondition": "Add Condition",
    "dxFilterBuilder-addGroup": "Add Group",
    "dxFilterBuilder-enterValueText": "<enter a value>",
    "dxFilterBuilder-filterOperationEquals": "Equals",
    "dxFilterBuilder-filterOperationNotEquals": "Does not equal",
    "dxFilterBuilder-filterOperationLess": "Is less than",
    "dxFilterBuilder-filterOperationLessOrEquals": "Is less than or equal to",
    "dxFilterBuilder-filterOperationGreater": "Is greater than",
    "dxFilterBuilder-filterOperationGreaterOrEquals": "Is greater than or equal to",
    "dxFilterBuilder-filterOperationStartsWith": "Starts with",
    "dxFilterBuilder-filterOperationContains": "Contains",
    "dxFilterBuilder-filterOperationNotContains": "Does not contain",
    "dxFilterBuilder-filterOperationEndsWith": "Ends with",
    "dxFilterBuilder-filterOperationIsBlank": "Is blank",
    "dxFilterBuilder-filterOperationIsNotBlank": "Is not blank",
    "dxFilterBuilder-filterOperationBetween": "Is between",
    "dxFilterBuilder-filterOperationAnyOf": "Is any of",
    "dxFilterBuilder-filterOperationNoneOf": "Is none of",
    "dxFilterBuilder-filterAriaRootElement": "Filter builder",
    "dxFilterBuilder-filterAriaGroupLevel": "Level {0}",
    "dxFilterBuilder-filterAriaGroupItem": "Group item",
    "dxFilterBuilder-filterAriaOperationButton": "Operation",
    "dxFilterBuilder-filterAriaAddButton": "Add",
    "dxFilterBuilder-filterAriaRemoveButton": "Remove {0}",
    "dxFilterBuilder-filterAriaItemField": "Item field",
    "dxFilterBuilder-filterAriaItemOperation": "Item operation",
    "dxFilterBuilder-filterAriaItemValue": "Item value",
    "dxHtmlEditor-dialogColorCaption": "Change Font Color",
    "dxHtmlEditor-dialogBackgroundCaption": "Change Background Color",
    "dxHtmlEditor-dialogLinkCaption": "Add Link",
    "dxHtmlEditor-dialogLinkUrlField": "URL",
    "dxHtmlEditor-dialogLinkTextField": "Text",
    "dxHtmlEditor-dialogLinkTargetField": "Open link in new window",
    "dxHtmlEditor-dialogImageCaption": "Add Image",
    "dxHtmlEditor-dialogImageUrlField": "URL",
    "dxHtmlEditor-dialogImageAltField": "Alternate text",
    "dxHtmlEditor-dialogImageWidthField": "Width (px)",
    "dxHtmlEditor-dialogImageHeightField": "Height (px)",
    "dxHtmlEditor-dialogInsertTableRowsField": "Rows",
    "dxHtmlEditor-dialogInsertTableColumnsField": "Columns",
    "dxHtmlEditor-dialogInsertTableCaption": "Insert Table",
    "dxHtmlEditor-dialogUpdateImageCaption": "Update Image",
    "dxHtmlEditor-dialogImageUpdateButton": "Update",
    "dxHtmlEditor-dialogImageAddButton": "Add",
    "dxHtmlEditor-dialogImageSpecifyUrl": "From the Web",
    "dxHtmlEditor-dialogImageSelectFile": "From This Device",
    "dxHtmlEditor-dialogImageKeepAspectRatio": "Keep Aspect Ratio",
    "dxHtmlEditor-dialogImageEncodeToBase64": "Encode to Base64",
    "dxHtmlEditor-heading": "Heading",
    "dxHtmlEditor-normalText": "Normal text",
    "dxHtmlEditor-background": "Background Color",
    "dxHtmlEditor-bold": "Bold",
    "dxHtmlEditor-color": "Font Color",
    "dxHtmlEditor-font": "Font",
    "dxHtmlEditor-italic": "Italic",
    "dxHtmlEditor-link": "Add Link",
    "dxHtmlEditor-image": "Add Image",
    "dxHtmlEditor-size": "Size",
    "dxHtmlEditor-strike": "Strikethrough",
    "dxHtmlEditor-subscript": "Subscript",
    "dxHtmlEditor-superscript": "Superscript",
    "dxHtmlEditor-underline": "Underline",
    "dxHtmlEditor-blockquote": "Blockquote",
    "dxHtmlEditor-header": "Header",
    "dxHtmlEditor-increaseIndent": "Increase Indent",
    "dxHtmlEditor-decreaseIndent": "Decrease Indent",
    "dxHtmlEditor-orderedList": "Ordered List",
    "dxHtmlEditor-bulletList": "Bullet List",
    "dxHtmlEditor-alignLeft": "Align Left",
    "dxHtmlEditor-alignCenter": "Align Center",
    "dxHtmlEditor-alignRight": "Align Right",
    "dxHtmlEditor-alignJustify": "Align Justify",
    "dxHtmlEditor-codeBlock": "Code Block",
    "dxHtmlEditor-variable": "Add Variable",
    "dxHtmlEditor-undo": "Undo",
    "dxHtmlEditor-redo": "Redo",
    "dxHtmlEditor-clear": "Clear Formatting",
    "dxHtmlEditor-insertTable": "Insert Table",
    "dxHtmlEditor-insertHeaderRow": "Insert Header Row",
    "dxHtmlEditor-insertRowAbove": "Insert Row Above",
    "dxHtmlEditor-insertRowBelow": "Insert Row Below",
    "dxHtmlEditor-insertColumnLeft": "Insert Column Left",
    "dxHtmlEditor-insertColumnRight": "Insert Column Right",
    "dxHtmlEditor-deleteColumn": "Delete Column",
    "dxHtmlEditor-deleteRow": "Delete Row",
    "dxHtmlEditor-deleteTable": "Delete Table",
    "dxHtmlEditor-cellProperties": "Cell Properties",
    "dxHtmlEditor-tableProperties": "Table Properties",
    "dxHtmlEditor-insert": "Insert",
    "dxHtmlEditor-delete": "Delete",
    "dxHtmlEditor-border": "Border",
    "dxHtmlEditor-style": "Style",
    "dxHtmlEditor-width": "Width",
    "dxHtmlEditor-height": "Height",
    "dxHtmlEditor-borderColor": "Color",
    "dxHtmlEditor-borderWidth": "Border Width",
    "dxHtmlEditor-tableBackground": "Background",
    "dxHtmlEditor-dimensions": "Dimensions",
    "dxHtmlEditor-alignment": "Alignment",
    "dxHtmlEditor-horizontal": "Horizontal",
    "dxHtmlEditor-vertical": "Vertical",
    "dxHtmlEditor-paddingVertical": "Vertical Padding",
    "dxHtmlEditor-paddingHorizontal": "Horizontal Padding",
    "dxHtmlEditor-pixels": "Pixels",
    "dxHtmlEditor-list": "List",
    "dxHtmlEditor-ordered": "Ordered",
    "dxHtmlEditor-bullet": "Bullet",
    "dxHtmlEditor-align": "Align",
    "dxHtmlEditor-center": "Center",
    "dxHtmlEditor-left": "Left",
    "dxHtmlEditor-right": "Right",
    "dxHtmlEditor-indent": "Indent",
    "dxHtmlEditor-justify": "Justify",
    "dxHtmlEditor-borderStyleNone": "none",
    "dxHtmlEditor-borderStyleHidden": "hidden",
    "dxHtmlEditor-borderStyleDotted": "dotted",
    "dxHtmlEditor-borderStyleDashed": "dashed",
    "dxHtmlEditor-borderStyleSolid": "solid",
    "dxHtmlEditor-borderStyleDouble": "double",
    "dxHtmlEditor-borderStyleGroove": "groove",
    "dxHtmlEditor-borderStyleRidge": "ridge",
    "dxHtmlEditor-borderStyleInset": "inset",
    "dxHtmlEditor-borderStyleOutset": "outset",
    "dxFileManager-newDirectoryName": "Untitled directory",
    "dxFileManager-rootDirectoryName": "Files",
    "dxFileManager-errorNoAccess": "Access Denied. Operation could not be completed.",
    "dxFileManager-errorDirectoryExistsFormat": "Directory '{0}' already exists.",
    "dxFileManager-errorFileExistsFormat": "File '{0}' already exists.",
    "dxFileManager-errorFileNotFoundFormat": "File '{0}' not found.",
    "dxFileManager-errorDirectoryNotFoundFormat": "Directory '{0}' not found.",
    "dxFileManager-errorWrongFileExtension": "File extension is not allowed.",
    "dxFileManager-errorMaxFileSizeExceeded": "File size exceeds the maximum allowed size.",
    "dxFileManager-errorInvalidSymbols": "This name contains invalid characters.",
    "dxFileManager-errorDefault": "Unspecified error.",
    "dxFileManager-errorDirectoryOpenFailed": "The directory cannot be opened",
    "dxFileManager-commandCreate": "New directory",
    "dxFileManager-commandRename": "Rename",
    "dxFileManager-commandMove": "Move to",
    "dxFileManager-commandCopy": "Copy to",
    "dxFileManager-commandDelete": "Delete",
    "dxFileManager-commandDownload": "Download",
    "dxFileManager-commandUpload": "Upload files",
    "dxFileManager-commandRefresh": "Refresh",
    "dxFileManager-commandThumbnails": "Thumbnails View",
    "dxFileManager-commandDetails": "Details View",
    "dxFileManager-commandClearSelection": "Clear selection",
    "dxFileManager-commandShowNavPane": "Toggle navigation pane",
    "dxFileManager-dialogDirectoryChooserMoveTitle": "Move to",
    "dxFileManager-dialogDirectoryChooserMoveButtonText": "Move",
    "dxFileManager-dialogDirectoryChooserCopyTitle": "Copy to",
    "dxFileManager-dialogDirectoryChooserCopyButtonText": "Copy",
    "dxFileManager-dialogRenameItemTitle": "Rename",
    "dxFileManager-dialogRenameItemButtonText": "Save",
    "dxFileManager-dialogCreateDirectoryTitle": "New directory",
    "dxFileManager-dialogCreateDirectoryButtonText": "Create",
    "dxFileManager-dialogDeleteItemTitle": "Delete",
    "dxFileManager-dialogDeleteItemButtonText": "Delete",
    "dxFileManager-dialogDeleteItemSingleItemConfirmation": "Are you sure you want to delete {0}?",
    "dxFileManager-dialogDeleteItemMultipleItemsConfirmation": "Are you sure you want to delete {0} items?",
    "dxFileManager-dialogButtonCancel": "Cancel",
    "dxFileManager-editingCreateSingleItemProcessingMessage": "Creating a directory inside {0}",
    "dxFileManager-editingCreateSingleItemSuccessMessage": "Created a directory inside {0}",
    "dxFileManager-editingCreateSingleItemErrorMessage": "Directory was not created",
    "dxFileManager-editingCreateCommonErrorMessage": "Directory was not created",
    "dxFileManager-editingRenameSingleItemProcessingMessage": "Renaming an item inside {0}",
    "dxFileManager-editingRenameSingleItemSuccessMessage": "Renamed an item inside {0}",
    "dxFileManager-editingRenameSingleItemErrorMessage": "Item was not renamed",
    "dxFileManager-editingRenameCommonErrorMessage": "Item was not renamed",
    "dxFileManager-editingDeleteSingleItemProcessingMessage": "Deleting an item from {0}",
    "dxFileManager-editingDeleteMultipleItemsProcessingMessage": "Deleting {0} items from {1}",
    "dxFileManager-editingDeleteSingleItemSuccessMessage": "Deleted an item from {0}",
    "dxFileManager-editingDeleteMultipleItemsSuccessMessage": "Deleted {0} items from {1}",
    "dxFileManager-editingDeleteSingleItemErrorMessage": "Item was not deleted",
    "dxFileManager-editingDeleteMultipleItemsErrorMessage": "{0} items were not deleted",
    "dxFileManager-editingDeleteCommonErrorMessage": "Some items were not deleted",
    "dxFileManager-editingMoveSingleItemProcessingMessage": "Moving an item to {0}",
    "dxFileManager-editingMoveMultipleItemsProcessingMessage": "Moving {0} items to {1}",
    "dxFileManager-editingMoveSingleItemSuccessMessage": "Moved an item to {0}",
    "dxFileManager-editingMoveMultipleItemsSuccessMessage": "Moved {0} items to {1}",
    "dxFileManager-editingMoveSingleItemErrorMessage": "Item was not moved",
    "dxFileManager-editingMoveMultipleItemsErrorMessage": "{0} items were not moved",
    "dxFileManager-editingMoveCommonErrorMessage": "Some items were not moved",
    "dxFileManager-editingCopySingleItemProcessingMessage": "Copying an item to {0}",
    "dxFileManager-editingCopyMultipleItemsProcessingMessage": "Copying {0} items to {1}",
    "dxFileManager-editingCopySingleItemSuccessMessage": "Copied an item to {0}",
    "dxFileManager-editingCopyMultipleItemsSuccessMessage": "Copied {0} items to {1}",
    "dxFileManager-editingCopySingleItemErrorMessage": "Item was not copied",
    "dxFileManager-editingCopyMultipleItemsErrorMessage": "{0} items were not copied",
    "dxFileManager-editingCopyCommonErrorMessage": "Some items were not copied",
    "dxFileManager-editingUploadSingleItemProcessingMessage": "Uploading an item to {0}",
    "dxFileManager-editingUploadMultipleItemsProcessingMessage": "Uploading {0} items to {1}",
    "dxFileManager-editingUploadSingleItemSuccessMessage": "Uploaded an item to {0}",
    "dxFileManager-editingUploadMultipleItemsSuccessMessage": "Uploaded {0} items to {1}",
    "dxFileManager-editingUploadSingleItemErrorMessage": "Item was not uploaded",
    "dxFileManager-editingUploadMultipleItemsErrorMessage": "{0} items were not uploaded",
    "dxFileManager-editingUploadCanceledMessage": "Canceled",
    "dxFileManager-editingDownloadSingleItemErrorMessage": "Item was not downloaded",
    "dxFileManager-editingDownloadMultipleItemsErrorMessage": "{0} items were not downloaded",
    "dxFileManager-listDetailsColumnCaptionName": "Name",
    "dxFileManager-listDetailsColumnCaptionDateModified": "Date Modified",
    "dxFileManager-listDetailsColumnCaptionFileSize": "File Size",
    "dxFileManager-listThumbnailsTooltipTextSize": "Size",
    "dxFileManager-listThumbnailsTooltipTextDateModified": "Date Modified",
    "dxFileManager-notificationProgressPanelTitle": "Progress",
    "dxFileManager-notificationProgressPanelEmptyListText": "No operations",
    "dxFileManager-notificationProgressPanelOperationCanceled": "Canceled",
    "dxDiagram-categoryGeneral": "General",
    "dxDiagram-categoryFlowchart": "Flowchart",
    "dxDiagram-categoryOrgChart": "Org Chart",
    "dxDiagram-categoryContainers": "Containers",
    "dxDiagram-categoryCustom": "Custom",
    "dxDiagram-commandExportToSvg": "Export to SVG",
    "dxDiagram-commandExportToPng": "Export to PNG",
    "dxDiagram-commandExportToJpg": "Export to JPEG",
    "dxDiagram-commandUndo": "Undo",
    "dxDiagram-commandRedo": "Redo",
    "dxDiagram-commandFontName": "Font Name",
    "dxDiagram-commandFontSize": "Font Size",
    "dxDiagram-commandBold": "Bold",
    "dxDiagram-commandItalic": "Italic",
    "dxDiagram-commandUnderline": "Underline",
    "dxDiagram-commandTextColor": "Font Color",
    "dxDiagram-commandLineColor": "Line Color",
    "dxDiagram-commandLineWidth": "Line Width",
    "dxDiagram-commandLineStyle": "Line Style",
    "dxDiagram-commandLineStyleSolid": "Solid",
    "dxDiagram-commandLineStyleDotted": "Dotted",
    "dxDiagram-commandLineStyleDashed": "Dashed",
    "dxDiagram-commandFillColor": "Fill Color",
    "dxDiagram-commandAlignLeft": "Align Left",
    "dxDiagram-commandAlignCenter": "Align Center",
    "dxDiagram-commandAlignRight": "Align Right",
    "dxDiagram-commandConnectorLineType": "Connector Line Type",
    "dxDiagram-commandConnectorLineStraight": "Straight",
    "dxDiagram-commandConnectorLineOrthogonal": "Orthogonal",
    "dxDiagram-commandConnectorLineStart": "Connector Line Start",
    "dxDiagram-commandConnectorLineEnd": "Connector Line End",
    "dxDiagram-commandConnectorLineNone": "None",
    "dxDiagram-commandConnectorLineArrow": "Arrow",
    "dxDiagram-commandFullscreen": "Full Screen",
    "dxDiagram-commandUnits": "Units",
    "dxDiagram-commandPageSize": "Page Size",
    "dxDiagram-commandPageOrientation": "Page Orientation",
    "dxDiagram-commandPageOrientationLandscape": "Landscape",
    "dxDiagram-commandPageOrientationPortrait": "Portrait",
    "dxDiagram-commandPageColor": "Page Color",
    "dxDiagram-commandShowGrid": "Show Grid",
    "dxDiagram-commandSnapToGrid": "Snap to Grid",
    "dxDiagram-commandGridSize": "Grid Size",
    "dxDiagram-commandZoomLevel": "Zoom Level",
    "dxDiagram-commandAutoZoom": "Auto Zoom",
    "dxDiagram-commandFitToContent": "Fit to Content",
    "dxDiagram-commandFitToWidth": "Fit to Width",
    "dxDiagram-commandAutoZoomByContent": "Auto Zoom by Content",
    "dxDiagram-commandAutoZoomByWidth": "Auto Zoom by Width",
    "dxDiagram-commandSimpleView": "Simple View",
    "dxDiagram-commandCut": "Cut",
    "dxDiagram-commandCopy": "Copy",
    "dxDiagram-commandPaste": "Paste",
    "dxDiagram-commandSelectAll": "Select All",
    "dxDiagram-commandDelete": "Delete",
    "dxDiagram-commandBringToFront": "Bring to Front",
    "dxDiagram-commandSendToBack": "Send to Back",
    "dxDiagram-commandLock": "Lock",
    "dxDiagram-commandUnlock": "Unlock",
    "dxDiagram-commandInsertShapeImage": "Insert Image...",
    "dxDiagram-commandEditShapeImage": "Change Image...",
    "dxDiagram-commandDeleteShapeImage": "Delete Image",
    "dxDiagram-commandLayoutLeftToRight": "Left-to-right",
    "dxDiagram-commandLayoutRightToLeft": "Right-to-left",
    "dxDiagram-commandLayoutTopToBottom": "Top-to-bottom",
    "dxDiagram-commandLayoutBottomToTop": "Bottom-to-top",
    "dxDiagram-unitIn": "in",
    "dxDiagram-unitCm": "cm",
    "dxDiagram-unitPx": "px",
    "dxDiagram-dialogButtonOK": "OK",
    "dxDiagram-dialogButtonCancel": "Cancel",
    "dxDiagram-dialogInsertShapeImageTitle": "Insert Image",
    "dxDiagram-dialogEditShapeImageTitle": "Change Image",
    "dxDiagram-dialogEditShapeImageSelectButton": "Select image",
    "dxDiagram-dialogEditShapeImageLabelText": "or drop a file here",
    "dxDiagram-uiExport": "Export",
    "dxDiagram-uiProperties": "Properties",
    "dxDiagram-uiSettings": "Settings",
    "dxDiagram-uiShowToolbox": "Show Toolbox",
    "dxDiagram-uiSearch": "Search",
    "dxDiagram-uiStyle": "Style",
    "dxDiagram-uiLayout": "Layout",
    "dxDiagram-uiLayoutTree": "Tree",
    "dxDiagram-uiLayoutLayered": "Layered",
    "dxDiagram-uiDiagram": "Diagram",
    "dxDiagram-uiText": "Text",
    "dxDiagram-uiObject": "Object",
    "dxDiagram-uiConnector": "Connector",
    "dxDiagram-uiPage": "Page",
    "dxDiagram-shapeText": "Text",
    "dxDiagram-shapeRectangle": "Rectangle",
    "dxDiagram-shapeEllipse": "Ellipse",
    "dxDiagram-shapeCross": "Cross",
    "dxDiagram-shapeTriangle": "Triangle",
    "dxDiagram-shapeDiamond": "Diamond",
    "dxDiagram-shapeHeart": "Heart",
    "dxDiagram-shapePentagon": "Pentagon",
    "dxDiagram-shapeHexagon": "Hexagon",
    "dxDiagram-shapeOctagon": "Octagon",
    "dxDiagram-shapeStar": "Star",
    "dxDiagram-shapeArrowLeft": "Left Arrow",
    "dxDiagram-shapeArrowUp": "Up Arrow",
    "dxDiagram-shapeArrowRight": "Right Arrow",
    "dxDiagram-shapeArrowDown": "Down Arrow",
    "dxDiagram-shapeArrowUpDown": "Up Down Arrow",
    "dxDiagram-shapeArrowLeftRight": "Left Right Arrow",
    "dxDiagram-shapeProcess": "Process",
    "dxDiagram-shapeDecision": "Decision",
    "dxDiagram-shapeTerminator": "Terminator",
    "dxDiagram-shapePredefinedProcess": "Predefined Process",
    "dxDiagram-shapeDocument": "Document",
    "dxDiagram-shapeMultipleDocuments": "Multiple Documents",
    "dxDiagram-shapeManualInput": "Manual Input",
    "dxDiagram-shapePreparation": "Preparation",
    "dxDiagram-shapeData": "Data",
    "dxDiagram-shapeDatabase": "Database",
    "dxDiagram-shapeHardDisk": "Hard Disk",
    "dxDiagram-shapeInternalStorage": "Internal Storage",
    "dxDiagram-shapePaperTape": "Paper Tape",
    "dxDiagram-shapeManualOperation": "Manual Operation",
    "dxDiagram-shapeDelay": "Delay",
    "dxDiagram-shapeStoredData": "Stored Data",
    "dxDiagram-shapeDisplay": "Display",
    "dxDiagram-shapeMerge": "Merge",
    "dxDiagram-shapeConnector": "Connector",
    "dxDiagram-shapeOr": "Or",
    "dxDiagram-shapeSummingJunction": "Summing Junction",
    "dxDiagram-shapeContainerDefaultText": "Container",
    "dxDiagram-shapeVerticalContainer": "Vertical Container",
    "dxDiagram-shapeHorizontalContainer": "Horizontal Container",
    "dxDiagram-shapeCardDefaultText": "Person's Name",
    "dxDiagram-shapeCardWithImageOnLeft": "Card with Image on the Left",
    "dxDiagram-shapeCardWithImageOnTop": "Card with Image on the Top",
    "dxDiagram-shapeCardWithImageOnRight": "Card with Image on the Right",
    "dxGantt-dialogTitle": "Title",
    "dxGantt-dialogStartTitle": "Start",
    "dxGantt-dialogEndTitle": "End",
    "dxGantt-dialogProgressTitle": "Progress",
    "dxGantt-dialogResourcesTitle": "Resources",
    "dxGantt-dialogResourceManagerTitle": "Resource Manager",
    "dxGantt-dialogTaskDetailsTitle": "Task Details",
    "dxGantt-dialogEditResourceListHint": "Edit Resource List",
    "dxGantt-dialogEditNoResources": "No resources",
    "dxGantt-dialogButtonAdd": "Add",
    "dxGantt-contextMenuNewTask": "New Task",
    "dxGantt-contextMenuNewSubtask": "New Subtask",
    "dxGantt-contextMenuDeleteTask": "Delete Task",
    "dxGantt-contextMenuDeleteDependency": "Delete Dependency",
    "dxGantt-dialogTaskDeleteConfirmation": "Deleting a task also deletes all its dependencies and subtasks. Are you sure you want to delete this task?",
    "dxGantt-dialogDependencyDeleteConfirmation": "Are you sure you want to delete the dependency from the task?",
    "dxGantt-dialogResourcesDeleteConfirmation": "Deleting a resource also deletes it from tasks to which this resource is assigned. Are you sure you want to delete these resources? Resources: {0}",
    "dxGantt-dialogConstraintCriticalViolationMessage": "The task you are attempting to move is linked to a second task by a dependency relation. This change would conflict with dependency rules. How would you like to proceed?",
    "dxGantt-dialogConstraintViolationMessage": "The task you are attempting to move is linked to a second task by a dependency relation. How would you like to proceed?",
    "dxGantt-dialogCancelOperationMessage": "Cancel the operation",
    "dxGantt-dialogDeleteDependencyMessage": "Delete the dependency",
    "dxGantt-dialogMoveTaskAndKeepDependencyMessage": "Move the task and keep the dependency",
    "dxGantt-dialogConstraintCriticalViolationSeveralTasksMessage": "The task you are attempting to move is linked to another tasks by dependency relations. This change would conflict with dependency rules. How would you like to proceed?",
    "dxGantt-dialogConstraintViolationSeveralTasksMessage": "The task you are attempting to move is linked to another tasks by dependency relations. How would you like to proceed?",
    "dxGantt-dialogDeleteDependenciesMessage": "Delete the dependency relations",
    "dxGantt-dialogMoveTaskAndKeepDependenciesMessage": "Move the task and keep the dependencies",
    "dxGantt-undo": "Undo",
    "dxGantt-redo": "Redo",
    "dxGantt-expandAll": "Expand All",
    "dxGantt-collapseAll": "Collapse All",
    "dxGantt-addNewTask": "Add New Task",
    "dxGantt-deleteSelectedTask": "Delete Selected Task",
    "dxGantt-zoomIn": "Zoom In",
    "dxGantt-zoomOut": "Zoom Out",
    "dxGantt-fullScreen": "Full Screen",
    "dxGantt-quarter": "Q{0}",
    "dxGantt-sortingAscendingText": "Sort Ascending",
    "dxGantt-sortingDescendingText": "Sort Descending",
    "dxGantt-sortingClearText": "Clear Sorting",
    "dxGantt-showResources": "Show Resources",
    "dxGantt-showDependencies": "Show Dependencies",
    "dxGantt-dialogStartDateValidation": "Start date must be after {0}",
    "dxGantt-dialogEndDateValidation": "End date must be after {0}",
    "dxGallery-itemName": "Gallery item",
    "dxMultiView-elementAriaRoleDescription": "MultiView",
    "dxMultiView-elementAriaLabel": "Use the arrow keys or swipe to navigate between views",
    "dxMultiView-itemAriaRoleDescription": "View",
    "dxMultiView-itemAriaLabel": "{0} of {1}",
    "dxSplitter-resizeHandleAriaLabel": "Split bar",
    "dxSplitter-resizeHandleAriaRoleDescription": "Separator"
  }
}, cW = x(!0, {}, uW), hW = (i, e) => {
  var t;
  return i[e] || e?.toLowerCase && ((t = Object.entries(i).find((n) => {
    let [s] = n;
    return s.toLowerCase() === e.toLowerCase();
  })) === null || t === void 0 ? void 0 : t[1]) || {};
}, ep = {}, S = qn({
  engine: function() {
    return "base";
  },
  _dictionary: cW,
  load: function(i) {
    x(!0, this._dictionary, i);
  },
  _localizablePrefix: "@",
  setup: function(i) {
    this._localizablePrefix = i;
  },
  localizeString: function(i) {
    const e = this, t = new RegExp("(^|[^a-zA-Z_0-9" + e._localizablePrefix + "-]+)(" + e._localizablePrefix + "{1,2})([a-zA-Z_0-9-]+)", "g"), n = e._localizablePrefix + e._localizablePrefix;
    return i.replace(t, (s, o, r, a) => {
      const l = e._localizablePrefix + a;
      let d;
      return r !== n && (d = e.format(a)), d || (ep[a] = XE(a)), o + (d || l);
    });
  },
  getMessagesByLocales: function() {
    return this._dictionary;
  },
  getDictionary: function(i) {
    return i ? ep : x({}, ep, this.getMessagesByLocales()[Kn.locale()]);
  },
  getFormatter: function(i) {
    return this._getFormatterBase(i) || this._getFormatterBase(i, "en");
  },
  _getFormatterBase: function(i, e) {
    const t = Kn.getValueByClosestLocale((n) => hW(this._dictionary, n)[i]);
    if (t)
      return function() {
        const n = arguments.length === 1 && Array.isArray(arguments[0]) ? arguments[0].slice(0) : Array.prototype.slice.call(arguments, 0);
        return n.unshift(t), Fi.apply(this, n);
      };
  },
  format: function(i) {
    const e = this.getFormatter(i), t = Array.prototype.slice.call(arguments, 1);
    return e && e.apply(this, t) || "";
  }
});
class nr {
  constructor(e) {
    let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    this._events = {}, this._owner = e, this._options = t;
  }
  static create(e, t) {
    return t ? B(t) ? t(e) : t : new nr(e);
  }
  hasEvent(e) {
    const t = this._events[e];
    return t ? t.has() : !1;
  }
  fireEvent(e, t) {
    const n = this._events[e];
    return n && n.fireWith(this._owner, t), this._owner;
  }
  on(e, t) {
    if (pe(e))
      y(e, (n, s) => {
        this.on(n, s);
      });
    else {
      let n = this._events[e];
      n || (n = Ie({
        syncStrategy: this._options.syncStrategy
      }), this._events[e] = n), (n.originalAdd || n.add).call(n, t);
    }
  }
  off(e, t) {
    const n = this._events[e];
    n && (B(t) ? n.remove(t) : n.empty());
  }
  dispose() {
    y(this._events, (e, t) => {
      t.empty();
    });
  }
}
let tp = [];
const pW = _s(() => {
  const i = O.listen(O.getDocument(), "DOMContentLoaded", () => {
    HI.fire(), i();
  });
}), HI = {
  add: (i) => {
    const e = ae();
    e && O.getReadyState() !== "loading" ? i() : (tp.push(i), e && pW());
  },
  fire: () => {
    tp.forEach((i) => i()), tp = [];
  }
}, Bi = qn(HI), qo = function() {
  let i;
  const e = Ie(), t = e.add, n = e.remove;
  if (!$t.hasWindow())
    return e;
  const s = function() {
    const l = $t.getWindow();
    return {
      width: l.innerWidth,
      height: l.innerHeight
    };
  }, o = function() {
    const l = s();
    if (l.width === i.width && l.height === i.height)
      return;
    let d;
    l.width === i.width && (d = "height"), l.height === i.height && (d = "width"), i = l, e.fire(d);
  }, r = _s(function() {
    i = s();
  });
  let a;
  return e.add = function() {
    const l = t.apply(e, arguments);
    return r(), Bi.add(function() {
      !a && e.has() && (a = O.listen($t.getWindow(), "resize", o));
    }), l;
  }, e.remove = function() {
    const l = n.apply(e, arguments);
    return !e.has() && a && (a(), a = void 0), l;
  }, e;
}(), gW = fe(), WI = function() {
  let i;
  try {
    i = gW.sessionStorage;
  } catch {
  }
  return i;
}, mW = Bi.add, eh = Ie();
let zI = p();
const Ys = function() {
  let i;
  return function(e) {
    if (!arguments.length)
      return i;
    const t = p(e);
    zI = t;
    const n = !!t.length, s = Ys();
    i = n ? t : p("body"), eh.fire(n ? Ys() : p(), s);
  };
}();
mW(function() {
  Ys(".dx-viewport");
});
function KI() {
  return zI;
}
const GI = fe(), fW = {
  iPhone: "iPhone",
  iPhone5: "iPhone",
  iPhone6: "iPhone",
  iPhone6plus: "iPhone",
  iPad: "iPad",
  iPadMini: "iPad Mini",
  androidPhone: "Android Mobile",
  androidTablet: "Android",
  msSurface: "Windows ARM Tablet PC",
  desktop: "desktop"
}, Ax = {
  deviceType: "desktop",
  platform: "generic",
  version: [],
  phone: !1,
  tablet: !1,
  android: !1,
  ios: !1,
  generic: !0,
  grade: "A",
  mac: !1
}, np = {
  generic(i) {
    const e = /windows phone/i.test(i) || i.match(/WPDesktop/), t = !e && /Windows(.*)arm(.*)Tablet PC/i.test(i), n = !e && !t && /msapphost/i.test(i), s = /((intel|ppc) mac os x)/.test(i.toLowerCase());
    return e || t || n || s ? {
      deviceType: e ? "phone" : t ? "tablet" : "desktop",
      platform: "generic",
      version: [],
      grade: "A",
      mac: s
    } : null;
  },
  appleTouchDevice(i) {
    const e = ua(), t = /Macintosh/i.test(i) && e?.maxTouchPoints > 2;
    if (!/ip(hone|od|ad)/i.test(i) && !t)
      return null;
    const s = /ip(hone|od)/i.test(i), o = i.match(/os\s{0,}X? (\d+)_(\d+)_?(\d+)?/i), r = o ? [parseInt(o[1], 10), parseInt(o[2], 10), parseInt(o[3] || 0, 10)] : [], l = GI.screen.height === 480 ? "B" : "A";
    return {
      deviceType: s ? "phone" : "tablet",
      platform: "ios",
      version: r,
      grade: l
    };
  },
  android(i) {
    const e = /android|htc_|silk/i.test(i), t = /windows phone/i.test(i);
    if (!e || t)
      return null;
    const n = /mobile/i.test(i), s = i.match(/android (\d+)\.?(\d+)?\.?(\d+)?/i), o = s ? [parseInt(s[1], 10), parseInt(s[2] || 0, 10), parseInt(s[3] || 0, 10)] : [], a = o.length > 1 && (o[0] < 4 || o[0] === 4 && o[1] < 4) ? "B" : "A";
    return {
      deviceType: n ? "phone" : "tablet",
      platform: "android",
      version: o,
      grade: a
    };
  }
}, Rx = [np.appleTouchDevice, np.android, np.generic];
class _W {
  constructor(e) {
    this._window = e?.window ?? GI, this._realDevice = this._getDevice(), this._currentDevice = void 0, this._currentOrientation = void 0, this._eventsStrategy = new nr(this), this.changed = Ie(), ae() && (Bi.add(this._recalculateOrientation.bind(this)), qo.add(this._recalculateOrientation.bind(this)));
  }
  current(e) {
    if (e) {
      this._currentDevice = this._getDevice(e), this._forced = !0, this.changed.fire();
      return;
    }
    if (!this._currentDevice) {
      e = void 0;
      try {
        e = this._getDeviceOrNameFromWindowScope();
      } catch {
        e = this._getDeviceNameFromSessionStorage();
      } finally {
        e || (e = this._getDeviceNameFromSessionStorage()), e && (this._forced = !0);
      }
      this._currentDevice = this._getDevice(e);
    }
    return this._currentDevice;
  }
  real(e) {
    return x({}, this._realDevice);
  }
  orientation() {
    return this._currentOrientation;
  }
  isForced() {
    return this._forced;
  }
  isRippleEmulator() {
    return !!this._window.tinyHippos;
  }
  _getCssClasses(e) {
    const t = [], n = this._realDevice;
    return e = e || this.current(), e.deviceType && (t.push(`dx-device-${e.deviceType}`), e.deviceType !== "desktop" && t.push("dx-device-mobile")), t.push(`dx-device-${n.platform}`), n.version && n.version.length && t.push(`dx-device-${n.platform}-${n.version[0]}`), this.isSimulator() && t.push("dx-simulator"), Pe().rtlEnabled && t.push("dx-rtl"), t;
  }
  attachCssClasses(e, t) {
    this._deviceClasses = this._getCssClasses(t).join(" "), p(e).addClass(this._deviceClasses);
  }
  detachCssClasses(e) {
    p(e).removeClass(this._deviceClasses);
  }
  isSimulator() {
    try {
      var e;
      return this._isSimulator || ae() && this._window.top !== this._window.self && ((e = this._window.top) === null || e === void 0 ? void 0 : e["dx-force-device"]) || this.isRippleEmulator();
    } catch {
      return !1;
    }
  }
  forceSimulator() {
    this._isSimulator = !0;
  }
  _getDevice(e) {
    if (e === "genericPhone" && (e = {
      deviceType: "phone",
      platform: "generic",
      generic: !0
    }), pe(e))
      return this._fromConfig(e);
    let t;
    if (e) {
      if (t = fW[e], !t)
        throw Ae.Error("E0005");
    } else
      t = ua().userAgent;
    return this._fromUA(t);
  }
  _getDeviceOrNameFromWindowScope() {
    var e, t;
    let n;
    if (ae() && ((e = this._window.top) !== null && e !== void 0 && e["dx-force-device-object"] || (t = this._window.top) !== null && t !== void 0 && t["dx-force-device"])) {
      var s, o;
      n = ((s = this._window.top) === null || s === void 0 ? void 0 : s["dx-force-device-object"]) || ((o = this._window.top) === null || o === void 0 ? void 0 : o["dx-force-device"]);
    }
    return n;
  }
  _getDeviceNameFromSessionStorage() {
    const e = WI();
    if (!e)
      return;
    const t = e.getItem("dx-force-device");
    try {
      return JSON.parse(t);
    } catch {
      return t;
    }
  }
  _fromConfig(e) {
    const t = x({}, Ax, this._currentDevice, e), n = {
      phone: t.deviceType === "phone",
      tablet: t.deviceType === "tablet",
      android: t.platform === "android",
      ios: t.platform === "ios",
      generic: t.platform === "generic"
    };
    return x(t, n);
  }
  _fromUA(e) {
    for (let t = 0; t < Rx.length; t += 1) {
      const n = Rx[t], s = n(e);
      if (s)
        return this._fromConfig(s);
    }
    return Ax;
  }
  _changeOrientation() {
    const e = p(this._window), t = le(e) > ne(e) ? "portrait" : "landscape";
    this._currentOrientation !== t && (this._currentOrientation = t, this._eventsStrategy.fireEvent("orientationChanged", [{
      orientation: t
    }]));
  }
  _recalculateOrientation() {
    const e = ne(this._window);
    this._currentWidth !== e && (this._currentWidth = e, this._changeOrientation());
  }
  on(e, t) {
    return this._eventsStrategy.on(e, t), this;
  }
  off(e, t) {
    return this._eventsStrategy.off(e, t), this;
  }
}
const z = new _W();
W(Gc).done(() => {
  const i = Ys();
  i && z.attachCssClasses(i), eh.add((e, t) => {
    z.detachCssClasses(t), z.attachCssClasses(e);
  });
});
const Fx = function() {
  let i = [];
  return {
    add: function(e) {
      i.includes(e) || i.push(e);
    },
    remove: function(e) {
      const t = i.indexOf(e);
      t !== -1 && i.splice(t, 1);
    },
    fire: function() {
      const e = i.pop(), t = !!e;
      return t && e(), t;
    },
    hasCallback: function() {
      return i.length > 0;
    }
  };
}(), {
  maxTouchPoints: UI
} = ua(), CW = {
  webkitTransition: "webkitTransitionEnd",
  MozTransition: "transitionend",
  OTransition: "oTransitionEnd",
  transition: "transitionend"
}, c_ = function(i) {
  return !!tr(i);
}, vW = function() {
  const {
    platform: i,
    mac: e
  } = z.real();
  return i === "ios" || i === "android" || e;
}, th = function(i) {
  if (i === "text")
    return !0;
  const e = O.createElement("input");
  try {
    return e.setAttribute("type", i), e.value = "wrongValue", !e.value;
  } catch {
    return !1;
  }
}, xW = function(i, e) {
  return (i("ontouchstart") || !!e) && !i("callPhantom");
}, yW = function(i) {
  return i("PointerEvent");
}, jI = xW(zf, UI), qI = yW(zf), bW = !!UI, om = jI || qI && bW, wW = _s(function() {
  return c_("transition");
}), SW = _s(function() {
  return CW[tr("transition")];
}), EW = _s(function() {
  return c_("animation");
}), IW = vW(), tn = {
  animation: EW,
  inputType: th,
  nativeScrolling: IW,
  pointerEvents: qI,
  styleProp: tr,
  stylePropPrefix: wu,
  supportProp: c_,
  touch: om,
  touchEvents: jI,
  transition: wW,
  transitionEndEventName: SW
}, DW = ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"], TW = ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"], OW = ["AM", "PM"], AW = ["Q1", "Q2", "Q3", "Q4"], kx = (i, e) => {
  const t = {
    abbreviated: 3,
    short: 2,
    narrow: 1
  };
  return mt(i, (n) => n.substr(0, t[e]));
}, Mr = {
  getMonthNames: function(i) {
    return kx(DW, i);
  },
  getDayNames: function(i) {
    return kx(TW, i);
  },
  getQuarterNames: function(i) {
    return AW;
  },
  getPeriodNames: function(i) {
    return OW;
  }
};
function Fn(i, e) {
  for (; i.length < e; )
    i = "0" + i;
  return i;
}
const Da = {
  3: "abbreviated",
  4: "wide",
  5: "narrow"
}, rm = {
  y: function(i, e, t) {
    let n = i[t ? "getUTCFullYear" : "getFullYear"]();
    return e === 2 && (n %= 100), Fn(n.toString(), e);
  },
  M: function(i, e, t, n) {
    const s = i[t ? "getUTCMonth" : "getMonth"](), o = Da[e];
    return o ? n.getMonthNames(o, "format")[s] : Fn((s + 1).toString(), Math.min(e, 2));
  },
  L: function(i, e, t, n) {
    const s = i[t ? "getUTCMonth" : "getMonth"](), o = Da[e];
    return o ? n.getMonthNames(o, "standalone")[s] : Fn((s + 1).toString(), Math.min(e, 2));
  },
  Q: function(i, e, t, n) {
    const s = i[t ? "getUTCMonth" : "getMonth"](), o = Math.floor(s / 3), r = Da[e];
    return r ? n.getQuarterNames(r)[o] : Fn((o + 1).toString(), Math.min(e, 2));
  },
  E: function(i, e, t, n) {
    const s = i[t ? "getUTCDay" : "getDay"](), o = Da[e < 3 ? 3 : e];
    return n.getDayNames(o)[s];
  },
  a: function(i, e, t, n) {
    const o = i[t ? "getUTCHours" : "getHours"]() < 12 ? 0 : 1, r = Da[e];
    return n.getPeriodNames(r)[o];
  },
  d: function(i, e, t) {
    return Fn(i[t ? "getUTCDate" : "getDate"]().toString(), Math.min(e, 2));
  },
  H: function(i, e, t) {
    return Fn(i[t ? "getUTCHours" : "getHours"]().toString(), Math.min(e, 2));
  },
  h: function(i, e, t) {
    const n = i[t ? "getUTCHours" : "getHours"]();
    return Fn((n % 12 || 12).toString(), Math.min(e, 2));
  },
  m: function(i, e, t) {
    return Fn(i[t ? "getUTCMinutes" : "getMinutes"]().toString(), Math.min(e, 2));
  },
  s: function(i, e, t) {
    return Fn(i[t ? "getUTCSeconds" : "getSeconds"]().toString(), Math.min(e, 2));
  },
  S: function(i, e, t) {
    return Fn(i[t ? "getUTCMilliseconds" : "getMilliseconds"]().toString(), 3).substr(0, e);
  },
  x: function(i, e, t) {
    const n = t ? 0 : i.getTimezoneOffset(), s = n > 0 ? "-" : "+", o = Math.abs(n), r = Math.floor(o / 60), a = o % 60, l = Fn(r.toString(), 2), d = Fn(a.toString(), 2);
    return s + l + (e >= 3 ? ":" : "") + (e > 1 || a ? d : "");
  },
  X: function(i, e, t) {
    return t || !i.getTimezoneOffset() ? "Z" : rm.x(i, e, t);
  },
  Z: function(i, e, t) {
    return rm.X(i, e >= 5 ? 3 : 2, t);
  }
}, YI = function(i, e) {
  return function(t) {
    let n, s, o, r = 0, a = !1, l, d = "";
    if (!t)
      return null;
    if (!i)
      return t;
    const u = i[i.length - 1] === "Z" || i.slice(-3) === "'Z'";
    for (n = 0; n < i.length; n++)
      o = i[n], s = rm[o], l = o === i[n + 1], r++, l || (s && !a && (d += s(t, r, u, e)), r = 0), o === "'" && !l ? a = !a : (a || !s) && (d += o), o === "'" && l && n++;
    return d;
  };
}, XI = /^(\d{4,})(-)?(\d{2})(-)?(\d{2})(?:T(\d{2})(:)?(\d{2})?(:)?(\d{2}(?:\.(\d{1,3})\d*)?)?)?(Z|([+-])(\d{2})(:)?(\d{2})?)?$/, ZI = /^(\d{2}):(\d{2})(:(\d{2}))?$/, Vx = ["", "yyyy", "", "MM", "", "dd", "THH", "", "mm", "", "ss", ".SSS"], RW = /^(\d{4})\/(\d{2})\/(\d{2})$/, QI = function(i, e) {
  let t;
  return te(i) && !e && (t = kW(i)), t || FW(i);
};
function jt(i) {
  return +i || 0;
}
function FW(i) {
  const e = JI(i) === "yyyy/MM/dd", t = !cn(i) && Date.parse(i);
  if (!t && e) {
    const n = i.match(RW);
    if (n) {
      const s = new Date(jt(n[1]), jt(n[2]), jt(n[3]));
      return s.setFullYear(jt(n[1])), s.setMonth(jt(n[2]) - 1), s.setDate(jt(n[3])), s;
    }
  }
  return $e(t) ? new Date(t) : i;
}
function kW(i) {
  let e = i.match(XI);
  if (!e)
    return e = i.match(ZI), e ? new Date(0, 0, 0, jt(e[1]), jt(e[2]), jt(e[4])) : void 0;
  const t = jt(e[1]), n = --e[3], s = e[5];
  let o = 0, r = 0;
  const a = (h) => (t < 100 && h.setFullYear(t), h);
  o = jt(e[14]), r = jt(e[16]), e[13] === "-" && (o = -o, r = -r);
  const l = jt(e[6]) - o, d = jt(e[8]) - r, u = jt(e[10]), c = function(h) {
    return h = h || "", jt(h) * 10 ** (3 - h.length);
  }(e[11]);
  return e[12] ? a(new Date(Date.UTC(t, n, s, l, d, u, c))) : a(new Date(t, n, s, l, d, u, c));
}
const VW = function(i, e) {
  let t = i.match(XI), n = "";
  if (!t)
    return t = i.match(ZI), t ? t[3] ? "HH:mm:ss" : "HH:mm" : void 0;
  for (let s = 1; s < Vx.length; s++)
    t[s] && (n += Vx[s] || t[s]);
  return t[12] === "Z" && (n += "'Z'"), t[14] && (t[15] ? n += "xxx" : t[16] ? n += "xx" : n += "x"), n;
}, PW = function(i) {
  return typeof i == "number" ? new Date(i) : QI(i, !Pe().forceIsoDateParsing);
}, MW = function(i, e) {
  return e ? cn(i) ? e === "number" ? i && i.valueOf ? i.valueOf() : null : YI(e, Mr)(i) : null : i;
}, JI = function(i) {
  if (typeof i == "number")
    return "number";
  if (te(i)) {
    let e;
    return Pe().forceIsoDateParsing && (e = VW(i)), e || (i.includes(":") ? "yyyy/MM/dd HH:mm:ss" : "yyyy/MM/dd");
  }
  if (i)
    return null;
}, pt = {
  dateParser: QI,
  deserializeDate: PW,
  serializeDate: MW,
  getDateSerializationFormat: JI
}, na = function(i) {
  return i === 0 ? 0 : i / Math.abs(i);
}, Lt = function(i, e, t) {
  const n = !e && e !== 0, s = !t && t !== 0;
  return n && (e = s ? i : Math.min(i, t)), s && (t = n ? i : Math.max(i, e)), Math.min(Math.max(i, e), t);
}, ss = function(i, e, t) {
  return i >= e && i <= t;
};
function Px(i) {
  return Math.abs(parseInt(i.toExponential().split("e")[1], 10));
}
function BW(i) {
  const e = i.toExponential().split("e"), t = parseFloat(e[0]);
  return {
    exponent: parseInt(e[1], 10),
    mantissa: t
  };
}
function eD(i, e) {
  const t = BW(i);
  return parseFloat(`${t.mantissa}e${t.exponent + e}`);
}
function $W() {
  return 3e-4.toPrecision(3) !== "0.000300";
}
function tD(i, e) {
  let t = NW(e || 0) + 2;
  const n = i.toString().split("."), s = i, o = Math.abs(i);
  let r;
  const a = Mg(i), l = o > 1 ? 10 : 0;
  return n.length === 1 ? i : (a || (Mg(e) && (t = n[0].length + Px(e)), i = o, i = i - Math.floor(i) + l), t = $W() && Px(i) > 6 || t > 7 ? 15 : 7, !a && (r = parseFloat(i.toPrecision(t)).toString().split("."), r[0] === l.toString()) ? parseFloat(`${n[0]}.${r[1]}`) : parseFloat(s.toPrecision(t)));
}
function NW(i) {
  const e = i.toString();
  if (e.indexOf(".") < 0)
    return 0;
  const t = e.split("."), n = t[1].indexOf("e");
  return n >= 0 ? n : t[1].length;
}
const LW = {
  millisecond: 1,
  second: 1e3,
  minute: 6e4,
  hour: 36e5,
  day: 864e5,
  week: 6048e5,
  month: 2592e6,
  quarter: 7776e6,
  year: 31536e6
};
function Ql(i) {
  return LW[i];
}
const qa = ["millisecond", "second", "minute", "hour", "day", "week", "month", "quarter", "year"], HW = function(i, e, t) {
  const n = e.getTime() - i.getTime(), s = Ql(t) || 1;
  return Math.floor(n / s);
}, WW = function(i, e) {
  switch (nh(i)) {
    case "millisecond":
      return "second";
    case "second":
      return "minute";
    case "minute":
      return "hour";
    case "hour":
      return "day";
    case "day":
      return e ? "week" : "month";
    case "week":
      return "month";
    case "month":
      return "quarter";
    case "quarter":
    case "year":
      return "year";
    default:
      return 0;
  }
}, nD = function(i) {
  let e, t, n;
  const s = ["millisecond", "second", "minute", "hour", "day", "month", "year"], o = {};
  for (e = s.length - 1; e >= 0; e--)
    n = s[e], t = Math.floor(i / Ql(n)), t > 0 && (o[`${n}s`] = t, i -= oc(n, t));
  return o;
}, zW = function(i) {
  let e = 0;
  return X(i) && y(i, function(t, n) {
    e += oc(t.substr(0, t.length - 1), n);
  }), te(i) && (e = oc(i, 1)), e;
};
function oc(i, e) {
  return Ql(i) * e;
}
function nh(i) {
  let e = -1, t;
  return te(i) ? i : X(i) ? (y(i, function(n, s) {
    for (t = 0; t < qa.length; t++)
      s && (n === `${qa[t]}s` || n === qa[t]) && e < t && (e = t);
  }), qa[e]) : "";
}
const KW = {
  millisecond: "millisecond",
  second: "longtime",
  minute: "shorttime",
  hour: "shorttime",
  day: "day",
  week: "day",
  month: "month",
  quarter: "quarter",
  year: "year"
};
function GW(i) {
  return KW[nh(i)] || "";
}
const iD = function(i) {
  return Math.floor(i / 3);
}, sD = function(i) {
  return 3 * iD(i);
};
function h_(i, e, t, n) {
  i = new Date(i.getTime());
  const s = new Date(i.getTime());
  let o, r;
  const a = nh(e);
  switch (a) {
    case "second":
      i = new Date(1e3 * Math.floor(s.getTime() / 1e3));
      break;
    case "minute":
      i = new Date(6e4 * Math.floor(s.getTime() / 6e4));
      break;
    case "hour":
      i = new Date(36e5 * Math.floor(s.getTime() / 36e5));
      break;
    case "year":
      i.setMonth(0);
    case "month":
      i.setDate(1);
    case "day":
      i.setHours(0, 0, 0, 0);
      break;
    case "week":
      i = cD(i, n || 0), i.setHours(0, 0, 0, 0);
      break;
    case "quarter":
      o = sD(i.getMonth()), r = i.getMonth(), i.setDate(1), i.setHours(0, 0, 0, 0), r !== o && i.setMonth(o);
  }
  return t && a !== "hour" && a !== "minute" && a !== "second" && gD(s, i), i;
}
function oD(i) {
  return h_(i, "day");
}
const UW = function(i) {
  const e = oD(i);
  return e.setDate(e.getDate() + 1), new Date(e.getTime() - 1);
}, jW = function(i, e) {
  let t = 0;
  const n = {
    year: i.getFullYear() !== e.getFullYear(),
    month: i.getMonth() !== e.getMonth(),
    day: i.getDate() !== e.getDate(),
    hour: i.getHours() !== e.getHours(),
    minute: i.getMinutes() !== e.getMinutes(),
    second: i.getSeconds() !== e.getSeconds(),
    millisecond: i.getMilliseconds() !== e.getMilliseconds()
  };
  return y(n, function(s, o) {
    o && t++;
  }), t === 0 && mD(i, e) !== 0 && (n.hour = !0, t++), n.count = t, n;
};
function rD(i, e, t) {
  const n = new Date(i.getTime()), s = te(e) ? lD(e.toLowerCase()) : $e(e) ? nD(e) : e;
  return s.years && n.setFullYear(n.getFullYear() + s.years * t), s.quarters && n.setMonth(n.getMonth() + 3 * s.quarters * t), s.months && n.setMonth(n.getMonth() + s.months * t), s.weeks && n.setDate(n.getDate() + 7 * s.weeks * t), s.days && n.setDate(n.getDate() + s.days * t), s.hours && n.setTime(n.getTime() + 36e5 * s.hours * t), s.minutes && n.setTime(n.getTime() + 6e4 * s.minutes * t), s.seconds && n.setTime(n.getTime() + 1e3 * s.seconds * t), s.milliseconds && n.setTime(n.getTime() + s.milliseconds * t), n;
}
const aD = function(i, e, t) {
  const n = t ? -1 : 1;
  return cn(i) ? rD(i, e, n) : tD(i + e * n, e);
}, qW = function(i, e, t) {
  const n = [];
  let s;
  for (n.push(cn(i) ? new Date(i.getTime()) : i), s = i; s < e; )
    s = aD(s, t), n.push(s);
  return n;
}, YW = function(i, e) {
  if (i === "month")
    return En(e.getFullYear(), e.getMonth(), 1);
  if (i === "year")
    return En(e.getFullYear(), 0, e.getDate());
  if (i === "decade")
    return En(ed(e), e.getMonth(), e.getDate());
  if (i === "century")
    return En(Jl(e), e.getMonth(), e.getDate());
}, XW = function(i, e) {
  if (i === "month")
    return En(e.getFullYear(), e.getMonth(), rc(e));
  if (i === "year")
    return En(e.getFullYear(), 11, e.getDate());
  if (i === "decade")
    return En(ed(e) + 9, e.getMonth(), e.getDate());
  if (i === "century")
    return En(Jl(e) + 90, e.getMonth(), e.getDate());
}, ZW = function(i, e) {
  const t = En(e.getFullYear(), e.getMonth(), 1);
  return i === "month" || (t.setMonth(0), i === "year") || (i === "decade" && t.setFullYear(ed(e)), i === "century" && t.setFullYear(Jl(e))), t;
}, QW = function(i, e) {
  const t = new Date(e);
  return t.setDate(rc(e)), i === "month" || (t.setMonth(11), t.setDate(rc(t)), i === "year") || (i === "decade" && t.setFullYear(ed(e) + 9), i === "century" && t.setFullYear(Jl(e) + 99)), t;
};
function rc(i) {
  return En(i.getFullYear(), i.getMonth() + 1, 0).getDate();
}
const JW = function(i) {
  switch (i) {
    case "month":
      return "year";
    case "year":
      return "decade";
    case "decade":
      return "century";
  }
}, ez = function(i) {
  switch (i) {
    case "century":
      return "decade";
    case "decade":
      return "year";
    case "year":
      return "month";
  }
}, tz = function(i) {
  let e = 1;
  return i === "year" && (e = 12), i === "decade" && (e = 120), i === "century" && (e = 1200), e;
}, nz = function(i) {
  let e = 1;
  return i === "decade" && (e = 12), i === "century" && (e = 120), e;
};
function lD(i) {
  const e = {};
  switch (i) {
    case "year":
      e.years = 1;
      break;
    case "month":
      e.months = 1;
      break;
    case "quarter":
      e.months = 3;
      break;
    case "week":
      e.weeks = 1;
      break;
    case "day":
      e.days = 1;
      break;
    case "hour":
      e.hours = 1;
      break;
    case "minute":
      e.minutes = 1;
      break;
    case "second":
      e.seconds = 1;
      break;
    case "millisecond":
      e.milliseconds = 1;
  }
  return e;
}
function dD(i, e) {
  return am(i, e) && i.getDate() === e.getDate();
}
function am(i, e) {
  return uD(i, e) && i.getMonth() === e.getMonth();
}
function uD(i, e) {
  return i && e && i.getFullYear() === e.getFullYear();
}
function iz(i, e) {
  return i && e && i.getHours() === e.getHours() && i.getMinutes() === e.getMinutes();
}
const sz = function(i, e) {
  if (!f(i) || !f(e))
    return;
  const t = i.getFullYear() - i.getFullYear() % 10, n = e.getFullYear() - e.getFullYear() % 10;
  return i && e && t === n;
}, oz = function(i, e) {
  if (!f(i) || !f(e))
    return;
  const t = i.getFullYear() - i.getFullYear() % 100, n = e.getFullYear() - e.getFullYear() % 100;
  return i && e && t === n;
}, rz = (i, e) => !Array.isArray(i) || !Array.isArray(e) || i.length !== e.length ? !1 : i.every((t, n) => {
  const s = e[n];
  return [t, s].some((o) => o !== null && !(o instanceof Date)) ? !1 : t instanceof Date && s instanceof Date ? dD(t, s) : t === s;
});
function Jl(i) {
  return i && i.getFullYear() - i.getFullYear() % 100;
}
function ed(i) {
  return i && i.getFullYear() - i.getFullYear() % 10;
}
const az = function() {
  return "yyyy/MM/dd";
}, lz = function(i) {
  let e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
  if (!f(i))
    return;
  const t = new Date(i.getTime()), n = t.getMonth() + e;
  return t.setMonth(n), En(t.getFullYear(), n, 1);
}, dz = function(i) {
  let e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
  if (!f(i))
    return;
  const t = new Date(i.getTime()), n = t.getMonth() + e;
  return t.setMonth(n), En(t.getFullYear(), n + 1, 0);
};
function cD(i, e) {
  const t = (i.getDay() - e + 7) % 7, n = new Date(i);
  return n.setDate(i.getDate() - t), n;
}
function Mx(i) {
  return Date.UTC(i.getFullYear(), i.getMonth(), i.getDate());
}
function uz(i) {
  const e = Mx(i) - Mx(hD(i.getFullYear()));
  return 1 + Math.floor(e / Ql("day"));
}
function hD(i) {
  return new Date(i, 0, 1);
}
function ip(i) {
  return new Date(i, 11, 31);
}
function Bx(i, e) {
  let t = i.getDay() - e + 1;
  return t <= 0 && (t += 7), t;
}
function lm(i, e, t) {
  const n = Bx(hD(i.getFullYear()), e), s = Bx(ip(i.getFullYear()), e), o = 7 - n + 1;
  let r = Math.ceil((uz(i) - o) / 7);
  switch (t) {
    case "fullWeek":
      if (o === 7 && r++, r === 0) {
        const a = ip(i.getFullYear() - 1);
        return lm(a, e, t);
      }
      return r;
    case "firstDay": {
      o > 0 && r++;
      const a = n === 7 || s === 7;
      return (r > 52 && !a || r === 54) && (r = 1), r;
    }
    case "firstFourDays": {
      o > 3 && r++;
      const a = n === 4 || s === 4;
      if (r > 52 && !a && (r = 1), r === 0) {
        const l = ip(i.getFullYear() - 1);
        return lm(l, e, t);
      }
      return r;
    }
  }
}
const cz = function(i, e) {
  const t = j.getDatesInterval(i, e, "day");
  let n = new Date(i);
  return t >= 6 && (n = new Date(n.setDate(n.getDate() + 7))), n;
}, hz = function(i, e, t, n) {
  return n === "date" && (e = e && j.correctDateWithUnitBeginning(e, "day"), t = t && j.correctDateWithUnitBeginning(t, "day"), i = i && j.correctDateWithUnitBeginning(i, "day")), pD(i, e, t) === i;
}, pz = function(i) {
  const {
    firstMin: e,
    firstMax: t,
    secondMin: n,
    secondMax: s
  } = i;
  return e <= n && n <= t || e > n && e < s || e < s && t > s;
}, gz = function(i) {
  const e = Math.floor(i), t = i % 1 * 60;
  return {
    hours: e,
    minutes: t
  };
}, mz = function(i, e) {
  const t = this.dateTimeFromDecimal(e), n = new Date(i);
  return (i.getHours() === t.hours && i.getMinutes() < t.minutes || i.getHours() < t.hours) && n.setHours(t.hours, t.minutes, 0, 0), n;
};
function pD(i, e, t) {
  let n = i;
  return f(i) ? (f(e) && i < e && (n = e), f(t) && i > t && (n = t), n) : i;
}
function gD(i, e) {
  if (!f(i))
    return;
  const t = e.getHours() - i.getHours();
  if (t === 0)
    return;
  const n = t === 1 || t === -23 ? -1 : 1, s = new Date(e.getTime() + 36e5 * n);
  (n > 0 || s.getDate() === e.getDate()) && e.setTime(s.getTime());
}
const fz = function(i) {
  const e = new Date(i.getTime());
  return e.setHours(e.getHours() + 1), e.setMinutes(0), e;
};
function mD(i, e) {
  return 60 * (e.getTimezoneOffset() - i.getTimezoneOffset()) * 1e3;
}
const _z = function(i) {
  return new Date(i);
}, Cz = function(i, e, t) {
  const n = [];
  let s = new Date(i.getTime());
  for (; s < e; )
    n.push(new Date(s.getTime())), s = this.addInterval(s, t);
  return n;
}, En = function(i) {
  for (var e = arguments.length, t = new Array(e > 1 ? e - 1 : 0), n = 1; n < e; n++)
    t[n - 1] = arguments[n];
  const s = new Date(i, ...t);
  return s.setFullYear(i), s;
}, vz = () => typeof Intl < "u" ? Intl.DateTimeFormat().resolvedOptions().timeZone : null, xz = (i) => {
  const t = i.map((r) => h_(r, "day").getTime()).sort((r, a) => r - a), n = Ql("day"), s = [];
  let o = t[0];
  for (let r = 1; r <= t.length; ++r) {
    const a = t[r], l = t[r - 1];
    if (a - l > n || r === t.length) {
      const c = (o === t[r - 1] ? [o] : [o, t[r - 1]]).map((h) => pt.deserializeDate(h));
      s.push(c), o = a;
    }
  }
  return s;
}, yz = function(i, e, t) {
  return j[Jr(`same ${i}`)](e, t);
}, j = {
  dateUnitIntervals: qa,
  convertMillisecondsToDateUnits: nD,
  dateToMilliseconds: zW,
  getNextDateUnit: WW,
  convertDateUnitToMilliseconds: oc,
  getDateUnitInterval: nh,
  getDateFormatByTickInterval: GW,
  getDatesDifferences: jW,
  correctDateWithUnitBeginning: h_,
  trimTime: oD,
  setToDayEnd: UW,
  roundDateByStartDayHour: mz,
  dateTimeFromDecimal: gz,
  addDateInterval: rD,
  addInterval: aD,
  getSequenceByInterval: qW,
  getDateIntervalByString: lD,
  sameHoursAndMinutes: iz,
  sameDate: dD,
  sameMonthAndYear: am,
  sameMonth: am,
  sameYear: uD,
  sameDecade: sz,
  sameCentury: oz,
  sameView: yz,
  sameDatesArrays: rz,
  getDifferenceInMonth: tz,
  getDifferenceInMonthForCells: nz,
  getFirstYearInDecade: ed,
  getFirstDecadeInCentury: Jl,
  getShortDateFormat: az,
  getViewFirstCellDate: YW,
  getViewLastCellDate: XW,
  getViewDown: ez,
  getViewUp: JW,
  getLastMonthDay: rc,
  getLastMonthDate: dz,
  getFirstMonthDate: lz,
  getFirstWeekDate: cD,
  getWeekNumber: lm,
  normalizeDateByWeek: cz,
  getQuarter: iD,
  getFirstQuarterMonth: sD,
  dateInRange: hz,
  intervalsOverlap: pz,
  roundToHour: fz,
  normalizeDate: pD,
  getViewMinBoundaryDate: ZW,
  getViewMaxBoundaryDate: QW,
  fixTimezoneGap: gD,
  getTimezonesDifference: mD,
  makeDate: _z,
  getDatesInterval: HW,
  getDatesOfInterval: Cz,
  createDateWithFullYear: En,
  getMachineTimezoneName: vz,
  getRangesByDates: xz
};
j.dateToMilliseconds;
j.dateToMilliseconds;
const sp = {}, ia = (i) => {
  const e = z.current();
  return i.reduce((t, n) => {
    let {
      device: s,
      options: o
    } = n;
    const r = s || {};
    return (B(r) ? r(e) : wz(e, r)) && x(!0, t, o), t;
  }, {});
}, bz = (i, e) => typeof i != "string" ? i : {
  [i]: e
}, wz = (i, e) => en(e) || Nf(i, [e]).length > 0, $x = (i) => i.substr(i.lastIndexOf(".") + 1), Nx = (i) => i.substr(0, i.lastIndexOf(".")), Sz = function(i, e) {
  return sp[e] = sp[e] || Be(e), sp[e](i, {
    functionsAsIs: !0
  });
}, Ez = function() {
  return arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [];
}, td = (i) => !i || typeof i != "string" ? !1 : /^\s*<svg[^>]*>(.|\r?\n)*?<\/svg>\s*$/i.test(i) ? "svg" : /data:.*base64|\.|[^<\s]\/{1,1}/.test(i) ? "image" : /^[\w-_]+$/.test(i) ? "dxIcon" : /^\s?([\w-_:]\s?)+$/.test(i) ? "fontIcon" : !1, cs = (i) => {
  switch (td(i)) {
    case "image":
      return p("<img>").attr("src", i).addClass("dx-icon");
    case "fontIcon":
      return p("<i>").addClass(`dx-icon ${i}`);
    case "dxIcon":
      return p("<i>").addClass(`dx-icon dx-icon-${i}`);
    case "svg":
      return p("<i>").addClass("dx-icon dx-svg-icon").append(i);
    default:
      return null;
  }
}, Br = Ie(), _e = Bf(Ae.ERROR_MESSAGES, {
  E1001: "Module '{0}'. Controller '{1}' is already registered",
  E1002: "Module '{0}'. Controller '{1}' does not inherit from DevExpress.ui.dxDataGrid.Controller",
  E1003: "Module '{0}'. View '{1}' is already registered",
  E1004: "Module '{0}'. View '{1}' does not inherit from DevExpress.ui.dxDataGrid.View",
  E1005: "Public method '{0}' is already registered",
  E1006: "Public method '{0}.{1}' does not exist",
  E1007: "State storing cannot be provided due to the restrictions of the browser",
  E1010: "The template does not contain the TextBox widget",
  E1011: 'Items cannot be deleted from the List. Implement the "remove" function in the data store',
  E1012: "Editing type '{0}' with the name '{1}' is unsupported",
  E1016: "Unexpected type of data source is provided for a lookup column",
  E1018: "The 'collapseAll' method cannot be called if you use a remote data source",
  E1019: "Search mode '{0}' is unavailable",
  E1020: "The type cannot be changed after initialization",
  E1021: "{0} '{1}' you are trying to remove does not exist",
  E1022: 'The "markers" option is given an invalid value. Assign an array instead',
  E1023: 'The "routes" option is given an invalid value. Assign an array instead',
  E1025: "This layout is too complex to render",
  E1026: 'The "calculateCustomSummary" function is missing from a field whose "summaryType" option is set to "custom"',
  E1031: "Unknown subscription in the Scheduler widget: '{0}'",
  E1032: "Unknown start date in an appointment: '{0}'",
  E1033: "Unknown step in the date navigator: '{0}'",
  E1034: "The browser does not implement an API for saving files",
  E1035: "The editor cannot be created: {0}",
  E1037: "Invalid structure of grouped data",
  E1038: "The browser does not support local storages for local web pages",
  E1039: "A cell's position cannot be calculated",
  E1040: "The '{0}' key value is not unique within the data array",
  E1041: "The '{0}' script is referenced after the DevExtreme scripts or not referenced at all",
  E1042: "{0} requires the key field to be specified",
  E1043: "Changes cannot be processed due to the incorrectly set key",
  E1044: "The key field specified by the keyExpr option does not match the key field specified in the data store",
  E1045: "Editing requires the key field to be specified in the data store",
  E1046: "The '{0}' key field is not found in data objects",
  E1047: 'The "{0}" field is not found in the fields array',
  E1048: 'The "{0}" operation is not found in the filterOperations array',
  E1049: "Column '{0}': filtering is allowed but the 'dataField' or 'name' option is not specified",
  E1050: "The validationRules option does not apply to third-party editors defined in the editCellTemplate",
  E1052: '{0} should have the "dataSource" option specified',
  E1053: 'The "buttons" option accepts an array that contains only objects or string values',
  E1054: "All text editor buttons must have names",
  E1055: 'One or several text editor buttons have invalid or non-unique "name" values',
  E1056: 'The {0} widget does not support buttons of the "{1}" type',
  E1058: 'The "startDayHour" and "endDayHour" options must be integers in the [0, 24] range, with "endDayHour" being greater than "startDayHour".',
  E1059: "The following column names are not unique: {0}",
  E1060: "All editable columns must have names",
  E1061: 'The "offset" option must be an integer in the [-1440, 1440] range, divisible by 5 without a remainder.',
  E1062: 'The "cellDuration" must be a positive integer, evenly dividing the ("endDayHour" - "startDayHour") interval into minutes.',
  W1001: 'The "key" option cannot be modified after initialization',
  W1002: "An item with the key '{0}' does not exist",
  W1003: "A group with the key '{0}' in which you are trying to select items does not exist",
  W1004: "The item '{0}' you are trying to select in the group '{1}' does not exist",
  W1005: "Due to column data types being unspecified, data has been loaded twice in order to apply initial filter settings. To resolve this issue, specify data types for all grid columns.",
  W1006: "The map service returned the following error: '{0}'",
  W1007: "No item with key {0} was found in the data source, but this key was used as the parent key for item {1}",
  W1008: "Cannot scroll to the '{0}' date because it does not exist on the current view",
  W1009: "Searching works only if data is specified using the dataSource option",
  W1010: "The capability to select all items works with source data of plain structure only",
  W1011: 'The "keyExpr" option is not applied when dataSource is not an array',
  W1012: "The '{0}' key field is not found in data objects",
  W1013: 'The "message" field in the dialog component was renamed to "messageHtml". Change your code correspondingly. In addition, if you used HTML code in the message, make sure that it is secure',
  W1014: "The Floating Action Button exceeds the recommended speed dial action count. If you need to display more speed dial actions, increase the maxSpeedDialActionCount option value in the global config.",
  W1016: "The '{0}' field in the HTML Editor toolbar item configuration was renamed to '{1}'. Please make a corresponding change in your code.",
  W1017: "The 'key' property is not specified for a lookup data source. Please specify it to prevent requests for the entire dataset when users filter data.",
  W1018: "Infinite scrolling may not work properly with multiple selection. To use these features together, set 'selection.deferred' to true or set 'selection.selectAllMode' to 'page'.",
  W1019: "Filter query string exceeds maximum length limit of {0} characters.",
  W1020: "hideEvent is ignored when the shading property is true",
  W1021: `The '{0}' is not rendered because none of the DOM elements match the value of the "container" property.`,
  W1022: "{0} JSON parsing error: '{1}'",
  W1023: "Appointments require unique keys. Otherwise, the agenda view may not work correctly.",
  W1024: "The client-side export is enabled. Implement the 'onExporting' function.",
  W1025: "'scrolling.mode' is set to 'virtual' or 'infinite'. Specify the height of the component."
}), fD = fe(), Iz = Bi.add, Dz = Ys, Tz = eh;
let Tl = new w();
const _D = "link[rel=dx-theme]", Oz = "data-theme", Az = "data-active";
let os, dm, rs, wn, Ps, Lx = 15e3;
function p_() {
  if (!ae())
    return null;
  const i = p("<div>", os).addClass("dx-theme-marker").appendTo(os.documentElement);
  let e;
  try {
    return e = fD.getComputedStyle(i.get(0)).fontFamily, !e || (e = e.replace(/["']/g, ""), e.substr(0, 3) !== "dx.") ? null : e.substr(3);
  } finally {
    i.remove();
  }
}
function Hx(i) {
  let e, t, n = !0;
  Ps = i;
  function s() {
    Ps = null, clearInterval(t), n = !0, Br.fire(), Br.empty(), Tl.resolve();
  }
  if (Wx() || !Lx)
    s();
  else {
    if (!n) {
      Ps && (Ps = i);
      return;
    }
    e = Date.now(), n = !1, t = setInterval(function() {
      const o = Wx(), r = !o && Date.now() - e > Lx;
      r && _e.log("W0004", Ps), (o || r) && s();
    }, 10);
  }
}
function Wx() {
  if (!Ps)
    return !0;
  const i = Ps === "any";
  if (Tl.state() === "resolved" && i)
    return !0;
  const e = p_();
  return e && i ? !0 : e === Ps;
}
function Rz() {
  const i = p(_D, os);
  i.length && (rs = {}, dm = p(Xf("<link rel=stylesheet>"), os), i.each(function() {
    const e = p(this, os), t = e.attr(Oz), n = e.attr("href"), s = e.attr(Az) === "true";
    rs[t] = {
      url: n,
      isActive: s
    };
  }), i.last().after(dm), i.remove());
}
function Fz(i) {
  const e = i ? i.split(".") : [];
  let t = null;
  if (rs) {
    if (i in rs)
      return i;
    y(rs, function(n, s) {
      const o = n.split(".");
      if (!(e[0] && o[0] !== e[0]) && !(e[1] && e[1] !== o[1]) && !(e[2] && e[2] !== o[2]) && ((!t || s.isActive) && (t = n), s.isActive))
        return !1;
    });
  }
  return t;
}
function kz(i) {
  try {
    i !== os && (rs = null);
  } catch {
    rs = null;
  }
  os = i;
}
function CD(i) {
  i = i || {}, kz(i.context || O.getDocument()), os && (Rz(), wn = void 0, pn(i));
}
function pn(i) {
  if (!arguments.length)
    return wn = wn || p_(), wn;
  xD(Dz()), i = i || {}, typeof i == "string" && (i = {
    theme: i
  });
  const e = i._autoInit, t = i.loadCallback;
  let n;
  if (wn = Fz(i.theme || wn), wn && (n = rs[wn]), t && Br.add(t), n)
    dm.attr("href", rs[wn].url), (Br.has() || Tl.state() !== "resolved" || i._forceTimeout) && Hx(wn);
  else if (e)
    ae() && Hx("any"), Br.fire(), Br.empty();
  else
    throw _e.Error("E0021", wn);
  Tl.done(() => vD(KI(), wn));
}
function Vz(i) {
  i = i || pn();
  const e = [], t = i && i.split(".");
  return t && (e.push("dx-theme-" + t[0], "dx-theme-" + t[0] + "-typography"), t.length > 1 && e.push("dx-color-scheme-" + t[1] + (Gn(i) ? "-" + t[2] : ""))), e;
}
let Ou;
function Pz(i, e) {
  Ou = Vz(e).join(" "), p(i).addClass(Ou), function() {
    const t = ae() && fD.devicePixelRatio;
    if (!t || t < 2)
      return;
    const n = p("<div>");
    n.css("border", ".5px solid transparent"), p("body").append(n), he(n) === 1 && (p(i).addClass("dx-hairlines"), Ou += " dx-hairlines"), n.remove();
  }();
}
function vD(i, e) {
  W(Gc).done(() => {
    Pz(i, e);
  });
}
function xD(i) {
  W(Gc).done(() => {
    p(i).removeClass(Ou);
  });
}
function g_(i, e) {
  return e || (e = wn || p_()), new RegExp(i).test(e);
}
function Gn(i) {
  return Zt(i) || nn(i);
}
function Zt(i) {
  return g_("material", i);
}
function nn(i) {
  return g_("fluent", i);
}
function m_(i) {
  return g_("generic", i);
}
function Mz(i, e) {
  const t = O.getDocument(), n = t.createElement("span");
  n.style.position = "absolute", n.style.top = "-9999px", n.style.left = "-9999px", n.style.visibility = "hidden", n.style.fontFamily = "Arial", n.style.fontSize = "250px", n.style.fontWeight = e, n.innerHTML = i, t.body.appendChild(n);
  const s = n.offsetWidth;
  n.style.fontFamily = "Roboto, RobotoFallback, Arial";
  const o = n.offsetWidth;
  return n.parentNode.removeChild(n), s !== o;
}
function Bz(i, e) {
  return new Promise((t) => {
    const n = () => {
      clearInterval(s), clearTimeout(o), t();
    }, s = setInterval(() => {
      Mz(i, e) && n();
    }, 15), o = setTimeout(n, 2e3);
  });
}
function zx() {
  if (CD({
    _autoInit: !0,
    _forceTimeout: !0
  }), p(_D, os).length)
    throw _e.Error("E0022");
}
ae() ? zx() : Iz(zx);
Tz.add(function(i, e) {
  Tl.done(function() {
    xD(e), vD(i);
  });
});
z.changed.add(function() {
  CD({
    _autoInit: !0
  });
});
const um = (i) => i && (i.defaultProps ? (e) => ki(qe(2, i, I({}, e))) : i), $z = (i, e) => Object.keys(i).length !== Object.keys(e).length ? !1 : Object.entries(i).every((t) => {
  let [n, s] = t;
  const o = e[n];
  return s instanceof Date && o instanceof Date ? s.getTime() === o.getTime() : s === o;
}), op = (i) => Array.isArray(i) ? [...i] : I({}, i), yD = (i, e, t) => {
  const n = t.length > 0 && e && i !== e ? op(e) : op(i), s = t[0];
  return t.length > 1 ? n[s] = yD(i[s], e?.[s], t.slice(1)) : s && (pe(i[s]) ? n[s] = op(i[s]) : n[s] = i[s]), n;
}, Nz = (i, e, t, n) => {
  const s = e[t], o = i[t], r = i;
  pe(s) || t !== n && Array.isArray(s) ? r[t] = yD(s, o, Jo(n).slice(1)) : r[t] = s;
}, Mn = ae() ? fe() : {};
let bD = function(i) {
  return setTimeout(i, 16.666666666666668);
}, wD = function(i) {
  clearTimeout(i);
};
const SD = _s(function() {
  const i = Mn.requestAnimationFrame || Mn.webkitRequestAnimationFrame || Mn.mozRequestAnimationFrame || Mn.oRequestAnimationFrame || Mn.msRequestAnimationFrame, e = Mn.cancelAnimationFrame || Mn.webkitCancelAnimationFrame || Mn.mozCancelAnimationFrame || Mn.oCancelAnimationFrame || Mn.msCancelAnimationFrame;
  i && e && (bD = i, wD = e);
});
function ac() {
  return SD(), bD.apply(Mn, arguments);
}
function Xi() {
  SD(), wD.apply(Mn, arguments);
}
function Lz(i) {
  return i && i.get ? i.get(0) : i;
}
let Hz = Lz;
function ee(i) {
  return Hz(i);
}
const Wz = /matrix(3d)?\((.+?)\)/, zz = /translate(?:3d)?\((.+?)\)/, Nn = function(i) {
  i = p(i);
  const e = dc(i);
  return {
    left: e.x,
    top: e.y
  };
};
function lc(i) {
  return yn(i) === "string" && i[i.length - 1] === "%";
}
function ED(i, e) {
  i.length && tt(i.get(0), "dxTranslator", e);
}
const f_ = function(i) {
  i.length && qc(i.get(0), "dxTranslator");
}, nd = function(i) {
  i.x = i.x || 0, i.y = i.y || 0;
  const e = lc(i.x) ? i.x : i.x + "px", t = lc(i.y) ? i.y : i.y + "px";
  return "translate(" + e + ", " + t + ")";
}, dc = function(i) {
  let e = i.length ? tt(i.get(0), "dxTranslator") : null;
  if (!e) {
    let n = (i.css("transform") || nd({
      x: 0,
      y: 0
    })).match(Wz);
    const s = n && n[1];
    n ? (n = n[2].split(","), s === "3d" ? n = n.slice(12, 15) : (n.push(0), n = n.slice(4, 7))) : n = [0, 0, 0], e = {
      x: parseFloat(n[0]),
      y: parseFloat(n[1]),
      z: parseFloat(n[2])
    }, ED(i, e);
  }
  return e;
}, Ot = function(i, e) {
  i = p(i);
  const t = e.left, n = e.top;
  let s;
  t === void 0 ? (s = dc(i), s.y = n || 0) : n === void 0 ? (s = dc(i), s.x = t || 0) : (s = {
    x: t || 0,
    y: n || 0,
    z: 0
  }, ED(i, s)), i.css({
    transform: nd(s)
  }), (lc(t) || lc(n)) && f_(i);
}, id = function(i, e) {
  i = p(i);
  let t;
  const n = {
    left: 0,
    top: 0,
    transform: "none"
  };
  e && (t = i.css("transition"), n.transition = "none"), i.css(n), f_(i), e && (i.get(0).offsetHeight, i.css("transition", t));
}, Kz = function(i) {
  let e = i.match(zz);
  if (!(!e || !e[1]))
    return e = e[1].split(","), e = {
      x: parseFloat(e[0]),
      y: parseFloat(e[1]),
      z: parseFloat(e[2])
    }, e;
}, Kx = /cubic-bezier\((\d+(?:\.\d+)?)\s*,\s*(\d+(?:\.\d+)?)\s*,\s*(\d+(?:\.\d+)?)\s*,\s*(\d+(?:\.\d+)?)\)/, Gx = {
  linear: "cubic-bezier(0, 0, 1, 1)",
  swing: "cubic-bezier(0.445, 0.05, 0.55, 0.95)",
  ease: "cubic-bezier(0.25, 0.1, 0.25, 1)",
  "ease-in": "cubic-bezier(0.42, 0, 1, 1)",
  "ease-out": "cubic-bezier(0, 0, 0.58, 1)",
  "ease-in-out": "cubic-bezier(0.42, 0, 0.58, 1)"
}, Gz = function(i, e, t, n) {
  const s = 3 * i, o = 3 * (t - i) - s, r = 1 - s - o, a = 3 * e, l = 3 * (n - e) - a, d = 1 - a - l, u = function(h) {
    return h * (s + h * (o + h * r));
  }, c = function(h) {
    return s + h * (2 * o + 3 * h * r);
  };
  return function(h) {
    return function(g) {
      return g * (a + g * (l + g * d));
    }(function(g) {
      let m = g, C = 0, v;
      for (; C < 14 && (v = u(m) - g, !(Math.abs(v) < 1e-3)); )
        m -= v / c(m), C++;
      return m;
    }(h));
  };
};
let cm = {};
const Uz = function(i) {
  i = Gx[i] || i;
  let e = i.match(Kx), t;
  e || (t = "linear", e = Gx[t].match(Kx)), e = e.slice(1, 5);
  for (let s = 0; s < e.length; s++)
    e[s] = parseFloat(e[s]);
  const n = t || "cubicbezier_" + e.join("_").replace(/\./g, "p");
  return B(cm[n]) || (cm[n] = function(s, o, r, a, l) {
    return a * Gz(e[0], e[1], e[2], e[3])(o / l) + r;
  }), n;
};
function jz(i) {
  return cm[i];
}
const ro = (i) => i ?? Pe().rtlEnabled ? "right" : "left", Ge = (i) => {
  var e;
  return lt(i) ? {
    width: i.outerWidth,
    height: i.outerHeight
  } : (e = i.getBoundingClientRect) === null || e === void 0 ? void 0 : e.call(i);
}, qz = ua(), Yz = /(webkit)[ /]([\w.]+)/, Xz = /(mozilla)(?:.*? rv:([\w.]+))/, Ux = (i) => {
  i = i.toLowerCase();
  const e = {}, t = Yz.exec(i) || i.indexOf("compatible") < 0 && Xz.exec(i) || [];
  let n = t[1], s = t[2];
  return n === "webkit" && (e.webkit = !0, i.indexOf("chrome") >= 0 || i.indexOf("crios") >= 0 ? (n = "chrome", s = /(?:chrome|crios)\/(\d+\.\d+)/.exec(i), s = s && s[1]) : i.indexOf("fxios") >= 0 ? (n = "mozilla", s = /fxios\/(\d+\.\d+)/.exec(i), s = s && s[1]) : i.indexOf("safari") >= 0 && /version|phantomjs/.test(i) ? (n = "safari", s = /(?:version|phantomjs)\/([0-9.]+)/.exec(i), s = s && s[1]) : (n = "unknown", s = /applewebkit\/([0-9.]+)/.exec(i), s = s && s[1])), n && (e[n] = !0, e.version = s), e;
}, ze = x({
  _fromUA: Ux
}, Ux(qz.userAgent)), jx = fe(), Zz = /left|right/, Qz = /top|bottom/, qx = /fit|flip|none/, Jz = /scale\(.+?\)/, eK = ze.safari, hm = function(i) {
  const e = {
    h: "center",
    v: "center"
  }, t = er(i);
  return t && y(t, function() {
    const n = String(this).toLowerCase();
    Zz.test(n) ? e.h = n : Qz.test(n) && (e.v = n);
  }), e;
}, Yx = function(i, e) {
  return Lf(i, e);
}, tK = function(i) {
  const e = er(i);
  let t = String(e && e[0]).toLowerCase(), n = String(e && e[1]).toLowerCase();
  return qx.test(t) || (t = "none"), qx.test(n) || (n = t), {
    h: t,
    v: n
  };
}, Xx = function(i) {
  switch (i) {
    case "center":
      return 0.5;
    case "right":
    case "bottom":
      return 1;
    default:
      return 0;
  }
}, pm = function(i) {
  switch (i) {
    case "left":
      return "right";
    case "right":
      return "left";
    case "top":
      return "bottom";
    case "bottom":
      return "top";
    default:
      return i;
  }
}, gm = function(i, e) {
  let t = 0;
  return i.myLocation < e.min && (t += e.min - i.myLocation), i.myLocation > e.max && (t += i.myLocation - e.max), t;
}, Zx = function(i, e, t) {
  return e.myLocation < t.min ? i === "h" ? "left" : "top" : e.myLocation > t.max ? i === "h" ? "right" : "bottom" : "none";
}, mm = function(i) {
  i.myLocation = i.atLocation + Xx(i.atAlign) * i.atSize - Xx(i.myAlign) * i.mySize + i.offset;
}, Md = {
  fit: function(i, e) {
    let t = !1;
    i.myLocation > e.max && (i.myLocation = e.max, t = !0), i.myLocation < e.min && (i.myLocation = e.min, t = !0), i.fit = t;
  },
  flip: function(i, e) {
    if (i.flip = !1, !(i.myAlign === "center" && i.atAlign === "center") && (i.myLocation < e.min || i.myLocation > e.max)) {
      const t = x({}, i, {
        myAlign: pm(i.myAlign),
        atAlign: pm(i.atAlign),
        offset: -i.offset
      });
      mm(t), t.oversize = gm(t, e), (t.myLocation >= e.min && t.myLocation <= e.max || i.oversize > t.oversize) && (i.myLocation = t.myLocation, i.oversize = t.oversize, i.flip = !0);
    }
  },
  flipfit: function(i, e) {
    this.flip(i, e), this.fit(i, e);
  },
  none: function(i) {
    i.oversize = 0;
  }
};
let ID;
const DD = function() {
  const i = p("<div>").css({
    width: 100,
    height: 100,
    overflow: "scroll",
    position: "absolute",
    top: -9999
  }).appendTo(p("body")), e = i.get(0).offsetWidth - i.get(0).clientWidth;
  i.remove(), ID = e;
}, nK = {
  h: {
    location: 0,
    flip: !1,
    fit: !1,
    oversize: 0
  },
  v: {
    location: 0,
    flip: !1,
    fit: !1,
    oversize: 0
  }
}, TD = function(i, e) {
  const t = p(i), n = t.offset(), s = x(!0, {}, nK, {
    h: {
      location: n.left
    },
    v: {
      location: n.top
    }
  });
  if (!e)
    return s;
  const o = hm(e.my), r = hm(e.at);
  let a = p(e.of).length && e.of || jx;
  const l = Yx(e.offset, e.precise), d = tK(e.collision), u = e.boundary, c = Yx(e.boundaryOffset, e.precise), h = {
    mySize: Ee(t),
    myAlign: o.h,
    atAlign: r.h,
    offset: l.h,
    collision: d.h,
    boundaryOffset: c.h
  }, g = {
    mySize: he(t),
    myAlign: o.v,
    atAlign: r.v,
    offset: l.v,
    collision: d.v,
    boundaryOffset: c.v
  };
  if (a.preventDefault)
    h.atLocation = a.pageX, g.atLocation = a.pageY, h.atSize = 0, g.atSize = 0;
  else if (a = p(a), lt(a[0]))
    h.atLocation = a.scrollLeft(), g.atLocation = a.scrollTop(), z.real().deviceType === "phone" && a[0].visualViewport ? (h.atLocation = Math.max(h.atLocation, a[0].visualViewport.offsetLeft), g.atLocation = Math.max(g.atLocation, a[0].visualViewport.offsetTop), h.atSize = a[0].visualViewport.width, g.atSize = a[0].visualViewport.height) : (h.atSize = a[0].innerWidth > a[0].outerWidth ? a[0].innerWidth : ne(a), g.atSize = a[0].innerHeight > a[0].outerHeight || eK ? a[0].innerHeight : le(a));
  else if (a[0].nodeType === 9)
    h.atLocation = 0, g.atLocation = 0, h.atSize = ne(a), g.atSize = le(a);
  else {
    const v = Ge(a.get(0)), E = uc(a);
    h.atLocation = E.left, g.atLocation = E.top, h.atSize = Math.max(v.width, Ee(a)), g.atSize = Math.max(v.height, he(a));
  }
  mm(h), mm(g);
  const m = function() {
    const v = p(jx), E = ne(v), T = le(v);
    let V = v.scrollLeft(), $ = v.scrollTop();
    const G = O.getDocumentElement(), H = om ? G.clientWidth / E : 1, ce = om ? G.clientHeight / T : 1;
    ID === void 0 && DD();
    let re = E, me = T;
    if (u && !lt(u)) {
      const dt = p(u), Ke = dt.offset();
      V = Ke.left, $ = Ke.top, re = ne(dt), me = le(dt);
    }
    return {
      h: {
        min: V + h.boundaryOffset,
        max: V + re / H - h.mySize - h.boundaryOffset
      },
      v: {
        min: $ + g.boundaryOffset,
        max: $ + me / ce - g.mySize - g.boundaryOffset
      }
    };
  }();
  h.oversize = gm(h, m.h), g.oversize = gm(g, m.v), h.collisionSide = Zx("h", h, m.h), g.collisionSide = Zx("v", g, m.v), Md[h.collision] && Md[h.collision](h, m.h), Md[g.collision] && Md[g.collision](g, m.v);
  const C = function(v) {
    return e.precise ? v : Math.round(v);
  };
  return x(!0, s, {
    h: {
      location: C(h.myLocation),
      oversize: C(h.oversize),
      fit: h.fit,
      flip: h.flip,
      collisionSide: h.collisionSide
    },
    v: {
      location: C(g.myLocation),
      oversize: C(g.oversize),
      fit: g.fit,
      flip: g.flip,
      collisionSide: g.collisionSide
    },
    precise: e.precise
  }), s;
}, Qx = function(i, e, t, n) {
  const s = f(i.style) && !O.isNode(i.style), o = n ? t.replace(e, "") : t;
  if (s)
    JE(i, o, !1);
  else {
    const r = O.createAttribute("style");
    r.value = o, i.setAttributeNode(r);
  }
}, uc = function(i) {
  var e, t;
  let n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : i;
  const s = n.get(0);
  if (!s)
    return i.offset();
  const o = ((e = s.getAttribute) === null || e === void 0 ? void 0 : e.call(s, "style")) || "", r = (t = o.match(Jz)) === null || t === void 0 ? void 0 : t[0];
  let a;
  return r ? (Qx(s, r, o, !0), a = uc(i, n.parent()), Qx(s, r, o, !1)) : a = uc(i, n.parent()), a;
}, Ol = function(i, e) {
  const t = p(i);
  if (!e)
    return t.offset();
  id(t, !0);
  const n = uc(t), s = e.h && e.v ? e : TD(t, e), o = function(r) {
    return e.precise ? r : Math.round(r);
  };
  return Ot(t, {
    left: s.h.location - o(n.left),
    top: s.v.location - o(n.top)
  }), s;
}, iK = function(i) {
  return i = p(i).get(0), lt(i) ? null : i && "pageY" in i && "pageX" in i ? {
    top: i.pageY,
    left: i.pageX
  } : p(i).offset();
};
Ol.inverseAlign || (Ol.inverseAlign = pm);
Ol.normalizeAlign || (Ol.normalizeAlign = hm);
const Un = {
  calculateScrollbarWidth: DD,
  calculate: TD,
  setup: Ol,
  offset: iK
}, OD = fe(), sl = R(On, "dxFX"), sK = /^([+-])=(.*)/i, oK = {
  initAnimation: function(i, e) {
    i.css({
      transitionProperty: "none"
    }), typeof e.from == "string" ? i.addClass(e.from) : _m(i, e.from);
    const t = this, n = new w(), s = e.cleanupWhen;
    e.transitionAnimation = {
      deferred: n,
      finish: function() {
        t._finishTransition(i), s ? W(n, s).always(function() {
          t._cleanup(i, e);
        }) : t._cleanup(i, e), n.resolveWith(i, [e, i]);
      }
    }, this._completeAnimationCallback(i, e).done(function() {
      e.transitionAnimation.finish();
    }).fail(function() {
      n.rejectWith(i, [e, i]);
    }), e.duration || e.transitionAnimation.finish(), i.css("transform");
  },
  animate: function(i, e) {
    return this._startAnimation(i, e), e.transitionAnimation.deferred.promise();
  },
  _completeAnimationCallback: function(i, e) {
    const t = this, n = Date.now() + e.delay, s = new w(), o = new w(), r = new w();
    let a;
    const l = tn.transitionEndEventName() + ".dxFX";
    e.transitionAnimation.cleanup = function() {
      clearTimeout(a), clearTimeout(d), _.off(i, l), _.off(i, sl);
    }, _.one(i, l, function() {
      Date.now() - n >= e.duration && o.reject();
    }), _.off(i, sl), _.on(i, sl, function() {
      t.stop(i, e), s.reject();
    });
    const d = setTimeout(function() {
      a = setTimeout(function() {
        r.reject();
      }, e.duration + e.delay + Le._simulatedTransitionEndDelay), W(o, r).fail(function() {
        s.resolve();
      }.bind(this));
    });
    return s.promise();
  },
  _startAnimation: function(i, e) {
    i.css({
      transitionProperty: "all",
      transitionDelay: e.delay + "ms",
      transitionDuration: e.duration + "ms",
      transitionTimingFunction: e.easing
    }), typeof e.to == "string" ? i[0].className += " " + e.to : e.to && _m(i, e.to);
  },
  _finishTransition: function(i) {
    i.css("transition", "none");
  },
  _cleanup: function(i, e) {
    e.transitionAnimation.cleanup(), typeof e.from == "string" && (i.removeClass(e.from), i.removeClass(e.to));
  },
  stop: function(i, e, t) {
    e && (t ? e.transitionAnimation.finish() : (pe(e.to) && y(e.to, function(n) {
      i.css(n, i.css(n));
    }), this._finishTransition(i), this._cleanup(i, e)));
  }
}, Jx = {
  initAnimation: function(i, e) {
    _m(i, e.from);
  },
  animate: function(i, e) {
    const t = new w(), n = this;
    return e ? (y(e.to, function(s) {
      e.from[s] === void 0 && (e.from[s] = n._normalizeValue(i.css(s)));
    }), e.to.transform && (e.from.transform = n._parseTransform(e.from.transform), e.to.transform = n._parseTransform(e.to.transform)), e.frameAnimation = {
      to: e.to,
      from: e.from,
      currentValue: e.from,
      easing: Uz(e.easing),
      duration: e.duration,
      startTime: (/* @__PURE__ */ new Date()).valueOf(),
      finish: function() {
        this.currentValue = this.to, this.draw(), Xi(e.frameAnimation.animationFrameId), t.resolve();
      },
      draw: function() {
        if (e.draw) {
          e.draw(this.currentValue);
          return;
        }
        const s = x({}, this.currentValue);
        s.transform && (s.transform = mt(s.transform, function(o, r) {
          if (r === "translate")
            return nd(o);
          if (r === "scale")
            return "scale(" + o + ")";
          if (r.substr(0, r.length - 1) === "rotate")
            return r + "(" + o + "deg)";
        }).join(" ")), i.css(s);
      }
    }, e.delay ? (e.frameAnimation.startTime += e.delay, e.frameAnimation.delayTimeout = setTimeout(function() {
      n._startAnimation(i, e);
    }, e.delay)) : n._startAnimation(i, e), t.promise()) : t.reject().promise();
  },
  _startAnimation: function(i, e) {
    _.off(i, sl), _.on(i, sl, function() {
      e.frameAnimation && Xi(e.frameAnimation.animationFrameId);
    }), this._animationStep(i, e);
  },
  _parseTransform: function(i) {
    const e = {};
    return y(i.match(/\w+\d*\w*\([^)]*\)\s*/g), function(t, n) {
      const s = Kz(n), o = n.match(/scale\((.+?)\)/), r = n.match(/(rotate.)\((.+)deg\)/);
      s && (e.translate = s), o && o[1] && (e.scale = parseFloat(o[1])), r && r[1] && (e[r[1]] = parseFloat(r[2]));
    }), e;
  },
  stop: function(i, e, t) {
    const n = e && e.frameAnimation;
    n && (Xi(n.animationFrameId), clearTimeout(n.delayTimeout), t && n.finish(), delete e.frameAnimation);
  },
  _animationStep: function(i, e) {
    const t = e && e.frameAnimation;
    if (!t)
      return;
    const n = (/* @__PURE__ */ new Date()).valueOf();
    if (n >= t.startTime + t.duration) {
      t.finish();
      return;
    }
    t.currentValue = this._calcStepValue(t, n - t.startTime), t.draw();
    const s = this;
    t.animationFrameId = ac(function() {
      s._animationStep(i, e);
    });
  },
  _calcStepValue: function(i, e) {
    const t = function(n, s) {
      const o = Array.isArray(s) ? [] : {};
      return y(s, function(r, a) {
        if (typeof a == "string" && parseFloat(a) === !1)
          return !0;
        o[r] = typeof a == "object" ? t(n[r], a) : function(l) {
          const d = e / i.duration, u = e, c = 1 * n[l], h = s[l] - n[l], g = i.duration;
          return jz(i.easing)(d, u, c, h, g);
        }(r);
      }), o;
    };
    return t(i.from, i.to);
  },
  _normalizeValue: function(i) {
    const e = parseFloat(i);
    return e === !1 ? i : e;
  }
}, rK = {
  initAnimation: function() {
  },
  animate: function() {
    return new w().resolve().promise();
  },
  stop: M,
  isSynchronous: !0
}, aK = function(i) {
  i = i || {};
  const e = {
    transition: tn.transition() ? oK : Jx,
    frame: Jx,
    noAnimation: rK
  };
  let t = i.strategy || "transition";
  return i.type === "css" && !tn.transition() && (t = "noAnimation"), e[t];
}, AD = function(i, e, t, n) {
  y(["from", "to"], function() {
    if (!t(i[this]))
      throw Ae.Error("E0010", e, this, n);
  });
}, RD = function(i, e) {
  return AD(i, e, function(t) {
    return pe(t);
  }, "a plain object");
}, lK = function(i, e) {
  return AD(i, e, function(t) {
    return typeof t == "string";
  }, "a string");
}, dK = {
  setup: function() {
  }
}, uK = {
  validateConfig: function(i) {
    lK(i, "css");
  },
  setup: function() {
  }
}, cK = {
  top: {
    my: "bottom center",
    at: "top center"
  },
  bottom: {
    my: "top center",
    at: "bottom center"
  },
  right: {
    my: "left center",
    at: "right center"
  },
  left: {
    my: "right center",
    at: "left center"
  }
}, rp = {
  validateConfig: function(i) {
    RD(i, "slide");
  },
  setup: function(i, e) {
    const t = Nn(i);
    if (e.type !== "slide") {
      const n = e.type === "slideIn" ? e.from : e.to;
      n.position = x({
        of: OD
      }, cK[e.direction]), fm(i, n);
    }
    this._setUpConfig(t, e.from), this._setUpConfig(t, e.to), f_(i);
  },
  _setUpConfig: function(i, e) {
    e.left = "left" in e ? e.left : "+=0", e.top = "top" in e ? e.top : "+=0", this._initNewPosition(i, e);
  },
  _initNewPosition: function(i, e) {
    const t = {
      left: e.left,
      top: e.top
    };
    delete e.left, delete e.top;
    let n = this._getRelativeValue(t.left);
    n !== void 0 ? t.left = n + i.left : e.left = 0, n = this._getRelativeValue(t.top), n !== void 0 ? t.top = n + i.top : e.top = 0, e.transform = nd({
      x: t.left,
      y: t.top
    });
  },
  _getRelativeValue: function(i) {
    let e;
    if (typeof i == "string" && (e = sK.exec(i)))
      return parseInt(e[1] + "1") * e[2];
  }
}, ap = {
  setup: function(i, e) {
    const t = e.from, n = e.to, s = e.type === "fadeOut" ? 1 : 0, o = e.type === "fadeOut" ? 0 : 1;
    let r = pe(t) ? String(t.opacity ?? s) : String(t), a = pe(n) ? String(n.opacity ?? o) : String(n);
    switch (e.skipElementInitialStyles || (r = i.css("opacity")), e.type) {
      case "fadeIn":
        a = 1;
        break;
      case "fadeOut":
        a = 0;
    }
    e.from = {
      visibility: "visible",
      opacity: r
    }, e.to = {
      opacity: a
    };
  }
}, hK = {
  validateConfig: function(i) {
    RD(i, "pop");
  },
  setup: function(i, e) {
    const t = e.from, n = e.to, s = "opacity" in t ? t.opacity : i.css("opacity"), o = "opacity" in n ? n.opacity : 1, r = "scale" in t ? t.scale : 0, a = "scale" in n ? n.scale : 1;
    e.from = {
      opacity: s
    };
    const l = dc(i);
    e.from.transform = this._getCssTransform(l, r), e.to = {
      opacity: o
    }, e.to.transform = this._getCssTransform(l, a);
  },
  _getCssTransform: function(i, e) {
    return nd(i) + "scale(" + e + ")";
  }
}, FD = {
  custom: dK,
  slide: rp,
  slideIn: rp,
  slideOut: rp,
  fade: ap,
  fadeIn: ap,
  fadeOut: ap,
  pop: hK,
  css: uK
}, pK = function(i) {
  const e = FD[i.type];
  if (!e)
    throw Ae.Error("E0011", i.type);
  return e;
}, gK = {
  type: "custom",
  from: {},
  to: {},
  duration: 400,
  start: M,
  complete: M,
  easing: "ease",
  delay: 0
}, mK = {
  duration: 400,
  easing: "ease",
  delay: 0
};
function fK() {
  const i = this.element, e = this.config;
  if (fm(i, e.from), fm(i, e.to), this.configurator.setup(i, e), i.data("dxAnimData", this), this.strategy.initAnimation(i, e), e.start) {
    const t = ee(i);
    e.start.apply(this, [t, e]);
  }
}
const _K = function(i) {
  const e = i.element, t = i.config;
  if (e.removeData("dxAnimData"), t.complete) {
    const n = ee(e);
    t.complete.apply(this, [n, t]);
  }
  i.deferred.resolveWith(this, [e, t]);
}, CK = function() {
  const i = this, e = i.element, t = i.config;
  return i.isStarted = !0, i.strategy.animate(e, t).done(function() {
    _K(i);
  }).fail(function() {
    i.deferred.rejectWith(this, [e, t]);
  });
}, vK = function(i) {
  const e = this, t = e.element, n = e.config;
  clearTimeout(e.startTimeout), e.isStarted || e.start(), e.strategy.stop(t, n, i);
}, lp = R(On, "dxFXStartAnimation"), xK = function(i) {
  _.off(i.element, lp), _.on(i.element, lp, function() {
    Le.stop(i.element);
  }), i.deferred.always(function() {
    _.off(i.element, lp);
  });
}, kD = function(i, e) {
  const t = e.type === "css" ? mK : gK, n = x(!0, {}, t, e), s = pK(n), o = aK(n), r = {
    element: p(i),
    config: n,
    configurator: s,
    strategy: o,
    isSynchronous: o.isSynchronous,
    setup: fK,
    start: CK,
    stop: vK,
    deferred: new w()
  };
  return B(s.validateConfig) && s.validateConfig(n), xK(r), r;
}, yK = function(i, e) {
  const t = p(i);
  if (!t.length)
    return new w().resolve().promise();
  const n = kD(t, e);
  return bK(t, n), n.deferred.promise();
};
function bK(i, e) {
  const t = __(i);
  wK(i, t), t.push(e), ih(i) || C_(i, t);
}
function __(i) {
  return i.data("dxAnimQueue") || [];
}
function wK(i, e) {
  i.data("dxAnimQueue", e);
}
const VD = function(i) {
  i.removeData("dxAnimQueue");
};
function ih(i) {
  return !!i.data("dxAnimData");
}
function C_(i, e) {
  if (e = __(i), !e.length)
    return;
  const t = e.shift();
  e.length === 0 && VD(i), SK(t).done(function() {
    ih(i) || C_(i);
  });
}
function SK(i) {
  return i.setup(), i.isSynchronous ? i.start() : i.startTimeout = setTimeout(function() {
    i.start();
  }), i.deferred.promise();
}
function fm(i, e) {
  if (!e || !e.position)
    return;
  const t = p(OD);
  let n = 0, s = 0;
  const o = Un.calculate(i, e.position), r = i.offset(), a = i.position();
  a.top > r.top && (s = t.scrollTop()), a.left > r.left && (n = t.scrollLeft()), x(e, {
    left: o.h.location - r.left + a.left - n,
    top: o.v.location - r.top + a.top - s
  }), delete e.position;
}
function _m(i, e) {
  y(e, function(t, n) {
    try {
      i.css(t, B(n) ? n() : n);
    } catch {
    }
  });
}
const EK = function(i, e) {
  const t = p(i), n = __(t);
  y(n, function(o, r) {
    r.config.delay = 0, r.config.duration = 0, r.isSynchronous = !0;
  }), ih(t) || C_(t, n);
  const s = t.data("dxAnimData");
  s && s.stop(e), t.removeData("dxAnimData"), VD(t);
}, Le = {
  off: !1,
  animationTypes: FD,
  animate: yK,
  createAnimation: kD,
  isAnimating: ih,
  stop: EK,
  _simulatedTransitionEndDelay: 100
};
class vn {
  constructor(e, t) {
    t = t || {}, this._action = e, this._context = t.context || fe(), this._beforeExecute = t.beforeExecute, this._afterExecute = t.afterExecute, this._component = t.component, this._validatingTargetName = t.validatingTargetName;
    const n = this._excludeValidators = {};
    if (t.excludeValidators)
      for (let s = 0; s < t.excludeValidators.length; s++)
        n[t.excludeValidators[s]] = !0;
  }
  execute() {
    for (var e = arguments.length, t = new Array(e), n = 0; n < e; n++)
      t[n] = arguments[n];
    const s = {
      action: this._action,
      args: Array.prototype.slice.call(t),
      context: this._context,
      component: this._component,
      validatingTargetName: this._validatingTargetName,
      cancel: !1,
      handled: !1
    }, o = this._beforeExecute, r = this._afterExecute, a = s.args[0] || {};
    if (!this._validateAction(s) || (o?.call(this._context, s), s.cancel))
      return;
    const l = this._executeAction(s);
    if (!a.cancel)
      return r?.call(this._context, s), l;
  }
  _validateAction(e) {
    const t = this._excludeValidators, {
      executors: n
    } = vn;
    for (const o in n)
      if (!t[o]) {
        var s;
        const r = n[o];
        if ((s = r.validate) === null || s === void 0 || s.call(r, e), e.cancel)
          return !1;
      }
    return !0;
  }
  _executeAction(e) {
    let t;
    const {
      executors: n
    } = vn;
    for (const o in n) {
      var s;
      const r = n[o];
      if ((s = r.execute) === null || s === void 0 || s.call(r, e), e.handled) {
        t = e.result;
        break;
      }
    }
    return t;
  }
  static registerExecutor(e, t) {
    if (pe(e)) {
      y(e, vn.registerExecutor);
      return;
    }
    vn.executors[e] = t;
  }
  static unregisterExecutor() {
    for (var e = arguments.length, t = new Array(e), n = 0; n < e; n++)
      t[n] = arguments[n];
    y(t, function() {
      delete vn.executors[this];
    });
  }
}
vn.executors = {};
const ey = (i) => (e) => {
  if (!e.args.length)
    return;
  const t = e.args[0], n = t[e.validatingTargetName] || t.element;
  n && i(p(n)) && (e.cancel = !0);
};
vn.registerExecutor({
  disabled: {
    validate: ey((i) => i.is(".dx-state-disabled, .dx-state-disabled *"))
  },
  readOnly: {
    validate: ey((i) => i.is(".dx-state-readonly, .dx-state-readonly *:not(.dx-state-independent)"))
  },
  undefined: {
    execute: (i) => {
      i.action || (i.result = void 0, i.handled = !0);
    }
  },
  func: {
    execute: (i) => {
      B(i.action) && (i.result = i.action.call(i.context, i.args[0]), i.handled = !0);
    }
  }
});
const IK = function(i, e) {
  return 1 / i === 1 / e;
}, DK = function(i, e) {
  return i = Mt(i, !0), e = Mt(e, !0), i && e && zn(i) && zn(e) ? e.is(i) : i !== i && e !== e ? !0 : i === 0 && e === 0 ? IK(i, e) : i === null || typeof i != "object" || O.isElementNode(i) ? i === e : !1;
}, dp = {}, up = {};
class TK {
  constructor(e, t) {
    this._options = e, this._optionsByReference = t, this._changingCallback, this._changedCallback, this._namePreparedCallbacks, this._validateOptionsCallback;
  }
  _setByReference(e, t) {
    x(!0, e, t);
    for (const n in this._optionsByReference)
      Object.prototype.hasOwnProperty.call(t, n) && (e[n] = t[n]);
  }
  _setPreparedValue(e, t, n, s) {
    const o = this.get(this._options, e, !1);
    if (!DK(o, t)) {
      const r = Jo(e);
      !s && this._changingCallback(e, o, t), up[e] = up[e] || $f(e), up[e](this._options, t, {
        functionsAsIs: !0,
        merge: f(n) ? n : !this._optionsByReference[e],
        unwrapObservables: r.length > 1 && !!this._optionsByReference[r[0]]
      }), !s && this._changedCallback(e, t, o);
    }
  }
  _prepareRelevantNames(e, t, n, s) {
    if (pe(n))
      for (const o in n)
        this._prepareRelevantNames(e, `${t}.${o}`, n[o]);
    this._namePreparedCallbacks(e, t, n, s);
  }
  get() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : this._options, t = arguments.length > 1 ? arguments[1] : void 0, n = arguments.length > 2 ? arguments[2] : void 0;
    return dp[t] = dp[t] || Be(t), dp[t](e, {
      functionsAsIs: !0,
      unwrapObservables: n
    });
  }
  set(e, t, n, s) {
    e = bz(e, t);
    for (const o in e)
      this._prepareRelevantNames(e, o, e[o], s);
    this._validateOptionsCallback && (e = this._validateOptionsCallback(e));
    for (const o in e)
      this._setPreparedValue(o, e[o], n, s);
  }
  onRelevantNamesPrepared(e) {
    this._namePreparedCallbacks = e;
  }
  onChanging(e) {
    this._changingCallback = e;
  }
  onChanged(e) {
    this._changedCallback = e;
  }
  onValidateOptions(e) {
    this._validateOptionsCallback = e;
  }
  dispose() {
    this._changingCallback = M, this._changedCallback = M;
  }
}
class OK {
  constructor(e, t, n, s) {
    this._deprecatedCallback, this._startChangeCallback, this._endChangeCallback, this._validateOptionsCallback, this._default = t, this._deprecated = s, this._deprecatedNames = [], this._initDeprecatedNames(), this._optionManager = new TK(e, n), this._optionManager.onRelevantNamesPrepared((o, r, a, l) => this._setRelevantNames(o, r, a, l)), this._cachedOptions = {}, this._rules = [];
  }
  set _initial(e) {
    this._initialOptions = e;
  }
  get _initial() {
    if (!this._initialOptions) {
      const e = this._getByRules(this.silent("defaultOptionsRules"));
      this._initialOptions = this._default, this._optionManager._setByReference(this._initialOptions, e);
    }
    return this._initialOptions;
  }
  _initDeprecatedNames() {
    for (const e in this._deprecated)
      this._deprecatedNames.push(e);
  }
  _getByRules(e) {
    return e = Array.isArray(e) ? this._rules.concat(e) : this._rules, ia(e);
  }
  _notifyDeprecated(e) {
    const t = this._deprecated[e];
    t && this._deprecatedCallback(e, t);
  }
  _setRelevantNames(e, t, n, s) {
    if (t) {
      const o = this._normalizeName(t, s);
      o && o !== t && (this._setField(e, o, n), this._clearField(e, t));
    }
  }
  _setField(e, t, n) {
    let s = "", o = null;
    do
      s = s ? `.${s}` : "", s = $x(t) + s, t = Nx(t), o = t ? this._optionManager.get(e, t, !1) : e;
    while (!o);
    o[s] = n;
  }
  _clearField(e, t) {
    delete e[t];
    const n = Nx(t), s = n ? this._optionManager.get(e, n, !1) : e;
    s && delete s[$x(t)];
  }
  _normalizeName(e, t) {
    if (this._deprecatedNames.length && e) {
      for (let n = 0; n < this._deprecatedNames.length; n++)
        if (this._deprecatedNames[n] === e) {
          const s = this._deprecated[e];
          if (s)
            return !t && this._notifyDeprecated(e), s.alias || e;
        }
    }
    return e;
  }
  addRules(e) {
    this._rules = e.concat(this._rules);
  }
  applyRules(e) {
    const t = this._getByRules(e);
    this.silent(t);
  }
  dispose() {
    this._deprecatedCallback = M, this._startChangeCallback = M, this._endChangeCallback = M, this._optionManager.dispose();
  }
  onChanging(e) {
    this._optionManager.onChanging(e);
  }
  onChanged(e) {
    this._optionManager.onChanged(e);
  }
  validateOptions(e) {
    this._optionManager.onValidateOptions(e);
  }
  onDeprecated(e) {
    this._deprecatedCallback = e;
  }
  onStartChange(e) {
    this._startChangeCallback = e;
  }
  onEndChange(e) {
    this._endChangeCallback = e;
  }
  isInitial(e) {
    const t = this.silent(e), n = this.initial(e);
    return B(t) && B(n) ? t.toString() === n.toString() : He(t, n);
  }
  initial(e) {
    return Sz(this._initial, e);
  }
  option(e, t) {
    if (arguments.length < 2 && yn(e) !== "object")
      return this._optionManager.get(void 0, this._normalizeName(e));
    this._startChangeCallback();
    try {
      this._optionManager.set(e, t);
    } finally {
      this._endChangeCallback();
    }
  }
  silent(e, t) {
    if (arguments.length < 2 && yn(e) !== "object")
      return this._optionManager.get(void 0, e, void 0, !0);
    this._optionManager.set(e, t, void 0, !0);
  }
  reset(e) {
    if (e) {
      const n = Jo(e).reduce((o, r) => o ? o[r] : this.initial(r), null), s = X(n) ? I({}, n) : n;
      this._optionManager.set(e, s, !1);
    }
  }
  getAliasesByName(e) {
    return Object.keys(this._deprecated).filter((t) => e === this._deprecated[t].alias);
  }
  isDeprecated(e) {
    return Object.prototype.hasOwnProperty.call(this._deprecated, e);
  }
  cache(e, t) {
    if (arguments.length < 2)
      return this._cachedOptions[e];
    this._cachedOptions[e] = x(this._cachedOptions[e], t);
  }
}
class AK {
  constructor() {
    this._postponedOperations = {};
  }
  add(e, t, n) {
    if (e in this._postponedOperations)
      n && this._postponedOperations[e].promises.push(n);
    else {
      const s = new w();
      this._postponedOperations[e] = {
        fn: t,
        completePromise: s,
        promises: n ? [n] : []
      };
    }
    return this._postponedOperations[e].completePromise.promise();
  }
  callPostponedOperations() {
    for (const e in this._postponedOperations) {
      const t = this._postponedOperations[e];
      f(t) && (t.promises && t.promises.length ? W(...t.promises).done(t.fn).then(t.completePromise.resolve) : t.fn().done(t.completePromise.resolve));
    }
    this._postponedOperations = {};
  }
}
const ty = (i) => i.charAt(2).toLowerCase() + i.substr(3), RK = (i) => i.indexOf("_", 0) === 0;
class PD extends se.inherit({}) {
  _setDeprecatedOptions() {
    this._deprecatedOptions = {};
  }
  _getDeprecatedOptions() {
    return this._deprecatedOptions;
  }
  _getDefaultOptions() {
    return {
      onInitialized: null,
      onOptionChanged: null,
      onDisposing: null,
      defaultOptionsRules: null
    };
  }
  _defaultOptionsRules() {
    return [];
  }
  _setOptionsByDevice(e) {
    this._options.applyRules(e);
  }
  _convertRulesToOptions(e) {
    return ia(e);
  }
  _isInitialOptionValue(e) {
    return this._options.isInitial(e);
  }
  _setOptionsByReference() {
    this._optionsByReference = {};
  }
  _getOptionsByReference() {
    return this._optionsByReference;
  }
  ctor() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    const {
      _optionChangedCallbacks: t,
      _disposingCallbacks: n
    } = e;
    this.NAME = Wl(this.constructor), this._eventsStrategy = nr.create(this, e.eventsStrategy), this._updateLockCount = 0, this._optionChangedCallbacks = t || Ie(), this._disposingCallbacks = n || Ie(), this.postponedOperations = new AK(), this._createOptions(e);
  }
  _createOptions(e) {
    this.beginUpdate();
    try {
      this._setOptionsByReference(), this._setDeprecatedOptions(), this._options = new OK(this._getDefaultOptions(), this._getDefaultOptions(), this._getOptionsByReference(), this._getDeprecatedOptions()), this._options.onChanging((t, n, s) => this._initialized && this._optionChanging(t, n, s)), this._options.onDeprecated((t, n) => this._logDeprecatedOptionWarning(t, n)), this._options.onChanged((t, n, s) => this._notifyOptionChanged(t, n, s)), this._options.onStartChange(() => this.beginUpdate()), this._options.onEndChange(() => this.endUpdate()), this._options.addRules(this._defaultOptionsRules()), this._options.validateOptions((t) => this._validateOptions(t)), e && e.onInitializing && e.onInitializing.apply(this, [e]), this._setOptionsByDevice(e.defaultOptionsRules), this._initOptions(e);
    } finally {
      this.endUpdate();
    }
  }
  _initOptions(e) {
    this.option(e);
  }
  _init() {
    this._createOptionChangedAction(), this.on("disposing", (e) => {
      this._disposingCallbacks.fireWith(this, [e]);
    });
  }
  _logDeprecatedOptionWarning(e, t) {
    const n = t.message || `Use the '${t.alias}' option instead`;
    Ae.log("W0001", this.NAME, e, t.since, n);
  }
  _logDeprecatedComponentWarning(e, t) {
    Ae.log("W0000", this.NAME, e, `Use the '${t}' widget instead`);
  }
  _createOptionChangedAction() {
    this._optionChangedAction = this._createActionByOption("onOptionChanged", {
      excludeValidators: ["disabled", "readOnly"]
    });
  }
  _createDisposingAction() {
    this._disposingAction = this._createActionByOption("onDisposing", {
      excludeValidators: ["disabled", "readOnly"]
    });
  }
  _optionChanged(e) {
    const {
      name: t
    } = e;
    switch (t) {
      case "onDisposing":
      case "onInitialized":
      case "defaultOptionsRules":
      default:
        break;
      case "onOptionChanged":
        this._createOptionChangedAction();
    }
  }
  _dispose() {
    var e;
    this._optionChangedCallbacks.empty(), this._createDisposingAction(), (e = this._disposingAction) === null || e === void 0 || e.call(this), this._eventsStrategy.dispose(), this._options.dispose(), this._disposed = !0;
  }
  _lockUpdate() {
    this._updateLockCount++;
  }
  _unlockUpdate() {
    this._updateLockCount = Math.max(this._updateLockCount - 1, 0);
  }
  _isUpdateAllowed() {
    return this._updateLockCount === 0;
  }
  _isInitializingRequired() {
    return !this._initializing && !this._initialized;
  }
  isInitialized() {
    return this._initialized;
  }
  _commitUpdate() {
    this.postponedOperations.callPostponedOperations(), this._isInitializingRequired() && this._initializeComponent();
  }
  _initializeComponent() {
    this._initializing = !0;
    try {
      this._init();
    } finally {
      this._initializing = !1, this._lockUpdate(), this._createActionByOption("onInitialized", {
        excludeValidators: ["disabled", "readOnly"]
      })(), this._unlockUpdate(), this._initialized = !0;
    }
  }
  instance() {
    return this;
  }
  beginUpdate() {
    this._lockUpdate();
  }
  endUpdate() {
    this._unlockUpdate(), this._isUpdateAllowed() && this._commitUpdate();
  }
  _optionChanging() {
  }
  _notifyOptionChanged(e, t, n) {
    if (this._initialized) {
      const o = [e].concat(this._options.getAliasesByName(e));
      for (let r = 0; r < o.length; r++) {
        const a = o[r], l = {
          name: Jo(a)[0],
          fullName: a,
          value: t,
          previousValue: n
        };
        if (!RK(a)) {
          var s;
          this._optionChangedCallbacks.fireWith(this, [x(this._defaultActionArgs(), l)]), (s = this._optionChangedAction) === null || s === void 0 || s.call(this, x({}, l));
        }
        !this._disposed && this._cancelOptionChange !== a && this._optionChanged(l);
      }
    }
  }
  initialOption(e) {
    return this._options.initial(e);
  }
  _defaultActionConfig() {
    return {
      context: this,
      component: this
    };
  }
  _defaultActionArgs() {
    return {
      component: this
    };
  }
  _createAction(e, t) {
    let n;
    return (s) => (f(s) || (s = {}), pe(s) || (s = {
      actionValue: s
    }), n = n || new vn(e, x({}, t, this._defaultActionConfig())), n.execute.call(n, x(s, this._defaultActionArgs())));
  }
  _createActionByOption(e, t) {
    var n = this;
    let s, o, r;
    t = x({}, t);
    const a = function() {
      var d, u;
      if (!o) {
        if (t = t || {}, typeof e != "string")
          throw Ae.Error("E0008");
        e.startsWith("on") && (o = ty(e)), r = n.option(e);
      }
      if (!(!s && !r && !((d = t) !== null && d !== void 0 && d.beforeExecute) && !((u = t) !== null && u !== void 0 && u.afterExecute) && !n._eventsStrategy.hasEvent(o))) {
        if (!s) {
          const {
            beforeExecute: m
          } = t;
          t.beforeExecute = function() {
            for (var C = arguments.length, v = new Array(C), E = 0; E < C; E++)
              v[E] = arguments[E];
            m && m.apply(n, v), n._eventsStrategy.fireEvent(o, v[0].args);
          }, s = n._createAction(r, t);
        }
        for (var c = arguments.length, h = new Array(c), g = 0; g < c; g++)
          h[g] = arguments[g];
        return Pe().wrapActionsBeforeExecute ? ((n.option("beforeActionExecute") || M)(n, s, t) || s).apply(n, h) : s.apply(n, h);
      }
    };
    return Pe().wrapActionsBeforeExecute ? a : (this.option("onActionCreated") || M)(this, a, t) || a;
  }
  on(e, t) {
    return this._eventsStrategy.on(e, t), this;
  }
  off(e, t) {
    return this._eventsStrategy.off(e, t), this;
  }
  hasActionSubscription(e) {
    return !!this._options.silent(e) || this._eventsStrategy.hasEvent(ty(e));
  }
  isOptionDeprecated(e) {
    return this._options.isDeprecated(e);
  }
  _setOptionWithoutOptionChange(e, t) {
    this._cancelOptionChange = e, this.option(e, t), this._cancelOptionChange = !1;
  }
  _getOptionValue(e, t) {
    const n = this.option(e);
    return B(n) ? n.bind(t)() : n;
  }
  option() {
    return this._options.option(...arguments);
  }
  resetOption(e) {
    this.beginUpdate(), this._options.reset(e), this.endUpdate();
  }
  _validateOptions(e) {
    return e;
  }
}
const Bd = {
  forward: " dx-forward",
  backward: " dx-backward",
  none: " dx-no-direction",
  undefined: " dx-no-direction"
}, FK = PD.inherit({
  ctor: function() {
    this.callBase.apply(this, arguments), this._registeredPresets = [], this.resetToDefaults();
  },
  _getDefaultOptions: function() {
    return x(this.callBase(), {
      defaultAnimationDuration: 400,
      defaultAnimationDelay: 0,
      defaultStaggerAnimationDuration: 300,
      defaultStaggerAnimationDelay: 40,
      defaultStaggerAnimationStartDelay: 500
    });
  },
  _defaultOptionsRules: function() {
    return this.callBase().concat([{
      device: function(i) {
        return i.phone;
      },
      options: {
        defaultStaggerAnimationDuration: 350,
        defaultStaggerAnimationDelay: 50,
        defaultStaggerAnimationStartDelay: 0
      }
    }, {
      device: function() {
        return z.current().android || z.real.android;
      },
      options: {
        defaultAnimationDelay: 100
      }
    }]);
  },
  _getPresetOptionName: function(i) {
    return "preset_" + i;
  },
  _createAndroidSlideAnimationConfig: function(i, e) {
    const t = this, n = function(s) {
      return {
        type: "slide",
        delay: s.delay === void 0 ? t.option("defaultAnimationDelay") : s.delay,
        duration: s.duration === void 0 ? t.option("defaultAnimationDuration") : s.duration
      };
    };
    return {
      enter: function(s, o) {
        const r = ne(s.parent()) * e, a = o.direction, l = n(o);
        return l.to = {
          left: 0,
          opacity: 1
        }, a === "forward" ? l.from = {
          left: r,
          opacity: i
        } : a === "backward" ? l.from = {
          left: -r,
          opacity: i
        } : l.from = {
          left: 0,
          opacity: 0
        }, Le.createAnimation(s, l);
      },
      leave: function(s, o) {
        const r = ne(s.parent()) * e, a = o.direction, l = n(o);
        return l.from = {
          left: 0,
          opacity: 1
        }, a === "forward" ? l.to = {
          left: -r,
          opacity: i
        } : a === "backward" ? l.to = {
          left: r,
          opacity: i
        } : l.to = {
          left: 0,
          opacity: 0
        }, Le.createAnimation(s, l);
      }
    };
  },
  _createOpenDoorConfig: function() {
    const i = this, e = function(t) {
      return {
        type: "css",
        extraCssClasses: "dx-opendoor-animation",
        delay: t.delay === void 0 ? i.option("defaultAnimationDelay") : t.delay,
        duration: t.duration === void 0 ? i.option("defaultAnimationDuration") : t.duration
      };
    };
    return {
      enter: function(t, n) {
        const s = n.direction, o = e(n);
        return o.delay = s === "none" ? o.delay : o.duration, o.from = "dx-enter dx-opendoor-animation" + Bd[s], o.to = "dx-enter-active", Le.createAnimation(t, o);
      },
      leave: function(t, n) {
        const s = n.direction, o = e(n);
        return o.from = "dx-leave dx-opendoor-animation" + Bd[s], o.to = "dx-leave-active", Le.createAnimation(t, o);
      }
    };
  },
  _createWinPopConfig: function() {
    const i = this, e = {
      type: "css",
      extraCssClasses: "dx-win-pop-animation",
      duration: i.option("defaultAnimationDuration")
    };
    return {
      enter: function(t, n) {
        const s = e, o = n.direction;
        return s.delay = o === "none" ? i.option("defaultAnimationDelay") : i.option("defaultAnimationDuration") / 2, s.from = "dx-enter dx-win-pop-animation" + Bd[o], s.to = "dx-enter-active", Le.createAnimation(t, s);
      },
      leave: function(t, n) {
        const s = e, o = n.direction;
        return s.delay = i.option("defaultAnimationDelay"), s.from = "dx-leave dx-win-pop-animation" + Bd[o], s.to = "dx-leave-active", Le.createAnimation(t, s);
      }
    };
  },
  resetToDefaults: function() {
    this.clear(), this.registerDefaultPresets(), this.applyChanges();
  },
  clear: function(i) {
    const e = this, t = [];
    y(this._registeredPresets, function(n, s) {
      !i || i === s.name ? e.option(e._getPresetOptionName(s.name), void 0) : t.push(s);
    }), this._registeredPresets = t, this.applyChanges();
  },
  registerPreset: function(i, e) {
    this._registeredPresets.push({
      name: i,
      config: e
    });
  },
  applyChanges: function() {
    const i = this, e = [];
    y(this._registeredPresets, function(t, n) {
      const s = {
        device: n.config.device,
        options: {}
      };
      s.options[i._getPresetOptionName(n.name)] = n.config.animation, e.push(s);
    }), this._setOptionsByDevice(e);
  },
  getPreset: function(i) {
    let e = i;
    for (; typeof e == "string"; )
      e = this.option(this._getPresetOptionName(e));
    return e;
  },
  registerDefaultPresets: function() {
    this.registerPreset("pop", {
      animation: {
        extraCssClasses: "dx-android-pop-animation",
        delay: this.option("defaultAnimationDelay"),
        duration: this.option("defaultAnimationDuration")
      }
    }), this.registerPreset("openDoor", {
      animation: this._createOpenDoorConfig()
    }), this.registerPreset("win-pop", {
      animation: this._createWinPopConfig()
    }), this.registerPreset("fade", {
      animation: {
        extraCssClasses: "dx-fade-animation",
        delay: this.option("defaultAnimationDelay"),
        duration: this.option("defaultAnimationDuration")
      }
    }), this.registerPreset("slide", {
      device: function() {
        return z.current().android || z.real.android;
      },
      animation: this._createAndroidSlideAnimationConfig(1, 1)
    }), this.registerPreset("slide", {
      device: function() {
        return !z.current().android && !z.real.android;
      },
      animation: {
        extraCssClasses: "dx-slide-animation",
        delay: this.option("defaultAnimationDelay"),
        duration: this.option("defaultAnimationDuration")
      }
    }), this.registerPreset("ios7-slide", {
      animation: {
        extraCssClasses: "dx-ios7-slide-animation",
        delay: this.option("defaultAnimationDelay"),
        duration: this.option("defaultAnimationDuration")
      }
    }), this.registerPreset("overflow", {
      animation: {
        extraCssClasses: "dx-overflow-animation",
        delay: this.option("defaultAnimationDelay"),
        duration: this.option("defaultAnimationDuration")
      }
    }), this.registerPreset("ios7-toolbar", {
      device: function() {
        return !z.current().android && !z.real.android;
      },
      animation: {
        extraCssClasses: "dx-ios7-toolbar-animation",
        delay: this.option("defaultAnimationDelay"),
        duration: this.option("defaultAnimationDuration")
      }
    }), this.registerPreset("ios7-toolbar", {
      device: function() {
        return z.current().android || z.real.android;
      },
      animation: this._createAndroidSlideAnimationConfig(0, 0.4)
    }), this.registerPreset("stagger-fade", {
      animation: {
        extraCssClasses: "dx-fade-animation",
        staggerDelay: this.option("defaultStaggerAnimationDelay"),
        duration: this.option("defaultStaggerAnimationDuration"),
        delay: this.option("defaultStaggerAnimationStartDelay")
      }
    }), this.registerPreset("stagger-slide", {
      animation: {
        extraCssClasses: "dx-slide-animation",
        staggerDelay: this.option("defaultStaggerAnimationDelay"),
        duration: this.option("defaultStaggerAnimationDuration"),
        delay: this.option("defaultStaggerAnimationStartDelay")
      }
    }), this.registerPreset("stagger-fade-slide", {
      animation: {
        extraCssClasses: "dx-fade-slide-animation",
        staggerDelay: this.option("defaultStaggerAnimationDelay"),
        duration: this.option("defaultStaggerAnimationDuration"),
        delay: this.option("defaultStaggerAnimationStartDelay")
      }
    }), this.registerPreset("stagger-drop", {
      animation: {
        extraCssClasses: "dx-drop-animation",
        staggerDelay: this.option("defaultStaggerAnimationDelay"),
        duration: this.option("defaultStaggerAnimationDuration"),
        delay: this.option("defaultStaggerAnimationStartDelay")
      }
    }), this.registerPreset("stagger-fade-drop", {
      animation: {
        extraCssClasses: "dx-fade-drop-animation",
        staggerDelay: this.option("defaultStaggerAnimationDelay"),
        duration: this.option("defaultStaggerAnimationDuration"),
        delay: this.option("defaultStaggerAnimationStartDelay")
      }
    }), this.registerPreset("stagger-fade-rise", {
      animation: {
        extraCssClasses: "dx-fade-rise-animation",
        staggerDelay: this.option("defaultStaggerAnimationDelay"),
        duration: this.option("defaultStaggerAnimationDuration"),
        delay: this.option("defaultStaggerAnimationStartDelay")
      }
    }), this.registerPreset("stagger-3d-drop", {
      animation: {
        extraCssClasses: "dx-3d-drop-animation",
        staggerDelay: this.option("defaultStaggerAnimationDelay"),
        duration: this.option("defaultStaggerAnimationDuration"),
        delay: this.option("defaultStaggerAnimationStartDelay")
      }
    }), this.registerPreset("stagger-fade-zoom", {
      animation: {
        extraCssClasses: "dx-fade-zoom-animation",
        staggerDelay: this.option("defaultStaggerAnimationDelay"),
        duration: this.option("defaultStaggerAnimationDuration"),
        delay: this.option("defaultStaggerAnimationStartDelay")
      }
    });
  }
}), kK = new FK(), VK = {
  forward: " dx-forward",
  backward: " dx-backward",
  none: " dx-no-direction",
  undefined: " dx-no-direction"
};
se.inherit({
  ctor: function() {
    this._accumulatedDelays = {
      enter: 0,
      leave: 0
    }, this._animations = [], this.reset();
  },
  _createAnimations: function(i, e, t, n) {
    i = p(i);
    const s = this, o = [];
    t = t || {};
    const r = this._prepareElementAnimationConfig(e, t, n);
    return r && i.each(function() {
      const a = s._createAnimation(p(this), r, t);
      a && (a.element.addClass("dx-animating"), a.setup(), o.push(a));
    }), o;
  },
  _prepareElementAnimationConfig: function(i, e, t) {
    let n;
    if (typeof i == "string") {
      const s = i;
      i = kK.getPreset(s);
    }
    if (!i)
      n = void 0;
    else if (B(i[t]))
      n = i[t];
    else {
      if (n = x({
        skipElementInitialStyles: !0,
        cleanupWhen: this._completePromise
      }, i, e), !n.type || n.type === "css") {
        const s = "dx-" + t, o = (n.extraCssClasses ? " " + n.extraCssClasses : "") + VK[n.direction];
        n.type = "css", n.from = (n.from || s) + o, n.to = n.to || s + "-active";
      }
      n.staggerDelay = n.staggerDelay || 0, n.delay = n.delay || 0, n.staggerDelay && (n.delay += this._accumulatedDelays[t], this._accumulatedDelays[t] += n.staggerDelay);
    }
    return n;
  },
  _createAnimation: function(i, e, t) {
    let n;
    return pe(e) ? n = Le.createAnimation(i, e) : B(e) && (n = e(i, t)), n;
  },
  _startAnimations: function() {
    const i = this._animations;
    for (let e = 0; e < i.length; e++)
      i[e].start();
  },
  _stopAnimations: function(i) {
    const e = this._animations;
    for (let t = 0; t < e.length; t++)
      e[t].stop(i);
  },
  _clearAnimations: function() {
    const i = this._animations;
    for (let e = 0; e < i.length; e++)
      i[e].element.removeClass("dx-animating");
    this._animations.length = 0;
  },
  reset: function() {
    this._accumulatedDelays.enter = 0, this._accumulatedDelays.leave = 0, this._clearAnimations(), this._completeDeferred = new w(), this._completePromise = this._completeDeferred.promise();
  },
  enter: function(i, e, t) {
    const n = this._createAnimations(i, e, t, "enter");
    this._animations.push.apply(this._animations, n);
  },
  leave: function(i, e, t) {
    const n = this._createAnimations(i, e, t, "leave");
    this._animations.push.apply(this._animations, n);
  },
  start: function() {
    const i = this;
    let e;
    if (!this._animations.length)
      i.reset(), e = new w().resolve().promise();
    else {
      const t = mt(this._animations, function(n) {
        const s = new w();
        return n.deferred.always(function() {
          s.resolve();
        }), s.promise();
      });
      e = W.apply(p, t).always(function() {
        i._completeDeferred.resolve(), i.reset();
      }), Wf.executeAsync(function() {
        i._startAnimations();
      });
    }
    return e;
  },
  stop: function(i) {
    this._stopAnimations(i);
  }
});
const sh = se.inherit({
  ctor(i) {
    this._$element = p(i), this._cancelCallback = Ie(), this._acceptCallback = Ie();
  },
  getElement() {
    return this._$element;
  },
  validate: (i) => !ln(i),
  validatePointers: (i) => oW(i) === 1,
  allowInterruptionByMouseWheel: () => !0,
  configure(i) {
    x(this, i);
  },
  addCancelCallback(i) {
    this._cancelCallback.add(i);
  },
  removeCancelCallback() {
    this._cancelCallback.empty();
  },
  _cancel(i) {
    this._cancelCallback.fire(this, i);
  },
  addAcceptCallback(i) {
    this._acceptCallback.add(i);
  },
  removeAcceptCallback() {
    this._acceptCallback.empty();
  },
  _accept(i) {
    this._acceptCallback.fire(this, i);
  },
  _requestAccept(i) {
    this._acceptRequestEvent = i;
  },
  _forgetAccept() {
    this._accept(this._acceptRequestEvent), this._acceptRequestEvent = null;
  },
  start: M,
  move: M,
  end: M,
  cancel: M,
  reset() {
    this._acceptRequestEvent && this._accept(this._acceptRequestEvent);
  },
  _fireEvent(i, e, t) {
    const n = x({
      type: i,
      originalEvent: e,
      target: this._getEmitterTarget(e),
      delegateTarget: this.getElement().get(0)
    }, t);
    return e = oo(n), e.cancel && this._cancel(e), e;
  },
  _getEmitterTarget(i) {
    return (this.delegateSelector ? p(i.target).closest(this.delegateSelector) : this.getElement()).get(0);
  },
  dispose: M
}), sd = "dxmousewheel", Cm = {
  setup(i) {
    const e = p(i);
    _.on(e, R("wheel", "dxWheel"), Cm._wheelHandler.bind(Cm));
  },
  teardown(i) {
    _.off(i, ".dxWheel");
  },
  _wheelHandler(i) {
    const {
      deltaMode: e,
      deltaY: t,
      deltaX: n,
      deltaZ: s
    } = i.originalEvent;
    oo({
      type: sd,
      originalEvent: i,
      delta: this._normalizeDelta(t, e),
      deltaX: n,
      deltaY: t,
      deltaZ: s,
      deltaMode: e,
      pointerType: "mouse"
    }), i.stopPropagation();
  },
  _normalizeDelta(i) {
    return (arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0) === 0 ? -i : -30 * i;
  }
};
Yn(sd, Cm);
const v_ = se.inherit({
  ctor(i, e) {
    this._eventName = i, this._originalEvents = R(e, "dxPointerEvents"), this._handlerCount = 0, this.noBubble = this._isNoBubble();
  },
  _isNoBubble() {
    const i = this._eventName;
    return i === "dxpointerenter" || i === "dxpointerleave";
  },
  _handler(i) {
    const e = this._getDelegateTarget(i), t = {
      type: this._eventName,
      pointerType: i.pointerType || Xl(i),
      originalEvent: i,
      delegateTarget: e,
      timeStamp: ze.mozilla ? (/* @__PURE__ */ new Date()).getTime() : i.timeStamp
    }, n = Mf(i);
    return t.target = n, this._fireEvent(t);
  },
  _getDelegateTarget(i) {
    let e;
    return this.noBubble && (e = i.delegateTarget), e;
  },
  _fireEvent: (i) => oo(i),
  _setSelector(i) {
    this._selector = this.noBubble && i ? i.selector : null;
  },
  _getSelector() {
    return this._selector;
  },
  setup: () => !0,
  add(i, e) {
    if (this._handlerCount <= 0 || this.noBubble) {
      i = this.noBubble ? i : O.getDocument(), this._setSelector(e);
      const t = this;
      _.on(i, this._originalEvents, this._getSelector(), (n) => {
        t._handler(n);
      });
    }
    this.noBubble || this._handlerCount++;
  },
  remove(i) {
    this._setSelector(i), this.noBubble || this._handlerCount--;
  },
  teardown(i) {
    this._handlerCount && !this.noBubble || (i = this.noBubble ? i : O.getDocument(), this._originalEvents !== ".dxPointerEvents" && _.off(i, this._originalEvents, this._getSelector()));
  },
  dispose(i) {
    i = this.noBubble ? i : O.getDocument(), _.off(i, this._originalEvents);
  }
}), $d = function(i, e) {
  Bi.add(() => {
    i.split(" ").forEach((t) => {
      O.listen(O.getDocument(), t, e, !0);
    });
  });
}, PK = function(i, e, t) {
  t = t || function() {
  };
  let n = [];
  const s = function(r) {
    let a = -1;
    return y(n, (l, d) => e(r, d) ? (a = l, !1) : !0), a;
  }, o = function(r) {
    const a = s(r);
    a > -1 && n.splice(a, 1);
  };
  $d(i.dxpointerdown, function(r) {
    s(r) === -1 && (t(r), n.push(r));
  }), $d(i.dxpointermove, function(r) {
    n[s(r)] = r;
  }), $d(i.dxpointerup, o), $d(i.dxpointercancel, o), this.pointers = function() {
    return n;
  }, this.reset = function() {
    n = [];
  };
}, x_ = {
  dxpointerdown: "mousedown",
  dxpointermove: "mousemove",
  dxpointerup: "mouseup",
  dxpointercancel: "pointercancel",
  dxpointerover: "mouseover",
  dxpointerout: "mouseout",
  dxpointerenter: "mouseenter",
  dxpointerleave: "mouseleave"
};
ze.safari && (x_.dxpointercancel += " dragstart");
const MD = function(i) {
  return i.pointerId = 1, {
    pointers: y_.pointers(),
    pointerId: 1
  };
};
let y_, ny = !1;
const BD = function() {
  ny || (y_ = new PK(x_, () => !0), ny = !0);
}, xs = v_.inherit({
  ctor() {
    this.callBase.apply(this, arguments), BD();
  },
  _fireEvent(i) {
    return this.callBase(x(MD(i.originalEvent), i));
  }
});
xs.map = x_;
xs.normalize = MD;
xs.activate = BD;
xs.resetObserver = function() {
  y_.reset();
};
const MK = {
  dxpointerdown: "touchstart",
  dxpointermove: "touchmove",
  dxpointerup: "touchend",
  dxpointercancel: "touchcancel",
  dxpointerover: "",
  dxpointerout: "",
  dxpointerenter: "",
  dxpointerleave: ""
}, $D = function(i) {
  const e = [];
  return y(i.touches, (t, n) => {
    e.push(x({
      pointerId: n.identifier
    }, n));
  }), {
    pointers: e,
    pointerId: i.changedTouches[0].identifier
  };
}, BK = function(i) {
  return z.real().platform === "ios" && (i === "dxpointerdown" || i === "dxpointerup");
}, od = v_.inherit({
  ctor() {
    this.callBase.apply(this, arguments), this._pointerId = 0;
  },
  _handler(i) {
    if (BK(this._eventName)) {
      const e = i.changedTouches[0];
      if (this._pointerId === e.identifier && this._pointerId !== 0)
        return;
      this._pointerId = e.identifier;
    }
    return this.callBase.apply(this, arguments);
  },
  _fireEvent(i) {
    return this.callBase(x($D(i.originalEvent), i));
  }
});
od.map = MK;
od.normalize = $D;
const $K = {
  dxpointerdown: "touchstart mousedown",
  dxpointermove: "touchmove mousemove",
  dxpointerup: "touchend mouseup",
  dxpointercancel: "touchcancel",
  dxpointerover: "mouseover",
  dxpointerout: "mouseout",
  dxpointerenter: "mouseenter",
  dxpointerleave: "mouseleave"
};
let iy = !1;
const NK = function() {
  iy || (xs.activate(), iy = !0);
}, oh = v_.inherit({
  EVENT_LOCK_TIMEOUT: 100,
  ctor() {
    this.callBase.apply(this, arguments), NK();
  },
  _handler(i) {
    const e = jo(i);
    if (e || (this._skipNextEvents = !0), !(e && this._mouseLocked)) {
      if (e && this._skipNextEvents) {
        this._skipNextEvents = !1, this._mouseLocked = !0, clearTimeout(this._unlockMouseTimer);
        const t = this;
        this._unlockMouseTimer = setTimeout(() => {
          t._mouseLocked = !1;
        }, this.EVENT_LOCK_TIMEOUT);
        return;
      }
      return this.callBase(i);
    }
  },
  _fireEvent(i) {
    const e = jo(i.originalEvent) ? xs.normalize : od.normalize;
    return this.callBase(x(e(i.originalEvent), i));
  },
  dispose() {
    this.callBase(), this._skipNextEvents = !1, this._mouseLocked = !1, clearTimeout(this._unlockMouseTimer);
  }
});
oh.map = $K;
oh.resetObserver = xs.resetObserver;
const LK = (i, e) => {
  let {
    tablet: t,
    phone: n
  } = e;
  const s = HK();
  return s || (i.touch && !(t || n) ? oh : i.touch ? od : xs);
}, sy = LK(tn, z.real());
y(sy.map, (i, e) => {
  Yn(i, new sy(i, e));
});
const ye = {
  down: "dxpointerdown",
  up: "dxpointerup",
  move: "dxpointermove",
  cancel: "dxpointercancel",
  enter: "dxpointerenter",
  leave: "dxpointerleave",
  over: "dxpointerover",
  out: "dxpointerout"
};
function HK() {
  const i = Pe().pointerEventStrategy;
  return {
    "mouse-and-touch": oh,
    touch: od,
    mouse: xs
  }[i];
}
const Nd = "dxEventManager", WK = se.inherit({
  ctor() {
    this._attachHandlers(), this.reset(), this._proxiedCancelHandler = this._cancelHandler.bind(this), this._proxiedAcceptHandler = this._acceptHandler.bind(this);
  },
  _attachHandlers() {
    Bi.add(() => {
      const i = O.getDocument();
      _.subscribeGlobal(i, R(ye.down, Nd), this._pointerDownHandler.bind(this)), _.subscribeGlobal(i, R(ye.move, Nd), this._pointerMoveHandler.bind(this)), _.subscribeGlobal(i, R([ye.up, ye.cancel].join(" "), Nd), this._pointerUpHandler.bind(this)), _.subscribeGlobal(i, R(sd, Nd), this._mouseWheelHandler.bind(this));
    });
  },
  _eachEmitter(i) {
    const e = this._activeEmitters || [];
    let t = 0;
    for (; e.length > t; ) {
      const n = e[t];
      if (i(n) === !1)
        break;
      e[t] === n && t++;
    }
  },
  _applyToEmitters(i, e) {
    this._eachEmitter((t) => {
      t[i].call(t, e);
    });
  },
  reset() {
    this._eachEmitter(this._proxiedCancelHandler), this._activeEmitters = [];
  },
  resetEmitter(i) {
    this._proxiedCancelHandler(i);
  },
  _pointerDownHandler(i) {
    jo(i) && i.which > 1 || this._updateEmitters(i);
  },
  _updateEmitters(i) {
    this._isSetChanged(i) && (this._cleanEmitters(i), this._fetchEmitters(i));
  },
  _isSetChanged(i) {
    const e = this._closestEmitter(i), t = this._emittersSet || [];
    let n = e.length !== t.length;
    return y(e, (s, o) => (n = n || t[s] !== o, !n)), this._emittersSet = e, n;
  },
  _closestEmitter(i) {
    const e = this, t = [];
    let n = p(i.target);
    function s(o, r) {
      r && r.validatePointers(i) && r.validate(i) && (r.addCancelCallback(e._proxiedCancelHandler), r.addAcceptCallback(e._proxiedAcceptHandler), t.push(r));
    }
    for (; n.length; ) {
      const o = tt(n.get(0), "dxEmitter") || [];
      y(o, s), n = n.parent();
    }
    return t;
  },
  _acceptHandler(i, e) {
    this._eachEmitter((t) => {
      t !== i && this._cancelEmitter(t, e);
    });
  },
  _cancelHandler(i, e) {
    this._cancelEmitter(i, e);
  },
  _cancelEmitter(i, e) {
    const t = this._activeEmitters;
    e ? i.cancel(e) : i.reset(), i.removeCancelCallback(), i.removeAcceptCallback();
    const n = t.indexOf(i);
    n > -1 && t.splice(n, 1);
  },
  _cleanEmitters(i) {
    this._applyToEmitters("end", i), this.reset(i);
  },
  _fetchEmitters(i) {
    this._activeEmitters = this._emittersSet.slice(), this._applyToEmitters("start", i);
  },
  _pointerMoveHandler(i) {
    this._applyToEmitters("move", i);
  },
  _pointerUpHandler(i) {
    this._updateEmitters(i);
  },
  _mouseWheelHandler(i) {
    this._allowInterruptionByMouseWheel() && (i.pointers = [null], this._pointerDownHandler(i), this._adjustWheelEvent(i), this._pointerMoveHandler(i), i.pointers = [], this._pointerUpHandler(i));
  },
  _allowInterruptionByMouseWheel() {
    let i = !0;
    return this._eachEmitter((e) => (i = e.allowInterruptionByMouseWheel() && i, i)), i;
  },
  _adjustWheelEvent(i) {
    let e = null;
    if (this._eachEmitter((o) => {
      if (!o.gesture)
        return;
      const r = o.getDirection(i);
      if (r !== "horizontal" && !i.shiftKey || r !== "vertical" && i.shiftKey)
        return e = o, !1;
    }), !e)
      return;
    const t = e.getDirection(i), s = t === "both" && !i.shiftKey || t === "vertical" ? "pageY" : "pageX";
    i[s] += i.delta;
  },
  isActive(i) {
    let e = !1;
    return this._eachEmitter((t) => {
      e = e || t.getElement().is(i);
    }), e;
  }
}), oy = new WK(), ha = function(i) {
  const e = i.emitter, t = i.events[0], n = i.events;
  y(n, (s, o) => {
    Yn(o, {
      noBubble: !i.bubble,
      setup(r) {
        const a = tt(r, "dxEmitterSubscription") || {}, l = tt(r, "dxEmitter") || {}, d = l[t] || new e(r);
        a[o] = !0, l[t] = d, tt(r, "dxEmitter", l), tt(r, "dxEmitterSubscription", a);
      },
      add(r, a) {
        tt(r, "dxEmitter")[t].configure(x({
          delegateSelector: a.selector
        }, a.data), a.type);
      },
      teardown(r) {
        const a = tt(r, "dxEmitterSubscription"), l = tt(r, "dxEmitter"), d = l[t];
        delete a[o];
        let u = !0;
        y(n, (c, h) => (u = u && !a[h], u)), u && (oy.isActive(r) && oy.resetEmitter(d), d && d.dispose(), delete l[t]);
      }
    });
  });
};
function ND(i) {
  return i && [i.target, i.delegateTarget, i.relatedTarget, i.currentTarget].filter((e) => !!e);
}
const zK = (i, e) => {
  _.one(ND(i), On, e);
}, KK = (i, e) => {
  _.off(ND(i), On, e);
}, b_ = fe(), GK = (i) => {
  if (!i.getRootNode)
    return;
  const {
    host: e
  } = i.getRootNode();
  if (!te(e))
    return e;
}, UK = () => {
  const i = O.getActiveElement();
  if (i && i !== O.getBody()) {
    var e;
    (e = i.blur) === null || e === void 0 || e.call(i);
  }
}, jK = () => {
  const i = b_.getSelection();
  if (i && i.type !== "Caret") {
    if (i.empty)
      i.empty();
    else if (i.removeAllRanges)
      try {
        i.removeAllRanges();
      } catch {
      }
  }
}, LD = (i, e) => {
  const t = p(i), n = p(e);
  if (t[0] === n[0])
    return t[0];
  const s = t.parents(), o = n.parents(), r = Math.min(s.length, o.length);
  for (let a = -r; a < 0; a++)
    if (s.get(a) === o.get(a))
      return s.get(a);
}, qK = (i) => {
  i = p(i);
  const e = i.length && i.filter(function() {
    const t = p(this);
    return t.is("script[type]") && !t.attr("type").includes("script");
  });
  return e.length ? e.eq(0).html() : (i = p("<div>").append(i), i.html());
}, rh = (i) => {
  let e = f(i) && (i.nodeType || zn(i)) ? p(i) : p("<div>").html(i).contents();
  return e.length === 1 && (e.is("script") ? e = rh(e.html().trim()) : e.is("table") && (e = e.children("tbody").contents())), e;
}, cc = (i, e) => {
  const t = i.originalEvent && i.originalEvent.clipboardData || b_.clipboardData;
  if (!e)
    return t && t.getData("Text");
  t && t.setData("Text", e);
}, Xs = (i, e) => e ? lt(i) ? Xs(i.document, e) : i.contains(e) || Xs(i, GK(e)) : !1, HD = (i, e, t) => {
  const n = b_.getComputedStyle(p(i).get(0)), s = t && t.includePaddings;
  return p("<div>").text(e).css({
    fontStyle: n.fontStyle,
    fontVariant: n.fontVariant,
    fontWeight: n.fontWeight,
    fontSize: n.fontSize,
    fontFamily: n.fontFamily,
    letterSpacing: n.letterSpacing,
    border: n.border,
    paddingTop: s ? n.paddingTop : "",
    paddingRight: s ? n.paddingRight : "",
    paddingBottom: s ? n.paddingBottom : "",
    paddingLeft: s ? n.paddingLeft : "",
    visibility: "hidden",
    whiteSpace: "pre",
    position: "absolute",
    float: "left"
  });
}, WD = (i, e) => (e && O.insertElement(i.parentNode, e, i), i), zD = (i, e) => {
  if (e && e[0])
    return e.is(i) ? i : (y(e, (t, n) => {
      WD(i[0], n);
    }), i.remove(), e);
}, pa = (i) => {
  const e = i?.get(0), t = e?.getRootNode().host;
  return !!p(t || e).closest(fe().document).length;
}, li = {
  resetActiveElement: UK,
  clearSelection: jK,
  closestCommonParent: LD,
  extractTemplateMarkup: qK,
  normalizeTemplateElement: rh,
  clipboardText: cc,
  contains: Xs,
  createTextElementHiddenCopy: HD,
  insertBefore: WD,
  replaceWith: zD,
  isElementInDom: pa
}, Te = "dxclick";
let vm = null, Ya = null;
const ry = () => {
  Ya = null;
}, ay = function(i) {
  const {
    originalEvent: e
  } = i, t = Ya === e || e && e.DXCLICK_FIRED;
  (!i.which || i.which === 1) && !vm && !t && (e && (e.DXCLICK_FIRED = !0), KK(Ya, ry), Ya = e, zK(Ya, ry), oo({
    type: "dxclick",
    originalEvent: i
  }));
}, YK = sh.inherit({
  ctor(i) {
    this.callBase(i), _.on(this.getElement(), "click", ay);
  },
  start() {
    vm = null;
  },
  cancel() {
    vm = !0;
  },
  dispose() {
    _.off(this.getElement(), "click", ay);
  }
});
(function() {
  if (!z.real().generic) {
    let e = null, t = !1;
    const n = function(d) {
      return p(d).is("input, textarea, select, button ,:focus, :focus *");
    }, s = function(d) {
      e = d.target, t = d.isDefaultPrevented();
    }, o = function(d) {
      const u = Mf(d);
      return p(u);
    }, r = function(d) {
      const u = o(d);
      !t && e && !u.is(e) && !p(e).is("label") && n(u) && li.resetActiveElement(), e = null, t = !1;
    }, a = "NATIVE_CLICK_FIXER", l = O.getDocument();
    _.subscribeGlobal(l, R(ye.down, a), s), _.subscribeGlobal(l, R("click", a), r);
  }
})();
ha({
  emitter: YK,
  bubble: !0,
  events: ["dxclick"]
});
const rd = "dxhoverstart", XK = R(ye.enter, "dxHoverStart"), ad = "dxhoverend", ZK = R(ye.leave, "dxHoverEnd"), KD = se.inherit({
  noBubble: !0,
  ctor() {
    this._handlerArrayKeyPath = `${this._eventNamespace}_HandlerStore`;
  },
  setup(i) {
    tt(i, this._handlerArrayKeyPath, {});
  },
  add(i, e) {
    const t = this, n = function(s) {
      t._handler(s);
    };
    _.on(i, this._originalEventName, e.selector, n), tt(i, this._handlerArrayKeyPath)[e.guid] = n;
  },
  _handler(i) {
    Zl(i) || z.isSimulator() || oo({
      type: this._eventName,
      originalEvent: i,
      delegateTarget: i.delegateTarget
    });
  },
  remove(i, e) {
    const t = tt(i, this._handlerArrayKeyPath)[e.guid];
    _.off(i, this._originalEventName, e.selector, t);
  },
  teardown(i) {
    qc(i, this._handlerArrayKeyPath);
  }
}), QK = KD.inherit({
  ctor() {
    this._eventNamespace = "dxHoverStart", this._eventName = rd, this._originalEventName = XK, this.callBase();
  },
  _handler(i) {
    (i.pointers || []).length || this.callBase(i);
  }
}), JK = KD.inherit({
  ctor() {
    this._eventNamespace = "dxHoverEnd", this._eventName = ad, this._originalEventName = ZK, this.callBase();
  }
});
Yn(rd, new QK());
Yn(ad, new JK());
const dn = l_(void 0), eG = {};
class GD extends bn {
  constructor() {
    super(...arguments), this.__getterCache = {};
  }
  get config() {
    return this.__getterCache.config !== void 0 ? this.__getterCache.config : this.__getterCache.config = (() => ({
      rtlEnabled: this.props.rtlEnabled
    }))();
  }
  componentWillUpdate(e) {
    this.props.rtlEnabled !== e.rtlEnabled && (this.__getterCache.config = void 0);
  }
  getChildContext() {
    return I({}, this.context, {
      [dn.id]: this.config || dn.defaultValue
    });
  }
  render() {
    return this.props.children;
  }
}
GD.defaultProps = eG;
const ld = (i) => Object.keys(i).filter((e) => !!e && i[e]).join(" ");
function tG(i, e) {
  return i !== void 0 ? i : e?.rtlEnabled !== void 0 ? e.rtlEnabled : Pe().rtlEnabled;
}
function nG(i, e) {
  const t = f(i), n = f(Pe().rtlEnabled) && !t && !f(e?.rtlEnabled);
  return t && i !== e?.rtlEnabled || n;
}
const dd = {
  className: "",
  activeStateEnabled: !1,
  disabled: !1,
  focusStateEnabled: !1,
  hoverStateEnabled: !1,
  tabIndex: 0,
  visible: !0
}, iG = Bi.add, {
  abs: ly
} = Math;
let hc = 10;
const sG = function() {
  return tr("pointer-events");
}, oG = _s(() => {
  const i = z.real().deviceType === "desktop";
  if (!sG() || !i)
    return M;
  const e = p("<div>").addClass("dx-gesture-cover").css("pointerEvents", "none");
  return _.subscribeGlobal(e, "dxmousewheel", (t) => {
    t.preventDefault();
  }), iG(() => {
    e.appendTo("body");
  }), function(t, n) {
    e.css("pointerEvents", t ? "all" : "none"), t && e.css("cursor", n);
  };
}), rG = function(i, e) {
  oG()(i, e);
}, ud = sh.inherit({
  gesture: !0,
  configure(i) {
    this.getElement().css("msTouchAction", i.immediate ? "pinch-zoom" : ""), this.callBase(i);
  },
  allowInterruptionByMouseWheel() {
    return this._stage !== 2;
  },
  getDirection() {
    return this.direction;
  },
  _cancel() {
    this.callBase.apply(this, arguments), this._toggleGestureCover(!1), this._stage = 0;
  },
  start(i) {
    if (i._needSkipEvent || NI(i)) {
      this._cancel(i);
      return;
    }
    this._startEvent = $s(i), this._startEventData = st(i), this._stage = 1, this._init(i), this._setupImmediateTimer();
  },
  _setupImmediateTimer() {
    if (clearTimeout(this._immediateTimer), this._immediateAccepted = !1, !!this.immediate) {
      if (this.immediateTimeout === 0) {
        this._immediateAccepted = !0;
        return;
      }
      this._immediateTimer = setTimeout(() => {
        this._immediateAccepted = !0;
      }, this.immediateTimeout ?? 180);
    }
  },
  move(i) {
    if (this._stage === 1 && this._directionConfirmed(i)) {
      if (this._stage = 2, this._resetActiveElement(), this._toggleGestureCover(!0), this._clearSelection(i), this._adjustStartEvent(i), this._start(this._startEvent), this._stage === 0)
        return;
      this._requestAccept(i), this._move(i), this._forgetAccept();
    } else
      this._stage === 2 && (this._clearSelection(i), this._move(i));
  },
  _directionConfirmed(i) {
    const e = this._getTouchBoundary(i), t = So(this._startEventData, st(i)), n = ly(t.x), s = ly(t.y), o = this._validateMove(e, n, s), r = this._validateMove(e, s, n), a = this.getDirection(i);
    return a === "both" && (o || r) || a === "horizontal" && o || a === "vertical" && r || this._immediateAccepted;
  },
  _validateMove(i, e, t) {
    return e && e >= i && (this.immediate ? e >= t : !0);
  },
  _getTouchBoundary(i) {
    return this.immediate || ln(i) ? 0 : hc;
  },
  _adjustStartEvent(i) {
    const e = this._getTouchBoundary(i), t = So(this._startEventData, st(i));
    this._startEvent.pageX += na(t.x) * e, this._startEvent.pageY += na(t.y) * e;
  },
  _resetActiveElement() {
    z.real().platform === "ios" && this.getElement().find(":focus").length && li.resetActiveElement();
  },
  _toggleGestureCover(i) {
    this._toggleGestureCoverImpl(i);
  },
  _toggleGestureCoverImpl(i) {
    this._stage === 2 && rG(i, this.getElement().css("cursor"));
  },
  _clearSelection(i) {
    ln(i) || Zl(i) || li.clearSelection();
  },
  end(i) {
    this._toggleGestureCover(!1), this._stage === 2 ? this._end(i) : this._stage === 1 && this._stop(i), this._stage = 0;
  },
  dispose() {
    clearTimeout(this._immediateTimer), this.callBase.apply(this, arguments), this._toggleGestureCover(!1);
  },
  _init: M,
  _start: M,
  _move: M,
  _stop: M,
  _end: M
});
ud.initialTouchBoundary = hc;
ud.touchBoundary = function(i) {
  if (f(i)) {
    hc = i;
    return;
  }
  return hc;
};
const {
  abstract: aG
} = se, lG = z.real(), UD = se.inherit(function() {
  const i = R("scroll", "dxScrollEmitter");
  return {
    ctor(e) {
      this._element = e, this._locked = !1, this._proxiedScroll = (t) => {
        this._disposed || this._scroll(t);
      }, _.on(this._element, i, this._proxiedScroll);
    },
    _scroll: aG,
    check(e, t) {
      this._locked && t();
    },
    dispose() {
      this._disposed = !0, _.off(this._element, i, this._proxiedScroll);
    }
  };
}()), jD = UD.inherit({
  ctor(i, e) {
    this.callBase(i), this._timeout = e;
  },
  _scroll() {
    this._prepare(), this._forget();
  },
  _prepare() {
    this._timer && this._clearTimer(), this._locked = !0;
  },
  _clearTimer() {
    clearTimeout(this._timer), this._locked = !1, this._timer = null;
  },
  _forget() {
    const i = this;
    this._timer = setTimeout(() => {
      i._clearTimer();
    }, this._timeout);
  },
  dispose() {
    this.callBase(), this._clearTimer();
  }
}), dy = jD.inherit({
  ctor(i) {
    this.callBase(i, 400), this._lastWheelDirection = null;
  },
  check(i, e) {
    this._checkDirectionChanged(i), this.callBase(i, e);
  },
  _checkDirectionChanged(i) {
    if (!ln(i)) {
      this._lastWheelDirection = null;
      return;
    }
    const e = i.shiftKey || !1, t = this._lastWheelDirection !== null && e !== this._lastWheelDirection;
    this._lastWheelDirection = e, this._locked = this._locked && !t;
  }
});
let xm = jD.inherit({
  ctor(i) {
    this.callBase(i, 400);
  }
});
(function() {
  const {
    ios: i,
    android: e
  } = lG;
  (i || e) && (xm = UD.inherit({
    _scroll() {
      this._locked = !0;
      const t = this;
      Xi(this._scrollFrame), this._scrollFrame = ac(() => {
        t._locked = !1;
      });
    },
    check(t, n) {
      Xi(this._scrollFrame), Xi(this._checkFrame);
      const s = this, {
        callBase: o
      } = this;
      this._checkFrame = ac(() => {
        o.call(s, t, n), s._locked = !1;
      });
    },
    dispose() {
      this.callBase(), Xi(this._scrollFrame), Xi(this._checkFrame);
    }
  }));
})();
const dG = ud.inherit(function() {
  const i = Math.round(16.666666666666668);
  return {
    ctor(e) {
      this.callBase.apply(this, arguments), this.direction = "both", this._pointerLocker = new xm(e), this._wheelLocker = new dy(e);
    },
    validate: () => !0,
    configure(e) {
      e.scrollTarget && (this._pointerLocker.dispose(), this._wheelLocker.dispose(), this._pointerLocker = new xm(e.scrollTarget), this._wheelLocker = new dy(e.scrollTarget)), this.callBase(e);
    },
    _init(e) {
      this._wheelLocker.check(e, () => {
        ln(e) && this._accept(e);
      }), this._pointerLocker.check(e, () => {
        const t = this.isNative && jo(e);
        !ln(e) && !t && this._accept(e);
      }), this._fireEvent("dxscrollinit", e), this._prevEventData = st(e);
    },
    move(e) {
      this.callBase.apply(this, arguments), e.isScrollingEvent = this.isNative || e.isScrollingEvent;
    },
    _start(e) {
      this._savedEventData = st(e), this._fireEvent("dxscrollstart", e), this._prevEventData = st(e);
    },
    _move(e) {
      const t = st(e);
      this._fireEvent("dxscroll", e, {
        delta: So(this._prevEventData, t)
      }), So(this._savedEventData, t).time > 200 && (this._savedEventData = this._prevEventData), this._prevEventData = st(e);
    },
    _end(e) {
      const t = So(this._prevEventData, st(e));
      let n = {
        x: 0,
        y: 0
      };
      if (!ln(e) && t.time < 100) {
        const s = So(this._savedEventData, this._prevEventData), o = i / s.time;
        n = {
          x: s.x * o,
          y: s.y * o
        };
      }
      this._fireEvent("dxscrollend", e, {
        velocity: n
      });
    },
    _stop(e) {
      this._fireEvent("dxscrollstop", e);
    },
    cancel(e) {
      this.callBase.apply(this, arguments), this._fireEvent("dxscrollcancel", e);
    },
    dispose() {
      this.callBase.apply(this, arguments), this._pointerLocker.dispose(), this._wheelLocker.dispose();
    },
    _clearSelection() {
      if (!this.isNative)
        return this.callBase.apply(this, arguments);
    },
    _toggleGestureCover() {
      if (!this.isNative)
        return this.callBase.apply(this, arguments);
    }
  };
}());
ha({
  emitter: dG,
  events: ["dxscrollinit", "dxscrollstart", "dxscroll", "dxscrollend", "dxscrollstop", "dxscrollcancel"]
});
const mr = {
  init: "dxscrollinit",
  start: "dxscrollstart",
  move: "dxscroll",
  end: "dxscrollend",
  stop: "dxscrollstop",
  cancel: "dxscrollcancel",
  scroll: "scroll"
};
function ir(i) {
  return (e, t, n, s) => {
    const o = s ? R(i, s) : i;
    if (t)
      return _.on(e, o, n, t), () => {
        _.off(e, o, t);
      };
  };
}
const uG = ir(Te), cG = ir("dxactive"), hG = ir("dxinactive"), pG = ir("dxhoverstart"), gG = ir("dxhoverend"), mG = ir("focusin"), fG = ir("focusout"), _G = (i) => Object.keys(i).reduce((e, t) => i[t] ? I({}, e, {
  [t === "role" || t === "id" ? t : `aria-${t}`]: String(i[t])
}) : e, {}), qD = I({}, dd, {
  _feedbackHideTimeout: 400,
  _feedbackShowTimeout: 30,
  cssText: "",
  aria: {},
  classes: "",
  name: "",
  addWidgetClass: !0
});
let ah = class extends ql {
  constructor(e) {
    super(e), this.state = {
      active: !1,
      focused: !1,
      hovered: !1
    }, this.refs = null, this.rootElementRef = ct(), this.widgetElementRef = ct(), this.setRootElementRef = this.setRootElementRef.bind(this), this.activeEffect = this.activeEffect.bind(this), this.inactiveEffect = this.inactiveEffect.bind(this), this.clickEffect = this.clickEffect.bind(this), this.focus = this.focus.bind(this), this.blur = this.blur.bind(this), this.activate = this.activate.bind(this), this.deactivate = this.deactivate.bind(this), this.focusInEffect = this.focusInEffect.bind(this), this.focusOutEffect = this.focusOutEffect.bind(this), this.hoverStartEffect = this.hoverStartEffect.bind(this), this.hoverEndEffect = this.hoverEndEffect.bind(this), this.keyboardEffect = this.keyboardEffect.bind(this), this.resizeEffect = this.resizeEffect.bind(this), this.windowResizeEffect = this.windowResizeEffect.bind(this), this.visibilityEffect = this.visibilityEffect.bind(this), this.checkDeprecation = this.checkDeprecation.bind(this), this.applyCssTextEffect = this.applyCssTextEffect.bind(this);
  }
  componentWillUpdate(e, t, n) {
    super.componentWillUpdate(e, t, n);
  }
  getConfig() {
    return this.context[dn.id] ? this.context[dn.id] : dn.defaultValue;
  }
  createEffects() {
    return [new et(this.setRootElementRef, []), new et(this.activeEffect, [this.props._feedbackShowTimeout, this.props.activeStateEnabled, this.props.activeStateUnit, this.props.disabled, this.props.onActive]), new et(this.inactiveEffect, [this.props._feedbackHideTimeout, this.props.activeStateEnabled, this.props.activeStateUnit, this.props.onInactive, this.state.active]), new et(this.clickEffect, [this.props.disabled, this.props.name, this.props.onClick]), new et(this.focusInEffect, [this.props.disabled, this.props.focusStateEnabled, this.props.name, this.props.onFocusIn]), new et(this.focusOutEffect, [this.props.focusStateEnabled, this.props.name, this.props.onFocusOut, this.state.focused]), new et(this.hoverStartEffect, [this.props.activeStateUnit, this.props.disabled, this.props.hoverStateEnabled, this.props.onHoverStart, this.state.active]), new et(this.hoverEndEffect, [this.props.activeStateUnit, this.props.hoverStateEnabled, this.props.onHoverEnd, this.state.hovered]), new et(this.keyboardEffect, [this.props.focusStateEnabled, this.props.onKeyDown]), new et(this.resizeEffect, [this.props.name, this.props.onDimensionChanged]), new et(this.windowResizeEffect, [this.props.onDimensionChanged]), new et(this.visibilityEffect, [this.props.name, this.props.onVisibilityChange]), new et(this.checkDeprecation, [this.props.height, this.props.width]), new et(this.applyCssTextEffect, [this.props.cssText]), Yl()];
  }
  updateEffects() {
    var e, t, n, s, o, r, a, l, d, u, c, h, g;
    (e = this._effects[1]) === null || e === void 0 || e.update([this.props._feedbackShowTimeout, this.props.activeStateEnabled, this.props.activeStateUnit, this.props.disabled, this.props.onActive]), (t = this._effects[2]) === null || t === void 0 || t.update([this.props._feedbackHideTimeout, this.props.activeStateEnabled, this.props.activeStateUnit, this.props.onInactive, this.state.active]), (n = this._effects[3]) === null || n === void 0 || n.update([this.props.disabled, this.props.name, this.props.onClick]), (s = this._effects[4]) === null || s === void 0 || s.update([this.props.disabled, this.props.focusStateEnabled, this.props.name, this.props.onFocusIn]), (o = this._effects[5]) === null || o === void 0 || o.update([this.props.focusStateEnabled, this.props.name, this.props.onFocusOut, this.state.focused]), (r = this._effects[6]) === null || r === void 0 || r.update([this.props.activeStateUnit, this.props.disabled, this.props.hoverStateEnabled, this.props.onHoverStart, this.state.active]), (a = this._effects[7]) === null || a === void 0 || a.update([this.props.activeStateUnit, this.props.hoverStateEnabled, this.props.onHoverEnd, this.state.hovered]), (l = this._effects[8]) === null || l === void 0 || l.update([this.props.focusStateEnabled, this.props.onKeyDown]), (d = this._effects[9]) === null || d === void 0 || d.update([this.props.name, this.props.onDimensionChanged]), (u = this._effects[10]) === null || u === void 0 || u.update([this.props.onDimensionChanged]), (c = this._effects[11]) === null || c === void 0 || c.update([this.props.name, this.props.onVisibilityChange]), (h = this._effects[12]) === null || h === void 0 || h.update([this.props.height, this.props.width]), (g = this._effects[13]) === null || g === void 0 || g.update([this.props.cssText]);
  }
  setRootElementRef() {
    var e;
    const {
      rootElementRef: t,
      onRootElementRendered: n
    } = this.props;
    t && this.widgetElementRef && (t.current = this.widgetElementRef.current), this !== null && this !== void 0 && (e = this.widgetElementRef) !== null && e !== void 0 && e.current && n?.(this.widgetElementRef.current);
  }
  activeEffect() {
    const {
      activeStateEnabled: e,
      activeStateUnit: t,
      disabled: n,
      _feedbackShowTimeout: s,
      onActive: o
    } = this.props, r = t;
    if (e && !n) {
      var a;
      return cG((a = this.widgetElementRef) === null || a === void 0 ? void 0 : a.current, (l) => {
        this.setState({
          active: !0
        }), o?.(l);
      }, {
        timeout: s,
        selector: r
      }, "UIFeedback");
    }
  }
  inactiveEffect() {
    const {
      activeStateEnabled: e,
      activeStateUnit: t,
      _feedbackHideTimeout: n,
      onInactive: s
    } = this.props, o = t;
    if (e) {
      var r;
      return hG((r = this.widgetElementRef) === null || r === void 0 ? void 0 : r.current, (a) => {
        this.state.active && (this.setState({
          active: !1
        }), s?.(a));
      }, {
        timeout: n,
        selector: o
      }, "UIFeedback");
    }
  }
  clickEffect() {
    const {
      name: e,
      onClick: t,
      disabled: n
    } = this.props, s = e;
    if (t && !n) {
      var o;
      return Tx.on((o = this.widgetElementRef) === null || o === void 0 ? void 0 : o.current, t, {
        namespace: s
      }), () => {
        var r;
        return Tx.off((r = this.widgetElementRef) === null || r === void 0 ? void 0 : r.current, {
          namespace: s
        });
      };
    }
  }
  focusInEffect() {
    const {
      disabled: e,
      focusStateEnabled: t,
      name: n,
      onFocusIn: s
    } = this.props, o = `${n}Focus`;
    if (t && !e) {
      var r;
      return mG((r = this.widgetElementRef) === null || r === void 0 ? void 0 : r.current, (a) => {
        a.isDefaultPrevented() || (this.setState({
          focused: !0
        }), s?.(a));
      }, null, o);
    }
  }
  focusOutEffect() {
    const {
      focusStateEnabled: e,
      name: t,
      onFocusOut: n
    } = this.props, s = `${t}Focus`;
    if (e) {
      var o;
      return fG((o = this.widgetElementRef) === null || o === void 0 ? void 0 : o.current, (r) => {
        !r.isDefaultPrevented() && this.state.focused && (this.setState({
          focused: !1
        }), n?.(r));
      }, null, s);
    }
  }
  hoverStartEffect() {
    const {
      activeStateUnit: e,
      hoverStateEnabled: t,
      disabled: n,
      onHoverStart: s
    } = this.props, o = e;
    if (t && !n) {
      var r;
      return pG((r = this.widgetElementRef) === null || r === void 0 ? void 0 : r.current, (a) => {
        this.state.active || this.setState({
          hovered: !0
        }), s?.(a);
      }, {
        selector: o
      }, "UIFeedback");
    }
  }
  hoverEndEffect() {
    const {
      activeStateUnit: e,
      hoverStateEnabled: t,
      onHoverEnd: n
    } = this.props, s = e;
    if (t) {
      var o;
      return gG((o = this.widgetElementRef) === null || o === void 0 ? void 0 : o.current, (r) => {
        this.state.hovered && (this.setState({
          hovered: !1
        }), n?.(r));
      }, {
        selector: s
      }, "UIFeedback");
    }
  }
  keyboardEffect() {
    const {
      onKeyDown: e,
      focusStateEnabled: t
    } = this.props;
    if (t && e) {
      var n, s;
      const o = oi.on((n = this.widgetElementRef) === null || n === void 0 ? void 0 : n.current, (s = this.widgetElementRef) === null || s === void 0 ? void 0 : s.current, (r) => e(r));
      return () => oi.off(o);
    }
  }
  resizeEffect() {
    const e = `${this.props.name}VisibilityChange`, {
      onDimensionChanged: t
    } = this.props;
    if (t) {
      var n;
      return ic.on((n = this.widgetElementRef) === null || n === void 0 ? void 0 : n.current, t, {
        namespace: e
      }), () => {
        var s;
        return ic.off((s = this.widgetElementRef) === null || s === void 0 ? void 0 : s.current, {
          namespace: e
        });
      };
    }
  }
  windowResizeEffect() {
    const {
      onDimensionChanged: e
    } = this.props;
    if (e)
      return qo.add(e), () => {
        qo.remove(e);
      };
  }
  visibilityEffect() {
    const {
      name: e,
      onVisibilityChange: t
    } = this.props, n = `${e}VisibilityChange`;
    if (t) {
      var s;
      return sc.on((s = this.widgetElementRef) === null || s === void 0 ? void 0 : s.current, () => t(!0), () => t(!1), {
        namespace: n
      }), () => {
        var o;
        return sc.off((o = this.widgetElementRef) === null || o === void 0 ? void 0 : o.current, {
          namespace: n
        });
      };
    }
  }
  checkDeprecation() {
    const {
      width: e,
      height: t
    } = this.props;
    B(e) && Ae.log("W0017", "width"), B(t) && Ae.log("W0017", "height");
  }
  applyCssTextEffect() {
    var e;
    const {
      cssText: t
    } = this.props;
    t !== void 0 && t !== "" && (e = this.widgetElementRef) !== null && e !== void 0 && e.current && (this.widgetElementRef.current.style.cssText = t);
  }
  getShouldRenderConfigProvider() {
    const {
      rtlEnabled: e
    } = this.props;
    return nG(e, this.config);
  }
  getRtlEnabled() {
    const {
      rtlEnabled: e
    } = this.props;
    return tG(e, this.config);
  }
  getAttributes() {
    const {
      aria: e,
      disabled: t,
      focusStateEnabled: n,
      visible: s
    } = this.props, o = n && !t && this.props.accessKey;
    return I({}, x({}, o && {
      accessKey: o
    }), _G(I({}, e, {
      disabled: t,
      hidden: !s
    })), x({}, this.getRestAttributes(this.props)));
  }
  getRestAttributes(e) {
    const t = I({}, e);
    return ["_feedbackHideTimeout", "_feedbackShowTimeout", "accessKey", "activeStateEnabled", "activeStateUnit", "addWidgetClass", "aria", "children", "className", "classes", "cssText", "disabled", "focusStateEnabled", "height", "hint", "hoverStateEnabled", "name", "onActive", "onClick", "onDimensionChanged", "onFocusIn", "onFocusOut", "onHoverEnd", "onHoverStart", "onInactive", "onKeyDown", "onRootElementRendered", "onVisibilityChange", "rootElementRef", "rtlEnabled", "tabIndex", "visible", "width"].forEach((n) => {
      delete t[n];
    }), t;
  }
  getStyles() {
    const {
      width: e,
      height: t
    } = this.props, n = this.props.style || {}, s = yl("width", B(e) ? e() : e), o = yl("height", B(t) ? t() : t);
    return I({}, n, {
      height: o ?? n.height,
      width: s ?? n.width
    });
  }
  getCssClasses() {
    const {
      classes: e,
      addWidgetClass: t,
      className: n,
      disabled: s,
      activeStateEnabled: o,
      focusStateEnabled: r,
      hoverStateEnabled: a,
      onVisibilityChange: l,
      visible: d
    } = this.props, u = !!r && !s, c = !!a && !s, h = !!o && !s, g = {
      "dx-widget": !!t,
      [String(e)]: !!e,
      [String(n)]: !!n,
      "dx-state-disabled": !!s,
      "dx-state-invisible": !d,
      "dx-state-focused": !!this.state.focused && u,
      "dx-state-active": !!this.state.active && h,
      "dx-state-hover": !!this.state.hovered && c && !this.state.active,
      "dx-rtl": !!this.props.rtlEnabled,
      "dx-visibility-change-handler": !!l
    };
    return ld(g);
  }
  getTabIndex() {
    const {
      focusStateEnabled: e,
      disabled: t,
      tabIndex: n
    } = this.props;
    return e && !t ? n : void 0;
  }
  focus() {
    var e;
    Tu.trigger((e = this.widgetElementRef) === null || e === void 0 ? void 0 : e.current);
  }
  blur() {
    var e, t;
    const n = O.getActiveElement((e = this.widgetElementRef) === null || e === void 0 ? void 0 : e.current);
    ((t = this.widgetElementRef) === null || t === void 0 ? void 0 : t.current) === n && n.blur();
  }
  activate() {
    this.setState({
      active: !0
    });
  }
  deactivate() {
    this.setState({
      active: !1
    });
  }
  render() {
    const {
      hint: e,
      children: t
    } = this.props, n = ki(gt(1, "div", this.getCssClasses(), t, 0, I({}, this.getAttributes(), {
      tabIndex: this.getTabIndex(),
      title: e,
      style: this.getStyles()
    }), null, this.widgetElementRef));
    return this.getShouldRenderConfigProvider() ? qe(2, GD, {
      rtlEnabled: this.getRtlEnabled(),
      children: n
    }) : n;
  }
};
ah.defaultProps = qD;
function Eo(i) {
  return Object.keys(i).filter((e) => i[e]).join(" ");
}
const CG = {
  position: "left",
  source: ""
};
class YD extends bn {
  constructor(e) {
    super(e), this.state = {};
  }
  get sourceType() {
    return td(this.props.source);
  }
  get cssClass() {
    return this.props.position !== "left" ? "dx-icon-right" : "";
  }
  get iconClassName() {
    const e = {
      "dx-icon": !0,
      [this.cssClass]: !!this.cssClass
    }, {
      source: t
    } = this.props;
    return this.sourceType === "dxIcon" ? Eo(I({}, e, {
      [`dx-icon-${t}`]: !0
    })) : this.sourceType === "fontIcon" ? Eo(I({}, e, {
      [String(t)]: !!t
    })) : this.sourceType === "image" ? Eo(e) : this.sourceType === "svg" ? Eo(I({}, e, {
      "dx-svg-icon": !0
    })) : "";
  }
  get restAttributes() {
    const e = I({}, this.props);
    return ["iconTemplate", "position", "source"].forEach((t) => {
      delete e[t];
    }), e;
  }
  render() {
    const {
      iconClassName: e,
      props: {
        source: t
      },
      sourceType: n
    } = this, s = um(this.props.iconTemplate);
    return Cs([n === "dxIcon" && gt(1, "i", e), n === "fontIcon" && gt(1, "i", e), n === "image" && gt(1, "img", e, null, 1, {
      alt: "",
      src: t
    }), s && gt(1, "i", e, s({}), 0)], 0);
  }
}
YD.defaultProps = CG;
const XD = function() {
  let i = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
  const {
    useHoldAnimation: e,
    waveSizeCoefficient: t,
    isCentered: n,
    wavesNumber: s
  } = i;
  return {
    waveSizeCoefficient: t || 2,
    isCentered: n || !1,
    wavesNumber: s || 1,
    durations: bG(e ?? !0)
  };
}, w_ = function(i) {
  const e = XD(i);
  return {
    showWave: QD.bind(this, e),
    hideWave: eT.bind(this, e)
  };
}, vG = function(i) {
  let e = i.children(".dx-inkripple");
  return e.length === 0 && (e = p("<div>").addClass("dx-inkripple").appendTo(i)), e;
}, ZD = function(i, e) {
  const t = vG(p(i)), n = t.children(".dx-inkripple-wave").toArray();
  for (let s = n.length; s < e; s++) {
    const o = p("<div>").appendTo(t).addClass("dx-inkripple-wave");
    n.push(o[0]);
  }
  return p(n);
}, xG = function(i, e) {
  const t = p(e.element), n = Ee(t), s = he(t), o = parseInt(Math.sqrt(n * n + s * s)), r = Math.min(4e3, parseInt(o * i.waveSizeCoefficient));
  let a, l;
  if (i.isCentered)
    a = (n - r) / 2, l = (s - r) / 2;
  else {
    const d = e.event, u = t.offset(), c = d.pageX - u.left, h = d.pageY - u.top;
    a = c - r / 2, l = h - r / 2;
  }
  return {
    left: a,
    top: l,
    height: r,
    width: r
  };
};
function QD(i, e) {
  const t = ZD(e.element, i.wavesNumber).eq(e.wave || 0);
  i.hidingTimeout && clearTimeout(i.hidingTimeout), JD(t), t.css(xG(i, e)), i.showingTimeout = setTimeout(yG.bind(this, i, t), 0);
}
function yG(i, e) {
  const t = i.durations.showingScale + "ms";
  e.addClass("dx-inkripple-showing").css("transitionDuration", t);
}
function bG(i) {
  return {
    showingScale: i ? 1e3 : 300,
    hidingScale: 300,
    hidingOpacity: 300
  };
}
function JD(i) {
  i.removeClass("dx-inkripple-hiding").css("transitionDuration", "");
}
function eT(i, e) {
  i.showingTimeout && clearTimeout(i.showingTimeout);
  const t = ZD(e.element, e.wavesNumber).eq(e.wave || 0), n = i.durations, s = n.hidingScale + "ms, " + n.hidingOpacity + "ms";
  t.addClass("dx-inkripple-hiding").removeClass("dx-inkripple-showing").css("transitionDuration", s);
  const o = Math.max(n.hidingScale, n.hidingOpacity);
  i.hidingTimeout = setTimeout(JD.bind(this, t), o);
}
class tT extends bn {
  constructor(e) {
    super(e), this.__getterCache = {}, this.state = {}, this.hideWave = this.hideWave.bind(this), this.showWave = this.showWave.bind(this);
  }
  get getConfig() {
    return this.__getterCache.getConfig !== void 0 ? this.__getterCache.getConfig : this.__getterCache.getConfig = (() => {
      const {
        config: e
      } = this.props;
      return XD(e);
    })();
  }
  get restAttributes() {
    const e = I({}, this.props);
    return delete e.config, e;
  }
  hideWave(e) {
    eT(this.getConfig, e);
  }
  showWave(e) {
    QD(this.getConfig, e);
  }
  componentWillUpdate(e) {
    this.props.config !== e.config && (this.__getterCache.getConfig = void 0);
  }
  render() {
    return ki(gt(1, "div", "dx-inkripple", null, 1, I({}, this.restAttributes)));
  }
}
tT.defaultProps = {
  config: {}
};
const wG = I({}, dd, {
  activeStateEnabled: !0,
  hoverStateEnabled: !0,
  icon: "",
  iconPosition: "left",
  stylingMode: "contained",
  text: "",
  type: "normal",
  useInkRipple: !1,
  useSubmitBehavior: !1,
  templateData: {}
}), SG = ["outlined", "text", "contained"], EG = (i) => {
  const {
    icon: e,
    iconPosition: t,
    stylingMode: n,
    text: s,
    type: o
  } = i, a = {
    "dx-button": !0,
    [`dx-button-mode-${n && SG.includes(n) ? n : "contained"}`]: !0,
    [`dx-button-${o ?? "normal"}`]: !0,
    "dx-button-has-text": !!s,
    "dx-button-has-icon": !!e,
    "dx-button-icon-right": t !== "left"
  };
  return Eo(a);
}, nT = Ez([{
  device: () => z.real().deviceType === "desktop" && !z.isSimulator(),
  options: {
    focusStateEnabled: !0
  }
}, {
  device: () => Zt(pn()),
  options: {
    useInkRipple: !0
  }
}]);
let pc = class extends ql {
  constructor(e) {
    super(e), this.contentRef = ct(), this.inkRippleRef = ct(), this.submitInputRef = ct(), this.widgetRef = ct(), this.__getterCache = {}, this.state = {}, this.focus = this.focus.bind(this), this.activate = this.activate.bind(this), this.deactivate = this.deactivate.bind(this), this.submitEffect = this.submitEffect.bind(this), this.onActive = this.onActive.bind(this), this.onInactive = this.onInactive.bind(this), this.onWidgetClick = this.onWidgetClick.bind(this), this.keyDown = this.keyDown.bind(this);
  }
  createEffects() {
    return [new et(this.submitEffect, [this.props.onSubmit, this.props.useSubmitBehavior]), Yl()];
  }
  updateEffects() {
    var e;
    (e = this._effects[0]) === null || e === void 0 || e.update([this.props.onSubmit, this.props.useSubmitBehavior]);
  }
  submitEffect() {
    const {
      onSubmit: e,
      useSubmitBehavior: t
    } = this.props;
    if (t && e)
      return Ox.on(this.submitInputRef.current, (n) => e({
        event: n,
        submitInput: this.submitInputRef.current
      }), {
        namespace: "UIFeedback"
      }), () => Ox.off(this.submitInputRef.current, {
        namespace: "UIFeedback"
      });
  }
  onActive(e) {
    const {
      useInkRipple: t
    } = this.props;
    t && this.inkRippleRef.current.showWave({
      element: this.contentRef.current,
      event: e
    });
  }
  onInactive(e) {
    const {
      useInkRipple: t
    } = this.props;
    t && this.inkRippleRef.current.hideWave({
      element: this.contentRef.current,
      event: e
    });
  }
  onWidgetClick(e) {
    const {
      onClick: t,
      useSubmitBehavior: n
    } = this.props;
    t?.({
      event: e
    }), n && this.submitInputRef.current.click();
  }
  keyDown(e) {
    const {
      onKeyDown: t
    } = this.props, {
      keyName: n,
      originalEvent: s,
      which: o
    } = e, r = t?.(e);
    if (r != null && r.cancel)
      return r;
    (n === "space" || o === "space" || n === "enter" || o === "enter") && (s.preventDefault(), this.onWidgetClick(s));
  }
  get aria() {
    const {
      icon: e,
      text: t
    } = this.props;
    let n = t ?? "";
    if (!t && e)
      switch (td(e)) {
        case "image": {
          const r = /^(?!(?:https?:\/\/)|(?:ftp:\/\/)|(?:www\.))[^\s]+$/;
          n = !e.includes("base64") && r.test(e) ? e.replace(/.+\/([^.]+)\..+$/, "$1") : "";
          break;
        }
        case "dxIcon":
          n = S.format(Jr(e, !0)) || e;
          break;
        case "fontIcon":
          n = e;
          break;
        case "svg": {
          var s;
          n = ((s = /<title>(.*?)<\/title>/.exec(e)) === null || s === void 0 ? void 0 : s[1]) ?? "";
          break;
        }
      }
    return I({
      role: "button"
    }, n ? {
      label: n
    } : {});
  }
  get cssClasses() {
    return EG(this.props);
  }
  get iconSource() {
    const {
      icon: e
    } = this.props;
    return e ?? "";
  }
  get inkRippleConfig() {
    return this.__getterCache.inkRippleConfig !== void 0 ? this.__getterCache.inkRippleConfig : this.__getterCache.inkRippleConfig = (() => {
      const {
        icon: e,
        text: t
      } = this.props;
      return !t && e ? {
        isCentered: !0,
        useHoldAnimation: !1,
        waveSizeCoefficient: 1
      } : {};
    })();
  }
  get buttonTemplateData() {
    const {
      icon: e,
      text: t,
      templateData: n
    } = this.props;
    return I({
      icon: e,
      text: t
    }, n);
  }
  get restAttributes() {
    const e = I({}, this.props);
    return ["accessKey", "activeStateEnabled", "children", "className", "disabled", "focusStateEnabled", "height", "hint", "hoverStateEnabled", "icon", "iconPosition", "iconTemplate", "onClick", "onKeyDown", "onSubmit", "pressed", "rtlEnabled", "stylingMode", "tabIndex", "template", "templateData", "text", "type", "useInkRipple", "useSubmitBehavior", "visible", "width"].forEach((t) => {
      delete e[t];
    }), e;
  }
  focus() {
    this.widgetRef.current.focus();
  }
  activate() {
    this.widgetRef.current.activate();
  }
  deactivate() {
    this.widgetRef.current.deactivate();
  }
  componentWillUpdate(e) {
    super.componentWillUpdate(), (this.props.icon !== e.icon || this.props.text !== e.text) && (this.__getterCache.inkRippleConfig = void 0);
  }
  render() {
    const {
      children: e,
      iconPosition: t,
      text: n
    } = this.props, s = um(this.props.template), o = um(this.props.iconTemplate), r = !this.props.template && !e && n !== "", a = t === "left", l = !s && !e && (this.iconSource || o) && qe(2, YD, {
      source: this.iconSource,
      position: t,
      iconTemplate: o
    });
    return ki(qe(2, ah, I({
      accessKey: this.props.accessKey,
      activeStateEnabled: this.props.activeStateEnabled,
      aria: this.aria,
      className: this.props.className,
      classes: this.cssClasses,
      disabled: this.props.disabled,
      focusStateEnabled: this.props.focusStateEnabled,
      height: this.props.height,
      hint: this.props.hint,
      hoverStateEnabled: this.props.hoverStateEnabled,
      onActive: this.onActive,
      onClick: this.onWidgetClick,
      onInactive: this.onInactive,
      onKeyDown: this.keyDown,
      rtlEnabled: this.props.rtlEnabled,
      tabIndex: this.props.tabIndex,
      visible: this.props.visible,
      width: this.props.width
    }, this.restAttributes, {
      children: gt(1, "div", "dx-button-content", [s && s({
        data: this.buttonTemplateData
      }), !s && e, a && l, r && gt(1, "span", "dx-button-text", n, 0), !a && l, this.props.useSubmitBehavior && gt(64, "input", "dx-button-submit-input", null, 1, {
        type: "submit",
        tabIndex: -1
      }, null, this.submitInputRef), this.props.useInkRipple && qe(2, tT, {
        config: this.inkRippleConfig
      }, null, this.inkRippleRef)], 0, null, null, this.contentRef)
    }), null, this.widgetRef));
  }
};
pc.defaultProps = I({}, wG, ia(nT));
const uy = [];
function IG(i) {
  uy.push(i), pc.defaultProps = Object.create(Object.prototype, Object.assign(Object.getOwnPropertyDescriptors(pc.defaultProps), Object.getOwnPropertyDescriptors(ia(nT)), Object.getOwnPropertyDescriptors(ia(uy))));
}
function DG(i) {
  return na(i) * Math.round(Math.abs(i));
}
function TG(i, e) {
  const t = Math.pow(10, e), n = eD(i, e);
  return DG(n) / t;
}
function iT(i, e) {
  const t = e || 0;
  return (t > 0 ? TG(...arguments) : i).toFixed(t);
}
const OG = {
  thousandsSeparator: ",",
  decimalSeparator: "."
};
function AG(i) {
  return i.split(",").slice(1).map(function(e) {
    let t = 0;
    return e.split("").filter(function(n, s) {
      t += n === "'";
      const o = n === "#" || n === "0", r = t % 2;
      return o && !r;
    }).length;
  });
}
function RG(i) {
  let e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : ";", t = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : "'";
  const n = [];
  let s = "", o = "searchingSeparator";
  for (let r = 0; r < i.length; r++) {
    const a = i[r];
    o === "searchingSeparator" && a === t ? o = "skippingSeparationInsideEscaping" : o === "skippingSeparationInsideEscaping" && a === t ? o = "searchingSeparator" : o === "searchingSeparator" && a === e && (o = "separating", n.push(s), s = ""), o !== "separating" ? s += a : o = "searchingSeparator";
  }
  return n.push(s), n;
}
function FG(i) {
  const e = RG(i);
  return e.length === 1 && e.push("-" + e[0]), e;
}
function cp(i) {
  return i.toString().split("").reverse().join("");
}
function kG(i) {
  return i.indexOf("%") !== -1 && !i.match(/'[^']*%[^']*'/g);
}
function sT(i) {
  return i.replace(/'[^']*'/g, "");
}
function cy(i) {
  if (!i)
    return 0;
  const e = sT(i);
  return e.length - e.replace(/[#]/g, "").length;
}
function hy(i) {
  if (!i)
    return 0;
  const e = sT(i);
  return e.length - e.replace(/[0]/g, "").length;
}
function py(i, e, t) {
  if (!i)
    return "";
  for (i.length > t && (i = i.substr(0, t)); i.length > e && i.slice(-1) === "0"; )
    i = i.substr(0, i.length - 1);
  for (; i.length < e; )
    i += "0";
  return i;
}
function VG(i, e, t) {
  if (!e.length)
    return i;
  const n = [];
  let s = 0;
  for (; i; ) {
    const o = e[s];
    if (!o)
      break;
    n.push(i.slice(0, o)), i = i.slice(o), s < e.length - 1 && s++;
  }
  return n.join(t);
}
function gy(i, e) {
  return i.split("'").map(function(t, n) {
    const s = n % 2;
    return !t && s ? "'" : s ? t : t.replace(/[,#0]+/, e);
  }).join("");
}
function PG(i) {
  let e = !1;
  for (let t = 0; t < i.length; t++)
    if (i[t] === "'" && (e = !e), i[t] === "." && !e)
      return t;
  return i.length;
}
function MG(i, e) {
  return e = e || OG, function(t) {
    if (typeof t != "number" || isNaN(t))
      return "";
    const n = FG(i), s = 1 / t === 1 / 0, o = t > 0 || s, r = n[o ? 0 : 1], a = PG(r), l = [r.substr(0, a), r.substr(a + 1)], d = hy(l[1]), u = d + cy(l[1]);
    kG(r) && (t = eD(t, 2)), o || (t = -t);
    const c = hy(l[0]), h = cy(l[0]) || e.unlimitedIntegerDigits ? void 0 : c, g = Math.floor(t).toString().length, m = Lt(u, 0, 15 - g), C = AG(l[0]).reverse(), v = iT(t, m < 0 ? 0 : m).split(".");
    let E = py(cp(v[0]), c, h);
    const T = py(v[1], d, u);
    E = VG(E, C, e.thousandsSeparator);
    const V = cp(gy(cp(l[0]), E)), $ = u ? gy(l[1], T) : "";
    return V + ($.match(/\d/) ? e.decimalSeparator : "") + $;
  };
}
function ol(i, e, t) {
  const n = (e ? 0.01 : 1) * parseFloat(i) || 0;
  return t ? -n : n;
}
function my(i, e, t, n) {
  let s = i, o, r, a;
  do
    a && (o = r.length === a.length ? "0" : "1", i = n ? o + i : i + o), r = a || e(ol(s, t)), s = n ? "1" + s : s + "1", a = e(ol(s, t));
  while (r !== a && (n ? r.length === a.length : r.length <= a.length));
  if (n && a.length > r.length) {
    const l = e(12345).indexOf("12345") === -1;
    do
      i = "1" + i;
    while (l && ol(i, t) < 1e5);
  }
  return i;
}
function fy(i, e, t, n) {
  let s = e(ol(i, t, n));
  const o = i.split("."), r = o[0] + ".3" + o[1].slice(1), a = ol(r, t, n), l = e(a).indexOf("3") - 1;
  return s = s.replace(/(\d)\D(\d)/g, "$1,$2"), l >= 0 && (s = s.slice(0, l) + "." + s.slice(l + 1)), s = s.replace(/1+/, "1").replace(/1/g, "#"), t || (s = s.replace(/%/g, "'%'")), s;
}
function BG(i) {
  let e = ".";
  const t = i(1).indexOf("100") >= 0;
  e = my(e, i, t, !0), e = my(e, i, t, !1);
  const n = fy(e, i, t, !1), s = fy(e, i, t, !0);
  return s === "-" + n ? n : n + ";" + s;
}
const $G = {
  _formatNumberCore: function(i, e, t) {
    if (e === "currency") {
      t.precision = t.precision || 0;
      let n = this.format(i, x({}, t, {
        type: "fixedpoint"
      }));
      const s = this.getCurrencySymbol().symbol.replace(/\$/g, "$$$$");
      return n = n.replace(/^(\D*)(\d.*)/, "$1" + s + "$2"), n;
    }
    return this.callBase.apply(this, arguments);
  },
  getCurrencySymbol: function() {
    return {
      symbol: "$"
    };
  },
  getOpenXmlCurrencyFormat: function() {
    return "$#,##0{0}_);\\($#,##0{0}\\)";
  }
}, NG = (i, e) => {
  if (!e)
    return;
  let t = i;
  if (typeof i == "string") {
    t = "";
    for (let o = 0; o < i.length; o++)
      i[o] !== "$" && (t += "\\"), t += i[o];
  }
  const n = {
    ".00": "{0}",
    "'": "\\'",
    "\\(": "\\(",
    "\\)": "\\)",
    " ": "\\ ",
    '"': "&quot;",
    "\\¤": t
  }, s = e.split(";");
  for (let o = 0; o < s.length; o++)
    for (const r in n)
      Object.prototype.hasOwnProperty.call(n, r) && (s[o] = s[o].replace(new RegExp(r, "g"), n[r]));
  return s.length === 2 ? s[0] + "_);" + s[1] : s[0];
}, LG = {
  af: "¤#,##0.00;(¤#,##0.00)",
  "af-NA": "¤#,##0.00;(¤#,##0.00)",
  agq: "#,##0.00¤",
  ak: "¤#,##0.00",
  am: "¤#,##0.00;(¤#,##0.00)",
  ar: "¤#,##0.00;(¤#,##0.00)",
  "ar-AE": "¤#,##0.00;(¤#,##0.00)",
  "ar-BH": "¤#,##0.00;(¤#,##0.00)",
  "ar-DJ": "¤#,##0.00;(¤#,##0.00)",
  "ar-DZ": "¤#,##0.00;(¤#,##0.00)",
  "ar-EG": "¤#,##0.00;(¤#,##0.00)",
  "ar-EH": "¤#,##0.00;(¤#,##0.00)",
  "ar-ER": "¤#,##0.00;(¤#,##0.00)",
  "ar-IL": "¤#,##0.00;(¤#,##0.00)",
  "ar-IQ": "¤#,##0.00;(¤#,##0.00)",
  "ar-JO": "¤#,##0.00;(¤#,##0.00)",
  "ar-KM": "¤#,##0.00;(¤#,##0.00)",
  "ar-KW": "¤#,##0.00;(¤#,##0.00)",
  "ar-LB": "¤#,##0.00;(¤#,##0.00)",
  "ar-LY": "¤#,##0.00;(¤#,##0.00)",
  "ar-MA": "¤#,##0.00;(¤#,##0.00)",
  "ar-MR": "¤#,##0.00;(¤#,##0.00)",
  "ar-OM": "¤#,##0.00;(¤#,##0.00)",
  "ar-PS": "¤#,##0.00;(¤#,##0.00)",
  "ar-QA": "¤#,##0.00;(¤#,##0.00)",
  "ar-SA": "¤#,##0.00;(¤#,##0.00)",
  "ar-SD": "¤#,##0.00;(¤#,##0.00)",
  "ar-SO": "¤#,##0.00;(¤#,##0.00)",
  "ar-SS": "¤#,##0.00;(¤#,##0.00)",
  "ar-SY": "¤#,##0.00;(¤#,##0.00)",
  "ar-TD": "¤#,##0.00;(¤#,##0.00)",
  "ar-TN": "¤#,##0.00;(¤#,##0.00)",
  "ar-YE": "¤#,##0.00;(¤#,##0.00)",
  as: "¤ #,##,##0.00",
  asa: "#,##0.00 ¤",
  ast: "#,##0.00 ¤",
  az: "#,##0.00 ¤",
  "az-Cyrl": "#,##0.00 ¤",
  "az-Latn": "#,##0.00 ¤",
  bas: "#,##0.00 ¤",
  be: "#,##0.00 ¤",
  "be-tarask": "#,##0.00 ¤",
  bem: "¤#,##0.00;(¤#,##0.00)",
  bez: "#,##0.00¤",
  bg: "0.00 ¤;(0.00 ¤)",
  bm: "¤#,##0.00;(¤#,##0.00)",
  bn: "#,##,##0.00¤;(#,##,##0.00¤)",
  "bn-IN": "#,##,##0.00¤;(#,##,##0.00¤)",
  bo: "¤ #,##0.00",
  "bo-IN": "¤ #,##0.00",
  br: "#,##0.00 ¤",
  brx: "¤ #,##,##0.00",
  bs: "#,##0.00 ¤",
  "bs-Cyrl": "#,##0.00 ¤",
  "bs-Latn": "#,##0.00 ¤",
  ca: "#,##0.00 ¤;(#,##0.00 ¤)",
  "ca-AD": "#,##0.00 ¤;(#,##0.00 ¤)",
  "ca-ES-valencia": "#,##0.00 ¤;(#,##0.00 ¤)",
  "ca-FR": "#,##0.00 ¤;(#,##0.00 ¤)",
  "ca-IT": "#,##0.00 ¤;(#,##0.00 ¤)",
  ccp: "#,##,##0.00¤;(#,##,##0.00¤)",
  "ccp-IN": "#,##,##0.00¤;(#,##,##0.00¤)",
  ce: "#,##0.00 ¤",
  ceb: "¤#,##0.00;(¤#,##0.00)",
  cgg: "¤#,##0.00",
  chr: "¤#,##0.00;(¤#,##0.00)",
  ckb: "¤ #,##0.00",
  "ckb-IR": "¤ #,##0.00",
  cs: "#,##0.00 ¤",
  cy: "¤#,##0.00;(¤#,##0.00)",
  da: "#,##0.00 ¤",
  "da-GL": "#,##0.00 ¤",
  dav: "¤#,##0.00;(¤#,##0.00)",
  de: "#,##0.00 ¤",
  "de-AT": "#,##0.00 ¤",
  "de-BE": "#,##0.00 ¤",
  "de-CH": "#,##0.00 ¤",
  "de-IT": "#,##0.00 ¤",
  "de-LI": "#,##0.00 ¤",
  "de-LU": "#,##0.00 ¤",
  dje: "#,##0.00¤",
  doi: "¤#,##0.00",
  dsb: "#,##0.00 ¤",
  dua: "#,##0.00 ¤",
  dyo: "#,##0.00 ¤",
  dz: "¤#,##,##0.00",
  ebu: "¤#,##0.00;(¤#,##0.00)",
  ee: "¤#,##0.00;(¤#,##0.00)",
  "ee-TG": "¤#,##0.00;(¤#,##0.00)",
  el: "#,##0.00 ¤",
  "el-CY": "#,##0.00 ¤",
  en: "¤#,##0.00;(¤#,##0.00)",
  "en-001": "¤#,##0.00;(¤#,##0.00)",
  "en-150": "#,##0.00 ¤",
  "en-AE": "¤#,##0.00;(¤#,##0.00)",
  "en-AG": "¤#,##0.00;(¤#,##0.00)",
  "en-AI": "¤#,##0.00;(¤#,##0.00)",
  "en-AS": "¤#,##0.00;(¤#,##0.00)",
  "en-AT": "¤ #,##0.00",
  "en-AU": "¤#,##0.00;(¤#,##0.00)",
  "en-BB": "¤#,##0.00;(¤#,##0.00)",
  "en-BE": "#,##0.00 ¤",
  "en-BI": "¤#,##0.00;(¤#,##0.00)",
  "en-BM": "¤#,##0.00;(¤#,##0.00)",
  "en-BS": "¤#,##0.00;(¤#,##0.00)",
  "en-BW": "¤#,##0.00;(¤#,##0.00)",
  "en-BZ": "¤#,##0.00;(¤#,##0.00)",
  "en-CA": "¤#,##0.00;(¤#,##0.00)",
  "en-CC": "¤#,##0.00;(¤#,##0.00)",
  "en-CH": "¤ #,##0.00;¤-#,##0.00",
  "en-CK": "¤#,##0.00;(¤#,##0.00)",
  "en-CM": "¤#,##0.00;(¤#,##0.00)",
  "en-CX": "¤#,##0.00;(¤#,##0.00)",
  "en-CY": "¤#,##0.00;(¤#,##0.00)",
  "en-DE": "#,##0.00 ¤",
  "en-DG": "¤#,##0.00;(¤#,##0.00)",
  "en-DK": "#,##0.00 ¤",
  "en-DM": "¤#,##0.00;(¤#,##0.00)",
  "en-ER": "¤#,##0.00;(¤#,##0.00)",
  "en-FI": "#,##0.00 ¤",
  "en-FJ": "¤#,##0.00;(¤#,##0.00)",
  "en-FK": "¤#,##0.00;(¤#,##0.00)",
  "en-FM": "¤#,##0.00;(¤#,##0.00)",
  "en-GB": "¤#,##0.00;(¤#,##0.00)",
  "en-GD": "¤#,##0.00;(¤#,##0.00)",
  "en-GG": "¤#,##0.00;(¤#,##0.00)",
  "en-GH": "¤#,##0.00;(¤#,##0.00)",
  "en-GI": "¤#,##0.00;(¤#,##0.00)",
  "en-GM": "¤#,##0.00;(¤#,##0.00)",
  "en-GU": "¤#,##0.00;(¤#,##0.00)",
  "en-GY": "¤#,##0.00;(¤#,##0.00)",
  "en-HK": "¤#,##0.00;(¤#,##0.00)",
  "en-IE": "¤#,##0.00;(¤#,##0.00)",
  "en-IL": "¤#,##0.00;(¤#,##0.00)",
  "en-IM": "¤#,##0.00;(¤#,##0.00)",
  "en-IN": "¤#,##0.00;(¤#,##0.00)",
  "en-IO": "¤#,##0.00;(¤#,##0.00)",
  "en-JE": "¤#,##0.00;(¤#,##0.00)",
  "en-JM": "¤#,##0.00;(¤#,##0.00)",
  "en-KE": "¤#,##0.00;(¤#,##0.00)",
  "en-KI": "¤#,##0.00;(¤#,##0.00)",
  "en-KN": "¤#,##0.00;(¤#,##0.00)",
  "en-KY": "¤#,##0.00;(¤#,##0.00)",
  "en-LC": "¤#,##0.00;(¤#,##0.00)",
  "en-LR": "¤#,##0.00;(¤#,##0.00)",
  "en-LS": "¤#,##0.00;(¤#,##0.00)",
  "en-MG": "¤#,##0.00;(¤#,##0.00)",
  "en-MH": "¤#,##0.00;(¤#,##0.00)",
  "en-MO": "¤#,##0.00;(¤#,##0.00)",
  "en-MP": "¤#,##0.00;(¤#,##0.00)",
  "en-MS": "¤#,##0.00;(¤#,##0.00)",
  "en-MT": "¤#,##0.00;(¤#,##0.00)",
  "en-MU": "¤#,##0.00;(¤#,##0.00)",
  "en-MV": "¤ #,##0.00",
  "en-MW": "¤#,##0.00;(¤#,##0.00)",
  "en-MY": "¤#,##0.00;(¤#,##0.00)",
  "en-NA": "¤#,##0.00;(¤#,##0.00)",
  "en-NF": "¤#,##0.00;(¤#,##0.00)",
  "en-NG": "¤#,##0.00;(¤#,##0.00)",
  "en-NL": "¤ #,##0.00;(¤ #,##0.00)",
  "en-NR": "¤#,##0.00;(¤#,##0.00)",
  "en-NU": "¤#,##0.00;(¤#,##0.00)",
  "en-NZ": "¤#,##0.00;(¤#,##0.00)",
  "en-PG": "¤#,##0.00;(¤#,##0.00)",
  "en-PH": "¤#,##0.00;(¤#,##0.00)",
  "en-PK": "¤#,##0.00;(¤#,##0.00)",
  "en-PN": "¤#,##0.00;(¤#,##0.00)",
  "en-PR": "¤#,##0.00;(¤#,##0.00)",
  "en-PW": "¤#,##0.00;(¤#,##0.00)",
  "en-RW": "¤#,##0.00;(¤#,##0.00)",
  "en-SB": "¤#,##0.00;(¤#,##0.00)",
  "en-SC": "¤#,##0.00;(¤#,##0.00)",
  "en-SD": "¤#,##0.00;(¤#,##0.00)",
  "en-SE": "#,##0.00 ¤",
  "en-SG": "¤#,##0.00;(¤#,##0.00)",
  "en-SH": "¤#,##0.00;(¤#,##0.00)",
  "en-SI": "#,##0.00 ¤;(#,##0.00 ¤)",
  "en-SL": "¤#,##0.00;(¤#,##0.00)",
  "en-SS": "¤#,##0.00;(¤#,##0.00)",
  "en-SX": "¤#,##0.00;(¤#,##0.00)",
  "en-SZ": "¤#,##0.00;(¤#,##0.00)",
  "en-TC": "¤#,##0.00;(¤#,##0.00)",
  "en-TK": "¤#,##0.00;(¤#,##0.00)",
  "en-TO": "¤#,##0.00;(¤#,##0.00)",
  "en-TT": "¤#,##0.00;(¤#,##0.00)",
  "en-TV": "¤#,##0.00;(¤#,##0.00)",
  "en-TZ": "¤#,##0.00;(¤#,##0.00)",
  "en-UG": "¤#,##0.00;(¤#,##0.00)",
  "en-UM": "¤#,##0.00;(¤#,##0.00)",
  "en-VC": "¤#,##0.00;(¤#,##0.00)",
  "en-VG": "¤#,##0.00;(¤#,##0.00)",
  "en-VI": "¤#,##0.00;(¤#,##0.00)",
  "en-VU": "¤#,##0.00;(¤#,##0.00)",
  "en-WS": "¤#,##0.00;(¤#,##0.00)",
  "en-ZA": "¤#,##0.00;(¤#,##0.00)",
  "en-ZM": "¤#,##0.00;(¤#,##0.00)",
  "en-ZW": "¤#,##0.00;(¤#,##0.00)",
  eo: "¤ #,##0.00",
  es: "#,##0.00 ¤",
  "es-419": "¤#,##0.00",
  "es-AR": "¤ #,##0.00;(¤ #,##0.00)",
  "es-BO": "¤#,##0.00",
  "es-BR": "¤#,##0.00",
  "es-BZ": "¤#,##0.00",
  "es-CL": "¤#,##0.00",
  "es-CO": "¤#,##0.00",
  "es-CR": "¤#,##0.00",
  "es-CU": "¤#,##0.00",
  "es-DO": "¤#,##0.00;(¤#,##0.00)",
  "es-EA": "#,##0.00 ¤",
  "es-EC": "¤#,##0.00",
  "es-GQ": "#,##0.00 ¤",
  "es-GT": "¤#,##0.00",
  "es-HN": "¤#,##0.00",
  "es-IC": "#,##0.00 ¤",
  "es-MX": "¤#,##0.00",
  "es-NI": "¤#,##0.00",
  "es-PA": "¤#,##0.00",
  "es-PE": "¤#,##0.00",
  "es-PH": "#,##0.00 ¤",
  "es-PR": "¤#,##0.00",
  "es-PY": "¤#,##0.00",
  "es-SV": "¤#,##0.00",
  "es-US": "¤#,##0.00",
  "es-UY": "¤ #,##0.00;(¤ #,##0.00)",
  "es-VE": "¤#,##0.00",
  et: "#,##0.00 ¤;(#,##0.00 ¤)",
  eu: "#,##0.00 ¤;(#,##0.00 ¤)",
  ewo: "#,##0.00 ¤",
  fa: "‎¤ #,##0.00;‎(¤ #,##0.00)",
  "fa-AF": "¤ #,##0.00;‎(¤ #,##0.00)",
  ff: "#,##0.00 ¤",
  "ff-Adlm": "¤ #,##0.00",
  "ff-Adlm-BF": "¤ #,##0.00",
  "ff-Adlm-CM": "¤ #,##0.00",
  "ff-Adlm-GH": "¤ #,##0.00",
  "ff-Adlm-GM": "¤ #,##0.00",
  "ff-Adlm-GW": "¤ #,##0.00",
  "ff-Adlm-LR": "¤ #,##0.00",
  "ff-Adlm-MR": "¤ #,##0.00",
  "ff-Adlm-NE": "¤ #,##0.00",
  "ff-Adlm-NG": "¤ #,##0.00",
  "ff-Adlm-SL": "¤ #,##0.00",
  "ff-Adlm-SN": "¤ #,##0.00",
  "ff-Latn": "#,##0.00 ¤",
  "ff-Latn-BF": "#,##0.00 ¤",
  "ff-Latn-CM": "#,##0.00 ¤",
  "ff-Latn-GH": "#,##0.00 ¤",
  "ff-Latn-GM": "#,##0.00 ¤",
  "ff-Latn-GN": "#,##0.00 ¤",
  "ff-Latn-GW": "#,##0.00 ¤",
  "ff-Latn-LR": "#,##0.00 ¤",
  "ff-Latn-MR": "#,##0.00 ¤",
  "ff-Latn-NE": "#,##0.00 ¤",
  "ff-Latn-NG": "#,##0.00 ¤",
  "ff-Latn-SL": "#,##0.00 ¤",
  fi: "#,##0.00 ¤",
  fil: "¤#,##0.00;(¤#,##0.00)",
  fo: "#,##0.00 ¤;(#,##0.00 ¤)",
  "fo-DK": "#,##0.00 ¤;(#,##0.00 ¤)",
  fr: "#,##0.00 ¤;(#,##0.00 ¤)",
  "fr-BE": "#,##0.00 ¤;(#,##0.00 ¤)",
  "fr-BF": "#,##0.00 ¤;(#,##0.00 ¤)",
  "fr-BI": "#,##0.00 ¤;(#,##0.00 ¤)",
  "fr-BJ": "#,##0.00 ¤;(#,##0.00 ¤)",
  "fr-BL": "#,##0.00 ¤;(#,##0.00 ¤)",
  "fr-CA": "#,##0.00 ¤;(#,##0.00 ¤)",
  "fr-CD": "#,##0.00 ¤;(#,##0.00 ¤)",
  "fr-CF": "#,##0.00 ¤;(#,##0.00 ¤)",
  "fr-CG": "#,##0.00 ¤;(#,##0.00 ¤)",
  "fr-CH": "#,##0.00 ¤;(#,##0.00 ¤)",
  "fr-CI": "#,##0.00 ¤;(#,##0.00 ¤)",
  "fr-CM": "#,##0.00 ¤;(#,##0.00 ¤)",
  "fr-DJ": "#,##0.00 ¤;(#,##0.00 ¤)",
  "fr-DZ": "#,##0.00 ¤;(#,##0.00 ¤)",
  "fr-GA": "#,##0.00 ¤;(#,##0.00 ¤)",
  "fr-GF": "#,##0.00 ¤;(#,##0.00 ¤)",
  "fr-GN": "#,##0.00 ¤;(#,##0.00 ¤)",
  "fr-GP": "#,##0.00 ¤;(#,##0.00 ¤)",
  "fr-GQ": "#,##0.00 ¤;(#,##0.00 ¤)",
  "fr-HT": "#,##0.00 ¤;(#,##0.00 ¤)",
  "fr-KM": "#,##0.00 ¤;(#,##0.00 ¤)",
  "fr-LU": "#,##0.00 ¤;(#,##0.00 ¤)",
  "fr-MA": "#,##0.00 ¤;(#,##0.00 ¤)",
  "fr-MC": "#,##0.00 ¤;(#,##0.00 ¤)",
  "fr-MF": "#,##0.00 ¤;(#,##0.00 ¤)",
  "fr-MG": "#,##0.00 ¤;(#,##0.00 ¤)",
  "fr-ML": "#,##0.00 ¤;(#,##0.00 ¤)",
  "fr-MQ": "#,##0.00 ¤;(#,##0.00 ¤)",
  "fr-MR": "#,##0.00 ¤;(#,##0.00 ¤)",
  "fr-MU": "#,##0.00 ¤;(#,##0.00 ¤)",
  "fr-NC": "#,##0.00 ¤;(#,##0.00 ¤)",
  "fr-NE": "#,##0.00 ¤;(#,##0.00 ¤)",
  "fr-PF": "#,##0.00 ¤;(#,##0.00 ¤)",
  "fr-PM": "#,##0.00 ¤;(#,##0.00 ¤)",
  "fr-RE": "#,##0.00 ¤;(#,##0.00 ¤)",
  "fr-RW": "#,##0.00 ¤;(#,##0.00 ¤)",
  "fr-SC": "#,##0.00 ¤;(#,##0.00 ¤)",
  "fr-SN": "#,##0.00 ¤;(#,##0.00 ¤)",
  "fr-SY": "#,##0.00 ¤;(#,##0.00 ¤)",
  "fr-TD": "#,##0.00 ¤;(#,##0.00 ¤)",
  "fr-TG": "#,##0.00 ¤;(#,##0.00 ¤)",
  "fr-TN": "#,##0.00 ¤;(#,##0.00 ¤)",
  "fr-VU": "#,##0.00 ¤;(#,##0.00 ¤)",
  "fr-WF": "#,##0.00 ¤;(#,##0.00 ¤)",
  "fr-YT": "#,##0.00 ¤;(#,##0.00 ¤)",
  fur: "¤ #,##0.00",
  fy: "¤ #,##0.00;(¤ #,##0.00)",
  ga: "¤#,##0.00;(¤#,##0.00)",
  "ga-GB": "¤#,##0.00;(¤#,##0.00)",
  gd: "¤#,##0.00;(¤#,##0.00)",
  gl: "#,##0.00 ¤",
  gsw: "#,##0.00 ¤",
  "gsw-FR": "#,##0.00 ¤",
  "gsw-LI": "#,##0.00 ¤",
  gu: "¤#,##,##0.00;(¤#,##,##0.00)",
  guz: "¤#,##0.00;(¤#,##0.00)",
  gv: "¤#,##0.00",
  ha: "¤ #,##0.00",
  "ha-GH": "¤ #,##0.00",
  "ha-NE": "¤ #,##0.00",
  haw: "¤#,##0.00;(¤#,##0.00)",
  he: "#,##0.00 ¤",
  hi: "¤#,##,##0.00",
  "hi-Latn": "¤#,##,##0.00",
  hr: "#,##0.00 ¤",
  "hr-BA": "#,##0.00 ¤",
  hsb: "#,##0.00 ¤",
  hu: "#,##0.00 ¤",
  hy: "#,##0.00 ¤",
  ia: "¤ #,##0.00;(¤ #,##0.00)",
  id: "¤#,##0.00",
  ig: "¤#,##0.00;(¤#,##0.00)",
  ii: "¤ #,##0.00",
  is: "#,##0.00 ¤",
  it: "#,##0.00 ¤",
  "it-CH": "#,##0.00 ¤",
  "it-SM": "#,##0.00 ¤",
  "it-VA": "#,##0.00 ¤",
  ja: "¤#,##0.00;(¤#,##0.00)",
  jgo: "¤ #,##0.00",
  jmc: "¤#,##0.00",
  jv: "¤ #,##0.00",
  ka: "#,##0.00 ¤",
  kab: "#,##0.00¤",
  kam: "¤#,##0.00;(¤#,##0.00)",
  kde: "¤#,##0.00;(¤#,##0.00)",
  kea: "#,##0.00 ¤;(#,##0.00 ¤)",
  kgp: "¤ #,##0.00",
  khq: "#,##0.00¤",
  ki: "¤#,##0.00;(¤#,##0.00)",
  kk: "#,##0.00 ¤",
  kkj: "¤ #,##0.00",
  kl: "¤#,##0.00;¤-#,##0.00",
  kln: "¤#,##0.00;(¤#,##0.00)",
  km: "#,##0.00¤;(#,##0.00¤)",
  kn: "¤#,##0.00;(¤#,##0.00)",
  ko: "¤#,##0.00;(¤#,##0.00)",
  "ko-KP": "¤#,##0.00;(¤#,##0.00)",
  kok: "¤#,##0.00;(¤#,##0.00)",
  ks: "¤#,##0.00",
  "ks-Arab": "¤#,##0.00",
  "ks-Deva": "¤ #,##0.00",
  ksb: "#,##0.00¤",
  ksf: "#,##0.00 ¤",
  ksh: "#,##0.00 ¤",
  ku: "#,##0.00 ¤;(#,##0.00 ¤)",
  kw: "¤#,##0.00",
  ky: "#,##0.00 ¤",
  lag: "¤ #,##0.00",
  lb: "#,##0.00 ¤",
  lg: "#,##0.00¤",
  lkt: "¤ #,##0.00",
  ln: "#,##0.00 ¤",
  "ln-AO": "#,##0.00 ¤",
  "ln-CF": "#,##0.00 ¤",
  "ln-CG": "#,##0.00 ¤",
  lo: "¤#,##0.00;¤-#,##0.00",
  lrc: "¤ #,##0.00",
  "lrc-IQ": "¤ #,##0.00",
  lt: "#,##0.00 ¤",
  lu: "#,##0.00¤",
  luo: "#,##0.00¤",
  luy: "¤#,##0.00;¤- #,##0.00",
  lv: "#,##0.00 ¤",
  mai: "¤ #,##0.00",
  mas: "¤#,##0.00;(¤#,##0.00)",
  "mas-TZ": "¤#,##0.00;(¤#,##0.00)",
  mer: "¤#,##0.00;(¤#,##0.00)",
  mfe: "¤ #,##0.00",
  mg: "¤#,##0.00",
  mgh: "¤ #,##0.00",
  mgo: "¤ #,##0.00",
  mi: "¤ #,##0.00",
  mk: "#,##0.00 ¤",
  ml: "¤#,##0.00;(¤#,##0.00)",
  mn: "¤ #,##0.00",
  mni: "¤ #,##0.00",
  "mni-Beng": "¤ #,##0.00",
  mr: "¤#,##0.00;(¤#,##0.00)",
  ms: "¤#,##0.00;(¤#,##0.00)",
  "ms-BN": "¤#,##0.00;(¤#,##0.00)",
  "ms-ID": "¤#,##0.00",
  "ms-SG": "¤#,##0.00;(¤#,##0.00)",
  mt: "¤#,##0.00",
  mua: "¤#,##0.00;(¤#,##0.00)",
  my: "¤ #,##0.00",
  mzn: "¤ #,##0.00",
  naq: "¤#,##0.00",
  nb: "¤ #,##0.00;(¤ #,##0.00)",
  "nb-SJ": "¤ #,##0.00;(¤ #,##0.00)",
  nd: "¤#,##0.00;(¤#,##0.00)",
  nds: "¤ #,##0.00",
  "nds-NL": "¤ #,##0.00",
  ne: "¤ #,##,##0.00",
  "ne-IN": "¤ #,##,##0.00",
  nl: "¤ #,##0.00;(¤ #,##0.00)",
  "nl-AW": "¤ #,##0.00;(¤ #,##0.00)",
  "nl-BE": "¤ #,##0.00;(¤ #,##0.00)",
  "nl-BQ": "¤ #,##0.00;(¤ #,##0.00)",
  "nl-CW": "¤ #,##0.00;(¤ #,##0.00)",
  "nl-SR": "¤ #,##0.00;(¤ #,##0.00)",
  "nl-SX": "¤ #,##0.00;(¤ #,##0.00)",
  nmg: "#,##0.00 ¤",
  nn: "#,##0.00 ¤",
  nnh: "¤ #,##0.00",
  no: "¤ #,##0.00;(¤ #,##0.00)",
  nus: "¤#,##0.00;(¤#,##0.00)",
  nyn: "¤#,##0.00",
  om: "¤#,##0.00",
  "om-KE": "¤#,##0.00",
  or: "¤#,##0.00;(¤#,##0.00)",
  os: "¤ #,##0.00",
  "os-RU": "¤ #,##0.00",
  pa: "¤ #,##0.00",
  "pa-Arab": "¤ #,##0.00",
  "pa-Guru": "¤ #,##0.00",
  pcm: "¤#,##0.00",
  pl: "#,##0.00 ¤;(#,##0.00 ¤)",
  ps: "¤#,##0.00;(¤#,##0.00)",
  "ps-PK": "¤#,##0.00;(¤#,##0.00)",
  pt: "¤ #,##0.00",
  "pt-AO": "#,##0.00 ¤;(#,##0.00 ¤)",
  "pt-CH": "#,##0.00 ¤;(#,##0.00 ¤)",
  "pt-CV": "#,##0.00 ¤;(#,##0.00 ¤)",
  "pt-GQ": "#,##0.00 ¤;(#,##0.00 ¤)",
  "pt-GW": "#,##0.00 ¤;(#,##0.00 ¤)",
  "pt-LU": "#,##0.00 ¤;(#,##0.00 ¤)",
  "pt-MO": "#,##0.00 ¤;(#,##0.00 ¤)",
  "pt-MZ": "#,##0.00 ¤;(#,##0.00 ¤)",
  "pt-PT": "#,##0.00 ¤;(#,##0.00 ¤)",
  "pt-ST": "#,##0.00 ¤;(#,##0.00 ¤)",
  "pt-TL": "#,##0.00 ¤;(#,##0.00 ¤)",
  qu: "¤ #,##0.00",
  "qu-BO": "¤ #,##0.00",
  "qu-EC": "¤ #,##0.00",
  rm: "#,##0.00 ¤",
  rn: "#,##0.00¤",
  ro: "#,##0.00 ¤;(#,##0.00 ¤)",
  "ro-MD": "#,##0.00 ¤;(#,##0.00 ¤)",
  rof: "¤#,##0.00",
  ru: "#,##0.00 ¤",
  "ru-BY": "#,##0.00 ¤",
  "ru-KG": "#,##0.00 ¤",
  "ru-KZ": "#,##0.00 ¤",
  "ru-MD": "#,##0.00 ¤",
  "ru-UA": "#,##0.00 ¤",
  rw: "¤ #,##0.00",
  rwk: "#,##0.00¤",
  sa: "¤ #,##0.00",
  sah: "#,##0.00 ¤",
  saq: "¤#,##0.00;(¤#,##0.00)",
  sat: "¤ #,##0.00",
  "sat-Olck": "¤ #,##0.00",
  sbp: "#,##0.00¤",
  sc: "#,##0.00 ¤",
  sd: "¤ #,##0.00",
  "sd-Arab": "¤ #,##0.00",
  "sd-Deva": "¤ #,##0.00",
  se: "#,##0.00 ¤",
  "se-FI": "#,##0.00 ¤",
  "se-SE": "#,##0.00 ¤",
  seh: "#,##0.00¤",
  ses: "#,##0.00¤",
  sg: "¤#,##0.00;¤-#,##0.00",
  shi: "#,##0.00¤",
  "shi-Latn": "#,##0.00¤",
  "shi-Tfng": "#,##0.00¤",
  si: "¤#,##0.00;(¤#,##0.00)",
  sk: "#,##0.00 ¤;(#,##0.00 ¤)",
  sl: "#,##0.00 ¤;(#,##0.00 ¤)",
  smn: "#,##0.00 ¤",
  sn: "¤#,##0.00;(¤#,##0.00)",
  so: "¤#,##0.00;(¤#,##0.00)",
  "so-DJ": "¤#,##0.00;(¤#,##0.00)",
  "so-ET": "¤#,##0.00;(¤#,##0.00)",
  "so-KE": "¤#,##0.00;(¤#,##0.00)",
  sq: "#,##0.00 ¤;(#,##0.00 ¤)",
  "sq-MK": "#,##0.00 ¤;(#,##0.00 ¤)",
  "sq-XK": "#,##0.00 ¤;(#,##0.00 ¤)",
  sr: "#,##0.00 ¤;(#,##0.00 ¤)",
  "sr-Cyrl": "#,##0.00 ¤;(#,##0.00 ¤)",
  "sr-Cyrl-BA": "#,##0.00 ¤;(#,##0.00 ¤)",
  "sr-Cyrl-ME": "#,##0.00 ¤;(#,##0.00 ¤)",
  "sr-Cyrl-XK": "#,##0.00 ¤;(#,##0.00 ¤)",
  "sr-Latn": "#,##0.00 ¤;(#,##0.00 ¤)",
  "sr-Latn-BA": "#,##0.00 ¤;(#,##0.00 ¤)",
  "sr-Latn-ME": "#,##0.00 ¤;(#,##0.00 ¤)",
  "sr-Latn-XK": "#,##0.00 ¤;(#,##0.00 ¤)",
  su: "¤#,##0.00",
  "su-Latn": "¤#,##0.00",
  sv: "#,##0.00 ¤",
  "sv-AX": "#,##0.00 ¤",
  "sv-FI": "#,##0.00 ¤",
  sw: "¤ #,##0.00",
  "sw-CD": "¤ #,##0.00",
  "sw-KE": "¤ #,##0.00",
  "sw-UG": "¤ #,##0.00",
  ta: "¤#,##0.00;(¤#,##0.00)",
  "ta-LK": "¤#,##0.00;(¤#,##0.00)",
  "ta-MY": "¤#,##0.00;(¤#,##0.00)",
  "ta-SG": "¤#,##0.00;(¤#,##0.00)",
  te: "¤#,##0.00;(¤#,##0.00)",
  teo: "¤#,##0.00;(¤#,##0.00)",
  "teo-KE": "¤#,##0.00;(¤#,##0.00)",
  tg: "#,##0.00 ¤",
  th: "¤#,##0.00;(¤#,##0.00)",
  ti: "¤#,##0.00",
  "ti-ER": "¤#,##0.00",
  tk: "#,##0.00 ¤",
  to: "¤ #,##0.00",
  tr: "¤#,##0.00;(¤#,##0.00)",
  "tr-CY": "¤#,##0.00;(¤#,##0.00)",
  tt: "#,##0.00 ¤",
  twq: "#,##0.00¤",
  tzm: "#,##0.00 ¤",
  ug: "¤#,##0.00;(¤#,##0.00)",
  uk: "#,##0.00 ¤",
  und: "¤ #,##0.00",
  ur: "¤#,##0.00;(¤#,##0.00)",
  "ur-IN": "¤#,##0.00;(¤#,##0.00)",
  uz: "#,##0.00 ¤",
  "uz-Arab": "¤ #,##0.00",
  "uz-Cyrl": "#,##0.00 ¤",
  "uz-Latn": "#,##0.00 ¤",
  vai: "¤#,##0.00;(¤#,##0.00)",
  "vai-Latn": "¤#,##0.00;(¤#,##0.00)",
  "vai-Vaii": "¤#,##0.00;(¤#,##0.00)",
  vi: "#,##0.00 ¤",
  vun: "¤#,##0.00",
  wae: "¤ #,##0.00",
  wo: "¤ #,##0.00",
  xh: "¤#,##0.00",
  xog: "#,##0.00 ¤",
  yav: "#,##0.00 ¤;(#,##0.00 ¤)",
  yi: "¤ #,##0.00",
  yo: "¤#,##0.00;(¤#,##0.00)",
  "yo-BJ": "¤#,##0.00;(¤#,##0.00)",
  yrl: "¤ #,##0.00",
  "yrl-CO": "¤ #,##0.00",
  "yrl-VE": "¤ #,##0.00",
  yue: "¤#,##0.00;(¤#,##0.00)",
  "yue-Hans": "¤#,##0.00;(¤#,##0.00)",
  "yue-Hant": "¤#,##0.00;(¤#,##0.00)",
  zgh: "#,##0.00¤",
  zh: "¤#,##0.00;(¤#,##0.00)",
  "zh-Hans": "¤#,##0.00;(¤#,##0.00)",
  "zh-Hans-HK": "¤#,##0.00;(¤#,##0.00)",
  "zh-Hans-MO": "¤#,##0.00;(¤#,##0.00)",
  "zh-Hans-SG": "¤#,##0.00;(¤#,##0.00)",
  "zh-Hant": "¤#,##0.00;(¤#,##0.00)",
  "zh-Hant-HK": "¤#,##0.00;(¤#,##0.00)",
  "zh-Hant-MO": "¤#,##0.00;(¤#,##0.00)",
  zu: "¤#,##0.00;(¤#,##0.00)"
}, HG = ["standard", "accounting"], WG = /([^\s0]+)?(\s*)0*[.,]*0*(\s*)([^\s0]+)?/, hp = {}, _y = (i) => {
  const e = Kn.locale() + "/" + JSON.stringify(i);
  return hp[e] || (hp[e] = new Intl.NumberFormat(Kn.locale(), i).format), hp[e];
}, zG = (i) => new Intl.NumberFormat(Kn.locale(), {
  style: "currency",
  currency: i
}), KG = {
  engine: function() {
    return "intl";
  },
  _formatNumberCore: function(i, e, t) {
    return e === "exponential" ? this.callBase.apply(this, arguments) : _y(this._normalizeFormatConfig(e, t, i))(i);
  },
  _normalizeFormatConfig: function(i, e, t) {
    let n;
    if (i === "decimal") {
      const s = String(t).split(".")[1];
      n = {
        minimumIntegerDigits: e.precision || void 0,
        useGrouping: !1,
        maximumFractionDigits: s && s.length,
        round: t < 0 ? "ceil" : "floor"
      };
    } else
      n = this._getPrecisionConfig(e.precision);
    if (i === "percent")
      n.style = "percent";
    else if (i === "currency") {
      const s = e.useCurrencyAccountingStyle ?? Pe().defaultUseCurrencyAccountingStyle;
      n.style = "currency", n.currency = e.currency || Pe().defaultCurrency, n.currencySign = HG[+s];
    }
    return n;
  },
  _getPrecisionConfig: function(i) {
    let e;
    return i === null ? e = {
      minimumFractionDigits: 0,
      maximumFractionDigits: 20
    } : e = {
      minimumFractionDigits: i || 0,
      maximumFractionDigits: i || 0
    }, e;
  },
  format: function(i, e) {
    return typeof i != "number" ? i : (e = this._normalizeFormat(e), e.currency === "default" && (e.currency = Pe().defaultCurrency), !e || typeof e != "function" && !e.type && !e.formatter ? _y(e)(i) : this.callBase.apply(this, arguments));
  },
  _getCurrencySymbolInfo: function(i) {
    const e = zG(i);
    return this._extractCurrencySymbolInfo(e.format(0));
  },
  _extractCurrencySymbolInfo: function(i) {
    const e = WG.exec(i) || [], t = e[1] ? "before" : "after", n = e[1] || e[4] || "", s = e[2] || e[3] || "";
    return {
      position: t,
      symbol: n,
      delimiter: s
    };
  },
  getCurrencySymbol: function(i) {
    return i || (i = Pe().defaultCurrency), {
      symbol: this._getCurrencySymbolInfo(i).symbol
    };
  },
  getOpenXmlCurrencyFormat: function(i) {
    const e = i || Pe().defaultCurrency, t = this._getCurrencySymbolInfo(e).symbol, n = Kn.getValueByClosestLocale((s) => LG[s]);
    return NG(t, n);
  }
}, GG = typeof Intl < "u", Cy = ["currency", "fixedpoint", "exponential", "percent", "decimal"], pp = {
  1: "K",
  2: "M",
  3: "B",
  4: "T"
}, vy = {
  largenumber: "auto",
  thousands: 1,
  millions: 2,
  billions: 3,
  trillions: 4
}, We = qn({
  engine: function() {
    return "base";
  },
  numericFormats: Cy,
  defaultLargeNumberFormatPostfixes: pp,
  _parseNumberFormatString: function(i) {
    const e = {};
    if (!i || typeof i != "string")
      return;
    const t = i.toLowerCase().split(" ");
    if (y(t, (n, s) => {
      Cy.includes(s) ? e.formatType = s : s in vy && (e.power = vy[s]);
    }), e.power && !e.formatType && (e.formatType = "fixedpoint"), e.formatType)
      return e;
  },
  _calculateNumberPower: function(i, e, t, n) {
    let s = Math.abs(i), o = 0;
    if (s > 1)
      for (; s && s >= e && (n === void 0 || o < n); )
        o++, s /= e;
    else if (s > 0 && s < 1)
      for (; s < 1 && (t === void 0 || o > t); )
        o--, s *= e;
    return o;
  },
  _getNumberByPower: function(i, e, t) {
    let n = i;
    for (; e > 0; )
      n /= t, e--;
    for (; e < 0; )
      n *= t, e++;
    return n;
  },
  _formatNumber: function(i, e, t) {
    e.power === "auto" && (e.power = this._calculateNumberPower(i, 1e3, 0, 4)), e.power && (i = this._getNumberByPower(i, e.power, 1e3));
    const n = this.defaultLargeNumberFormatPostfixes[e.power] || "";
    let s = this._formatNumberCore(i, e.formatType, t);
    return s = s.replace(/(\d|.$)(\D*)$/, "$1" + n + "$2"), s;
  },
  _formatNumberExponential: function(i, e) {
    let t = this._calculateNumberPower(i, 10), n = this._getNumberByPower(i, t, 10);
    e.precision === void 0 && (e.precision = 1), n.toFixed(e.precision || 0) >= 10 && (t++, n /= 10);
    const s = (t >= 0 ? "+" : "") + t.toString();
    return this._formatNumberCore(n, "fixedpoint", e) + "E" + s;
  },
  _addZeroes: function(i, e) {
    const t = Math.pow(10, e), n = i < 0 ? "-" : "";
    i = (Math.abs(i) * t >>> 0) / t;
    let s = i.toString();
    for (; s.length < e; )
      s = "0" + s;
    return n + s;
  },
  _addGroupSeparators: function(i) {
    const e = i.toString().split(".");
    return e[0].replace(/\B(?=(\d{3})+(?!\d))/g, Pe().thousandsSeparator) + (e[1] ? Pe().decimalSeparator + e[1] : "");
  },
  _formatNumberCore: function(i, e, t) {
    return e === "exponential" ? this._formatNumberExponential(i, t) : (e !== "decimal" && t.precision !== null && (t.precision = t.precision || 0), e === "percent" && (i *= 100), t.precision !== void 0 && (e === "decimal" ? i = this._addZeroes(i, t.precision) : i = t.precision === null ? i.toPrecision() : iT(i, t.precision)), e !== "decimal" ? i = this._addGroupSeparators(i) : i = i.toString().replace(".", Pe().decimalSeparator), e === "percent" && (i += "%"), i);
  },
  _normalizeFormat: function(i) {
    return i ? (typeof i == "function" || pe(i) || (i = {
      type: i
    }), i) : {};
  },
  _getSeparators: function() {
    return {
      decimalSeparator: this.getDecimalSeparator(),
      thousandsSeparator: this.getThousandsSeparator()
    };
  },
  getThousandsSeparator: function() {
    return this.format(1e4, "fixedPoint")[2];
  },
  getDecimalSeparator: function() {
    return this.format(1.2, {
      type: "fixedPoint",
      precision: 1
    })[1];
  },
  convertDigits: function(i, e) {
    const t = this.format(90, "decimal");
    if (typeof i != "string" || t[1] === "0")
      return i;
    const n = e ? t[1] : "0", s = e ? "0" : t[1], o = e ? t[0] : "9", r = new RegExp("[" + n + "-" + o + "]", "g");
    return i.replace(r, (a) => String.fromCharCode(a.charCodeAt(0) + (s.charCodeAt(0) - n.charCodeAt(0))));
  },
  getNegativeEtalonRegExp: function(i) {
    const e = this._getSeparators(), t = new RegExp("[0-9" + ns(e.decimalSeparator + e.thousandsSeparator) + "]+", "g");
    let n = this.format(-1, i).replace(t, "1");
    return ["\\", "(", ")", "[", "]", "*", "+", "$", "^", "?", "|", "{", "}"].forEach((s) => {
      n = n.replace(new RegExp(`\\${s}`, "g"), `\\${s}`);
    }), n = n.replace(/ /g, "\\s"), n = n.replace(/1/g, ".*"), new RegExp(n, "g");
  },
  getSign: function(i, e) {
    if (!e)
      return i.replace(/[^0-9-]/g, "").charAt(0) === "-" ? -1 : 1;
    const t = this.getNegativeEtalonRegExp(e);
    return i.match(t) ? -1 : 1;
  },
  format: function(i, e) {
    if (typeof i != "number" || typeof e == "number")
      return i;
    if (e = e && e.formatter || e, typeof e == "function")
      return e(i);
    e = this._normalizeFormat(e), e.type || (e.type = "decimal");
    const t = this._parseNumberFormatString(e.type);
    if (!t) {
      const n = this._getSeparators();
      return n.unlimitedIntegerDigits = e.unlimitedIntegerDigits, this.convertDigits(MG(e.type, n)(i));
    }
    return this._formatNumber(i, t, e);
  },
  parse: function(i, e) {
    if (!i)
      return;
    if (e && e.parser)
      return e.parser(i);
    i = this.convertDigits(i, !0), e && typeof e != "string" && Ae.log("W0011");
    const t = this.getDecimalSeparator(), n = new RegExp("[^0-9" + ns(t) + "]", "g"), s = i.replace(n, "").replace(t, ".").replace(/\.$/g, "");
    if (s === "." || s === "")
      return null;
    if (this._calcSignificantDigits(s) > 15)
      return NaN;
    let o = +s * this.getSign(i, e);
    e = this._normalizeFormat(e);
    const r = this._parseNumberFormatString(e.type);
    let a = r?.power;
    if (a) {
      if (a === "auto") {
        const l = i.match(/\d(K|M|B|T)/);
        l && (a = Object.keys(pp).find((d) => pp[d] === l[1]));
      }
      o *= Math.pow(10, 3 * a);
    }
    return r?.formatType === "percent" && (o /= 100), o;
  },
  _calcSignificantDigits: function(i) {
    const [e, t] = i.split("."), n = (o) => {
      let r = -1;
      for (let a = 0; a < o.length; a++)
        if (o[a] !== "0") {
          r = a;
          break;
        }
      return r > -1 ? o.length - r : 0;
    };
    let s = 0;
    return e && (s += n(e.split(""))), t && (s += n(t.split("").reverse())), s;
  }
});
We.inject($G);
GG && We.inject(KG);
const UG = /^[\d\w.+_-]+@[\d\w._-]+\.[\w]+$/i, _t = {
  valid: "valid",
  invalid: "invalid",
  pending: "pending"
};
class ao {
  constructor() {
    this.NAME = "base";
  }
  defaultMessage(e) {
    return S.getFormatter(`validation-${this.NAME}`)(e);
  }
  defaultFormattedMessage(e) {
    return S.getFormatter(`validation-${this.NAME}-formatted`)(e);
  }
  _isValueEmpty(e) {
    return !cd.required.validate(e, {});
  }
  validate(e, t) {
    const n = Array.isArray(e) ? e : [e];
    let s = !0;
    return n.length ? n.every((o) => (s = this._validate(o, t), s)) : s = this._validate(null, t), s;
  }
}
class jG extends ao {
  constructor() {
    super(), this.NAME = "required";
  }
  _validate(e, t) {
    return !f(e) || e === !1 ? !1 : (e = String(e), (t.trim || !f(t.trim)) && (e = e.trim()), e !== "");
  }
}
class qG extends ao {
  constructor() {
    super(), this.NAME = "numeric";
  }
  _validate(e, t) {
    return t.ignoreEmptyValue !== !1 && this._isValueEmpty(e) ? !0 : t.useCultureSettings && te(e) ? !isNaN(We.parse(e)) : $e(e);
  }
}
class YG extends ao {
  constructor() {
    super(), this.NAME = "range";
  }
  _validate(e, t) {
    if (t.ignoreEmptyValue !== !1 && this._isValueEmpty(e))
      return !0;
    const n = cd.numeric.validate(e, t), s = f(e) && e !== "", o = n ? parseFloat(e) : s && e.valueOf(), {
      min: r
    } = t, {
      max: a
    } = t;
    if (!(n || cn(e)) && !s)
      return !1;
    if (f(r))
      return f(a) ? o >= r && o <= a : o >= r;
    if (f(a))
      return o <= a;
    throw Ae.Error("E0101");
  }
}
class XG extends ao {
  constructor() {
    super(), this.NAME = "stringLength";
  }
  _validate(e, t) {
    return e = String(e ?? ""), (t.trim || !f(t.trim)) && (e = e.trim()), t.ignoreEmptyValue && this._isValueEmpty(e) ? !0 : cd.range.validate(e.length, x({}, t));
  }
}
class oT extends ao {
  constructor() {
    super(), this.NAME = "custom";
  }
  validate(e, t) {
    if (t.ignoreEmptyValue && this._isValueEmpty(e))
      return !0;
    const {
      validator: n
    } = t, s = n && B(n.option) && n.option("dataGetter"), o = B(s) && s(), r = {
      value: e,
      validator: n,
      rule: t
    };
    return o && x(r, o), t.validationCallback(r);
  }
}
class ZG extends oT {
  constructor() {
    super(), this.NAME = "async";
  }
  validate(e, t) {
    if (f(t.reevaluate) || x(t, {
      reevaluate: !0
    }), t.ignoreEmptyValue && this._isValueEmpty(e))
      return !0;
    const {
      validator: n
    } = t, s = n && B(n.option) && n.option("dataGetter"), o = B(s) && s(), r = {
      value: e,
      validator: n,
      rule: t
    };
    o && x(r, o);
    const a = t.validationCallback(r);
    if (!no(a))
      throw Ae.Error("E0103");
    return this._getWrappedPromise(It(a).promise());
  }
  _getWrappedPromise(e) {
    const t = w();
    return e.then((n) => {
      t.resolve(n);
    }, (n) => {
      const s = {
        isValid: !1
      };
      f(n) && (te(n) ? s.message = n : X(n) && f(n.message) && te(n.message) && (s.message = n.message)), t.resolve(s);
    }), t.promise();
  }
}
class QG extends ao {
  constructor() {
    super(), this.NAME = "compare";
  }
  _validate(e, t) {
    if (!t.comparisonTarget)
      throw Ae.Error("E0102");
    if (t.ignoreEmptyValue && this._isValueEmpty(e))
      return !0;
    x(t, {
      reevaluate: !0
    });
    const n = t.comparisonTarget();
    switch (t.comparisonType || "==") {
      case "==":
        return e == n;
      case "!=":
        return e != n;
      case "===":
        return e === n;
      case "!==":
        return e !== n;
      case ">":
        return e > n;
      case ">=":
        return e >= n;
      case "<":
        return e < n;
      case "<=":
        return e <= n;
    }
  }
}
class JG extends ao {
  constructor() {
    super(), this.NAME = "pattern";
  }
  _validate(e, t) {
    if (t.ignoreEmptyValue !== !1 && this._isValueEmpty(e))
      return !0;
    let {
      pattern: n
    } = t;
    return te(n) && (n = new RegExp(n)), n.test(e);
  }
}
class e4 extends ao {
  constructor() {
    super(), this.NAME = "email";
  }
  _validate(e, t) {
    return t.ignoreEmptyValue !== !1 && this._isValueEmpty(e) ? !0 : cd.pattern.validate(e, x({}, t, {
      pattern: UG
    }));
  }
}
const cd = {
  required: new jG(),
  numeric: new qG(),
  range: new YG(),
  stringLength: new XG(),
  custom: new oT(),
  async: new ZG(),
  compare: new QG(),
  pattern: new JG(),
  email: new e4()
};
class t4 extends se.inherit({}) {
  ctor(e, t) {
    this.group = e, this.validators = [], this._isRemovable = t, this._pendingValidators = [], this._onValidatorStatusChanged = this._onValidatorStatusChanged.bind(this), this._resetValidationInfo(), this._eventsStrategy = new nr(this);
  }
  validate() {
    const e = {
      isValid: !0,
      brokenRules: [],
      validators: [],
      status: _t.valid,
      complete: null
    };
    return this._unsubscribeFromAllChangeEvents(), this._pendingValidators = [], this._resetValidationInfo(), y(this.validators, (t, n) => {
      const s = n.validate();
      e.isValid = e.isValid && s.isValid, s.brokenRules && (e.brokenRules = e.brokenRules.concat(s.brokenRules)), e.validators.push(n), s.status === _t.pending && this._addPendingValidator(n), this._subscribeToChangeEvents(n);
    }), this._pendingValidators.length ? e.status = _t.pending : (e.status = e.isValid ? _t.valid : _t.invalid, this._unsubscribeFromAllChangeEvents(), this._raiseValidatedEvent(e)), this._updateValidationInfo(e), x({}, this._validationInfo.result);
  }
  _subscribeToChangeEvents(e) {
    e.on("validating", this._onValidatorStatusChanged), e.on("validated", this._onValidatorStatusChanged);
  }
  _unsubscribeFromChangeEvents(e) {
    e.off("validating", this._onValidatorStatusChanged), e.off("validated", this._onValidatorStatusChanged);
  }
  _unsubscribeFromAllChangeEvents() {
    y(this.validators, (e, t) => {
      this._unsubscribeFromChangeEvents(t);
    });
  }
  _updateValidationInfo(e) {
    this._validationInfo.result = e, e.status === _t.pending && (this._validationInfo.deferred || (this._validationInfo.deferred = w(), this._validationInfo.result.complete = this._validationInfo.deferred.promise()));
  }
  _addPendingValidator(e) {
    Wt(this._pendingValidators, (n) => n === e)[0] || this._pendingValidators.push(e);
  }
  _removePendingValidator(e) {
    const t = this._pendingValidators.indexOf(e);
    t >= 0 && this._pendingValidators.splice(t, 1);
  }
  _orderBrokenRules(e) {
    let t = [];
    return y(this.validators, (n, s) => {
      const o = Wt(e, (r) => r.validator === s);
      o.length && (t = t.concat(o));
    }), t;
  }
  _updateBrokenRules(e) {
    if (!this._validationInfo.result)
      return;
    let {
      brokenRules: t
    } = this._validationInfo.result;
    const n = Wt(t, (s) => s.validator !== e.validator);
    e.brokenRules && (t = n.concat(e.brokenRules)), this._validationInfo.result.brokenRules = this._orderBrokenRules(t);
  }
  _onValidatorStatusChanged(e) {
    if (e.status === _t.pending) {
      this._addPendingValidator(e.validator);
      return;
    }
    this._resolveIfComplete(e);
  }
  _resolveIfComplete(e) {
    if (this._removePendingValidator(e.validator), this._updateBrokenRules(e), !this._pendingValidators.length) {
      if (this._unsubscribeFromAllChangeEvents(), !this._validationInfo.result)
        return;
      this._validationInfo.result.status = this._validationInfo.result.brokenRules.length === 0 ? _t.valid : _t.invalid, this._validationInfo.result.isValid = this._validationInfo.result.status === _t.valid;
      const t = x({}, this._validationInfo.result, {
        complete: null
      }), {
        deferred: n
      } = this._validationInfo;
      this._validationInfo.deferred = null, this._raiseValidatedEvent(t), n && setTimeout(() => {
        n.resolve(t);
      });
    }
  }
  _raiseValidatedEvent(e) {
    this._eventsStrategy.fireEvent("validated", [e]);
  }
  _resetValidationInfo() {
    this._validationInfo = {
      result: null,
      deferred: null
    };
  }
  _synchronizeValidationInfo() {
    this._validationInfo.result && (this._validationInfo.result.validators = this.validators);
  }
  removeRegisteredValidator(e) {
    const t = this.validators.indexOf(e);
    t > -1 && (this.validators.splice(t, 1), this._synchronizeValidationInfo(), this._resolveIfComplete({
      validator: e
    }));
  }
  registerValidator(e) {
    this.validators.includes(e) || (this.validators.push(e), this._synchronizeValidationInfo());
  }
  reset() {
    y(this.validators, (e, t) => {
      t.reset();
    }), this._pendingValidators = [], this._resetValidationInfo();
  }
  on(e, t) {
    return this._eventsStrategy.on(e, t), this;
  }
  off(e, t) {
    return this._eventsStrategy.off(e, t), this;
  }
}
const Ve = {
  groups: [],
  getGroupConfig(i) {
    const e = Wt(this.groups, (t) => t.group === i);
    if (e.length)
      return e[0];
  },
  findGroup(i, e) {
    var t;
    const s = ((t = i.data()) === null || t === void 0 || (t = t.dxComponents) === null || t === void 0 ? void 0 : t.includes("dxValidationGroup")) && i.dxValidationGroup("instance");
    if (s)
      return s;
    const o = i.parents(".dx-validationgroup").first();
    return o.length ? o.dxValidationGroup("instance") : e;
  },
  initGroups() {
    this.groups = [], this.addGroup(void 0, !1);
  },
  addGroup(i) {
    let e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !0, t = this.getGroupConfig(i);
    return t || (t = new t4(i, e), this.groups.push(t)), t;
  },
  removeGroup(i) {
    const e = this.getGroupConfig(i), t = this.groups.indexOf(e);
    return t > -1 && this.groups.splice(t, 1), e;
  },
  _setDefaultMessage(i) {
    const {
      rule: e,
      validator: t,
      name: n
    } = i;
    f(e.message) || (t.defaultFormattedMessage && f(n) ? e.message = t.defaultFormattedMessage(n) : e.message = t.defaultMessage());
  },
  _addBrokenRule(i) {
    const {
      result: e,
      rule: t
    } = i;
    e.brokenRule || (e.brokenRule = t), e.brokenRules || (e.brokenRules = []), e.brokenRules.push(t);
  },
  validate(i, e, t) {
    var n;
    let s = {
      name: t,
      value: i,
      brokenRule: null,
      brokenRules: null,
      isValid: !0,
      validationRules: e,
      pendingRules: null,
      status: _t.valid,
      complete: null
    };
    const o = e == null || (n = e[0]) === null || n === void 0 ? void 0 : n.validator, r = [];
    return y(e || [], (a, l) => {
      const d = cd[l.type];
      let u;
      if (d) {
        if (f(l.isValid) && l.value === i && !l.reevaluate)
          return l.isValid ? !0 : (s.isValid = !1, this._addBrokenRule({
            result: s,
            rule: l
          }), !1);
        if (l.value = i, l.type === "async")
          return r.push({
            rule: l,
            ruleValidator: d
          }), !0;
        if (u = d.validate(i, l), l.isValid = u, u || (s.isValid = !1, this._setDefaultMessage({
          rule: l,
          validator: d,
          name: t
        }), this._addBrokenRule({
          result: s,
          rule: l
        })), !l.isValid)
          return !1;
      } else
        throw Ae.Error("E0100");
    }), s.isValid && !s.brokenRules && r.length && (s = this._validateAsyncRules({
      value: i,
      items: r,
      result: s,
      name: t
    })), this._synchronizeGroupValidationInfo(o, s), s.status = s.pendingRules ? _t.pending : s.isValid ? _t.valid : _t.invalid, s;
  },
  _synchronizeGroupValidationInfo(i, e) {
    if (!i)
      return;
    const t = Ve.getGroupConfig(i._validationGroup);
    t._updateBrokenRules.call(t, {
      validator: i,
      brokenRules: e.brokenRules ?? []
    });
  },
  _validateAsyncRules(i) {
    let {
      result: e,
      value: t,
      items: n,
      name: s
    } = i;
    const o = [];
    return y(n, (r, a) => {
      const l = a.ruleValidator.validate(t, a.rule);
      if (!no(l))
        this._updateRuleConfig({
          rule: a.rule,
          ruleResult: this._getPatchedRuleResult(l),
          validator: a.ruleValidator,
          name: s
        });
      else {
        e.pendingRules || (e.pendingRules = []), e.pendingRules.push(a.rule);
        const d = l.then((u) => {
          const c = this._getPatchedRuleResult(u);
          return this._updateRuleConfig({
            rule: a.rule,
            ruleResult: c,
            validator: a.ruleValidator,
            name: s
          }), c;
        });
        o.push(d);
      }
    }), o.length && (e.complete = Promise.all(o).then((r) => this._getAsyncRulesResult({
      result: e,
      values: r
    }))), e;
  },
  _updateRuleConfig(i) {
    let {
      rule: e,
      ruleResult: t,
      validator: n,
      name: s
    } = i;
    e.isValid = t.isValid, t.isValid || (f(t.message) && te(t.message) && t.message.length ? e.message = t.message : this._setDefaultMessage({
      rule: e,
      validator: n,
      name: s
    }));
  },
  _getPatchedRuleResult(i) {
    let e;
    return X(i) ? (e = x({}, i), f(e.isValid) || (e.isValid = !0)) : e = {
      isValid: Zr(i) ? i : !0
    }, e;
  },
  _getAsyncRulesResult(i) {
    let {
      values: e,
      result: t
    } = i;
    return y(e, (n, s) => {
      if (s.isValid === !1) {
        t.isValid = s.isValid;
        const o = t.pendingRules[n];
        this._addBrokenRule({
          result: t,
          rule: o
        });
      }
    }), t.pendingRules = null, t.complete = null, t.status = t.isValid ? _t.valid : _t.invalid, t;
  },
  registerValidatorInGroup(i, e) {
    const t = Ve.addGroup(i);
    t.registerValidator.call(t, e);
  },
  removeRegisteredValidator(i, e) {
    const t = Ve.getGroupConfig(i);
    if (t) {
      t.removeRegisteredValidator.call(t, e);
      const n = t.validators, s = t._isRemovable;
      n.length === 0 && s && this.removeGroup(i);
    }
  },
  initValidationOptions(i) {
    const e = {};
    return i && ["isValid", "validationStatus", "validationError", "validationErrors"].forEach((n) => {
      n in i && x(e, this.synchronizeValidationOptions({
        name: n,
        value: i[n]
      }, i));
    }), e;
  },
  synchronizeValidationOptions(i, e) {
    let {
      name: t,
      value: n
    } = i;
    switch (t) {
      case "validationStatus": {
        const s = n === _t.valid || n === _t.pending;
        return e.isValid !== s ? {
          isValid: s
        } : {};
      }
      case "isValid": {
        const {
          validationStatus: s
        } = e;
        let o = s;
        return n && s === _t.invalid ? o = _t.valid : !n && s !== _t.invalid && (o = _t.invalid), o !== s ? {
          validationStatus: o
        } : {};
      }
      case "validationErrors": {
        const s = n != null && n.length ? n[0] : null;
        return e.validationError !== s ? {
          validationError: s
        } : {};
      }
      case "validationError": {
        const {
          validationErrors: s
        } = e;
        if (!n && s)
          return {
            validationErrors: null
          };
        if (n && !s)
          return {
            validationErrors: [n]
          };
        if (n && s && n !== s[0])
          return s[0] = n, {
            validationErrors: s.slice()
          };
      }
    }
    return {};
  },
  validateGroup(i) {
    const e = Ve.getGroupConfig(i);
    if (!e)
      throw Ae.Error("E0110");
    return e.validate();
  },
  resetGroup(i) {
    const e = Ve.getGroupConfig(i);
    if (!e)
      throw Ae.Error("E0110");
    return e.reset();
  }
};
Ve.initGroups();
const n4 = "dxactive", Ld = se.inherit({
  ctor(i, e) {
    this._timeout = i, this._fire = e;
  },
  start() {
    const i = this;
    this._schedule(() => {
      i.force();
    });
  },
  _schedule(i) {
    this.stop(), this._timer = setTimeout(i, this._timeout);
  },
  stop() {
    clearTimeout(this._timer);
  },
  force() {
    this._fired || (this.stop(), this._fire(), this._fired = !0);
  },
  fired() {
    return this._fired;
  }
});
let ni;
const S_ = sh.inherit({
  ctor() {
    this.callBase.apply(this, arguments), this._active = new Ld(0, M), this._inactive = new Ld(0, M);
  },
  configure(i, e) {
    switch (e) {
      case "dxactive":
        i.activeTimeout = i.timeout;
        break;
      case "dxinactive":
        i.inactiveTimeout = i.timeout;
    }
    this.callBase(i);
  },
  start(i) {
    if (ni) {
      const e = Xs(this.getElement().get(0), ni.getElement().get(0)), t = !ni._active.fired();
      if (e && t) {
        this._cancel();
        return;
      }
      ni._inactive.force();
    }
    ni = this, this._initEvents(i), this._active.start();
  },
  _initEvents(i) {
    const e = this, t = this._getEmitterTarget(i), n = jo(i), o = z.isSimulator() || !n, r = Qe(this.activeTimeout, 30), a = Qe(this.inactiveTimeout, 400);
    this._active = new Ld(o ? r : 0, () => {
      e._fireEvent("dxactive", i, {
        target: t
      });
    }), this._inactive = new Ld(o ? a : 0, () => {
      e._fireEvent("dxinactive", i, {
        target: t
      }), ni = null;
    });
  },
  cancel(i) {
    this.end(i);
  },
  end(i) {
    const e = i.type !== ye.up;
    e ? this._active.stop() : this._active.force(), this._inactive.start(), e && this._inactive.force();
  },
  dispose() {
    this._active.stop(), this._inactive.stop(), ni === this && (ni = null), this.callBase();
  },
  lockInactive() {
    return this._active.force(), this._inactive.stop(), ni = null, this._cancel(), this._inactive.force.bind(this._inactive);
  }
});
S_.lock = function(i) {
  const e = ni ? ni.lockInactive() : M;
  i.done(e);
};
ha({
  emitter: S_,
  events: ["dxactive", "dxinactive"]
});
const {
  lock: i4
} = S_;
function hi(i, e) {
  if (i == null)
    return {};
  var t = {};
  for (var n in i)
    if ({}.hasOwnProperty.call(i, n)) {
      if (e.indexOf(n) !== -1)
        continue;
      t[n] = i[n];
    }
  return t;
}
const s4 = [];
function o4(i) {
  const {
    major: e,
    minor: t,
    patch: n
  } = i;
  return [e, t, n].join(".");
}
function rT(i) {
  const [e, t, n] = i.split(".").map(Number);
  return {
    major: e,
    minor: t,
    patch: n
  };
}
function r4(i) {
  return i.map((e) => `${e.packageName}: ${e.version}`).join(`
`);
}
function a4(i, e) {
  return i.major === e.major && i.minor === e.minor && i.patch === e.patch;
}
function l4(i) {
  let {
    major: e,
    minor: t,
    patch: n
  } = i;
  return t === 1 ? {
    major: e - 1,
    minor: 2,
    patch: n
  } : {
    major: e,
    minor: t - 1,
    patch: n
  };
}
function d4(i) {
  const e = s4.filter((t) => !a4(rT(t.version), i));
  return e.length ? (Ae.log("W0023", r4([{
    packageName: "devextreme",
    version: o4(i)
  }, ...e])), !1) : !0;
}
function u4(i) {
  return new Uint8Array(atob(i).split("").map((e) => e.charCodeAt(0)));
}
function c4(i) {
  var e;
  return new Uint8Array(((e = i.match(/.{1,2}/g)) === null || e === void 0 ? void 0 : e.map((t) => parseInt(t, 16))) ?? []);
}
function h4(i) {
  const e = new Uint8Array(i.length);
  for (let t = 0; t < i.length; t += 1)
    e[t] = 255 & i.charCodeAt(t);
  return e;
}
function p4(i) {
  const e = new Uint8Array(4 * i.length);
  for (let t = 0; t < e.length; t += 1)
    e[t] = i[t >> 2] >>> 8 * (3 - t % 4);
  return e;
}
function g4(i) {
  const e = new Uint32Array(1 + (i.length - 1 >> 2));
  for (let t = 0; t < i.length; t += 1)
    e[t >> 2] |= i[t] << 8 * (3 - t % 4);
  return e;
}
function xy(i, e) {
  return (i << e | i >>> 32 - e) >>> 0;
}
function yy(i, e) {
  const t = new Uint8Array(i.length + e.length);
  return t.set(i, 0), t.set(e, i.length), t;
}
const aT = {
  e: 65537,
  n: new Uint8Array([200, 219, 153, 203, 140, 7, 228, 253, 193, 243, 62, 137, 139, 60, 68, 242, 48, 142, 113, 88, 185, 235, 253, 105, 80, 74, 32, 170, 96, 74, 111, 250, 7, 205, 154, 3, 146, 115, 153, 53, 45, 132, 123, 56, 61, 208, 184, 201, 63, 24, 109, 223, 0, 179, 169, 102, 139, 224, 73, 233, 45, 173, 138, 66, 98, 88, 69, 76, 177, 111, 113, 218, 192, 33, 101, 152, 25, 134, 34, 173, 32, 82, 230, 44, 247, 200, 253, 170, 192, 246, 30, 12, 96, 205, 100, 249, 181, 93, 0, 231])
}, m4 = "Q3aoqHsRD3vXeUMPdXH7q5", f4 = "3021300906052b0e03021a05000414";
function _4(i) {
  const e = (8 * aT.n.length + 6) / 8, t = yy(c4(f4), i);
  if (t.length + 10 > e)
    throw Error("Key is too short for SHA1 signing algorithm");
  const n = new Uint8Array(e - t.length);
  return n.fill(255, 0, n.length - 1), n[0] = 0, n[1] = 1, n[n.length - 1] = 0, yy(n, t);
}
function C4(i) {
  try {
    const e = BigInt(0), t = BigInt(1), n = BigInt(8), s = (c, h, g) => {
      let m = t, C = c, v = h;
      for (; v; )
        v & t && (m = m * C % g), C = C * C % g, v >>= t;
      return m;
    }, o = (c) => c.reduce((h, g) => (h << n) + BigInt(g), e), r = o(i.actual), a = o(i.signature), l = BigInt(i.key.e), d = o(i.key.n);
    return s(a, l, d) === r;
  } catch {
    return !0;
  }
}
function v4(i) {
  const e = new Uint8Array(i.length + 1);
  e.set(h4(i)), e[e.length - 1] = 128;
  const t = g4(new Uint8Array(e)), n = new Uint32Array(16 * Math.ceil((t.length + 2) / 16));
  return n.set(t, 0), n[n.length - 1] = 8 * (e.length - 1), n;
}
function x4(i) {
  const e = v4(i), t = new Uint32Array([1732584193, 4023233417, 2562383102, 271733878, 3285377520]);
  for (let n = 0; n < e.length; n += 16) {
    const s = new Uint32Array(80);
    for (let u = 0; u < 16; u += 1)
      s[u] = e[n + u];
    for (let u = 16; u < 80; u += 1) {
      const c = s[u - 3] ^ s[u - 8] ^ s[u - 14] ^ s[u - 16];
      s[u] = c << 1 | c >>> 31;
    }
    let o = t[0], r = t[1], a = t[2], l = t[3], d = t[4];
    for (let u = 0; u < 80; u += 1) {
      const [c, h] = u < 20 ? [r & a | ~r & l, 1518500249] : u < 40 ? [r ^ a ^ l, 1859775393] : u < 60 ? [r & a | r & l | a & l, 2400959708] : [r ^ a ^ l, 3395469782], g = xy(o, 5) + c + d + h + s[u];
      d = l, l = a, a = xy(r, 30), r = o, o = g;
    }
    t[0] += o, t[1] += r, t[2] += a, t[3] += l, t[4] += d;
  }
  return p4(t);
}
const lT = () => typeof HTMLElement < "u" && typeof customElements < "u", dT = lT() ? HTMLElement : class {
}, No = {
  trigger: "dx-license-trigger",
  panel: "dx-license"
}, Bn = {
  buyNow: "buy-now",
  licensingDoc: "licensing-doc",
  version: "version"
}, uT = {
  opacity: "1",
  visibility: "visible",
  "clip-path": "none",
  filter: "none"
}, cT = I({}, uT, {
  width: "100%",
  height: "auto",
  "line-height": "normal",
  display: "block",
  "z-index": "1500",
  position: "static",
  transform: "translate(0px, 0px)",
  "background-color": "#FF7200",
  border: "none",
  margin: "auto",
  "box-sizing": "border-box",
  "text-align": "center"
}), y4 = I({}, cT, {
  display: "flex",
  "align-items": "center",
  "flex-direction": "row",
  position: "relative",
  top: "0px",
  left: "0px",
  padding: "0.5rem"
}), b4 = {
  width: "1rem",
  cursor: "pointer",
  height: "1rem"
}, by = I({}, uT, {
  display: "inline",
  position: "static",
  padding: "0px",
  margin: "0px",
  color: "white",
  "font-family": "'Segoe UI','Open Sans Condensed',-apple-system,BlinkMacSystemFont,avenir next,avenir,helvetica neue,helvetica,Cantarell,Ubuntu,roboto,noto,arial,sans-serif",
  "font-size": "0.875rem",
  "font-wight": "600"
});
function Ui(i, e) {
  const t = e ? I({}, i, e) : i;
  return Object.keys(t).reduce((n, s) => `${n}${[s, `${t[s]} !important;`].join(": ")}`, "");
}
class Zi extends dT {
  constructor() {
    var e, t, n, s, o;
    super(), this._observer = null, this._inReassign = !1, this._hidden = !1, this._spanStyles = Ui(by, (e = Zi.customStyles) === null || e === void 0 ? void 0 : e.textStyles), this._linkStyles = Ui(by, (t = Zi.customStyles) === null || t === void 0 ? void 0 : t.linkStyles), this._containerStyles = Ui(y4, (n = Zi.customStyles) === null || n === void 0 ? void 0 : n.containerStyles), this._contentStyles = Ui(cT, (s = Zi.customStyles) === null || s === void 0 ? void 0 : s.contentStyles), this._buttonStyles = Ui(b4, (o = Zi.customStyles) === null || o === void 0 ? void 0 : o.contentStyles);
  }
  _createSpan(e) {
    const t = document.createElement("span");
    return t.innerText = e, t.style.cssText = this._spanStyles, t;
  }
  _createLink(e, t) {
    const n = document.createElement("a");
    return n.innerText = e, n.style.cssText = this._linkStyles, n.href = t, n.target = "_blank", n;
  }
  _createButton() {
    const e = document.createElement("div");
    e.style.cssText = this._buttonStyles;
    const t = document.createElementNS("http://www.w3.org/2000/svg", "polygon"), n = document.createElementNS("http://www.w3.org/2000/svg", "svg");
    return t.setAttribute("points", "13.4 12.7 8.7 8 13.4 3.4 12.6 2.6 8 7.3 3.4 2.6 2.6 3.4 7.3 8 2.6 12.6 3.4 13.4 8 8.7 12.7 13.4 13.4 12.7"), t.style.cssText = Ui({
      fill: "#fff",
      opacity: ".5",
      "stroke-width": "0px"
    }), n.setAttribute("id", "Layer_1"), n.setAttribute("data-name", "Layer 1"), n.setAttribute("version", "1.1"), n.setAttribute("viewBox", "0 0 16 16"), n.style.cssText = Ui({
      "vertical-align": "baseline"
    }), n.appendChild(t), e.appendChild(n), e.onclick = () => {
      this._hidden = !0, this.style.cssText = Ui({
        display: "none"
      });
    }, e;
  }
  _createContentContainer() {
    const e = document.createElement("div");
    return e.style.cssText = this._contentStyles, e.append(this._createSpan("For evaluation purposes only. Redistribution prohibited. Please "), this._createLink("register", this.getAttribute(Bn.licensingDoc)), this._createSpan(" an existing license or "), this._createLink("purchase a new license", this.getAttribute(Bn.buyNow)), this._createSpan(` to continue use of DevExpress product libraries (v${this.getAttribute(Bn.version)}).`)), e;
  }
  _reassignComponent() {
    this.innerHTML = "", this.style.cssText = this._containerStyles, this.append(this._createContentContainer(), this._createButton());
  }
  connectedCallback() {
    this._reassignComponent(), this._observer || (this._observer = new MutationObserver(() => {
      if (this._hidden) {
        var e;
        (e = this._observer) === null || e === void 0 || e.disconnect();
        return;
      }
      this._inReassign ? this._inReassign = !1 : (this._inReassign = !0, this._reassignComponent());
    }), this._observer.observe(this, {
      childList: !0,
      attributes: !0,
      subtree: !0
    }));
  }
  disconnectedCallback() {
    setTimeout(() => {
      document.getElementsByTagName(No.panel).length || document.body.prepend(this);
    }, 100);
  }
}
Zi.customStyles = void 0;
class w4 extends dT {
  connectedCallback() {
    if (this.style.cssText = Ui({
      display: "none"
    }), !document.getElementsByTagName(No.panel).length) {
      const t = document.createElement(No.panel);
      t.setAttribute(Bn.version, this.getAttribute(Bn.version)), t.setAttribute(Bn.buyNow, this.getAttribute(Bn.buyNow)), t.setAttribute(Bn.licensingDoc, this.getAttribute(Bn.licensingDoc)), t.setAttribute("data-permanent", "true"), document.body.prepend(t);
    }
  }
}
function S4(i) {
  customElements.get(No.trigger) || (Zi.customStyles = i, customElements.define(No.trigger, w4), customElements.define(No.panel, Zi));
}
function E4(i, e, t, n) {
  S4(n);
  const s = document.createElement(No.trigger);
  s.setAttribute(Bn.buyNow, i), s.setAttribute(Bn.licensingDoc, e), s.setAttribute(Bn.version, t), document.body.appendChild(s);
}
function I4(i, e, t, n) {
  lT() && E4(i, e, t, n);
}
var jn;
(function(i) {
  i.corrupted = "corrupted", i.verified = "verified", i.internal = "internal";
})(jn || (jn = {}));
const D4 = ["customerId", "maxVersionAllowed", "format", "internalUsageId"], T4 = "https://go.devexpress.com/Licensing_Installer_Watermark_DevExtremeJQuery.aspx", O4 = "https://go.devexpress.com/Licensing_Documentation_DevExtremeJQuery.aspx", wy = {
  kind: jn.corrupted,
  error: "general"
}, A4 = {
  kind: jn.corrupted,
  error: "verification"
}, R4 = {
  kind: jn.corrupted,
  error: "decoding"
}, F4 = {
  kind: jn.corrupted,
  error: "deserialization"
}, k4 = {
  kind: jn.corrupted,
  error: "payload"
}, V4 = {
  kind: jn.corrupted,
  error: "version"
};
let ym = !1;
function P4(i) {
  let {
    text: e,
    signature: t
  } = i;
  return C4({
    key: aT,
    signature: u4(t),
    actual: _4(x4(e))
  });
}
function M4(i) {
  if (i === void 0)
    return wy;
  const e = i.split(".");
  if (e.length !== 2 || e[0].length === 0 || e[1].length === 0)
    return wy;
  if (!P4({
    text: e[0],
    signature: e[1]
  }))
    return A4;
  let t = "";
  try {
    t = atob(e[0]);
  } catch {
    return R4;
  }
  let n = {};
  try {
    n = JSON.parse(t);
  } catch {
    return F4;
  }
  const {
    customerId: s,
    maxVersionAllowed: o,
    format: r,
    internalUsageId: a
  } = n, l = hi(n, D4);
  return a !== void 0 ? {
    kind: jn.internal,
    internalUsageId: a
  } : s === void 0 || o === void 0 || r === void 0 ? k4 : r !== 1 ? V4 : {
    kind: jn.verified,
    payload: I({
      customerId: s,
      maxVersionAllowed: o
    }, l)
  };
}
function hT(i) {
  return isNaN(i) || i < 3;
}
function B4(i) {
  let {
    licenseKey: e,
    version: t
  } = i, n = !1;
  try {
    n = hT(t.patch);
    const {
      major: s,
      minor: o
    } = n ? l4(t) : t;
    if (!e)
      return {
        preview: n,
        error: "W0019"
      };
    const r = M4(e);
    return r.kind === jn.corrupted ? {
      preview: n,
      error: "W0021"
    } : r.kind === jn.internal ? {
      preview: n,
      internal: !0,
      error: r.internalUsageId === m4 ? void 0 : "W0020"
    } : s && o ? 10 * s + o > r.payload.maxVersionAllowed ? {
      preview: n,
      error: "W0020"
    } : {
      preview: n,
      error: void 0
    } : {
      preview: n,
      error: "W0021"
    };
  } catch {
    return {
      preview: n,
      error: "W0021"
    };
  }
}
function $4(i) {
  let e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : qv;
  if (ym)
    return;
  ym = !0;
  const t = rT(e), n = d4(t), {
    internal: s,
    error: o
  } = B4({
    licenseKey: i,
    version: t
  });
  if (!n && s)
    return;
  if (o && !s) {
    const a = Pe().buyNowLink ?? T4, l = Pe().licensingDocLink ?? O4;
    I4(a, l, qv);
  }
  const r = hT(t.patch);
  if (o) {
    Ae.log(r ? "W0022" : o);
    return;
  }
  r && !s && Ae.log("W0022");
}
function Sy() {
  return ym;
}
const N4 = {
  validateLicense: $4
}, E_ = function(i) {
  return function(e) {
    const t = p(e || "body"), n = t.filter(".dx-visibility-change-handler").add(t.find(".dx-visibility-change-handler"));
    for (let s = 0; s < n.length; s++)
      _.triggerHandler(n[s], i);
  };
}, L4 = E_("dxshown"), H4 = E_("dxhiding"), W4 = E_("dxresize"), I_ = {
  triggerHidingEvent: H4,
  triggerResizeEvent: W4,
  triggerShownEvent: L4
}, D_ = I_.triggerShownEvent, z4 = I_.triggerHidingEvent, Ii = I_.triggerResizeEvent, K4 = Ie({
  syncStrategy: !0
});
class sr {
  render(e) {
    e = e || {};
    const {
      onRendered: t
    } = e;
    delete e.onRendered;
    let n;
    return e.renovated && e.transclude && this._element ? n = p("<div>").append(this._element).contents() : n = this._renderCore(e), this._ensureResultInContainer(n, e.container), K4.fire(n, e.container), t && t(), n;
  }
  _ensureResultInContainer(e, t) {
    if (!t)
      return;
    const n = p(t), s = Xs(n.get(0), e.get(0));
    n.append(e), !(s || !Xs(O.getBody(), n.get(0))) && D_(e);
  }
  _renderCore() {
    throw Ae.Error("E0001");
  }
}
class Lo extends sr {
  _renderCore() {
    return p();
  }
}
class sa extends sr {
  constructor(e) {
    super(), this._render = e;
  }
  _renderCore(e) {
    return rh(this._render(e));
  }
}
class T_ extends sr {
  constructor(e) {
    super(), this.name = e;
  }
}
LN("default", {
  compile: (i) => rh(i),
  render: (i, e, t) => i.clone()
});
HN("default");
class G4 extends sr {
  constructor(e) {
    super(), this._element = e;
  }
  _renderCore(e) {
    const {
      transclude: t
    } = e;
    return !t && !this._compiledTemplate && (this._compiledTemplate = Xv().compile(this._element)), p("<div>").append(t ? this._element : Xv().render(this._compiledTemplate, e.model, e.index)).contents();
  }
  source() {
    return p(this._element).clone();
  }
}
function U4(i) {
  return i.reduce((e, t) => {
    const n = (e.get(t) ?? 0) + 1;
    return e.set(t, n), e;
  }, /* @__PURE__ */ new Map());
}
const j4 = function(i) {
  return Array.isArray(i) ? i : [i];
}, q4 = function(i) {
  return [...new Set(i)];
}, Ey = function() {
  let i = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [], e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [];
  const t = U4(e);
  return i.filter((n) => {
    const s = t.get(n);
    return s && t.set(n, s - 1), !s;
  });
}, Al = function(i, e, t, n) {
  const s = {}, {
    useLegacyVisibleIndex: o
  } = Pe();
  let r = 0;
  const a = (l) => !f(l[e]) && (!n || n(l));
  i.forEach((l) => {
    const d = l[e];
    d >= 0 ? (s[d] = s[d] || [], l === t ? s[d].unshift(l) : s[d].push(l)) : l[e] = void 0;
  }), o || i.forEach((l) => {
    if (a(l)) {
      for (; s[r]; )
        r++;
      s[r] = [l], r++;
    }
  }), r = 0, Bg(s, function(l, d) {
    d.forEach((u) => {
      l >= 0 && (u[e] = r++);
    });
  }), o && i.forEach((l) => {
    a(l) && (l[e] = r++);
  });
}, Y4 = (i, e) => i.reduce((t, n) => {
  const s = e(n);
  return t[s] = t[s] ?? [], t[s].push(n), t;
}, {}), pT = (i, e) => {
  const t = p(i).contents().filter(`[data-options*="${e}"]`);
  return [].slice.call(t).map((n) => {
    const s = p(n).attr("data-options") || "";
    return {
      element: n,
      options: Pe().optionsParser(s)[e]
    };
  }).filter((n) => !!n.options);
}, X4 = (i) => {
  const e = Y4(i, (n) => n.options.name);
  if (e.undefined)
    throw Ae.Error("E0023");
  const t = {};
  return Object.keys(e).forEach((n) => {
    var s;
    const o = (s = Nf(z.current(), e[n], (r) => r.options)[0]) === null || s === void 0 ? void 0 : s.element;
    o && (t[n] = o);
  }), t;
}, gT = (i) => {
  const e = i.render.bind(i);
  return x({}, i, {
    render(t) {
      const n = e(t);
      return t && t.onRendered && t.onRendered(), n;
    }
  });
}, Z4 = (i) => {
  const e = i.render.bind(i);
  return x({}, i, {
    render(t) {
      const n = p(t.container);
      return e(I({}, t, {
        container: ee(n)
      }));
    }
  });
}, Q4 = (i) => {
  const e = [];
  return "model" in i && e.push(i.model), "index" in i && e.push(i.index), e.push(i.container), e;
}, J4 = (i) => typeof i == "string" ? li.normalizeTemplateElement(i) : i, Iy = (i) => tl.isRenderer(i) && i[0] || i, eU = (i) => new G4(i), tU = (i, e, t, n) => {
  let s = null;
  return (!n || n.indexOf(i) === -1) && (s = e[i], s && !(s instanceof sr) && (tl.isFunction(s.render) && (s = Z4(s)), t || (s = gT(s)))), s;
}, Dy = (i, e, t, n, s, o) => i == null ? new Lo() : i instanceof T_ ? o[i.name] : i instanceof sr ? i : tl.isFunction(i.render) && !tl.isRenderer(i) ? n ? i : gT(i) : i.nodeType || tl.isRenderer(i) ? e(p(i)) : tU(i, t, n, s) || o[i] || e(i), nU = new sa((i) => {
  let {
    model: e,
    parent: t
  } = i;
  const n = e.widget;
  if (!n)
    return p();
  const s = p("<div>"), o = e.options || {};
  return t ? t._createComponent(s, n, o) : s[n](o), s;
});
class iU {
  constructor(e, t) {
    this._tempTemplates = [], this._defaultTemplates = {}, this._anonymousTemplateName = t || "template", this._createElement = e || eU, this._createTemplateIfNeeded = this._createTemplateIfNeeded.bind(this);
  }
  static createDefaultOptions() {
    return {
      integrationOptions: {
        watchMethod: function(e, t) {
          return (arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}).skipImmediate || t(e()), M;
        },
        templates: {
          "dx-polymorph-widget": nU
        },
        useDeferUpdateForTemplates: !0
      }
    };
  }
  get anonymousTemplateName() {
    return this._anonymousTemplateName;
  }
  addDefaultTemplates(e) {
    this._defaultTemplates = x({}, this._defaultTemplates, e);
  }
  dispose() {
    this._tempTemplates.forEach((e) => {
      e.template.dispose && e.template.dispose();
    }), this._tempTemplates = [];
  }
  extractTemplates(e) {
    const t = this._extractTemplates(e), n = this._extractAnonymousTemplate(e);
    return {
      templates: t,
      anonymousTemplateMeta: n
    };
  }
  _extractTemplates(e) {
    const t = pT(e, "dxTemplate"), n = X4(t);
    return t.forEach((s) => {
      let {
        element: o,
        options: {
          name: r
        }
      } = s;
      o === n[r] ? p(o).addClass("dx-template-wrapper").detach() : p(o).remove();
    }), Object.keys(n).map((s) => ({
      name: s,
      template: this._createTemplate(n[s])
    }));
  }
  _extractAnonymousTemplate(e) {
    const t = e.contents().detach();
    return t.filter((s, o) => {
      const r = o.nodeType === 3, a = p(o).text().trim().length < 1;
      return !(r && a);
    }).length > 0 ? {
      template: this._createTemplate(t),
      name: this._anonymousTemplateName
    } : {};
  }
  _createTemplateIfNeeded(e) {
    const t = this._tempTemplates.filter((s) => s.source === Iy(e))[0];
    if (t)
      return t.template;
    const n = this._createTemplate(e);
    return this._tempTemplates.push({
      template: n,
      source: Iy(e)
    }), n;
  }
  _createTemplate(e) {
    return this._createElement(J4(e));
  }
  getTemplate(e, t, n, s) {
    let {
      isAsyncTemplate: o,
      skipTemplates: r
    } = n;
    return B(e) ? new sa((a) => {
      const l = e.apply(s, Q4(a));
      if (!f(l))
        return new Lo();
      let d = !1;
      const u = Dy(l, (h) => h.nodeType || zn(h) && !p(h).is("script") ? new sa(() => h) : (d = !0, this._createTemplate(h)), t, o, r, this._defaultTemplates), c = u.render(a);
      return d && u.dispose && u.dispose(), c;
    }) : Dy(e, this._createTemplateIfNeeded, t, o, r, this._defaultTemplates);
  }
}
const Ty = {
  TemplateManager: iU
};
class ui extends PD {
  static getInstance(e) {
    return iI(p(e), this);
  }
  static defaultOptions(e) {
    this._classCustomRules = Object.hasOwnProperty.bind(this)("_classCustomRules") && this._classCustomRules ? this._classCustomRules : [], this._classCustomRules.push(e);
  }
  _getDefaultOptions() {
    return x(super._getDefaultOptions(), {
      width: void 0,
      height: void 0,
      rtlEnabled: Pe().rtlEnabled,
      elementAttr: {},
      disabled: !1,
      integrationOptions: {}
    }, this._useTemplates() ? Ty.TemplateManager.createDefaultOptions() : {});
  }
  ctor(e, t) {
    this._customClass = null, this._createElement(e), nI(this._$element, this, this._dispose), super.ctor(t);
    const n = Sy();
    N4.validateLicense(Pe().licenseKey), !n && Sy() && Pe({
      licenseKey: ""
    }), Gc.resolve();
  }
  _createElement(e) {
    this._$element = p(e);
  }
  _getSynchronizableOptionsForCreateComponent() {
    return ["rtlEnabled", "disabled", "templatesRenderAsynchronously"];
  }
  _checkFunctionValueDeprecation(e) {
    this.option("_ignoreFunctionValueDeprecation") || e.forEach((t) => {
      B(this.option(t)) && Ae.log("W0017", t);
    });
  }
  _visibilityChanged(e) {
  }
  _dimensionChanged() {
  }
  _init() {
    super._init(), this._checkFunctionValueDeprecation(["width", "height", "maxHeight", "maxWidth", "minHeight", "minWidth", "popupHeight", "popupWidth"]), this._attachWindowResizeCallback(), this._initTemplateManager();
  }
  _setOptionsByDevice(e) {
    super._setOptionsByDevice([].concat(this.constructor._classCustomRules || [], e || []));
  }
  _isInitialOptionValue(e) {
    return !(this.constructor._classCustomRules && Object.prototype.hasOwnProperty.call(this._convertRulesToOptions(this.constructor._classCustomRules), e)) && super._isInitialOptionValue(e);
  }
  _attachWindowResizeCallback() {
    if (this._isDimensionChangeSupported()) {
      const e = this._windowResizeCallBack = this._dimensionChanged.bind(this);
      qo.add(e);
    }
  }
  _isDimensionChangeSupported() {
    return this._dimensionChanged !== ui.prototype._dimensionChanged;
  }
  _renderComponent() {
    nL(this.$element()), this._initMarkup(), ae() && this._render();
  }
  _initMarkup() {
    const {
      rtlEnabled: e
    } = this.option() || {};
    this._renderElementAttributes(), this._toggleRTLDirection(e), this._renderVisibilityChange(), this._renderDimensions();
  }
  _render() {
    this._attachVisibilityChangeHandlers();
  }
  _renderElementAttributes() {
    const {
      elementAttr: e
    } = this.option() || {}, t = x({}, e), n = t.class;
    delete t.class, this.$element().attr(t).removeClass(this._customClass).addClass(n), this._customClass = n;
  }
  _renderVisibilityChange() {
    this._isDimensionChangeSupported() && this._attachDimensionChangeHandlers(), this._isVisibilityChangeSupported() && this.$element().addClass("dx-visibility-change-handler");
  }
  _renderDimensions() {
    const e = this.$element(), t = e.get(0), n = this._getOptionValue("width", t), s = this._getOptionValue("height", t);
    this._isCssUpdateRequired(t, s, n) && e.css({
      width: n === null ? "" : n,
      height: s === null ? "" : s
    });
  }
  _isCssUpdateRequired(e, t, n) {
    return !!(f(n) || f(t) || e.style.width || e.style.height);
  }
  _attachDimensionChangeHandlers() {
    const e = this.$element(), t = `${this.NAME}VisibilityChange`;
    ic.off(e, {
      namespace: t
    }), ic.on(e, () => this._dimensionChanged(), {
      namespace: t
    });
  }
  _attachVisibilityChangeHandlers() {
    if (this._isVisibilityChangeSupported()) {
      const e = this.$element(), t = `${this.NAME}VisibilityChange`;
      this._isHidden = !this._isVisible(), sc.off(e, {
        namespace: t
      }), sc.on(e, () => this._checkVisibilityChanged("shown"), () => this._checkVisibilityChanged("hiding"), {
        namespace: t
      });
    }
  }
  _isVisible() {
    return this.$element().is(":visible");
  }
  _checkVisibilityChanged(e) {
    this._isVisible() && (e === "hiding" && !this._isHidden ? (this._visibilityChanged(!1), this._isHidden = !0) : e === "shown" && this._isHidden && (this._isHidden = !1, this._visibilityChanged(!0)));
  }
  _isVisibilityChangeSupported() {
    return this._visibilityChanged !== ui.prototype._visibilityChanged && ae();
  }
  _clean() {
  }
  _modelByElement(e) {
    const {
      modelByElement: t
    } = this.option(), n = this.$element();
    return t ? t(n) : void 0;
  }
  _invalidate() {
    if (this._isUpdateAllowed())
      throw Ae.Error("E0007");
    this._requireRefresh = !0;
  }
  _refresh() {
    this._clean(), this._renderComponent();
  }
  _dispose() {
    this._templateManager && this._templateManager.dispose(), super._dispose(), this._clean(), this._detachWindowResizeCallback();
  }
  _detachWindowResizeCallback() {
    this._isDimensionChangeSupported() && qo.remove(this._windowResizeCallBack);
  }
  _toggleRTLDirection(e) {
    this.$element().toggleClass("dx-rtl", e);
  }
  _createComponent(e, t, n) {
    const s = n ?? {}, o = Wt(this._getSynchronizableOptionsForCreateComponent(), (u) => !(u in s)), {
      integrationOptions: r
    } = this.option();
    let {
      nestedComponentOptions: a
    } = this.option();
    a = a ?? M;
    const l = x({
      integrationOptions: r
    }, a(this));
    o.forEach((u) => l[u] = this.option(u)), this._extendConfig(s, l);
    let d;
    if (te(t) ? d = p(e)[t](s)[t]("instance") : e && (d = t.getInstance(e), d ? d.option(s) : d = new t(e, s)), d) {
      const u = (c) => {
        let {
          name: h,
          value: g
        } = c;
        o.includes(h) && d.option(h, g);
      };
      this.on("optionChanged", u), d.on("disposing", () => this.off("optionChanged", u));
    }
    return d;
  }
  _extendConfig(e, t) {
    y(t, (n, s) => {
      !Object.prototype.hasOwnProperty.call(e, n) && (e[n] = s);
    });
  }
  _defaultActionConfig() {
    const e = this.$element(), t = this._modelByElement(e);
    return x(super._defaultActionConfig(), {
      context: t
    });
  }
  _defaultActionArgs() {
    const e = this.$element(), t = this._modelByElement(e), n = this.element();
    return x(super._defaultActionArgs(), {
      element: n,
      model: t
    });
  }
  _optionChanged(e) {
    const {
      name: t
    } = e;
    switch (t) {
      case "width":
      case "height":
        this._renderDimensions();
        break;
      case "rtlEnabled":
        this._invalidate();
        break;
      case "elementAttr":
        this._renderElementAttributes();
        break;
      case "disabled":
      case "integrationOptions":
        break;
      default:
        super._optionChanged(e);
    }
  }
  _removeAttributes(e) {
    const t = e.attributes;
    for (let n = t.length - 1; n >= 0; n--) {
      const s = t[n];
      if (s) {
        const {
          name: o
        } = s;
        (!o.indexOf("aria-") || o.indexOf("dx-") !== -1 || o === "role" || o === "style" || o === "tabindex") && e.removeAttribute(o);
      }
    }
  }
  _removeClasses(e) {
    e.className = e.className.split(" ").filter((t) => t.lastIndexOf("dx-", 0) !== 0).join(" ");
  }
  _updateDOMComponent(e) {
    e ? this._renderComponent() : this._requireRefresh && (this._requireRefresh = !1, this._refresh());
  }
  endUpdate() {
    const e = this._isInitializingRequired();
    super.endUpdate(), this._isUpdateAllowed() && this._updateDOMComponent(e);
  }
  $element() {
    return this._$element;
  }
  element() {
    const e = this.$element();
    return ee(e);
  }
  dispose() {
    const e = this.$element().get(0);
    Ll(e, !0), e.textContent = "", this._removeAttributes(e), this._removeClasses(e);
  }
  resetOption(e) {
    if (super.resetOption(e), e === "width" || e === "height") {
      const t = this.initialOption(e);
      !f(t) && this.$element().css(e, "");
    }
  }
  _getAnonymousTemplateName() {
  }
  _initTemplateManager() {
    if (this._templateManager || !this._useTemplates())
      return;
    const {
      integrationOptions: e = {}
    } = this.option(), {
      createTemplate: t
    } = e;
    this._templateManager = new Ty.TemplateManager(t, this._getAnonymousTemplateName()), this._initTemplates();
  }
  _initTemplates() {
    const {
      templates: e,
      anonymousTemplateMeta: t
    } = this._templateManager.extractTemplates(this.$element()), n = this.option(`integrationOptions.templates.${t.name}`);
    e.forEach((s) => {
      let {
        name: o,
        template: r
      } = s;
      this._options.silent(`integrationOptions.templates.${o}`, r);
    }), t.name && !n && (this._options.silent(`integrationOptions.templates.${t.name}`, t.template), this._options.silent("_hasAnonymousTemplateContent", !0));
  }
  _getTemplateByOption(e) {
    return this._getTemplate(this.option(e));
  }
  _getTemplate(e) {
    const t = this.option("integrationOptions.templates"), n = this.option("templatesRenderAsynchronously"), s = this.option("integrationOptions.skipTemplates");
    return this._templateManager.getTemplate(e, t, {
      isAsyncTemplate: n,
      skipTemplates: s
    }, this);
  }
  _saveTemplate(e, t) {
    this._setOptionWithoutOptionChange(`integrationOptions.templates.${e}`, this._templateManager._createTemplate(t));
  }
  _useTemplates() {
    return !0;
  }
}
const Oy = (i) => {
  const {
    parentNode: e
  } = i;
  if (e) {
    const {
      nextSibling: t
    } = i;
    Ll(i), e.$V = i.$V, Jc(null, e), e.insertBefore(i, t), i.innerHTML = "", delete e.$V;
  }
  delete i.$V;
}, fr = qn({
  createElement: (i, e) => Du(i, e),
  remove: Oy,
  onAfterRender: () => {
    Rs.callEffects();
  },
  onPreRender: () => {
    Rs.lock();
  },
  render: (i, e, t, n) => {
    if (n)
      Jc(Du(i, e), t);
    else {
      const {
        parentNode: s
      } = t, o = t?.nextSibling, r = O.createElement("div");
      r.appendChild(t);
      const a = O.createDocumentFragment().appendChild(r);
      !!t.$V && Oy(t), NH(Du(i, e), a), t.$V = a.$V, s && s.insertBefore(t, o);
    }
  }
}), sU = ["isEqual"], oU = (i) => !!i.toArray, rU = (i, e) => {
  const t = {
    template: e,
    model: I({}, i)
  }, n = i.data ?? {}, {
    isEqual: s
  } = n, o = hi(n, sU);
  return s && (t.model.data = o, t.isEqual = s), t;
}, aU = (i, e) => {
  const {
    data: t,
    index: n
  } = i.model ?? {
    data: {}
  };
  t && Object.keys(t).forEach((o) => {
    t[o] && O.isNode(t[o]) && (t[o] = ee(p(t[o])));
  });
  const s = i.template.render(I({
    container: e,
    transclude: i.transclude
  }, {
    renovated: i.renovated
  }, i.transclude ? {} : {
    model: t
  }, !i.transclude && Number.isFinite(n) ? {
    index: n
  } : {}));
  return s === void 0 ? [] : oU(s) ? s.toArray() : [p(s).get(0)];
}, lU = (i, e) => {
  e.forEach((t) => {
    !!!i.find((s) => t === s) && t.parentNode && p(t).remove();
  });
};
class Ay extends vs {
  constructor(e) {
    super(e), this.renderTemplate = this.renderTemplate.bind(this);
  }
  renderTemplate() {
    const e = Hn(this.$LI, !0);
    if (!(e != null && e.parentNode))
      return () => {
      };
    const t = e.parentNode, n = p(t), s = n.contents().toArray(), o = aU(this.props, ee(n));
    return zD(p(e), p(o)), () => {
      const r = p(t).contents().toArray();
      lU(s, r), t.appendChild(e);
    };
  }
  shouldComponentUpdate(e) {
    const {
      template: t,
      model: n
    } = this.props, {
      template: s,
      model: o,
      isEqual: r
    } = e, a = r ?? $z;
    if (t !== s)
      return !0;
    if (!f(n) || !f(o))
      return n !== o;
    const {
      data: l,
      index: d
    } = n, {
      data: u,
      index: c
    } = o;
    return d !== c ? !0 : !f(l) || !f(u) ? n !== o : !a(l, u);
  }
  createEffects() {
    return [new et(this.renderTemplate, [this.props.template, this.props.model])];
  }
  updateEffects() {
    this._effects[0].update([this.props.template, this.props.model]);
  }
  componentWillUnmount() {
  }
  render() {
    return null;
  }
}
const gp = (i, e) => (t) => {
  Object.prototype.hasOwnProperty.call(i, t) && i[t] === void 0 && (i[t] = e(t));
};
class hd extends ui {
  get _propsInfo() {
    return {
      allowNull: [],
      twoWay: [],
      elements: [],
      templates: [],
      props: []
    };
  }
  constructor(e, t) {
    super(e, t), this._shouldRaiseContentReady = !1, this.validateKeyDownHandler();
  }
  validateKeyDownHandler() {
    const t = this.getSupportedKeyNames().length > 0, n = typeof this._viewComponent.prototype.keyDown == "function";
    if (t && !n)
      throw Error("Component's declaration must have 'keyDown' method.");
  }
  get viewRef() {
    var e;
    return (e = this._viewRef) === null || e === void 0 ? void 0 : e.current;
  }
  _checkContentReadyOption(e) {
    const t = this._getContentReadyOptions().reduce((n, s) => (n[s] = !0, n), {});
    return this._checkContentReadyOption = (n) => !!t[n], this._checkContentReadyOption(e);
  }
  _getContentReadyOptions() {
    return ["rtlEnabled"];
  }
  _fireContentReady() {
    this._actionsMap.onContentReady({});
  }
  _getDefaultOptions() {
    const e = this._getViewComponentDefaultProps();
    return x(!0, super._getDefaultOptions(), e, this._propsInfo.twoWay.reduce((t, n) => {
      let [s, o, r] = n;
      return I({}, t, {
        [s]: e[o],
        [r]: (a) => this.option(s, a)
      });
    }, {}), this._propsInfo.templates.reduce((t, n) => I({}, t, {
      [n]: null
    }), {}));
  }
  _getUnwrappedOption() {
    const e = {};
    return Object.keys(this.option()).forEach((t) => {
      e[t] = this.option(t);
    }), e;
  }
  _initializeComponent() {
    var e;
    super._initializeComponent(), (e = this._templateManager) === null || e === void 0 || e.addDefaultTemplates(this.getDefaultTemplates());
    const t = this._getUnwrappedOption();
    this._props = this._optionsWithDefaultTemplates(t), this._propsInfo.templates.forEach((n) => {
      this._componentTemplates[n] = this._createTemplateComponent(this._props[n]);
    }), Object.keys(this._getActionConfigsFull()).forEach((n) => this._addAction(n)), this._viewRef = ct(), this.defaultKeyHandlers = this._createDefaultKeyHandlers();
  }
  _initMarkup() {
    const e = this.getProps();
    this._renderWrapper(e);
  }
  _renderWrapper(e) {
    const t = this.$element()[0];
    this._isNodeReplaced || fr.onPreRender(), fr.render(this._viewComponent, e, t, this._isNodeReplaced), this._isNodeReplaced || (this._isNodeReplaced = !0, fr.onAfterRender(), this._shouldRaiseContentReady = !0), this._shouldRaiseContentReady && (this._fireContentReady(), this._shouldRaiseContentReady = !1);
  }
  _silent(e, t) {
    this._options.silent(e, t);
  }
  _render() {
  }
  _removeWidget() {
    fr.remove(this.$element()[0]);
  }
  _dispose() {
    this._removeWidget(), super._dispose();
  }
  get elementAttr() {
    const e = this.$element()[0];
    if (!this._elementAttr) {
      const {
        attributes: s
      } = e, o = Array.from(s).filter((r) => {
        var a;
        return !this._propsInfo.templates.includes(r.name) && ((a = s[r.name]) === null || a === void 0 ? void 0 : a.specified);
      }).reduce((r, a) => {
        let {
          name: l,
          value: d
        } = a;
        const u = r, c = l in e;
        return u[l] = d === "" && c ? e[l] : d, u;
      }, {});
      this._elementAttr = o, this._storedClasses = e.getAttribute("class") || "";
    }
    const t = e.style, n = {};
    for (let s = 0; s < t.length; s += 1)
      n[t[s]] = t.getPropertyValue(t[s]);
    return this._elementAttr.style = n, this._elementAttr.class = this._storedClasses, this._elementAttr;
  }
  _getAdditionalActionConfigs() {
    return {
      onContentReady: {
        excludeValidators: ["disabled", "readOnly"]
      }
    };
  }
  _getAdditionalProps() {
    return [];
  }
  _patchOptionValues(e) {
    const {
      allowNull: t,
      twoWay: n,
      elements: s,
      props: o
    } = this._propsInfo, r = this._getViewComponentDefaultProps(), a = Object.keys(r), l = this._getDefaultOptions(), {
      ref: d,
      children: u,
      onKeyboardHandled: c
    } = e, g = {
      ref: d,
      children: u,
      onKeyDown: c ? (m, C) => {
        c(C);
      } : void 0
    };
    return [...o, ...this._getAdditionalProps()].forEach((m) => {
      Object.prototype.hasOwnProperty.call(e, m) && (g[m] = e[m]);
    }), t.forEach(gp(g, () => null)), a.forEach(gp(g, (m) => l[m])), n.forEach((m) => {
      let [C, v] = m;
      gp(g, () => l[v])(C);
    }), s.forEach((m) => {
      if (m in g) {
        const C = g[m];
        zn(C) && (g[m] = this._patchElementParam(C));
      }
    }), g;
  }
  getSupportedKeyNames() {
    return [];
  }
  prepareStyleProp(e) {
    return typeof e.style == "string" ? I({}, e, {
      style: {},
      cssText: e.style
    }) : e;
  }
  getProps() {
    const {
      elementAttr: e
    } = this.option(), t = this._patchOptionValues(I({}, this._props, {
      ref: this._viewRef,
      children: this._extractDefaultSlot(),
      aria: this._aria
    }));
    return this._propsInfo.templates.forEach((n) => {
      t[n] = this._componentTemplates[n];
    }), this.prepareStyleProp(I({}, t, this.elementAttr, e, {
      className: [...(this.elementAttr.class ?? "").split(" "), ...(e?.class ?? "").split(" ")].filter((n, s, o) => n && o.indexOf(n) === s).join(" ").trim(),
      class: ""
    }, this._actionsMap));
  }
  _getActionConfigs() {
    return {};
  }
  _getActionConfigsFull() {
    return I({}, this._getActionConfigs(), this._getAdditionalActionConfigs());
  }
  getDefaultTemplates() {
    const e = Object.values(this._templatesInfo), t = {};
    return e.forEach((n) => {
      t[n] = "dx-renovation-template-mock";
    }), t;
  }
  get _templatesInfo() {
    return {};
  }
  _optionsWithDefaultTemplates(e) {
    const t = Object.entries(this._templatesInfo).reduce((n, s) => {
      let [o, r] = s;
      return I({}, n, {
        [o]: e[o] ?? r
      });
    }, {});
    return I({}, e, t);
  }
  _init() {
    super._init(), this.customKeyHandlers = {}, this._actionsMap = {}, this._aria = {}, this._componentTemplates = {};
  }
  _createDefaultKeyHandlers() {
    const e = {};
    return this.getSupportedKeyNames().forEach((n) => {
      e[n] = (s) => this.viewRef.keyDown(u_.createKeyDownOptions(s));
    }), e;
  }
  _addAction(e, t) {
    let n = t;
    if (!n) {
      const s = this._createActionByOption(e, this._getActionConfigsFull()[e]);
      n = (o) => (Object.keys(o).forEach((r) => {
        f(o[r]) && O.isNode(o[r]) && (o[r] = ee(p(o[r])));
      }), s(o));
    }
    this._actionsMap[e] = n;
  }
  _optionChanged(e) {
    const {
      name: t,
      fullName: n,
      value: s,
      previousValue: o
    } = e;
    Nz(this._props, this.option(), t, n), this._propsInfo.templates.includes(t) && s !== o && (this._componentTemplates[t] = this._createTemplateComponent(s)), t && this._getActionConfigsFull()[t] && this._addAction(t), this._shouldRaiseContentReady = this._shouldRaiseContentReady || this._checkContentReadyOption(n), super._optionChanged(e), this._invalidate();
  }
  _validateOptions(e) {
    return super._validateOptions(e);
  }
  _extractDefaultSlot() {
    return this.option("_hasAnonymousTemplateContent") ? fr.createElement(Ay, {
      template: this._getTemplate(this._templateManager.anonymousTemplateName),
      transclude: !0,
      renovated: !0
    }) : null;
  }
  _createTemplateComponent(e) {
    if (!e)
      return;
    const t = this._getTemplate(e);
    if (!(te(t) && t === "dx-renovation-template-mock"))
      return (n) => fr.createElement(Ay, rU(n, t));
  }
  _wrapKeyDownHandler(e) {
    return (t) => {
      const {
        originalEvent: n,
        keyName: s,
        which: o
      } = t, r = this.customKeyHandlers, a = r[s] || r[o];
      return a !== void 0 && !a.bind(this)(n, t) ? (n.cancel = !0, n) : e?.(n, t);
    };
  }
  _toPublicElement(e) {
    return ee(p(e));
  }
  _patchElementParam(e) {
    try {
      const t = p(e), n = t?.get(0);
      return n != null && n.nodeType ? n : e;
    } catch {
      return e;
    }
  }
  focus() {
    const e = this.$element();
    if (!(e.is(":focus") || e.find(":focus").length > 0))
      if (this.option("focusStateEnabled"))
        e.focus();
      else {
        var n;
        (n = e.find("[tabindex]")[0]) === null || n === void 0 || n.focus();
      }
  }
  repaint() {
    this._isNodeReplaced = !1, this._shouldRaiseContentReady = !0, this._removeWidget(), this._refresh();
  }
  _supportedKeys() {
    return I({}, this.defaultKeyHandlers, this.customKeyHandlers);
  }
  registerKeyHandler(e, t) {
    this.customKeyHandlers[e] = t;
  }
  setAria(e, t) {
    this._aria[e] = t, this._initMarkup();
  }
  _getViewComponentDefaultProps() {
    return this._viewComponent.defaultProps || {};
  }
}
hd.IS_RENOVATED_WIDGET = !1;
hd.IS_RENOVATED_WIDGET = !0;
class dU extends hd {
  get _validationGroupConfig() {
    return Ve.getGroupConfig(this._findGroup());
  }
  getDefaultTemplateNames() {
    return ["content"];
  }
  getSupportedKeyNames() {
    return ["space", "enter"];
  }
  getProps() {
    const e = super.getProps();
    return e.onClick = (n) => {
      let {
        event: s
      } = n;
      this._clickAction({
        event: s,
        validationGroup: this._validationGroupConfig
      });
    }, td(e.icon) === "svg" && (e.iconTemplate = this._createTemplateComponent(() => e.icon)), e;
  }
  get _templatesInfo() {
    return {
      template: "content"
    };
  }
  _toggleActiveState(e, t) {
    const n = this.viewRef;
    t ? n.activate() : n.deactivate();
  }
  _getSubmitAction() {
    let e = !0, t = "valid";
    return this._createAction((n) => {
      let {
        event: s,
        submitInput: o
      } = n;
      if (e) {
        const r = this._validationGroupConfig;
        if (r !== void 0 && r !== "") {
          const a = r.validate();
          t = a.status, a.status === "pending" && (e = !1, this.option("disabled", !0), a.complete.then((l) => {
            let {
              status: d
            } = l;
            this.option("disabled", !1), t = d, t === "valid" && o.click(), e = !0;
          }));
        }
      }
      t !== "valid" && s.preventDefault(), s.stopPropagation();
    });
  }
  _initializeComponent() {
    super._initializeComponent(), this._addAction("onSubmit", this._getSubmitAction()), this._clickAction = this._createClickAction();
  }
  _initMarkup() {
    super._initMarkup();
    const e = this.$element().find(".dx-button-content").first(), t = e.children().filter(".dx-template-wrapper"), n = e.children().filter(".dx-button-submit-input");
    t.length && (t.addClass("dx-button-content"), t.append(n), e.replaceWith(t));
  }
  _patchOptionValues(e) {
    return super._patchOptionValues(I({}, e, {
      templateData: e._templateData
    }));
  }
  _findGroup() {
    const e = this.$element(), t = this.option("validationGroup");
    return t !== void 0 && t !== "" ? t : Ve.findGroup(e, this._modelByElement(e));
  }
  _createClickAction() {
    return this._createActionByOption("onClick", {
      excludeValidators: ["readOnly"]
    });
  }
  _optionChanged(e) {
    e.name === "onClick" && (this._clickAction = this._createClickAction()), super._optionChanged(e);
  }
}
class wt extends dU {
  getProps() {
    const e = super.getProps();
    return e.onKeyDown = this._wrapKeyDownHandler(e.onKeyDown), e;
  }
  focus() {
    let e;
    return (e = this.viewRef) === null || e === void 0 ? void 0 : e.focus(...arguments);
  }
  activate() {
    let e;
    return (e = this.viewRef) === null || e === void 0 ? void 0 : e.activate(...arguments);
  }
  deactivate() {
    let e;
    return (e = this.viewRef) === null || e === void 0 ? void 0 : e.deactivate(...arguments);
  }
  _getActionConfigs() {
    return {
      onClick: {
        excludeValidators: ["readOnly"]
      },
      onSubmit: {}
    };
  }
  get _propsInfo() {
    return {
      twoWay: [],
      allowNull: [],
      elements: ["onSubmit"],
      templates: ["template", "iconTemplate"],
      props: ["activeStateEnabled", "hoverStateEnabled", "icon", "iconPosition", "onClick", "onSubmit", "pressed", "stylingMode", "template", "iconTemplate", "text", "type", "useInkRipple", "useSubmitBehavior", "templateData", "className", "accessKey", "disabled", "focusStateEnabled", "height", "hint", "onKeyDown", "rtlEnabled", "tabIndex", "visible", "width"]
    };
  }
  get _viewComponent() {
    return pc;
  }
}
xe("dxButton", wt);
wt.defaultOptions = IG;
/*!
 * devextreme-vue
 * Version: 24.2.7
 * Build date: Mon Apr 28 2025
 *
 * Copyright (c) 2012 - 2025 Developer Express Inc. ALL RIGHTS RESERVED
 *
 * This software may be modified and distributed under the terms
 * of the MIT license. See the LICENSE file in the root of the project for details.
 *
 * https://github.com/DevExpress/devextreme-vue
 */
const mT = {
  props: {
    accessKey: String,
    activeStateEnabled: Boolean,
    disabled: Boolean,
    elementAttr: Object,
    focusStateEnabled: Boolean,
    height: [Function, Number, String],
    hint: String,
    hoverStateEnabled: Boolean,
    icon: String,
    onClick: Function,
    onContentReady: Function,
    onDisposing: Function,
    onInitialized: Function,
    onOptionChanged: Function,
    rtlEnabled: Boolean,
    stylingMode: String,
    tabIndex: Number,
    template: {},
    text: String,
    type: String,
    useSubmitBehavior: Boolean,
    validationGroup: String,
    visible: Boolean,
    width: [Function, Number, String]
  },
  emits: {
    "update:isActive": null,
    "update:hoveredElement": null,
    "update:accessKey": null,
    "update:activeStateEnabled": null,
    "update:disabled": null,
    "update:elementAttr": null,
    "update:focusStateEnabled": null,
    "update:height": null,
    "update:hint": null,
    "update:hoverStateEnabled": null,
    "update:icon": null,
    "update:onClick": null,
    "update:onContentReady": null,
    "update:onDisposing": null,
    "update:onInitialized": null,
    "update:onOptionChanged": null,
    "update:rtlEnabled": null,
    "update:stylingMode": null,
    "update:tabIndex": null,
    "update:template": null,
    "update:text": null,
    "update:type": null,
    "update:useSubmitBehavior": null,
    "update:validationGroup": null,
    "update:visible": null,
    "update:width": null
  },
  computed: {
    instance() {
      return this.$_instance;
    }
  },
  beforeCreate() {
    this.$_WidgetClass = wt, this.$_hasAsyncTemplate = !0;
  }
};
io(mT);
const Yne = /* @__PURE__ */ A(mT), gc = {
  draggableColumn: "draggable-column"
}, bm = "dx-state-focused", uU = "dx-cell-focus-disabled", fT = ".dx-datagrid-rowsview .dx-row", Ry = `${fT} > td`, _T = ".dx-treelist-rowsview .dx-row", Fy = `${_T} > td`, ky = {
  groupPanel: [".dx-datagrid-group-panel .dx-group-panel-item[tabindex]"],
  columnHeaders: [".dx-datagrid-headers .dx-header-row > td.dx-datagrid-action", ".dx-treelist-headers .dx-header-row > td.dx-treelist-action"],
  filterRow: [".dx-datagrid-headers .dx-datagrid-filter-row .dx-editor-cell .dx-texteditor-input", ".dx-treelist-headers .dx-treelist-filter-row .dx-editor-cell .dx-texteditor-input"],
  rowsView: [".dx-row-focused", `${fT}[tabindex]`, `${Ry}[tabindex]`, `${Ry}`, `${_T}[tabindex]`, `${Fy}[tabindex]`, `${Fy}`],
  footer: [".dx-datagrid-total-footer .dx-datagrid-summary-item", ".dx-treelist-total-footer .dx-treelist-summary-item"],
  filterPanel: [".dx-datagrid-filter-panel .dx-icon-filter", ".dx-treelist-filter-panel .dx-icon-filter"],
  pager: [".dx-datagrid-pager [tabindex]", ".dx-treelist-pager [tabindex]"]
};
let mp = !1, mc = !1, Tr = null;
function cU(i, e, t, n, s, o) {
  if (pU(e, t.originalEvent, o))
    return;
  const a = Ye(t);
  a === "enter" || a === "space" ? (CT(t.target, e), n && n({
    event: t
  })) : a === "tab" ? s.addClass(bm) : A_(i, e, t);
}
function CT(i, e) {
  const t = p(i), n = t.attr("aria-label"), o = vT(n, e.element()).index(t);
  Tr = x({}, {
    ariaLabel: n,
    index: o
  }, {
    viewInstance: e
  });
}
function vT(i, e) {
  const t = p(e);
  let n;
  if (i) {
    const s = i?.replace(/\\/g, "\\\\").replace(/"/g, '\\"');
    n = t.find(`[aria-label="${s}"][tabindex]`);
  } else
    n = t.find("[tabindex]");
  return n;
}
function hU(i, e) {
  const t = e?.getRootNode() || O.getDocument();
  for (const n in i) {
    const s = i[n], o = p(t).find(s).first();
    if (o.length)
      return o;
  }
}
function pU(i, e, t) {
  const n = {
    event: e,
    handled: !1
  };
  return t ? t(n) : i._createActionByOption("onKeyDown")(n), n.handled;
}
function xT() {
  mc = O.getDocument().visibilityState === "visible";
}
function gU() {
  _.on(O.getDocument(), "visibilitychange", xT);
}
function Vy() {
  _.off(O.getDocument(), "visibilitychange", xT);
}
function mU(i, e) {
  mc = !0, i.focus({
    preventScroll: e
  }), mc = !1;
}
function yT(i, e, t, n, s, o) {
  if (e.option("useLegacyKeyboardNavigation"))
    return M;
  const r = () => p(e.element()), a = (u) => cU(i, e, u, s, r(), o), l = () => {
    mp = !0, r().removeClass(bm);
  }, d = () => {
    !mp && !mc && r().addClass(bm), mp = !1;
  };
  return _.on(t, "keydown", n, a), _.on(t, "mousedown", n, l), _.on(t, "focusin", n, d), () => {
    _.off(t, "keydown", n, a), _.off(t, "mousedown", n, l), _.off(t, "focusin", n, d);
  };
}
function O_(i) {
  if (!i.option("useLegacyKeyboardNavigation") && Tr) {
    const e = Tr.viewInstance;
    if (e) {
      const n = vT(Tr.ariaLabel, e.element()).eq(Tr.index);
      Tr = null, _.trigger(n, "focus");
    }
  }
}
function A_(i, e, t) {
  const n = Ye(t);
  if (t.ctrlKey && (n === "upArrow" || n === "downArrow")) {
    const s = Object.keys(ky);
    let o = s.indexOf(i);
    for (; o >= 0 && o < s.length; ) {
      o = n === "upArrow" ? --o : ++o;
      const r = s[o], a = ky[r], l = hU(a, t.target);
      if (l && l.length) {
        l.attr("tabindex", e.option("tabindex") || 0), _.trigger(l, "focus"), l.removeClass(uU);
        break;
      }
    }
  }
}
function fU(i, e) {
  i.option("useLegacyKeyboardnavigation") || e.attr("tabindex", i.option("tabindex") || 0);
}
const rl = function(i, e, t, n, s) {
  const o = e.getController("keyboardNavigation");
  e.option("useLegacyKeyboardNavigation") || o && !o.isKeyboardEnabled() || (e.createAction("onKeyDown"), yT(i, e, t, n, s, (r) => {
    e.executeAction("onKeyDown", r);
  }));
}, pd = "dxdblclick", Py = R(Te, "dxDblClick"), _U = se.inherit({
  ctor() {
    this._handlerCount = 0, this._forgetLastClick();
  },
  _forgetLastClick() {
    this._firstClickTarget = null, this._lastClickTimeStamp = -300;
  },
  add() {
    this._handlerCount <= 0 && _.on(O.getDocument(), Py, this._clickHandler.bind(this)), this._handlerCount += 1;
  },
  _clickHandler(i) {
    const e = i.timeStamp || Date.now(), t = e - this._lastClickTimeStamp;
    !(t < 0) && t < 300 ? (oo({
      type: "dxdblclick",
      target: LD(this._firstClickTarget, i.target),
      originalEvent: i
    }), this._forgetLastClick()) : (this._firstClickTarget = i.target, this._lastClickTimeStamp = e, clearTimeout(this._lastClickClearTimeout), this._lastClickClearTimeout = setTimeout(() => {
      this._forgetLastClick();
    }, 600));
  },
  remove() {
    this._handlerCount -= 1, this._handlerCount <= 0 && (this._forgetLastClick(), _.off(O.getDocument(), Py, void 0), clearTimeout(this._lastClickClearTimeout), this._handlerCount = 0);
  }
}), CU = new _U();
Yn(pd, CU);
const vU = (i) => class extends i {
  _applyColumnState(e) {
    var t;
    const n = this.option("rtlEnabled"), s = this._getColumnAlignment(e.column.alignment, n), o = x(!0, {
      columnAlignment: s
    }, e), r = o.rootElement.hasClass("dx-group-panel-item"), a = this._createIndicatorContainer(o, r), l = p("<span>").addClass(this._getIndicatorClassName(e.name)), d = (t = this.component) === null || t === void 0 ? void 0 : t.getController("columns"), u = d?.getHeaderContentAlignment(s) || s;
    return o.container = a, o.indicator = l, this._renderIndicator(o), a[(r || !e.showColumnLines) && u === "left" ? "appendTo" : "prependTo"](e.rootElement), l;
  }
  _getIndicatorClassName(e) {
  }
  _getColumnAlignment(e, t) {
    return t = t || this.option("rtlEnabled"), e && e !== "center" ? e : ro(t);
  }
  _createIndicatorContainer(e, t) {
    let n = this._getIndicatorContainer(e.rootElement);
    const s = e.columnAlignment === "left" ? "right" : "left";
    return n.length || (n = p("<div>").addClass("dx-column-indicators")), this.setAria("role", "presentation", n), n.css("float", e.showColumnLines && !t ? s : null);
  }
  _getIndicatorContainer(e) {
    return e && e.find(".dx-column-indicators");
  }
  _getIndicatorElements(e) {
    const t = this._getIndicatorContainer(e);
    return t && t.children();
  }
  _renderIndicator(e) {
    const t = e.container, n = e.indicator;
    t && n && t.append(n);
  }
  _updateIndicators(e) {
    const t = this, n = t.getColumns(), s = t.getColumnElements();
    let o;
    if (!(!s || n.length !== s.length))
      for (let r = 0; r < n.length; r++) {
        o = s.eq(r), t._updateIndicator(o, n[r], e);
        const a = o.parent().data("options");
        a && a.cells && (a.cells[o.index()].column = n[r]);
      }
  }
  _updateIndicator(e, t, n) {
    if (!t.command)
      return this._applyColumnState({
        name: n,
        rootElement: e,
        column: t,
        showColumnLines: this.option("showColumnLines")
      });
  }
}, xU = ["rowsView"], ws = {
  borderedTop: "dx-bordered-top-view",
  borderedBottom: "dx-bordered-bottom-view"
}, yU = (i) => {
  let {
    columnHeadersView: e,
    rowsView: t
  } = i;
  return e != null && e.isVisible() ? e.element() : t.element();
}, bU = (i) => {
  let {
    filterPanelView: e,
    footerView: t,
    rowsView: n
  } = i;
  return e != null && e.isVisible() ? e.element() : t != null && t.isVisible() ? t.element() : n.element();
}, My = (i, e) => {
  const t = Object.values(i).find((n) => {
    var s;
    return n == null || (s = n.element()) === null || s === void 0 ? void 0 : s.hasClass(e);
  });
  return t?.element() ?? null;
}, wU = (i, e) => {
  var t;
  if (!Object.keys(e).includes(i))
    return !1;
  const {
    rowsView: n
  } = e, s = hi(e, xU);
  return f(n == null || (t = n.element) === null || t === void 0 ? void 0 : t.call(n)) ? Object.values(s).filter((o) => {
    var r;
    return o == null || (r = o.isVisible) === null || r === void 0 ? void 0 : r.call(o);
  }).every((o) => f(o?.element())) : !1;
}, SU = (i, e) => {
  if (!wU(i, e))
    return;
  const t = My(e, ws.borderedTop), n = My(e, ws.borderedBottom), s = yU(e), o = bU(e);
  t && !t.is(s) && t.removeClass(ws.borderedTop), n && !n.is(o) && n.removeClass(ws.borderedBottom), s.hasClass(ws.borderedTop) || s.addClass(ws.borderedTop), o.hasClass(ws.borderedBottom) || o.addClass(ws.borderedBottom);
};
class bT {
  constructor(e) {
    const t = this;
    t._updateLockCount = 0, t.component = e, t._actions = {}, t._actionConfigs = {}, y(this.callbackNames() || [], function(n, s) {
      const o = t.callbackFlags(s) || {};
      o.unique = !0, o.syncStrategy = !0, t[this] = Ie(o);
    });
  }
  _endUpdateCore() {
  }
  init() {
  }
  callbackNames() {
  }
  callbackFlags(e) {
  }
  publicMethods() {
    return [];
  }
  beginUpdate() {
    this._updateLockCount++;
  }
  endUpdate() {
    this._updateLockCount > 0 && (this._updateLockCount--, this._updateLockCount || this._endUpdateCore());
  }
  option(e) {
    const {
      component: t
    } = this, n = t._optionCache;
    return arguments.length === 1 && n ? (e in n || (n[e] = t.option(e)), n[e]) : t.option.apply(t, arguments);
  }
  _silentOption(e, t) {
    const {
      component: n
    } = this, s = n._optionCache;
    return s && (s[e] = t), n._setOptionWithoutOptionChange(e, t);
  }
  localize(e) {
    const t = this.component._optionCache;
    return t ? (e in t || (t[e] = S.format(e)), t[e]) : S.format(e);
  }
  on(e, t) {
    return this.component.on.apply(this.component, arguments);
  }
  off() {
    return this.component.off.apply(this.component, arguments);
  }
  optionChanged(e) {
    e.name in this._actions && (this.createAction(e.name, this._actionConfigs[e.name]), e.handled = !0);
  }
  getAction(e) {
    return this._actions[e];
  }
  setAria(e, t, n) {
    const s = n.get(0), o = e !== "role" && e !== "id" ? "aria-" : "";
    s.setAttribute ? s.setAttribute(o + e, t) : n.attr(o + e, t);
  }
  _createComponent(e, t, n) {
    return this.component._createComponent(e, t, n);
  }
  getController(e) {
    return this.component._controllers[e];
  }
  createAction(e, t) {
    if (B(e)) {
      const n = this.component._createAction(e.bind(this), t);
      return function(s) {
        n({
          event: s
        });
      };
    }
    this._actions[e] = this.component._createActionByOption(e, t), this._actionConfigs[e] = t;
  }
  executeAction(e, t) {
    const n = this._actions[e];
    return n && n(t);
  }
  dispose() {
    const e = this;
    y(e.callbackNames() || [], function() {
      e[this].empty();
    });
  }
  addWidgetPrefix(e) {
    return `dx-${this.component.NAME.slice(2).toLowerCase()}${e ? `-${e}` : ""}`;
  }
  getWidgetContainerClass() {
    const e = this.component.NAME === "dxDataGrid" ? null : "container";
    return this.addWidgetPrefix(e);
  }
  elementIsInsideGrid(e) {
    return e.closest(`.${this.getWidgetContainerClass()}`).parent().is(this.component.$element());
  }
}
class R_ extends bT {
}
class EU extends R_ {
  getView(e) {
    return this.component._views[e];
  }
  getViews() {
    return this.component._views;
  }
}
class wT extends bT {
  constructor(e) {
    super(e), this.renderCompleted = Ie(), this.resizeCompleted = Ie();
  }
  _isReady() {
    return this.component.isReady();
  }
  _endUpdateCore() {
    super._endUpdateCore(), !this._isReady() && this._requireReady && (this._requireRender = !1, this.component._requireResize = !1), this._requireRender && (this._requireRender = !1, this.render(this._$parent));
  }
  _invalidate(e, t) {
    this._requireRender = !0, this.component._requireResize = ae() && (this.component._requireResize || e), this._requireReady = this._requireReady || t;
  }
  _renderCore(e) {
  }
  _resizeCore() {
  }
  _parentElement() {
    return this._$parent;
  }
  element() {
    return this._$element;
  }
  getElementHeight() {
    const e = this.element();
    if (!e)
      return 0;
    const t = parseFloat(e.css("marginTop")) || 0, n = parseFloat(e.css("marginBottom")) || 0, {
      offsetHeight: s
    } = e.get(0);
    return s + t + n;
  }
  isVisible() {
    return !0;
  }
  getTemplate(e) {
    return this.component._getTemplate(e);
  }
  getView(e) {
    return this.component._views[e];
  }
  _getBorderedViews() {
    return {
      columnHeadersView: this.component._views.columnHeadersView,
      rowsView: this.component._views.rowsView,
      filterPanelView: this.component._views.filterPanelView,
      footerView: this.component._views.footerView
    };
  }
  render(e, t) {
    let n = this._$element;
    const s = this.isVisible();
    if (!(!n && !e) && (this._requireReady = !1, n || (n = this._$element = p("<div>").appendTo(e), this._$parent = e), n.toggleClass("dx-hidden", !s), this.component._views && SU(this.name, this._getBorderedViews()), s)) {
      this.component._optionCache = {};
      const o = this._renderCore(t);
      this.component._optionCache = void 0, o ? o.done(() => {
        this.renderCompleted.fire(t);
      }) : this.renderCompleted.fire(t);
    }
  }
  resize() {
    this.isResizing = !0, this._resizeCore(), this.resizeCompleted.fire(), this.isResizing = !1;
  }
  focus(e) {
    this.element().get(0).focus({
      preventScroll: e
    });
  }
}
function By(i) {
  let e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  const t = {};
  return Object.entries(e).forEach((n) => {
    let [s, o] = n;
    const r = i[s];
    if (r)
      if (B(o))
        t[s] = o(r);
      else {
        const a = r;
        t[s] = a.inherit(o);
      }
  }), t;
}
function IU(i, e, t) {
  const n = t.publicMethods();
  n && y(n, (s, o) => {
    if (t[o])
      if (!i[o])
        i[o] = function() {
          return t[o](...arguments);
        };
      else
        throw _e.Error("E1005", o);
    else
      throw _e.Error("E1006", e, o);
  });
}
function DU(i, e) {
  const {
    modules: t
  } = e, {
    modulesOrder: n
  } = e;
  function s(u) {
    const c = {};
    return y(u, (h, g) => {
      const m = new g(i);
      m.name = h, IU(i, h, m), c[h] = m;
    }), c;
  }
  n && t.sort((u, c) => {
    let h = n.indexOf(u.name), g = n.indexOf(c.name);
    return h < 0 && (h = 1e6), g < 0 && (g = 1e6), h - g;
  });
  const o = {}, r = {};
  t.forEach((u) => {
    let {
      name: c,
      controllers: h = {},
      views: g = {}
    } = u;
    Object.entries(h).forEach((m) => {
      let [C, v] = m;
      if (o[C])
        throw _e.Error("E1001", c, C);
      if (!(v?.prototype instanceof R_))
        throw _e.Error("E1002", c, C);
      o[C] = v;
    }), Object.entries(g).forEach((m) => {
      let [C, v] = m;
      if (r[C])
        throw _e.Error("E1003", c, C);
      if (!(v?.prototype instanceof wT))
        throw _e.Error("E1004", c, C);
      r[C] = v;
    });
  });
  const a = t.filter((u) => {
    let {
      extenders: c
    } = u;
    return !!c;
  }), l = a.reduce((u, c) => {
    let {
      extenders: h
    } = c;
    return I({}, u, By(u, h?.controllers));
  }, o), d = a.reduce((u, c) => {
    let {
      extenders: h
    } = c;
    return I({}, u, By(u, h?.views));
  }, r);
  i._controllers = s(l), i._views = s(d);
}
const TU = function(i, e, t) {
  t = t || [], i._controllers && y(i._controllers, function() {
    this[e] && this[e].apply(this, t);
  }), i._views && y(i._views, function() {
    this[e] && this[e].apply(this, t);
  });
}, Ue = {
  modules: [],
  View: wT,
  ViewController: EU,
  Controller: R_,
  registerModule(i, e) {
    const {
      modules: t
    } = this;
    for (let n = 0; n < t.length; n++)
      if (t[n].name === i)
        return;
    e.name = i, t.push(e);
  },
  registerModulesOrder(i) {
    this.modulesOrder = i;
  },
  unregisterModule(i) {
    this.modules = Wt(this.modules, (e) => e.name !== i);
  },
  processModules: DU,
  callModuleItemsMethod: TU
}, vt = Bf(Ae.ERROR_MESSAGES, {
  E4000: "[DevExpress.data]: {0}",
  E4001: "Unknown aggregating function is detected: '{0}'",
  E4002: "Unsupported OData protocol version is used",
  E4003: "Unknown filter operation is used: {0}",
  E4004: "The thenby() method is called before the sortby() method",
  E4005: "Store requires a key expression for this operation",
  E4006: "ArrayStore 'data' option must be an array",
  E4007: "Compound keys cannot be auto-generated",
  E4008: "Attempt to insert an item with a duplicated key",
  E4009: "Data item cannot be found",
  E4010: "CustomStore does not support creating queries",
  E4011: "Custom Store method is not implemented or is not a function: {0}",
  E4012: "Custom Store method returns an invalid value: {0}",
  E4013: "Local Store requires the 'name' configuration option is specified",
  E4014: "Unknown data type is specified for ODataStore: {0}",
  E4015: "Unknown entity name or alias is used: {0}",
  E4016: "The compileSetter(expr) method is called with 'self' passed as a parameter",
  E4017: "Keys cannot be modified",
  E4018: "The server has returned a non-numeric value in a response to an item count request",
  E4019: "Mixing of group operators inside a single group of filter expression is not allowed",
  E4020: "Unknown store type is detected: {0}",
  E4021: "The server response does not provide the totalCount value",
  E4022: "The server response does not provide the groupCount value",
  E4023: "Could not parse the following XML: {0}",
  E4024: "String function {0} cannot be used with the data field {1} of type {2}.",
  W4000: "Data returned from the server has an incorrect structure",
  W4001: 'The {0} field is listed in both "keyType" and "fieldTypes". The value of "fieldTypes" is used.',
  W4002: "Data loading has failed for some cells due to the following error: {0}"
});
let OU = null;
const F_ = function(i) {
  var e;
  (e = OU) === null || e === void 0 || e(i);
}, AU = Bi.add, ST = "DEVEXTREME_XHR_ERROR_UNLOAD", RU = function(i) {
  return [i[0], i.length < 3 ? "=" : String(i[1]).toLowerCase(), i.length < 2 ? !0 : i[i.length - 1]];
}, hs = function(i) {
  return Array.isArray(i) || (i = [i]), mt(i, (e) => {
    const t = {
      selector: B(e) || typeof e == "string" ? e : e.getter || e.field || e.selector,
      desc: !!(e.desc || String(e.dir).charAt(0).toLowerCase() === "d")
    };
    return e.compare && (t.compare = e.compare), t;
  });
}, FU = function() {
  const i = {
    timeout: "Network connection timeout",
    error: "Unspecified network error",
    parsererror: "Unexpected server response"
  };
  let e;
  return AU(() => {
    const t = fe();
    O.listen(t, "beforeunload", () => {
      e = !0;
    });
  }), function(t, n) {
    return e ? ST : t.status < 400 ? function(s) {
      let o = i[s];
      return o || s;
    }(n) : t.statusText;
  };
}(), k_ = {
  count: {
    seed: 0,
    step: (i) => 1 + i
  },
  sum: {
    seed: 0,
    step: (i, e) => i + e
  },
  min: {
    step: (i, e) => e < i ? e : i
  },
  max: {
    step: (i, e) => e > i ? e : i
  },
  avg: {
    seed: [0, 0],
    step: (i, e) => [i[0] + e, i[1] + 1],
    finalize: (i) => i[1] ? i[0] / i[1] : NaN
  }
}, kU = function() {
  let i = 0, e;
  return {
    obtain: function() {
      i === 0 && (e = new w()), i++;
    },
    release: function() {
      i--, i < 1 && e.resolve();
    },
    promise: function() {
      return (i === 0 ? new w().resolve() : e).promise();
    },
    reset: function() {
      i = 0, e && e.resolve();
    }
  };
}();
function VU(i) {
  return /^(and|&&|&)$/i.test(i);
}
const gd = function(i, e, t) {
  if (Array.isArray(i)) {
    const n = mt(e, (o, r) => r);
    let s;
    for (let o = 0; o < n.length; o++)
      if (s = n[o], !He(e[s], t[s], {
        strict: !1
      }))
        return !1;
    return !0;
  }
  return He(e, t, {
    strict: !1
  });
}, PU = function(i) {
  return i[0] === "!" && Array.isArray(i[1]);
}, MU = function(i) {
  return i === "and" || i === "or";
}, BU = function(i) {
  if (i.length > 2 && Array.isArray(i[0]) && i[1] === "or" && typeof i[0][0] == "string" && i[0][1] === "=") {
    const [e] = i[0];
    return !i.find((t, n) => n % 2 !== 0 ? t !== "or" : !Array.isArray(t) || t.length !== 3 || t[0] !== e || t[1] !== "=");
  }
  return !1;
}, $U = function(i) {
  const e = i[0], t = i[1];
  return !!(Array.isArray(e) || B(e) && (Array.isArray(t) || B(t) || MU(t)));
}, Ur = function() {
  const i = new w();
  return i.resolve.apply(i, arguments).promise();
}, ET = function() {
  const i = new w();
  return i.reject.apply(i, arguments).promise();
};
function NU(i, e) {
  let t;
  return function() {
    return t || (t = setTimeout(() => {
      t = void 0, i.call(this);
    }, B(e) ? e() : e)), t;
  };
}
function LU(i, e) {
  let t = [];
  const n = NU(function() {
    i.call(this, t), t = [];
  }, e);
  return function(s) {
    return Array.isArray(s) && t.push(...s), n.call(this, t);
  };
}
function HU(i, e) {
  let t;
  const n = typeof e == "string" ? e.split() : e.slice();
  for (; n.length; )
    if (t = n.shift(), t in i)
      return !0;
  return !1;
}
function IT(i, e, t, n) {
  let s, o;
  if (n) {
    for (let r = 0; r < e.length; r++)
      if (s = e[r].items || e[r].collapsedItems || [], o = IT(i, s || [], t, n - 1), o)
        return o;
  } else if (Yo(i, e, t) >= 0)
    return e;
}
function WU(i, e, t, n) {
  return n ? IT(i, e, t, n) || [] : e;
}
function zU(i, e) {
  if (i.key() && (!e._dataByKeyMap || e._dataByKeyMapLength !== e.length)) {
    const t = {}, n = e.length;
    for (let s = 0; s < n; s++)
      t[JSON.stringify(i.keyOf(e[s]))] = e[s];
    e._dataByKeyMap = t, e._dataByKeyMapLength = n;
  }
}
function KU(i, e) {
  if (i._dataByKeyMap)
    return i._dataByKeyMap[JSON.stringify(e)];
}
function GU(i, e) {
  return i._dataByKeyMap ? i._dataByKeyMap[JSON.stringify(e)] : !0;
}
function DT(i, e, t) {
  i._dataByKeyMap && (i._dataByKeyMap[JSON.stringify(e)] = t, i._dataByKeyMapLength += t ? 1 : -1);
}
function TT(i, e, t) {
  t = t || /* @__PURE__ */ new WeakMap();
  const n = i ? Object.create(Object.getPrototypeOf(i)) : {};
  i && t.set(i, n);
  const s = I({}, i);
  an(n, s, !0, !0, !0);
  for (const o in s) {
    const r = s[o], a = e?.[o];
    X(r) && !pe(r) && X(a) && !t.has(r) && (n[o] = TT(r, a, t));
  }
  for (const o in n) {
    const r = n[o];
    X(r) && t.has(r) && (n[o] = t.get(r));
  }
  return n;
}
function Ns(i, e) {
  const t = TT(i, e);
  return an(t, e, !0, !0, !0);
}
function Ho(i) {
  let {
    keyInfo: e,
    data: t,
    changes: n,
    groupCount: s,
    useInsertIndex: o,
    immutable: r,
    disableCache: a,
    logError: l,
    skipCopying: d
  } = i;
  const u = r === !0 ? [...t] : t;
  return n.forEach((c) => {
    const h = c.type === "insert" ? u : WU(e, u, c.key, s);
    switch (!a && zU(e, h), c.type) {
      case "update":
        V_(e, h, c.key, c.data, !0, r, l);
        break;
      case "insert":
        P_(e, h, c.data, o && f(c.index) ? c.index : -1, !0, l, d);
        break;
      case "remove":
        OT(e, h, c.key, !0, l);
    }
  }), u;
}
function fc(i, e, t) {
  return i ? e && vt.log(t) : ET(vt.Error(t));
}
function V_(i, e, t, n, s, o, r) {
  let a;
  const l = i.key();
  if (l) {
    if (HU(n, l) && !gd(l, t, i.keyOf(n)))
      return fc(s, r, "E4017");
    if (a = KU(e, t), !a) {
      const d = Yo(i, e, t);
      if (d < 0)
        return fc(s, r, "E4009");
      if (a = e[d], o === !0 && f(a)) {
        const u = Ns(a, n);
        return e[d] = u, !s && Ur(u, t);
      }
    }
  } else
    a = t;
  if (an(a, n, !0, !1, !0, !0), !s)
    return Pe().useLegacyStoreResult ? Ur(t, n) : Ur(a, t);
}
function P_(i, e, t, n, s, o, r) {
  let a;
  const l = i.key(), d = pe(t) && !r ? x({}, t) : t;
  if (l) {
    if (a = i.keyOf(d), a === void 0 || typeof a == "object" && en(a)) {
      if (Array.isArray(l))
        throw vt.Error("E4007");
      a = d[l] = String(new Xe());
    } else if (e[Yo(i, e, a)] !== void 0)
      return fc(s, o, "E4008");
  } else
    a = d;
  if (n >= 0 ? e.splice(n, 0, d) : e.push(d), DT(e, a, d), !s)
    return Ur(Pe().useLegacyStoreResult ? t : d, a);
}
function OT(i, e, t, n, s) {
  const o = Yo(i, e, t);
  if (o > -1 && (e.splice(o, 1), DT(e, t, null)), !n)
    return Ur(t);
  if (o < 0)
    return fc(n, s, "E4009");
}
function Yo(i, e, t) {
  const n = i.key();
  if (!GU(e, t))
    return -1;
  for (let s = 0, o = e.length; s < o; s++)
    if (gd(n, i.keyOf(e[s]), t))
      return s;
  return -1;
}
const md = se.inherit({
  toArray() {
    const i = [];
    for (this.reset(); this.next(); )
      i.push(this.current());
    return i;
  },
  countable: () => !1
}), M_ = md.inherit({
  ctor(i) {
    this.array = i, this.index = -1;
  },
  next() {
    return this.index + 1 < this.array.length ? (this.index++, !0) : !1;
  },
  current() {
    return this.array[this.index];
  },
  reset() {
    this.index = -1;
  },
  toArray() {
    return this.array.slice(0);
  },
  countable: () => !0,
  count() {
    return this.array.length;
  }
}), lh = md.inherit({
  ctor(i) {
    this.iter = i;
  },
  next() {
    return this.iter.next();
  },
  current() {
    return this.iter.current();
  },
  reset() {
    return this.iter.reset();
  }
}), fp = lh.inherit({
  ctor(i, e) {
    this.callBase(i), this.index = -1, this.mapper = e;
  },
  current() {
    return this.mapper(this.callBase(), this.index);
  },
  next() {
    const i = this.callBase();
    return i && this.index++, i;
  }
}), UU = function(i, e, t) {
  return te(i) && te(e) && (t != null && t.locale || t != null && t.collatorOptions) ? new Intl.Collator(t?.locale || void 0, t?.collatorOptions || void 0).compare(i, e) : (i = Mt(i, !1, t), e = Mt(e, !1, t), i === null && e !== null ? -1 : i !== null && e === null || i === void 0 && e !== void 0 ? 1 : i !== void 0 && e === void 0 || i < e ? -1 : i > e ? 1 : 0);
}, wm = md.inherit({
  ctor(i, e, t, n) {
    this.langParams = i.langParams, i instanceof fp || (i = new fp(i, this._wrap), i.langParams = this.langParams), this.iter = i, this.rules = [{
      getter: e,
      desc: t,
      compare: n,
      langParams: this.langParams
    }];
  },
  thenBy(i, e, t) {
    const n = new wm(this.sortedIter || this.iter, i, e, t);
    return this.sortedIter || (n.rules = this.rules.concat(n.rules)), n;
  },
  next() {
    return this._ensureSorted(), this.sortedIter.next();
  },
  current() {
    return this._ensureSorted(), this.sortedIter.current();
  },
  reset() {
    delete this.sortedIter;
  },
  countable() {
    return this.sortedIter || this.iter.countable();
  },
  count() {
    return this.sortedIter ? this.sortedIter.count() : this.iter.count();
  },
  _ensureSorted() {
    const i = this;
    i.sortedIter || (y(i.rules, function() {
      this.getter = Be(this.getter);
    }), i.sortedIter = new fp(new M_(this.iter.toArray().sort((e, t) => i._compare(e, t))), i._unwrap));
  },
  _wrap: (i, e) => ({
    index: e,
    value: i
  }),
  _unwrap: (i) => i.value,
  _getDefaultCompare: (i) => (e, t) => UU(e, t, i),
  _compare(i, e) {
    const t = i.index, n = e.index;
    if (i = i.value, e = e.value, i === e)
      return t - n;
    for (let s = 0, o = this.rules.length; s < o; s++) {
      const r = this.rules[s], a = r.getter(i), l = r.getter(e), u = (r.compare || this._getDefaultCompare(r.langParams))(a, l);
      if (u)
        return r.desc ? -u : u;
    }
    return t - n;
  }
}), Sm = function() {
  let i = {};
  const e = (r) => Mt(r, !1, i), t = function(r) {
    if (BU(r))
      return ((u) => {
        const c = Be(u[0][0]), h = u.reduce((g, m, C) => (C % 2 === 0 && g.push(e(m[2])), g), []);
        return (g) => {
          const m = e(c(g));
          return h.some((C) => o(C) ? m === C : m == C);
        };
      })(r);
    const a = [];
    let l = !1, d = !1;
    return y(r, function() {
      if (Array.isArray(this) || B(this)) {
        if (a.length > 1 && l !== d)
          throw vt.Error("E4019");
        a.push(Sm(this, i)), l = d, d = !0;
      } else
        d = VU(this);
    }), function(u) {
      let c = l;
      for (let h = 0; h < a.length; h++)
        if (a[h](u) !== l) {
          c = !l;
          break;
        }
      return c;
    };
  }, n = function(r) {
    var a;
    return f(r) ? (a = i) !== null && a !== void 0 && a.locale ? r.toLocaleString(i.locale) : r.toString() : "";
  };
  function s(r, a, l) {
    return function(d) {
      d = e(r(d));
      let u = o(a) ? d === a : d == a;
      return l && (u = !u), u;
    };
  }
  function o(r) {
    return r === "" || r === 0 || r === !1;
  }
  return function(r, a) {
    return i = a || {}, B(r) ? r : $U(r) ? t(r) : PU(r) ? function(l) {
      const d = l[0], u = Sm(l[1], i);
      if (d === "!")
        return function(c) {
          return !u(c);
        };
      throw vt.Error("E4003", d);
    }(r) : function(l) {
      l = RU(l);
      const d = Be(l[0]), u = l[1];
      let c = l[2];
      c = e(c);
      const h = (g, m) => (g = e(d(g)), (c == null || g == null) && c !== g ? !1 : m(g, c));
      switch (u.toLowerCase()) {
        case "=":
          return s(d, c);
        case "<>":
          return s(d, c, !0);
        case ">":
          return (g) => h(g, (m, C) => m > C);
        case "<":
          return (g) => h(g, (m, C) => m < C);
        case ">=":
          return (g) => h(g, (m, C) => m >= C);
        case "<=":
          return (g) => h(g, (m, C) => m <= C);
        case "startswith":
          return (g) => e(n(d(g))).startsWith(c);
        case "endswith":
          return (g) => e(n(d(g))).endsWith(c);
        case "contains":
          return (g) => e(n(d(g))).includes(c);
        case "notcontains":
          return (g) => !e(n(d(g))).includes(c);
      }
      throw vt.Error("E4003", u);
    }(r);
  };
}(), jU = lh.inherit({
  ctor(i, e) {
    this.callBase(i), this.langParams = i.langParams, this.criteria = Sm(e, this.langParams);
  },
  next() {
    for (; this.iter.next(); )
      if (this.criteria(this.current()))
        return !0;
    return !1;
  }
}), qU = md.inherit({
  ctor(i, e) {
    this.iter = i, this.getter = e;
  },
  next() {
    return this._ensureGrouped(), this.groupedIter.next();
  },
  current() {
    return this._ensureGrouped(), this.groupedIter.current();
  },
  reset() {
    delete this.groupedIter;
  },
  countable() {
    return !!this.groupedIter;
  },
  count() {
    return this.groupedIter.count();
  },
  _ensureGrouped() {
    if (this.groupedIter)
      return;
    const i = {}, e = [], {
      iter: t
    } = this, n = Be(this.getter);
    for (t.reset(); t.next(); ) {
      const s = t.current(), o = n(s);
      o in i ? i[o].push(s) : (i[o] = [s], e.push(o));
    }
    this.groupedIter = new M_(mt(e, (s) => ({
      key: s,
      items: i[s]
    })));
  }
}), YU = lh.inherit({
  ctor(i, e) {
    this.callBase(i), this.getter = Be(e);
  },
  current() {
    return this.getter(this.callBase());
  },
  countable() {
    return this.iter.countable();
  },
  count() {
    return this.iter.count();
  }
}), XU = lh.inherit({
  ctor(i, e, t) {
    this.callBase(i), this.skip = Math.max(0, e), this.take = Math.max(0, t), this.pos = 0;
  },
  next() {
    if (this.pos >= this.skip + this.take)
      return !1;
    for (; this.pos < this.skip && this.iter.next(); )
      this.pos++;
    return this.pos++, this.iter.next();
  },
  reset() {
    this.callBase(), this.pos = 0;
  },
  countable() {
    return this.iter.countable();
  },
  count() {
    return Math.min(this.iter.count() - this.skip, this.take);
  }
}), fd = function(i, e) {
  e = e || {}, i instanceof md || (i = new M_(i)), e.langParams && (i.langParams = e.langParams);
  const t = function(l) {
    const d = e.errorHandler;
    d && d(l), F_(l);
  }, n = function(l) {
    const d = new w().fail(t);
    let u;
    const {
      step: c
    } = l, {
      finalize: h
    } = l;
    try {
      i.reset(), "seed" in l ? u = l.seed : u = i.next() ? i.current() : NaN;
      let g = u;
      for (; i.next(); )
        g = c(g, i.current());
      d.resolve(h ? h(g) : g);
    } catch (g) {
      d.reject(g);
    }
    return d.promise();
  }, s = function(l) {
    return n(k_[l]);
  }, o = function(l) {
    return !B(l) && !Array.isArray(l) && (l = [].slice.call(arguments)), a(new YU(i, l));
  }, r = function(l) {
    return o(Be(l));
  };
  function a(l) {
    return fd(l, e);
  }
  return {
    toArray: () => i.toArray(),
    enumerate() {
      const l = new w().fail(t);
      try {
        l.resolve(i.toArray());
      } catch (d) {
        l.reject(d);
      }
      return l.promise();
    },
    setLangParams(l) {
      i.langParams = l;
    },
    sortBy: (l, d, u) => a(new wm(i, l, d, u)),
    thenBy(l, d, u) {
      if (i instanceof wm)
        return a(i.thenBy(l, d, u));
      throw vt.Error("E4004");
    },
    filter(l) {
      return Array.isArray(l) || (l = [].slice.call(arguments)), a(new jU(i, l));
    },
    slice(l, d) {
      return d === void 0 && (d = Number.MAX_VALUE), a(new XU(i, l, d));
    },
    select: o,
    groupBy: (l) => a(new qU(i, l)),
    aggregate: function(l, d, u) {
      return arguments.length < 2 ? n({
        step: arguments[0]
      }) : n({
        seed: l,
        step: d,
        finalize: u
      });
    },
    count() {
      if (i.countable()) {
        const l = new w().fail(t);
        try {
          l.resolve(i.count());
        } catch (d) {
          l.reject(d);
        }
        return l.promise();
      }
      return s("count");
    },
    sum(l) {
      return l ? r(l).sum() : s("sum");
    },
    min(l) {
      return l ? r(l).min() : s("min");
    },
    max(l) {
      return l ? r(l).max() : s("max");
    },
    avg(l) {
      return l ? r(l).avg() : s("avg");
    }
  };
};
function B_(i, e) {
  return i = i.groupBy(e[0].selector), e.length > 1 && (i = i.select((t) => x({}, t, {
    items: B_(fd(t.items), e.slice(1)).toArray()
  }))), i;
}
function AT(i, e) {
  const t = [];
  return y(i, (n, s) => {
    Wt(e, (r) => s.selector === r.selector).length < 1 && t.push(s);
  }), t.concat(e);
}
function ZU(i, e, t) {
  var n;
  e = e || {};
  const {
    filter: s
  } = e;
  if ((n = e) !== null && n !== void 0 && n.langParams) {
    var o, r;
    (o = (r = i).setLangParams) === null || o === void 0 || o.call(r, e.langParams);
  }
  if (s && (i = i.filter(s)), t)
    return i;
  let {
    sort: a
  } = e;
  const {
    select: l
  } = e;
  let {
    group: d
  } = e;
  const {
    skip: u
  } = e, {
    take: c
  } = e;
  return d && (d = hs(d), d.keepInitialKeyOrder = !!e.group.keepInitialKeyOrder), (a || d) && (a = hs(a || []), d && !d.keepInitialKeyOrder && (a = AT(d, a)), y(a, function(h) {
    i = i[h ? "thenBy" : "sortBy"](this.selector, this.desc, this.compare);
  })), l && (i = i.select(l)), d && (i = B_(i, d)), (c || u) && (i = i.slice(u || 0, c)), i;
}
const ps = {
  multiLevelGroup: B_,
  arrangeSortingInfo: AT,
  queryByOptions: ZU
}, {
  abstract: Ta
} = se, {
  queryByOptions: $y
} = ps, Em = {}, Oi = se.inherit({
  _langParams: {},
  ctor(i) {
    const e = this;
    i = i || {}, this._eventsStrategy = new nr(this), y(["onLoaded", "onLoading", "onInserted", "onInserting", "onUpdated", "onUpdating", "onPush", "onRemoved", "onRemoving", "onModified", "onModifying"], (t, n) => {
      n in i && e.on(n.slice(2).toLowerCase(), i[n]);
    }), this._key = i.key, this._errorHandler = i.errorHandler, this._useDefaultSearch = !0;
  },
  _clearCache: M,
  _customLoadOptions: () => null,
  key() {
    return this._key;
  },
  keyOf(i) {
    return this._keyGetter || (this._keyGetter = Be(this.key())), this._keyGetter(i);
  },
  _requireKey() {
    if (!this.key())
      throw vt.Error("E4005");
  },
  load(i) {
    const e = this;
    return i = i || {}, this._eventsStrategy.fireEvent("loading", [i]), this._withLock(this._loadImpl(i)).done((t) => {
      e._eventsStrategy.fireEvent("loaded", [t, i]);
    });
  },
  _loadImpl(i) {
    return en(this._langParams) || (i = i || {}, i._langParams = I({}, this._langParams, i._langParams)), $y(this.createQuery(i), i).enumerate();
  },
  _withLock(i) {
    const e = new w();
    return i.done(function() {
      const t = this, n = arguments;
      kU.promise().done(() => {
        e.resolveWith(t, n);
      });
    }).fail(function() {
      e.rejectWith(this, arguments);
    }), e;
  },
  createQuery: Ta,
  totalCount(i) {
    return this._totalCountImpl(i);
  },
  _totalCountImpl(i) {
    return $y(this.createQuery(i), i, !0).count();
  },
  byKey(i, e) {
    return this._addFailHandlers(this._withLock(this._byKeyImpl(i, e)));
  },
  _byKeyImpl: Ta,
  insert(i) {
    const e = this;
    return e._eventsStrategy.fireEvent("modifying"), e._eventsStrategy.fireEvent("inserting", [i]), e._addFailHandlers(e._insertImpl(i).done((t, n) => {
      e._eventsStrategy.fireEvent("inserted", [t, n]), e._eventsStrategy.fireEvent("modified");
    }));
  },
  _insertImpl: Ta,
  update(i, e) {
    const t = this;
    return t._eventsStrategy.fireEvent("modifying"), t._eventsStrategy.fireEvent("updating", [i, e]), t._addFailHandlers(t._updateImpl(i, e).done(() => {
      t._eventsStrategy.fireEvent("updated", [i, e]), t._eventsStrategy.fireEvent("modified");
    }));
  },
  _updateImpl: Ta,
  push(i) {
    const e = {
      changes: i,
      waitFor: []
    };
    this._eventsStrategy.fireEvent("beforePushAggregation", [e]), W(...e.waitFor).done(() => {
      this._pushImpl(i), this._eventsStrategy.fireEvent("beforePush", [{
        changes: i
      }]), this._eventsStrategy.fireEvent("push", [i]);
    });
  },
  _pushImpl: M,
  remove(i) {
    const e = this;
    return e._eventsStrategy.fireEvent("modifying"), e._eventsStrategy.fireEvent("removing", [i]), e._addFailHandlers(e._removeImpl(i).done((t) => {
      e._eventsStrategy.fireEvent("removed", [t]), e._eventsStrategy.fireEvent("modified");
    }));
  },
  _removeImpl: Ta,
  _addFailHandlers(i) {
    return i.fail(this._errorHandler).fail(F_);
  },
  on(i, e) {
    return this._eventsStrategy.on(i, e), this;
  },
  off(i, e) {
    return this._eventsStrategy.off(i, e), this;
  }
});
Oi.create = function(i, e) {
  if (!(i in Em))
    throw vt.Error("E4020", i);
  return new Em[i](e);
};
Oi.registerClass = function(i, e) {
  return e && (Em[e] = i), i;
};
Oi.inherit = function(i) {
  return function(e, t) {
    const n = i.apply(this, [e]);
    return Oi.registerClass(n, t), n;
  };
}(Oi.inherit);
const RT = "totalCount", Im = "load", FT = "byKey", Ny = "insert", Ly = "update", Hy = "remove";
function jr(i) {
  return i && B(i.then);
}
function Wo(i) {
  return new w().resolve(i).promise();
}
function al(i, e) {
  if (!B(e))
    throw vt.Error("E4011", i);
}
function kT(i) {
  throw vt.Error("E4012", i);
}
function vo(i) {
  return function(e) {
    let t;
    e instanceof Error ? t = e : t = new Error(function(n) {
      const s = n[0], o = n[1];
      return !s || !s.getResponseHeader ? null : FU(s, o);
    }(arguments) || e && String(e) || "Unknown error"), t.message !== ST && i.reject(t);
  };
}
function VT(i, e) {
  const t = i._loadFunc;
  let n;
  return al(Im, t), n = t.apply(i, [e]), Array.isArray(n) ? n = Wo(n) : n == null ? n = Wo([]) : jr(n) || kT(Im), It(n);
}
function QU(i, e) {
  const t = i._totalCountFunc;
  let n;
  if (!B(t))
    throw vt.Error("E4021");
  return n = t.apply(i, [e]), jr(n) || (n = Number(n), isFinite(n) || kT(RT), n = Wo(n)), It(n);
}
function JU(i, e, t) {
  const n = i._byKeyFunc;
  let s;
  return al(FT, n), s = n.apply(i, [e, t]), jr(s) || (s = Wo(s)), It(s);
}
function PT(i, e, t, n) {
  if (e.__rawData)
    n(e.__rawData);
  else {
    const s = e.__rawDataPromise || VT(e, t);
    e._cacheRawData && (e.__rawDataPromise = s), s.always(() => {
      delete e.__rawDataPromise;
    }).done((o) => {
      e._cacheRawData && (e.__rawData = o), n(o);
    }).fail((o) => {
      var r;
      const a = vo(i);
      (r = e._errorHandler) === null || r === void 0 || r.call(e, o), a(o);
    });
  }
}
function Wy(i, e, t, n) {
  t = t || {};
  const s = {};
  "userData" in t && (s.userData = t.userData), PT(i, e, s, (o) => {
    const r = fd(o, {
      errorHandler: e._errorHandler
    });
    let a, l;
    const d = [];
    let u, c;
    n || (a = ps.queryByOptions(r, t), a === r ? u = o.slice(0) : d.push(a.enumerate().done((h) => {
      u = h;
    }))), (t.requireTotalCount || n) && (l = ps.queryByOptions(r, t, !0), l === r ? c = o.length : d.push(l.count().done((h) => {
      c = h;
    }))), W.apply(p, d).done(() => {
      n ? i.resolve(c) : t.requireTotalCount ? i.resolve(u, {
        totalCount: c
      }) : i.resolve(u);
    }).fail((h) => {
      i.reject(h);
    });
  });
}
function e2(i, e, t) {
  PT(i, e, {}, (n) => {
    const s = e.key();
    let o;
    for (let r = 0, a = n.length; r < a; r++)
      if (o = n[r], gd(s, e.keyOf(n[r]), t)) {
        i.resolve(o);
        return;
      }
    i.reject(vt.Error("E4009"));
  });
}
const dh = Oi.inherit({
  ctor(i) {
    i = i || {}, this.callBase(i), this._useDefaultSearch = !!i.useDefaultSearch || i.loadMode === "raw", this._loadMode = i.loadMode, this._cacheRawData = i.cacheRawData !== !1, this._loadFunc = i[Im], this._totalCountFunc = i[RT], this._byKeyFunc = i[FT], this._insertFunc = i[Ny], this._updateFunc = i[Ly], this._removeFunc = i[Hy];
  },
  _clearCache() {
    delete this.__rawData;
  },
  createQuery() {
    throw vt.Error("E4010");
  },
  clearRawDataCache() {
    this._clearCache();
  },
  _totalCountImpl(i) {
    let e = new w();
    return this._loadMode === "raw" && !this._totalCountFunc ? Wy(e, this, i, !0) : (QU(this, i).done((t) => {
      e.resolve(Number(t));
    }).fail(vo(e)), e = this._addFailHandlers(e)), e.promise();
  },
  _pushImpl(i) {
    this.__rawData && Ho({
      keyInfo: this,
      data: this.__rawData,
      changes: i
    });
  },
  _loadImpl(i) {
    let e = new w();
    return this._loadMode === "raw" ? Wy(e, this, i, !1) : (VT(this, i).done((t, n) => {
      e.resolve(t, n);
    }).fail(vo(e)), e = this._addFailHandlers(e)), e.promise();
  },
  _byKeyImpl(i, e) {
    const t = new w();
    return this._byKeyViaLoad() ? (this._requireKey(), e2(t, this, i)) : JU(this, i, e).done((n) => {
      t.resolve(n);
    }).fail(vo(t)), t.promise();
  },
  _byKeyViaLoad() {
    return this._loadMode === "raw" && !this._byKeyFunc;
  },
  _insertImpl(i) {
    const e = this, t = e._insertFunc;
    let n;
    const s = new w();
    return al(Ny, t), n = t.apply(e, [i]), jr(n) || (n = Wo(n)), It(n).done((o) => {
      Pe().useLegacyStoreResult ? s.resolve(i, o) : s.resolve(o || i, e.keyOf(o));
    }).fail(vo(s)), s.promise();
  },
  _updateImpl(i, e) {
    const t = this._updateFunc;
    let n;
    const s = new w();
    return al(Ly, t), n = t.apply(this, [i, e]), jr(n) || (n = Wo(n)), It(n).done((o) => {
      Pe().useLegacyStoreResult ? s.resolve(i, e) : s.resolve(o || e, i);
    }).fail(vo(s)), s.promise();
  },
  _removeImpl(i) {
    const e = this._removeFunc;
    let t;
    const n = new w();
    return al(Hy, e), t = e.apply(this, [i]), jr(t) || (t = Wo()), It(t).done(() => {
      n.resolve(i);
    }).fail(vo(n)), n.promise();
  }
}), t2 = {}, MT = function(i, e, t) {
  t = t || [], e = e || {};
  const n = function(r, a) {
    return {
      name: r,
      args: a
    };
  }, s = function(r) {
    const a = new w();
    let l, d, u, c, h;
    const g = function(C) {
      const v = e.errorHandler;
      v && v(C), F_(C), a.reject(C);
    };
    function m(C) {
      switch (C.name) {
        case "sortBy":
          return h = [C.args], !0;
        case "thenBy":
          if (!h)
            throw vt.Error("E4004");
          return h.push(C.args), !0;
      }
      return !1;
    }
    try {
      l = e.adapter, B(l) || (l = t2[l]), d = l(e), u = [].concat(t).concat(r);
      const {
        optimize: C
      } = d;
      for (C && C(u); u.length; ) {
        if (c = u[0], !m(c)) {
          if (h) {
            u.unshift(n("multiSort", [h])), h = null;
            continue;
          }
          if (String(c.name) !== "enumerate" && (!d[c.name] || d[c.name].apply(d, c.args) === !1))
            break;
        }
        u.shift();
      }
      ((function() {
        const v = u[0], E = [];
        v && v.name === "multiSort" && (u.shift(), y(v.args[0], function() {
          E.push(n(E.length ? "thenBy" : "sortBy", this));
        })), u = E.concat(u);
      }))(), d.exec(i).done((v, E) => {
        if (!u.length)
          a.resolve(v, E);
        else {
          let T = fd(v, {
            errorHandler: e.errorHandler
          });
          y(u, function() {
            T = T[this.name].apply(T, this.args);
          }), T.done(a.resolve).fail(a.reject);
        }
      }).fail(g);
    } catch (C) {
      g(C);
    }
    return a.promise();
  }, o = {};
  return y(["sortBy", "thenBy", "filter", "slice", "select", "groupBy"], function() {
    const r = String(this);
    o[r] = function() {
      return MT(i, e, t.concat(n(r, arguments)));
    };
  }), y(["count", "min", "max", "sum", "avg", "aggregate", "enumerate"], function() {
    const r = String(this);
    o[r] = function() {
      return s.call(this, n(r, arguments));
    };
  }), o;
}, n2 = {
  array: fd,
  remote: MT
}, un = function() {
  const i = Array.isArray(arguments[0]) ? "array" : "remote";
  return n2[i].apply(this, arguments);
}, _d = Oi.inherit({
  ctor(i) {
    Array.isArray(i) ? i = {
      data: i
    } : i = i || {}, this.callBase(i);
    const e = i.data;
    if (e && !Array.isArray(e))
      throw vt.Error("E4006");
    this._array = e || [];
  },
  createQuery() {
    return un(this._array, {
      errorHandler: this._errorHandler
    });
  },
  _byKeyImpl(i) {
    const e = Yo(this, this._array, i);
    return e === -1 ? ET(vt.Error("E4009")) : Ur(this._array[e]);
  },
  _insertImpl(i) {
    return P_(this, this._array, i);
  },
  _pushImpl(i) {
    Ho({
      keyInfo: this,
      data: this._array,
      changes: i
    });
  },
  _updateImpl(i, e) {
    return V_(this, this._array, i, e);
  },
  _removeImpl(i) {
    return OT(this, this._array, i);
  },
  clear() {
    this._eventsStrategy.fireEvent("modifying"), this._array = [], this._eventsStrategy.fireEvent("modified");
  }
}, "array"), i2 = fe(), s2 = {
  getXhr: () => new i2.XMLHttpRequest()
}, o2 = qn(s2), BT = fe(), $T = function(i) {
  const e = O.createElement("script");
  for (const t in i)
    e[t] = i[t];
  return e;
}, NT = function(i) {
  return O.getHead().appendChild(i);
}, LT = function(i) {
  i.parentNode.removeChild(i);
}, zy = function(i) {
  const e = $T({
    text: i
  });
  NT(e), LT(e);
}, r2 = function(i) {
  const e = $T({
    src: i
  });
  return new Promise((t, n) => {
    const s = {
      load: t,
      error: n
    }, o = function(r) {
      s[r.type](), LT(e);
    };
    for (const r in s)
      O.listen(e, r, o);
    NT(e);
  });
};
function $_(i) {
  return (i.method || "GET").toUpperCase();
}
const a2 = function(i) {
  const e = [];
  for (const t in i) {
    let n = i[t];
    n !== void 0 && (n === null && (n = ""), typeof n == "function" && (n = n()), e.push(`${encodeURIComponent(t)}=${encodeURIComponent(n)}`));
  }
  return e.join("&");
}, l2 = function(i) {
  let e;
  return i.data && !i.upload && $_(i) !== "GET" && (e = "application/x-www-form-urlencoded;charset=utf-8"), i.contentType || e;
}, d2 = function(i) {
  const e = i.dataType || "*", t = "text/javascript, application/javascript, application/ecmascript, application/x-ecmascript", n = {
    "*": "*/*",
    text: "text/plain",
    html: "text/html",
    xml: "application/xml, text/xml",
    json: "application/json, text/javascript",
    jsonp: t,
    script: t
  };
  return EN(n, i.accepts, !0), n[e] ? n[e] + (e !== "*" ? ", */*; q=0.01" : "") : n["*"];
}, u2 = function(i) {
  const e = i.headers || {};
  return e["Content-Type"] = e["Content-Type"] || l2(i), e.Accept = e.Accept || d2(i), !i.crossDomain && !e["X-Requested-With"] && (e["X-Requested-With"] = "XMLHttpRequest"), e;
}, c2 = function(i) {
  if (i.dataType === "jsonp") {
    const e = Math.random().toString().replace(/\D/g, ""), t = i.jsonpCallback || `dxCallback${Date.now()}_${e}`, n = i.jsonp || "callback";
    return i.data = i.data || {}, i.data[n] = t, t;
  }
}, h2 = function(i, e) {
  let t = i.data;
  const n = typeof t == "string";
  let s = i.url || BT.location.href;
  return !n && !i.cache && (t = t || {}, t._ = Date.now()), t && !i.upload && (n || (t = a2(t)), $_(i) === "GET" ? (t !== "" && (s += (s.indexOf("?") > -1 ? "&" : "?") + t), t = null) : e["Content-Type"] && e["Content-Type"].indexOf("application/x-www-form-urlencoded") > -1 && (t = t.replace(/%20/g, "+"))), {
    url: s,
    parameters: t
  };
}, p2 = function(i) {
  if (!ae())
    return !0;
  let e = !1;
  const t = O.createElement("a"), n = O.createElement("a");
  t.href = BT.location.href;
  try {
    n.href = i, n.href = n.href, e = `${t.protocol}//${t.host}` != `${n.protocol}//${n.host}`;
  } catch {
    e = !0;
  }
  return e;
}, g2 = fe(), ll = "success", _p = "error", m2 = "timeout", f2 = "nocontent", _2 = "parsererror", C2 = function(i) {
  return i >= 200 && i < 300;
}, v2 = function(i) {
  return i !== 204;
}, x2 = function(i) {
  return i.responseType && i.responseType !== "text" || typeof i.responseText != "string" ? i.response : i.responseText;
}, y2 = function(i, e, t) {
  const n = x2(e);
  switch (t) {
    case "jsonp":
      zy(n);
      break;
    case "script":
      zy(n), i.resolve(n, ll, e);
      break;
    case "json":
      try {
        i.resolve(JSON.parse(n), ll, e);
      } catch (s) {
        i.reject(e, _2, s);
      }
      break;
    default:
      i.resolve(n, ll, e);
  }
}, b2 = function(i, e) {
  return i && setTimeout(function() {
    e.customStatus = m2, e.abort();
  }, i);
}, w2 = function(i) {
  const e = o2.getXhr(), t = new w(), n = t.promise(), s = f(i.async) ? i.async : !0, {
    dataType: o
  } = i, r = i.timeout || 0;
  let a;
  i.crossDomain = p2(i.url);
  const l = o === "jsonp" || o === "script";
  i.cache === void 0 && (i.cache = !l);
  const d = c2(i), u = u2(i), c = h2(i, u), {
    url: h
  } = c, {
    parameters: g
  } = c;
  if (d && (g2[d] = function(m) {
    t.resolve(m, ll, e);
  }), i.crossDomain && l) {
    const m = function() {
      t.reject(e, _p);
    }, C = function() {
      o !== "jsonp" && t.resolve(null, ll, e);
    };
    return r2(h).then(C, m), n;
  }
  if (i.crossDomain && !("withCredentials" in e))
    return t.reject(e, _p), n;
  if (e.open($_(i), h, s, i.username, i.password), s && (e.timeout = r, a = b2(r, e)), e.onreadystatechange = function(m) {
    e.readyState === 4 && (clearTimeout(a), C2(e.status) ? v2(e.status) ? y2(t, e, o) : t.resolve(null, f2, e) : t.reject(e, e.customStatus || _p));
  }, i.upload && (e.upload.onprogress = i.upload.onprogress, e.upload.onloadstart = i.upload.onloadstart, e.upload.onabort = i.upload.onabort), i.xhrFields)
    for (const m in i.xhrFields)
      e[m] = i.xhrFields[m];
  i.responseType === "arraybuffer" && (e.responseType = i.responseType);
  for (const m in u)
    Object.prototype.hasOwnProperty.call(u, m) && f(u[m]) && e.setRequestHeader(m, u[m]);
  return i.beforeSend && i.beforeSend(e), e.send(g), n.abort = function() {
    e.abort();
  }, n;
}, S2 = qn({
  sendRequest: w2
}), E2 = ["items"], HT = "canceled", Ky = (i) => i.state() === "pending", Gy = (i) => {
  switch (i.length) {
    case 0:
      return;
    case 1:
      return i[0];
  }
  return [].slice.call(i);
}, I2 = (i, e, t) => mt(i, (n) => {
  const s = hi(n, E2);
  return I({}, s, {
    items: WT(n.items, e - 1, t)
  });
}), WT = (i, e, t) => Array.isArray(i) ? e ? I2(i, e, t) : mt(i, t) : i, D2 = (i, e, t) => {
  const n = t ? hs(t).length : 0;
  return WT(i, n, e);
}, zT = (i, e) => {
  var t;
  return (t = i) !== null && t !== void 0 && t.data && (e = i, i = i.data), Array.isArray(i) || (i = [i]), {
    data: i,
    extra: e
  };
}, T2 = (i) => {
  const e = {};
  return y(["useDefaultSearch", "key", "load", "loadMode", "cacheRawData", "byKey", "lookup", "totalCount", "insert", "update", "remove"], function() {
    e[this] = i[this], delete i[this];
  }), new dh(e);
}, O2 = (i) => {
  const e = i.type;
  return delete i.type, Oi.create(e, i);
}, A2 = (i, e) => new dh({
  load: () => S2.sendRequest({
    url: i,
    dataType: "json"
  }),
  loadMode: e?.fromUrlLoadMode
}), lo = (i, e) => {
  let t;
  return typeof i == "string" && (i = {
    paginate: !1,
    store: A2(i, e)
  }), i === void 0 && (i = []), Array.isArray(i) || i instanceof Oi ? i = {
    store: i
  } : i = x({}, i), i.store === void 0 && (i.store = []), t = i.store, "load" in i ? t = T2(i) : Array.isArray(t) ? t = new _d(t) : pe(t) && (t = O2(x({}, t))), i.store = t, i;
};
class R2 {
  constructor() {
    this._counter = -1, this._deferreds = {};
  }
  add(e) {
    return this._counter++, this._deferreds[this._counter] = e, this._counter;
  }
  remove(e) {
    return delete this._deferreds[e];
  }
  cancel(e) {
    return e in this._deferreds ? (this._deferreds[e].reject(HT), !0) : !1;
  }
  cancelAll() {
    for (; this._counter > -1; )
      this.cancel(this._counter), this._counter--;
  }
}
function F2(i) {
  let e = [], t = !1;
  function n() {
    for (; e.length; ) {
      t = !0;
      const o = e.shift()();
      if (o !== void 0) {
        if (o.then) {
          W(o).always(n);
          return;
        }
        throw Ae.Error("E0015");
      }
    }
    t = !1;
  }
  return {
    add: function(s, o) {
      i ? (e[0] && o && o(e[0]), e = [s]) : e.push(s), t || n();
    },
    busy: function() {
      return t;
    }
  };
}
const In = se.inherit({
  ctor(i) {
    if (i = lo(i), this._eventsStrategy = new nr(this, {
      syncStrategy: !0
    }), this._store = i.store, this._changedTime = 0, i.pushAggregationTimeout !== 0) {
      const t = i.pushAggregationTimeout === void 0 ? () => 5 * this._changedTime : i.pushAggregationTimeout;
      let n, s;
      const o = LU((r) => {
        n.resolve(), W(...s).done(() => this._onPush(r)), s = void 0, n = void 0;
      }, t);
      this._onPushHandler = (r) => {
        this._aggregationTimeoutId = o(r.changes), n || (n = new w()), s = r.waitFor, r.waitFor.push(n.promise());
      }, this._store.on("beforePushAggregation", this._onPushHandler);
    } else
      this._onPushHandler = (t) => this._onPush(t), this._store.on("push", this._onPushHandler);
    this._storeLoadOptions = this._extractLoadOptions(i), this._mapFunc = i.map, this._postProcessFunc = i.postProcess, this._pageIndex = i.pageIndex !== void 0 ? i.pageIndex : 0, this._pageSize = i.pageSize !== void 0 ? i.pageSize : 20, this._loadingCount = 0, this._loadQueue = this._createLoadQueue(), this._searchValue = "searchValue" in i ? i.searchValue : null, this._searchOperation = i.searchOperation || "contains", this._searchExpr = i.searchExpr, this._paginate = i.paginate, this._reshapeOnPush = i.reshapeOnPush ?? !1, y(["onChanged", "onLoadError", "onLoadingChanged", "onCustomizeLoadResult", "onCustomizeStoreLoadOptions"], (t, n) => {
      n in i && this.on(n.substr(2, 1).toLowerCase() + n.substr(3), i[n]);
    }), this._operationManager = new R2(), this._init();
  },
  _init() {
    this._items = [], this._userData = {}, this._totalCount = -1, this._isLoaded = !1, f(this._paginate) || (this._paginate = !this.group()), this._isLastPage = !this._paginate;
  },
  dispose() {
    var i;
    this._store.off("beforePushAggregation", this._onPushHandler), this._store.off("push", this._onPushHandler), this._eventsStrategy.dispose(), clearTimeout(this._aggregationTimeoutId), (i = this._delayedLoadTask) === null || i === void 0 || i.abort(), this._operationManager.cancelAll(), delete this._store, delete this._items, delete this._delayedLoadTask, this._disposed = !0;
  },
  _extractLoadOptions(i) {
    const e = {};
    let t = ["sort", "filter", "langParams", "select", "group", "requireTotalCount"];
    const n = this._store._customLoadOptions();
    return n && (t = t.concat(n)), y(t, function() {
      e[this] = i[this];
    }), e;
  },
  loadOptions() {
    return this._storeLoadOptions;
  },
  items() {
    return this._items;
  },
  pageIndex(i) {
    if (!$e(i))
      return this._pageIndex;
    this._pageIndex = i, this._isLastPage = !this._paginate;
  },
  paginate(i) {
    if (!Zr(i))
      return this._paginate;
    this._paginate !== i && (this._paginate = i, this.pageIndex(0));
  },
  pageSize(i) {
    if (!$e(i))
      return this._pageSize;
    this._pageSize = i;
  },
  isLastPage() {
    return this._isLastPage;
  },
  generateStoreLoadOptionAccessor(i) {
    return (e) => {
      const t = Gy(e);
      if (t === void 0)
        return this._storeLoadOptions[i];
      this._storeLoadOptions[i] = t;
    };
  },
  sort() {
    for (var i = arguments.length, e = new Array(i), t = 0; t < i; t++)
      e[t] = arguments[t];
    return this.generateStoreLoadOptionAccessor("sort")(e);
  },
  filter() {
    const i = Gy(arguments);
    if (i === void 0)
      return this._storeLoadOptions.filter;
    this._storeLoadOptions.filter = i, this.pageIndex(0);
  },
  group() {
    for (var i = arguments.length, e = new Array(i), t = 0; t < i; t++)
      e[t] = arguments[t];
    return this.generateStoreLoadOptionAccessor("group")(e);
  },
  select() {
    for (var i = arguments.length, e = new Array(i), t = 0; t < i; t++)
      e[t] = arguments[t];
    return this.generateStoreLoadOptionAccessor("select")(e);
  },
  requireTotalCount(i) {
    if (!Zr(i))
      return this._storeLoadOptions.requireTotalCount;
    this._storeLoadOptions.requireTotalCount = i;
  },
  searchValue(i) {
    if (arguments.length < 1)
      return this._searchValue;
    this._searchValue = i, this.pageIndex(0);
  },
  searchOperation(i) {
    if (!te(i))
      return this._searchOperation;
    this._searchOperation = i, this.pageIndex(0);
  },
  searchExpr(i) {
    const e = arguments.length;
    if (e === 0)
      return this._searchExpr;
    e > 1 && (i = [].slice.call(arguments)), this._searchExpr = i, this.pageIndex(0);
  },
  store() {
    return this._store;
  },
  key() {
    var i;
    return (i = this._store) === null || i === void 0 ? void 0 : i.key();
  },
  totalCount() {
    return this._totalCount;
  },
  isLoaded() {
    return this._isLoaded;
  },
  isLoading() {
    return this._loadingCount > 0;
  },
  beginLoading() {
    this._changeLoadingCount(1);
  },
  endLoading() {
    this._changeLoadingCount(-1);
  },
  _createLoadQueue: () => F2(),
  _changeLoadingCount(i) {
    const e = this.isLoading();
    this._loadingCount += i;
    const t = this.isLoading();
    e ^ t && this._eventsStrategy.fireEvent("loadingChanged", [t]);
  },
  _scheduleLoadCallbacks(i) {
    this.beginLoading(), i.always(() => {
      this.endLoading();
    });
  },
  _scheduleFailCallbacks(i) {
    var e = this;
    i.fail(function() {
      for (var t = arguments.length, n = new Array(t), s = 0; s < t; s++)
        n[s] = arguments[s];
      n[0] !== HT && e._eventsStrategy.fireEvent("loadError", n);
    });
  },
  _fireChanged(i) {
    const e = /* @__PURE__ */ new Date();
    this._eventsStrategy.fireEvent("changed", i), this._changedTime = /* @__PURE__ */ new Date() - e;
  },
  _scheduleChangedCallbacks(i) {
    i.done(() => this._fireChanged());
  },
  loadSingle(i, e) {
    const t = new w(), n = this.key(), s = this._store, o = this._createStoreLoadOptions();
    return this._scheduleFailCallbacks(t), arguments.length < 2 && (e = i, i = n), delete o.skip, delete o.group, delete o.refresh, delete o.pageIndex, delete o.searchString, (() => i === n || s instanceof dh && !s._byKeyViaLoad() ? s.byKey(e, o) : (o.take = 1, o.filter = o.filter ? [o.filter, [i, e]] : [i, e], s.load(o)))().fail(t.reject).done((r) => {
      const a = Array.isArray(r) && !r.length;
      !f(r) || a ? t.reject(vt.Error("E4009")) : (Array.isArray(r) || (r = [r]), t.resolve(this._applyMapFunction(r)[0]));
    }), t.promise();
  },
  load() {
    const i = new w(), e = () => {
      if (!this._disposed && Ky(i))
        return this._loadFromStore(t, i);
    };
    this._scheduleLoadCallbacks(i), this._scheduleFailCallbacks(i), this._scheduleChangedCallbacks(i);
    const t = this._createLoadOperation(i);
    return this._eventsStrategy.fireEvent("customizeStoreLoadOptions", [t]), this._loadQueue.add(() => (typeof t.delay == "number" ? this._delayedLoadTask = Wf.executeAsync(e, t.delay) : e(), i.promise())), i.promise({
      operationId: t.operationId
    });
  },
  _onPush(i) {
    if (this._reshapeOnPush)
      this.load();
    else {
      const e = {
        changes: i
      };
      this._eventsStrategy.fireEvent("changing", [e]);
      const t = this.group(), n = this.items();
      let s = 0, o = this.paginate() || t ? i.filter((r) => r.type === "update") : i;
      t && (s = Array.isArray(t) ? t.length : 1), this._mapFunc && o.forEach((r) => {
        r.type === "insert" && (r.data = this._mapFunc(r.data));
      }), e.postProcessChanges && (o = e.postProcessChanges(o)), Ho({
        keyInfo: this.store(),
        data: n,
        changes: o,
        groupCount: s,
        useInsertIndex: !0
      }), this._fireChanged([{
        changes: i
      }]);
    }
  },
  _createLoadOperation(i) {
    const e = this._operationManager.add(i), t = this._createStoreLoadOptions();
    return this._store && !en(t?.langParams) && (this._store._langParams = I({}, this._store._langParams, t.langParams)), i.always(() => this._operationManager.remove(e)), {
      operationId: e,
      storeLoadOptions: t
    };
  },
  reload() {
    return this.store()._clearCache(), this._init(), this.load();
  },
  cancel(i) {
    return this._operationManager.cancel(i);
  },
  cancelAll() {
    return this._operationManager.cancelAll();
  },
  _addSearchOptions(i) {
    this._disposed || (this.store()._useDefaultSearch ? this._addSearchFilter(i) : (i.searchOperation = this._searchOperation, i.searchValue = this._searchValue, i.searchExpr = this._searchExpr));
  },
  _createStoreLoadOptions() {
    const i = x({}, this._storeLoadOptions);
    return this._addSearchOptions(i), this._paginate && this._pageSize && (i.skip = this._pageIndex * this._pageSize, i.take = this._pageSize), i.userData = this._userData, i;
  },
  _addSearchFilter(i) {
    const e = this._searchValue, t = this._searchOperation;
    let n = this._searchExpr;
    const s = [];
    e && (n || (n = "this"), Array.isArray(n) || (n = [n]), y(n, (o, r) => {
      s.length && s.push("or"), s.push([r, t, e]);
    }), i.filter ? i.filter = [s, i.filter] : i.filter = s);
  },
  _loadFromStore(i, e) {
    const t = (n, s) => {
      if (this._disposed || !Ky(e))
        return;
      const o = x(zT(n, s), i);
      this._eventsStrategy.fireEvent("customizeLoadResult", [o]), W(o.data).done((r) => {
        o.data = r, this._processStoreLoadResult(o, e);
      }).fail(e.reject);
    };
    return i.data ? new w().resolve(i.data).done(t) : this.store().load(i.storeLoadOptions).done(t).fail(e.reject);
  },
  _processStoreLoadResult(i, e) {
    let {
      data: t
    } = i, {
      extra: n
    } = i;
    const {
      storeLoadOptions: s
    } = i, o = () => (this._isLoaded = !0, this._totalCount = isFinite(n.totalCount) ? n.totalCount : -1, e.resolve(t, n)), r = () => {
      this.store().totalCount(s).done((a) => {
        n.totalCount = a, o();
      }).fail(e.reject);
    };
    this._disposed || (t = this._applyPostProcessFunction(this._applyMapFunction(t)), X(n) || (n = {}), this._items = t, (!t.length || !this._paginate || this._pageSize && t.length < this._pageSize) && (this._isLastPage = !0), s.requireTotalCount && !isFinite(n.totalCount) ? r() : o());
  },
  _applyMapFunction(i) {
    return this._mapFunc ? D2(i, this._mapFunc, this.group()) : i;
  },
  _applyPostProcessFunction(i) {
    return this._postProcessFunc ? this._postProcessFunc(i) : i;
  },
  on(i, e) {
    return this._eventsStrategy.on(i, e), this;
  },
  off(i, e) {
    return this._eventsStrategy.off(i, e), this;
  }
}), KT = " .,:;/\\<>()-[]،", Hs = function(i) {
  const e = i && We.convertDigits(i, !1).charCodeAt(0), t = We.convertDigits("0", !1).charCodeAt(0);
  return t <= e && e < t + 10;
}, k2 = function(i, e, t, n) {
  const s = i[t], o = i[t + 1];
  if (!n && (s === "." || s === " " && i.slice(t - 1, t + 3) === ". m." || s === "-" && !Hs(o)))
    return !0;
  const r = n && e.some((a) => i[t] !== a[t]);
  return KT.indexOf(s) < 0 && n === Hs(s) && (!n || r);
}, V2 = function(i, e) {
  if (!Hs(i[e]))
    for (; e > 0 && !Hs(i[e - 1]) && (i[e - 1] === "." || KT.indexOf(i[e - 1]) < 0); )
      e--;
  return e;
}, P2 = function(i, e, t, n) {
  let s = 0;
  const o = [], r = function(a) {
    return i[s] !== a[s] && (n === void 0 || Hs(i[s]) === n);
  };
  for (Array.isArray(e) || (e = [e]), s = 0; s < i.length; s++)
    if (t.indexOf(s) < 0 && e.filter(r).length) {
      s = V2(i, s);
      do {
        if (n = Hs(i[s]), !o.length && !n && Hs(e[0][s]))
          break;
        o.push(s), t.unshift(s), s++;
      } while (i[s] && k2(i, e, s, n));
      break;
    }
  return o.length === 1 && (i[t[0] - 1] === "0" || i[t[0] - 1] === "٠") && t.unshift(t[0] - 1), o;
}, M2 = function(i, e, t, n) {
  const s = e[0], o = s < n.length ? n[s] : s;
  return e.forEach(function(r, a) {
    i = i.substr(0, o + a) + (t.length > 1 ? t[a] : t) + i.substr(o + a + 1);
  }), e.length === 1 && (i = i.replace("0" + t, t + t), i = i.replace("٠" + t, t + t)), i;
}, B2 = function(i, e, t, n) {
  let s, o, r;
  if (!Hs(i[e[0]] || "0")) {
    const a = Math.max(e.length <= 3 ? 3 : 4, t.length);
    for (; e.length > a; ) {
      for (o = e.pop(), r = n[o], n[o] = -1, s = o + 1; s < n.length; s++)
        n[s]--;
      i = i.substr(0, r) + i.substr(r + 1);
    }
    for (o = e[e.length - 1] + 1, r = o < n.length ? n[o] : o; e.length < a; ) {
      for (e.push(e[e.length - 1] + 1), s = o; s < n.length; s++)
        n[s]++;
      i = i.substr(0, r) + " " + i.substr(r);
    }
  }
  return i = M2(i, e, t, n), i;
}, Uy = function(i, e) {
  return Array.isArray(i) ? i.map(function(t) {
    return (e(t) || "").toString();
  }) : (e(i) || "").toString();
}, $2 = /[a-zA-Z]/g, N2 = function(i, e, t, n) {
  const s = e.split("").map(function(o, r) {
    return t.indexOf(r) < 0 && (o.match($2) || o === "'") ? n[r] : -1;
  });
  return i = i.split("").map(function(o, r) {
    let a = o;
    const l = s.indexOf(r) >= 0, d = r > 0 && s.indexOf(r - 1) >= 0, u = s.indexOf(r + 1) >= 0;
    return l && (d || (a = "'" + a), u || (a += "'")), a;
  }).join(""), i;
}, GT = function(i) {
  const e = [], t = Uy(new Date(2009, 8, 8, 6, 5, 4), i), n = t.split("").map(function(a, l) {
    return l;
  });
  let s = t;
  const o = {}, r = [{
    date: new Date(2009, 8, 8, 6, 5, 4, 111),
    pattern: "S"
  }, {
    date: new Date(2009, 8, 8, 6, 5, 2),
    pattern: "s"
  }, {
    date: new Date(2009, 8, 8, 6, 2, 4),
    pattern: "m"
  }, {
    date: new Date(2009, 8, 8, 18, 5, 4),
    pattern: "H",
    isDigit: !0
  }, {
    date: new Date(2009, 8, 8, 2, 5, 4),
    pattern: "h",
    isDigit: !0
  }, {
    date: new Date(2009, 8, 8, 18, 5, 4),
    pattern: "a",
    isDigit: !1
  }, {
    date: new Date(2009, 8, 1, 6, 5, 4),
    pattern: "d"
  }, {
    date: [new Date(2009, 8, 2, 6, 5, 4), new Date(2009, 8, 3, 6, 5, 4), new Date(2009, 8, 4, 6, 5, 4)],
    pattern: "E"
  }, {
    date: new Date(2009, 9, 6, 6, 5, 4),
    pattern: "M"
  }, {
    date: new Date(1998, 8, 8, 6, 5, 4),
    pattern: "y"
  }];
  if (s && (r.forEach(function(a) {
    const l = P2(t, Uy(a.date, i), e, a.isDigit), d = a.pattern === "M" && !o.d ? "L" : a.pattern;
    s = B2(s, l, d, n), o[d] = l.length;
  }), s = N2(s, t, e, n), e.length))
    return s;
}, as = {
  3: "abbreviated",
  4: "wide",
  5: "narrow"
}, jy = function(i, e) {
  return i > 2 ? Object.keys(as).map(function(t) {
    return ["format", "standalone"].map(function(n) {
      return e.getMonthNames(as[t], n).join("|");
    }).join("|");
  }).join("|") : i === 2 ? "1[012]|0?[1-9]" : "0??[1-9]|1[012]";
}, L2 = {
  ":": function(i, e) {
    const t = i > 1 ? `{${i}}` : "";
    let n = ns(e.getTimeSeparator());
    return n !== ":" && (n = `${n}|:`), `${n}${t}`;
  },
  y: function(i) {
    return i === 2 ? `[0-9]{${i}}` : "[0-9]+?";
  },
  M: jy,
  L: jy,
  Q: function(i, e) {
    return i > 2 ? e.getQuarterNames(as[i], "format").join("|") : "0?[1-4]";
  },
  E: function(i, e) {
    return "\\D*";
  },
  a: function(i, e) {
    return e.getPeriodNames(as[i < 3 ? 3 : i], "format").join("|");
  },
  d: function(i) {
    return i === 2 ? "3[01]|[12][0-9]|0?[1-9]" : "0??[1-9]|[12][0-9]|3[01]";
  },
  H: function(i) {
    return i === 2 ? "2[0-3]|1[0-9]|0?[0-9]" : "0??[0-9]|1[0-9]|2[0-3]";
  },
  h: function(i) {
    return i === 2 ? "1[012]|0?[1-9]" : "0??[1-9]|1[012]";
  },
  m: function(i) {
    return i === 2 ? "[1-5][0-9]|0?[0-9]" : "0??[0-9]|[1-5][0-9]";
  },
  s: function(i) {
    return i === 2 ? "[1-5][0-9]|0?[0-9]" : "0??[0-9]|[1-5][0-9]";
  },
  S: function(i) {
    return `[0-9]{1,${i}}`;
  },
  w: function(i) {
    return i === 2 ? "[1-5][0-9]|0?[0-9]" : "0??[0-9]|[1-5][0-9]";
  },
  x: function(i) {
    return i === 3 ? "[+-](?:2[0-3]|[01][0-9]):(?:[0-5][0-9])|Z" : "[+-](?:2[0-3]|[01][0-9])(?:[0-5][0-9])|Z";
  }
}, ji = Number, Dm = function(i, e) {
  return i.map((t) => t.toLowerCase()).indexOf(e.toLowerCase());
}, qy = function(i, e, t) {
  return e > 2 ? ["format", "standalone"].map(function(n) {
    return Object.keys(as).map(function(s) {
      const o = t.getMonthNames(as[s], n);
      return Dm(o, i);
    });
  }).reduce(function(n, s) {
    return n.concat(s);
  }).filter(function(n) {
    return n >= 0;
  })[0] : ji(i) - 1;
}, H2 = {
  y: function(i, e) {
    const t = ji(i);
    return e === 2 ? t < 30 ? 2e3 + t : 1900 + t : t;
  },
  M: qy,
  L: qy,
  Q: function(i, e, t) {
    return e > 2 ? t.getQuarterNames(as[e], "format").indexOf(i) : ji(i) - 1;
  },
  E: function(i, e, t) {
    const n = t.getDayNames(as[e < 3 ? 3 : e], "format");
    return Dm(n, i);
  },
  a: function(i, e, t) {
    const n = t.getPeriodNames(as[e < 3 ? 3 : e], "format");
    return Dm(n, i);
  },
  d: ji,
  H: ji,
  h: ji,
  m: ji,
  s: ji,
  S: function(i, e) {
    for (e = Math.max(e, 3), i = i.slice(0, 3); e < 3; )
      i += "0", e++;
    return ji(i);
  }
}, _c = ["y", "M", "d", "h", "m", "s", "S"], N_ = {
  y: "setFullYear",
  M: "setMonth",
  L: "setMonth",
  a: function(i, e, t) {
    let n = i.getHours();
    const s = t.h;
    s !== void 0 && s !== n && n--, !e && n === 12 ? n = 0 : e && n !== 12 && (n += 12), i.setHours(n);
  },
  d: "setDate",
  H: "setHours",
  h: "setHours",
  m: "setMinutes",
  s: "setSeconds",
  S: "setMilliseconds"
}, W2 = function(i, e) {
  const t = i[e];
  if (!t)
    return 0;
  let n = 0;
  do
    e++, n++;
  while (i[e] === t);
  return n;
}, z2 = function(i, e) {
  let t = "";
  for (let n = 0; n < e; n++)
    t += i;
  return t;
}, UT = function(i, e) {
  let t = "", n = "", s;
  const o = [], r = function() {
    n && (o.push(`'${n}'`), t += `${ns(n)})`, n = "");
  };
  for (let a = 0; a < i.length; a++) {
    const l = i[a], d = l === "'", u = L2[l];
    if (!(d && (s = !s, i[a - 1] !== "'")))
      if (u && !s) {
        const c = W2(i, a), h = z2(l, c);
        r(), o.push(h), t += `(${u(c, e)})`, a += c - 1;
      } else
        n || (t += "("), n += l;
  }
  return r(), G2(o) || Kc.warn(`The following format may be parsed incorrectly: ${i}.`), {
    patterns: o,
    regexp: new RegExp(`^${t}$`, "i")
  };
}, K2 = ["d", "H", "h", "m", "s", "w", "M", "L", "Q"], G2 = function(i) {
  const e = (s) => {
    if (!s)
      return !1;
    const o = s[0];
    return ["y", "S"].includes(o) || K2.includes(o) && s.length < 3;
  };
  let t = !0, n = 0;
  return i.every((s, o, r) => (e(s) && (((a) => a[0] !== "S" && a.length !== 2)(s) && (t = ++n < 2), e(r[o + 1]) || (n = 0)), t));
}, U2 = function() {
  return N_;
}, j2 = function(i, e, t, n, s) {
  const o = e[0], r = N_[o], a = H2[o];
  if (r && a) {
    const l = a(t, e.length, n);
    s[e] = l, i[r] ? i[r](l) : r(i, l, s);
  }
}, q2 = function(i, e, t) {
  const n = N_[e], s = "g" + n.substr(1), o = t[s]();
  i[n](o);
}, Y2 = function(i) {
  return i.map(function(e) {
    return e[0] === "'" ? "" : e[0] === "H" ? "h" : e[0];
  });
}, X2 = function(i) {
  const e = i.map(function(t) {
    return _c.indexOf(t);
  });
  return Math.max.apply(Math, e);
}, Z2 = function(i) {
  const e = i.filter(function(t) {
    return _c.indexOf(t) < 0;
  });
  return _c.concat(e);
}, Q2 = function(i, e) {
  const t = UT(i, e);
  return function(n) {
    const s = t.regexp.exec(n);
    if (s) {
      const o = /* @__PURE__ */ new Date(), r = new Date(o.getFullYear(), 0, 1), a = Y2(t.patterns), l = X2(a), d = Z2(a), u = {};
      return d.forEach(function(c, h) {
        if (!c || h < _c.length && h > l)
          return;
        const g = a.indexOf(c);
        if (g >= 0) {
          const m = t.patterns[g], C = s[g + 1];
          j2(r, m, C, e, u);
        } else
          q2(r, c, o);
      }), r;
    }
    return null;
  };
}, J2 = {
  "af-NA": 1,
  agq: 1,
  ak: 1,
  ar: 6,
  "ar-EH": 1,
  "ar-ER": 1,
  "ar-KM": 1,
  "ar-LB": 1,
  "ar-MA": 1,
  "ar-MR": 1,
  "ar-PS": 1,
  "ar-SO": 1,
  "ar-SS": 1,
  "ar-TD": 1,
  "ar-TN": 1,
  asa: 1,
  ast: 1,
  az: 1,
  "az-Cyrl": 1,
  bas: 1,
  be: 1,
  bem: 1,
  bez: 1,
  bg: 1,
  bm: 1,
  br: 1,
  bs: 1,
  "bs-Cyrl": 1,
  ca: 1,
  ce: 1,
  cgg: 1,
  ckb: 6,
  cs: 1,
  cy: 1,
  da: 1,
  de: 1,
  dje: 1,
  dsb: 1,
  dua: 1,
  dyo: 1,
  ee: 1,
  el: 1,
  "en-001": 1,
  "en-AE": 6,
  "en-BI": 1,
  "en-MP": 1,
  "en-MV": 5,
  "en-SD": 6,
  eo: 1,
  es: 1,
  et: 1,
  eu: 1,
  ewo: 1,
  fa: 6,
  ff: 1,
  "ff-Adlm": 1,
  fi: 1,
  fo: 1,
  fr: 1,
  "fr-DJ": 6,
  "fr-DZ": 6,
  "fr-SY": 6,
  fur: 1,
  fy: 1,
  ga: 1,
  gd: 1,
  gl: 1,
  gsw: 1,
  gv: 1,
  ha: 1,
  hr: 1,
  hsb: 1,
  hu: 1,
  hy: 1,
  ia: 1,
  ig: 1,
  is: 1,
  it: 1,
  jgo: 1,
  jmc: 1,
  ka: 1,
  kab: 6,
  kde: 1,
  kea: 1,
  khq: 1,
  kk: 1,
  kkj: 1,
  kl: 1,
  "ko-KP": 1,
  ksb: 1,
  ksf: 1,
  ksh: 1,
  ku: 1,
  kw: 1,
  ky: 1,
  lag: 1,
  lb: 1,
  lg: 1,
  ln: 1,
  lrc: 6,
  lt: 1,
  lu: 1,
  lv: 1,
  "mas-TZ": 1,
  mfe: 1,
  mg: 1,
  mgo: 1,
  mi: 1,
  mk: 1,
  mn: 1,
  ms: 1,
  mua: 1,
  mzn: 6,
  naq: 1,
  nds: 1,
  nl: 1,
  nmg: 1,
  nnh: 1,
  no: 1,
  nus: 1,
  nyn: 1,
  os: 1,
  pcm: 1,
  pl: 1,
  ps: 6,
  "pt-AO": 1,
  "pt-CH": 1,
  "pt-CV": 1,
  "pt-GQ": 1,
  "pt-GW": 1,
  "pt-LU": 1,
  "pt-ST": 1,
  "pt-TL": 1,
  "qu-BO": 1,
  "qu-EC": 1,
  rm: 1,
  rn: 1,
  ro: 1,
  rof: 1,
  ru: 1,
  rw: 1,
  rwk: 1,
  sah: 1,
  sbp: 1,
  sc: 1,
  se: 1,
  ses: 1,
  sg: 1,
  shi: 1,
  "shi-Latn": 1,
  si: 1,
  sk: 1,
  sl: 1,
  smn: 1,
  so: 1,
  "so-DJ": 6,
  sq: 1,
  sr: 1,
  "sr-Latn": 1,
  sv: 1,
  sw: 1,
  "ta-LK": 1,
  "ta-MY": 1,
  teo: 1,
  tg: 1,
  "ti-ER": 1,
  tk: 1,
  to: 1,
  tr: 1,
  tt: 1,
  twq: 1,
  tzm: 1,
  uk: 1,
  uz: 1,
  "uz-Arab": 6,
  "uz-Cyrl": 1,
  vai: 1,
  "vai-Latn": 1,
  vi: 1,
  vun: 1,
  wae: 1,
  wo: 1,
  xog: 1,
  yav: 1,
  yi: 1,
  yo: 1,
  zgh: 1
}, ej = /[\u200E\u200F]/g, tj = /[\u202F]/g, yo = (i) => (e) => {
  if (!i.timeZoneName) {
    const t = e.getFullYear(), n = String(t).length < 3, o = n ? t + 400 : t, r = new Date(Date.UTC(o, e.getMonth(), e.getDate(), e.getHours(), e.getMinutes(), e.getSeconds(), e.getMilliseconds()));
    n && r.setFullYear(t);
    const a = x({
      timeZone: "UTC"
    }, i);
    return Tm(r, a);
  }
  return Tm(e, i);
}, Cp = {}, nj = (i) => {
  const e = Kn.locale() + "/" + JSON.stringify(i);
  return Cp[e] || (Cp[e] = new Intl.DateTimeFormat(Kn.locale(), i).format), Cp[e];
};
function Tm(i, e) {
  return nj(e)(i).replace(ej, "").replace(tj, " ");
}
const Om = (i) => new Intl.NumberFormat(Kn.locale()).format(i), ij = (() => {
  const i = {};
  return (e) => {
    if (!(e in i)) {
      if (Om(0) === "0")
        return i[e] = !1, !1;
      i[e] = {};
      for (let t = 0; t < 10; ++t)
        i[e][Om(t)] = t;
    }
    return i[e];
  };
})(), Hd = (i) => {
  const e = ij(Kn.locale());
  return e ? i.split("").map((t) => t in e ? String(e[t]) : t).join("") : i;
}, Yy = (i) => i.replace(/(\D)0+(\d)/g, "$1$2"), sj = (i, e) => Yy(i) === Yy(e), Am = (i) => i.replace("d’", "de "), L_ = {
  day: {
    day: "numeric"
  },
  date: {
    year: "numeric",
    month: "long",
    day: "numeric"
  },
  dayofweek: {
    weekday: "long"
  },
  longdate: {
    weekday: "long",
    year: "numeric",
    month: "long",
    day: "numeric"
  },
  longdatelongtime: {
    weekday: "long",
    year: "numeric",
    month: "long",
    day: "numeric",
    hour: "numeric",
    minute: "numeric",
    second: "numeric"
  },
  longtime: {
    hour: "numeric",
    minute: "numeric",
    second: "numeric"
  },
  month: {
    month: "long"
  },
  monthandday: {
    month: "long",
    day: "numeric"
  },
  monthandyear: {
    year: "numeric",
    month: "long"
  },
  shortdate: {},
  shorttime: {
    hour: "numeric",
    minute: "numeric"
  },
  shortyear: {
    year: "2-digit"
  },
  year: {
    year: "numeric"
  }
};
Object.defineProperty(L_, "shortdateshorttime", {
  get: function() {
    const i = Intl.DateTimeFormat(Kn.locale()).resolvedOptions();
    return {
      year: i.year,
      month: i.month,
      day: i.day,
      hour: "numeric",
      minute: "numeric"
    };
  }
});
const oj = (i) => typeof i == "string" && L_[i.toLowerCase()], jT = {
  standalone: function(i, e) {
    const t = new Date(1999, i, 13, 1);
    return yo({
      month: e
    })(t);
  },
  format: function(i, e) {
    const t = new Date(0, i, 13, 1), s = Am(yo({
      day: "numeric",
      month: e
    })(t)).split(" ").filter((o) => o.indexOf("13") < 0);
    return s.length === 1 ? s[0] : s.length === 2 ? s[0].length > s[1].length ? s[0] : s[1] : jT.standalone(i, e);
  }
}, rj = {
  engine: function() {
    return "intl";
  },
  getMonthNames: function(i, e) {
    const t = {
      wide: "long",
      abbreviated: "short",
      narrow: "narrow"
    }[i || "wide"];
    return e = e === "format" ? e : "standalone", Array.apply(null, new Array(12)).map((n, s) => jT[e](s, t));
  },
  getDayNames: function(i) {
    return ((t) => Array.apply(null, new Array(7)).map((n, s) => yo({
      weekday: t
    })(new Date(0, 0, s))))({
      wide: "long",
      abbreviated: "short",
      short: "narrow",
      narrow: "narrow"
    }[i || "wide"]);
  },
  getPeriodNames: function() {
    const i = yo({
      hour: "numeric",
      hour12: !0
    });
    return [1, 13].map((e) => {
      const t = Om(1), n = i(new Date(0, 0, 1, e)).split(t);
      return n.length !== 2 ? "" : (n[0].length > n[1].length ? n[0] : n[1]).trim();
    });
  },
  format: function(i, e) {
    if (!i)
      return;
    if (!e)
      return i;
    typeof e != "function" && !e.formatter && (e = e.type || e);
    const t = oj(e);
    if (t)
      return yo(t)(i);
    const n = typeof e;
    return e.formatter || n === "function" || n === "string" ? this.callBase.apply(this, arguments) : yo(e)(i);
  },
  parse: function(i, e) {
    let t;
    return e && !e.parser && typeof i == "string" && (i = Am(i), t = (n) => Am(this.format(n, e))), this.callBase(i, t || e);
  },
  _parseDateBySimpleFormat: function(i, e) {
    i = Hd(i);
    const t = this.getFormatParts(e), n = i.split(/\D+/).filter((r) => r.length > 0);
    if (t.length !== n.length)
      return;
    const s = this._generateDateArgs(t, n), o = (r) => {
      const a = ((l, d) => {
        const u = d ? 12 : 0;
        return new Date(l.year, l.month, l.day, (l.hours + u) % 24, l.minutes, l.seconds);
      })(s, r);
      if (sj(Hd(this.format(a, e)), i))
        return a;
    };
    return o(!1) || o(!0);
  },
  _generateDateArgs: function(i, e) {
    const t = /* @__PURE__ */ new Date(), n = {
      year: t.getFullYear(),
      month: t.getMonth(),
      day: t.getDate(),
      hours: 0,
      minutes: 0,
      seconds: 0
    };
    return i.forEach((s, o) => {
      const r = e[o];
      let a = parseInt(r, 10);
      s === "month" && (a -= 1), n[s] = a;
    }), n;
  },
  formatUsesMonthName: function(i) {
    return typeof i == "object" && !(i.type || i.format) ? i.month === "long" : this.callBase.apply(this, arguments);
  },
  formatUsesDayName: function(i) {
    return typeof i == "object" && !(i.type || i.format) ? i.weekday === "long" : this.callBase.apply(this, arguments);
  },
  getTimeSeparator: function() {
    return Hd(Tm(new Date(2001, 1, 1, 11, 11), {
      hour: "numeric",
      minute: "numeric",
      hour12: !1
    })).replace(/\d/g, "");
  },
  getFormatParts: function(i) {
    if (typeof i == "string")
      return this.callBase(i);
    const e = x({}, L_[i.toLowerCase()]), t = new Date(2001, 2, 4, 5, 6, 7);
    let n = yo(e)(t);
    return n = Hd(n), [{
      name: "year",
      value: 1
    }, {
      name: "month",
      value: 3
    }, {
      name: "day",
      value: 4
    }, {
      name: "hours",
      value: 5
    }, {
      name: "minutes",
      value: 6
    }, {
      name: "seconds",
      value: 7
    }].map((s) => ({
      name: s.name,
      index: n.indexOf(s.value)
    })).filter((s) => s.index > -1).sort((s, o) => s.index - o.index).map((s) => s.name);
  }
}, aj = typeof Intl < "u", vp = {
  shortdate: "M/d/y",
  shorttime: "h:mm a",
  longdate: "EEEE, MMMM d, y",
  longtime: "h:mm:ss a",
  monthandday: "MMMM d",
  monthandyear: "MMMM y",
  quarterandyear: "QQQ y",
  day: "d",
  year: "y",
  shortdateshorttime: "M/d/y, h:mm a",
  longdatelongtime: "EEEE, MMMM d, y, h:mm:ss a",
  month: "LLLL",
  shortyear: "yy",
  dayofweek: "EEEE",
  quarter: "QQQ",
  hour: "HH",
  minute: "mm",
  second: "ss",
  millisecond: "SSS",
  "datetime-local": "yyyy-MM-ddTHH':'mm':'ss"
}, lj = {
  year: ["y", "yy", "yyyy"],
  day: ["d", "dd"],
  month: ["M", "MM", "MMM", "MMMM"],
  hours: ["H", "HH", "h", "hh", "ah"],
  minutes: ["m", "mm"],
  seconds: ["s", "ss"],
  milliseconds: ["S", "SS", "SSS"]
}, ue = qn({
  engine: function() {
    return "base";
  },
  _getPatternByFormat: function(i) {
    return vp[i.toLowerCase()];
  },
  _expandPattern: function(i) {
    return this._getPatternByFormat(i) || i;
  },
  formatUsesMonthName: function(i) {
    return this._expandPattern(i).indexOf("MMMM") !== -1;
  },
  formatUsesDayName: function(i) {
    return this._expandPattern(i).indexOf("EEEE") !== -1;
  },
  getFormatParts: function(i) {
    const e = this._getPatternByFormat(i) || i, t = [];
    return y(e.split(/\W+/), (n, s) => {
      y(lj, (o, r) => {
        r.includes(s) && t.push(o);
      });
    }), t;
  },
  getMonthNames: function(i) {
    return Mr.getMonthNames(i);
  },
  getDayNames: function(i) {
    return Mr.getDayNames(i);
  },
  getQuarterNames: function(i) {
    return Mr.getQuarterNames(i);
  },
  getPeriodNames: function(i) {
    return Mr.getPeriodNames(i);
  },
  getTimeSeparator: function() {
    return ":";
  },
  is24HourFormat: function(i) {
    const e = new Date(2017, 0, 20, 11, 0, 0, 0), t = new Date(2017, 0, 20, 23, 0, 0, 0), n = this.format(e, i), s = this.format(t, i);
    for (let o = 0; o < n.length; o++)
      if (n[o] !== s[o])
        return !isNaN(parseInt(n[o]));
  },
  format: function(i, e) {
    if (!i)
      return;
    if (!e)
      return i;
    let t;
    if (typeof e == "function")
      t = e;
    else if (e.formatter)
      t = e.formatter;
    else if (e = e.type || e, te(e))
      return e = vp[e.toLowerCase()] || e, We.convertDigits(YI(e, this)(i));
    if (t)
      return t(i);
  },
  parse: function(i, e) {
    const t = this;
    let n, s;
    if (!i)
      return;
    if (!e)
      return this.parse(i, "shortdate");
    if (e.parser)
      return e.parser(i);
    if (typeof e == "string" && !vp[e.toLowerCase()])
      n = e;
    else {
      s = (r) => {
        const a = t.format(r, e);
        return We.convertDigits(a, !0);
      };
      try {
        n = GT(s);
      } catch {
      }
    }
    if (n)
      return i = We.convertDigits(i, !0), Q2(n, this)(i);
    Ae.log("W0012");
    const o = new Date(i);
    if (!(!o || isNaN(o.getTime())))
      return o;
  },
  firstDayOfWeekIndex: function() {
    const i = Kn.getValueByClosestLocale((e) => J2[e]);
    return i === void 0 ? 0 : i;
  }
});
aj && ue.inject(rj);
const qT = qn({
  format: function(i, e) {
    const t = te(e) && e !== "" || pe(e) || B(e), n = $e(i) || cn(i);
    if (!t || !n)
      return f(i) ? i.toString() : "";
    if (B(e))
      return e(i);
    if (te(e) && (e = {
      type: e
    }), $e(i))
      return We.format(i, e);
    if (cn(i))
      return ue.format(i, e);
  },
  getTimeFormat: function(i) {
    return i ? "longtime" : "shorttime";
  },
  _normalizeFormat: function(i) {
    return Array.isArray(i) ? i.length === 1 ? i[0] : function(e) {
      return i.map(function(t) {
        return ue.format(e, t);
      }).join(" ");
    } : i;
  },
  getDateFormatByDifferences: function(i, e) {
    const t = [], n = e && i.millisecond && !(i.year || i.month || i.day);
    if (n) {
      const s = function(o) {
        return o.getSeconds() + o.getMilliseconds() / 1e3 + "s";
      };
      t.push(s);
    } else
      i.millisecond && t.push("millisecond");
    if ((i.hour || i.minute || !n && i.second) && t.unshift(this.getTimeFormat(i.second)), i.year && i.month && i.day)
      return e && e === "month" ? "monthandyear" : (t.unshift("shortdate"), this._normalizeFormat(t));
    if (i.year && i.month)
      return "monthandyear";
    if (i.year && i.quarter)
      return "quarterandyear";
    if (i.year)
      return "year";
    if (i.quarter)
      return "quarter";
    if (i.month && i.day) {
      if (e) {
        const s = function(o) {
          return ue.getMonthNames("abbreviated")[o.getMonth()] + " " + ue.format(o, "day");
        };
        t.unshift(s);
      } else
        t.unshift("monthandday");
      return this._normalizeFormat(t);
    }
    if (i.month)
      return "month";
    if (i.day) {
      if (e)
        t.unshift("day");
      else {
        const s = function(o) {
          return ue.format(o, "dayofweek") + ", " + ue.format(o, "day");
        };
        t.unshift(s);
      }
      return this._normalizeFormat(t);
    }
    return this._normalizeFormat(t);
  },
  getDateFormatByTicks: function(i) {
    let e, t, n;
    if (i.length > 1)
      for (e = j.getDatesDifferences(i[0], i[1]), n = 1; n < i.length - 1; n++)
        t = j.getDatesDifferences(i[n], i[n + 1]), e.count < t.count && (e = t);
    else
      e = {
        year: !0,
        month: !0,
        day: !0,
        hour: i[0].getHours() > 0,
        minute: i[0].getMinutes() > 0,
        second: i[0].getSeconds() > 0,
        millisecond: i[0].getMilliseconds() > 0
      };
    return this.getDateFormatByDifferences(e);
  },
  getDateFormatByTickInterval: function(i, e, t) {
    let n;
    const s = function(a, l, d) {
      switch (l) {
        case "year":
        case "quarter":
          a.month = d;
        case "month":
          a.day = d;
        case "week":
        case "day":
          a.hour = d;
        case "hour":
          a.minute = d;
        case "minute":
          a.second = d;
        case "second":
          a.millisecond = d;
      }
    };
    t = te(t) ? t.toLowerCase() : t;
    const o = j.getDatesDifferences(i, e);
    return i !== e && function(a, l, d) {
      !d.getMilliseconds() && d.getSeconds() ? d.getSeconds() - l.getSeconds() === 1 && (a.millisecond = !0, a.second = !1) : !d.getSeconds() && d.getMinutes() ? d.getMinutes() - l.getMinutes() === 1 && (a.second = !0, a.minute = !1) : !d.getMinutes() && d.getHours() ? d.getHours() - l.getHours() === 1 && (a.minute = !0, a.hour = !1) : !d.getHours() && d.getDate() > 1 ? d.getDate() - l.getDate() === 1 && (a.hour = !0, a.day = !1) : d.getDate() === 1 && d.getMonth() ? d.getMonth() - l.getMonth() === 1 && (a.day = !0, a.month = !1) : !d.getMonth() && d.getFullYear() && d.getFullYear() - l.getFullYear() === 1 && (a.month = !0, a.year = !1);
    }(o, i > e ? e : i, i > e ? i : e), n = j.getDateUnitInterval(o), s(o, n, !0), n = j.getDateUnitInterval(t || "second"), s(o, n, !1), o[{
      week: "day"
    }[n] || n] = !0, this.getDateFormatByDifferences(o);
  }
});
function YT(i, e, t) {
  function n(o) {
    return typeof o == "string" ? o.split(".") : typeof o == "number" ? [o] : o;
  }
  i = n(i), e = n(e);
  let s = Math.max(i.length, e.length);
  isFinite(t) && (s = Math.min(s, t));
  for (let o = 0; o < s; o++) {
    const r = parseInt(i[o] || 0, 10), a = parseInt(e[o] || 0, 10);
    if (r < a)
      return -1;
    if (r > a)
      return 1;
  }
  return 0;
}
const dj = "dx-state-focused";
function Xy(i, e, t) {
  i = i === "role" || i === "id" ? i : `aria-${i}`, e = f(e) ? e.toString() : null, t.attr(i, e);
}
class Rt extends ui {
  constructor() {
    super(...arguments), this._feedbackHideTimeout = 400, this._feedbackShowTimeout = 30;
  }
  static getOptionsFromContainer(e) {
    let {
      name: t,
      fullName: n,
      value: s
    } = e, o = {};
    if (t === n)
      o = s;
    else {
      const r = n.split(".").pop();
      o[r] = s;
    }
    return o;
  }
  _supportedKeys() {
    return {};
  }
  _getDefaultOptions() {
    return x(super._getDefaultOptions(), {
      hoveredElement: null,
      isActive: !1,
      disabled: !1,
      visible: !0,
      hint: void 0,
      activeStateEnabled: !1,
      onContentReady: null,
      hoverStateEnabled: !1,
      focusStateEnabled: !1,
      tabIndex: 0,
      accessKey: void 0,
      onFocusIn: null,
      onFocusOut: null,
      onKeyboardHandled: null,
      ignoreParentReadOnly: !1,
      useResizeObserver: !0
    });
  }
  _defaultOptionsRules() {
    return super._defaultOptionsRules().concat([{
      device() {
        const e = z.real(), {
          platform: t
        } = e, {
          version: n
        } = e;
        return t === "ios" && YT(n, "13.3") <= 0;
      },
      options: {
        useResizeObserver: !1
      }
    }]);
  }
  _init() {
    super._init(), this._initContentReadyAction();
  }
  _innerWidgetOptionChanged(e, t) {
    const n = Rt.getOptionsFromContainer(t);
    e && e.option(n), this._options.cache(t.name, n);
  }
  _bindInnerWidgetOptions(e, t) {
    const n = () => this._options.silent(t, x({}, e.option()));
    n(), e.on("optionChanged", n);
  }
  _getAriaTarget() {
    return this._focusTarget();
  }
  _initContentReadyAction() {
    this._contentReadyAction = this._createActionByOption("onContentReady", {
      excludeValidators: ["disabled", "readOnly"]
    });
  }
  _initMarkup() {
    const {
      disabled: e,
      visible: t
    } = this.option();
    this.$element().addClass("dx-widget"), this._toggleDisabledState(e), this._toggleVisibility(t), this._renderHint(), this._isFocusable() && this._renderFocusTarget(), super._initMarkup();
  }
  _render() {
    super._render(), this._renderContent(), this._renderFocusState(), this._attachFeedbackEvents(), this._attachHoverEvents(), this._toggleIndependentState();
  }
  _renderHint() {
    const {
      hint: e
    } = this.option();
    this.$element().attr("title", e || null);
  }
  _renderContent() {
    ft(() => this._disposed ? void 0 : this._renderContentImpl()).done(() => this._disposed ? void 0 : this._fireContentReadyAction());
  }
  _renderContentImpl() {
  }
  _fireContentReadyAction() {
    return ft(() => {
      var e;
      return (e = this._contentReadyAction) === null || e === void 0 ? void 0 : e.call(this);
    });
  }
  _dispose() {
    this._contentReadyAction = null, this._detachKeyboardEvents(), super._dispose();
  }
  _resetActiveState() {
    this._toggleActiveState(this._eventBindingTarget(), !1);
  }
  _clean() {
    this._cleanFocusState(), this._resetActiveState(), super._clean(), this.$element().empty();
  }
  _toggleVisibility(e) {
    this.$element().toggleClass("dx-state-invisible", !e);
  }
  _renderFocusState() {
    this._attachKeyboardEvents(), this._isFocusable() && (this._renderFocusTarget(), this._attachFocusEvents(), this._renderAccessKey());
  }
  _renderAccessKey() {
    const e = this._focusTarget(), {
      accessKey: t
    } = this.option();
    e.attr("accesskey", t);
  }
  _isFocusable() {
    const {
      focusStateEnabled: e,
      disabled: t
    } = this.option();
    return e && !t;
  }
  _eventBindingTarget() {
    return this.$element();
  }
  _focusTarget() {
    return this._getActiveElement();
  }
  _isFocusTarget(e) {
    return p(this._focusTarget()).toArray().includes(e);
  }
  _findActiveTarget(e) {
    return e.find(this._activeStateUnit).not(".dx-state-disabled");
  }
  _getActiveElement() {
    const e = this._eventBindingTarget();
    return this._activeStateUnit ? this._findActiveTarget(e) : e;
  }
  _renderFocusTarget() {
    const {
      tabIndex: e
    } = this.option();
    this._focusTarget().attr("tabIndex", e);
  }
  _keyboardEventBindingTarget() {
    return this._eventBindingTarget();
  }
  _refreshFocusEvent() {
    this._detachFocusEvents(), this._attachFocusEvents();
  }
  _focusEventTarget() {
    return this._focusTarget();
  }
  _focusInHandler(e) {
    e.isDefaultPrevented() || this._createActionByOption("onFocusIn", {
      beforeExecute: () => this._updateFocusState(e, !0),
      excludeValidators: ["readOnly"]
    })({
      event: e
    });
  }
  _focusOutHandler(e) {
    e.isDefaultPrevented() || this._createActionByOption("onFocusOut", {
      beforeExecute: () => this._updateFocusState(e, !1),
      excludeValidators: ["readOnly", "disabled"]
    })({
      event: e
    });
  }
  _updateFocusState(e, t) {
    let {
      target: n
    } = e;
    this._isFocusTarget(n) && this._toggleFocusClass(t, p(n));
  }
  _toggleFocusClass(e, t) {
    (t && t.length ? t : this._focusTarget()).toggleClass("dx-state-focused", e);
  }
  _hasFocusClass(e) {
    return p(e ?? this._focusTarget()).hasClass("dx-state-focused");
  }
  _isFocused() {
    return this._hasFocusClass();
  }
  _getKeyboardListeners() {
    return [];
  }
  _attachKeyboardEvents() {
    this._detachKeyboardEvents();
    const {
      focusStateEnabled: e,
      onKeyboardHandled: t
    } = this.option(), n = this._getKeyboardListeners().length;
    (e || n || !!t) && (this._keyboardListenerId = oi.on(this._keyboardEventBindingTarget(), this._focusTarget(), (r) => this._keyboardHandler(r)));
  }
  _keyboardHandler(e, t) {
    if (!t) {
      const {
        originalEvent: o,
        keyName: r,
        which: a
      } = e, l = this._supportedKeys(o), d = l[r] || l[a];
      if (d !== void 0 && !d.bind(this)(o, e))
        return !1;
    }
    const n = this._getKeyboardListeners(), {
      onKeyboardHandled: s
    } = this.option();
    return n.forEach((o) => o && o._keyboardHandler(e)), s && s(e), !0;
  }
  _refreshFocusState() {
    this._cleanFocusState(), this._renderFocusState();
  }
  _cleanFocusState() {
    this._focusTarget().removeAttr("tabIndex"), this._toggleFocusClass(!1), this._detachFocusEvents(), this._detachKeyboardEvents();
  }
  _detachKeyboardEvents() {
    oi.off(this._keyboardListenerId), this._keyboardListenerId = null;
  }
  _attachHoverEvents() {
    const {
      hoverStateEnabled: e
    } = this.option(), t = this._activeStateUnit, n = this._eventBindingTarget();
    Dx.off(n, {
      selector: t,
      namespace: "UIFeedback"
    }), e && Dx.on(n, new vn((s) => {
      let {
        event: o,
        element: r
      } = s;
      this._hoverStartHandler(o), this.option("hoveredElement", p(r));
    }, {
      excludeValidators: ["readOnly"]
    }), (s) => {
      this.option("hoveredElement", null), this._hoverEndHandler(s);
    }, {
      selector: t,
      namespace: "UIFeedback"
    });
  }
  _attachFeedbackEvents() {
    const {
      activeStateEnabled: e
    } = this.option(), t = this._activeStateUnit, n = this._eventBindingTarget();
    Ix.off(n, {
      namespace: "UIFeedback",
      selector: t
    }), e && Ix.on(n, new vn((s) => {
      let {
        event: o,
        element: r
      } = s;
      return this._toggleActiveState(p(r), !0, o);
    }), new vn((s) => {
      let {
        event: o,
        element: r
      } = s;
      return this._toggleActiveState(p(r), !1, o);
    }, {
      excludeValidators: ["disabled", "readOnly"]
    }), {
      showTimeout: this._feedbackShowTimeout,
      hideTimeout: this._feedbackHideTimeout,
      selector: t,
      namespace: "UIFeedback"
    });
  }
  _detachFocusEvents() {
    const e = this._focusEventTarget();
    Tu.off(e, {
      namespace: `${this.NAME}Focus`
    });
  }
  _attachFocusEvents() {
    const e = this._focusEventTarget();
    Tu.on(e, (t) => this._focusInHandler(t), (t) => this._focusOutHandler(t), {
      namespace: `${this.NAME}Focus`,
      isFocusable: (t, n) => p(n).is(em)
    });
  }
  _hoverStartHandler(e) {
  }
  _hoverEndHandler(e) {
  }
  _toggleActiveState(e, t, n) {
    this.option("isActive", t), e.toggleClass("dx-state-active", t);
  }
  _updatedHover() {
    const e = this._options.silent("hoveredElement");
    this._hover(e, e);
  }
  _findHoverTarget(e) {
    return e && e.closest(this._activeStateUnit || this._eventBindingTarget());
  }
  _hover(e, t) {
    const {
      hoverStateEnabled: n,
      disabled: s,
      isActive: o
    } = this.option();
    if (t = this._findHoverTarget(t), t && t.toggleClass("dx-state-hover", !1), e && n && !s && !o) {
      const r = this._findHoverTarget(e);
      r && r.toggleClass("dx-state-hover", !0);
    }
  }
  _toggleDisabledState(e) {
    this.$element().toggleClass("dx-state-disabled", !!e), this.setAria("disabled", e || void 0);
  }
  _toggleIndependentState() {
    const {
      ignoreParentReadOnly: e
    } = this.option();
    this.$element().toggleClass("dx-state-independent", e);
  }
  _setWidgetOption(e, t) {
    if (!this[e])
      return;
    if (pe(t[0])) {
      y(t[0], (r, a) => this._setWidgetOption(e, [r, a]));
      return;
    }
    const n = t[0];
    let s = t[1];
    t.length === 1 && (s = this.option(n));
    const o = this[`${e}OptionMap`];
    this[e].option(o ? o(n) : n, s);
  }
  _optionChanged(e) {
    const {
      name: t,
      value: n,
      previousValue: s
    } = e;
    switch (t) {
      case "disabled":
        this._toggleDisabledState(n), this._updatedHover(), this._refreshFocusState();
        break;
      case "hint":
        this._renderHint();
        break;
      case "ignoreParentReadOnly":
        this._toggleIndependentState();
        break;
      case "activeStateEnabled":
        this._attachFeedbackEvents();
        break;
      case "hoverStateEnabled":
        this._attachHoverEvents(), this._updatedHover();
        break;
      case "tabIndex":
      case "focusStateEnabled":
        this._refreshFocusState();
        break;
      case "onFocusIn":
      case "onFocusOut":
      case "useResizeObserver":
        break;
      case "accessKey":
        this._renderAccessKey();
        break;
      case "hoveredElement":
        this._hover(n, s);
        break;
      case "isActive":
        this._updatedHover();
        break;
      case "visible":
        this._toggleVisibility(n), this._isVisibilityChangeSupported() && this._checkVisibilityChanged(n ? "shown" : "hiding");
        break;
      case "onKeyboardHandled":
        this._attachKeyboardEvents();
        break;
      case "onContentReady":
        this._initContentReadyAction();
        break;
      default:
        super._optionChanged(e);
    }
  }
  _isVisible() {
    const {
      visible: e
    } = this.option();
    return super._isVisible() && e;
  }
  beginUpdate() {
    this._ready(!1), super.beginUpdate();
  }
  endUpdate() {
    super.endUpdate(), this._initialized && this._ready(!0);
  }
  _ready(e) {
    return arguments.length === 0 ? !!this._isReady : (this._isReady = !!e, this._isReady);
  }
  setAria() {
    if (!pe(arguments.length <= 0 ? void 0 : arguments[0]))
      Xy(arguments.length <= 0 ? void 0 : arguments[0], arguments.length <= 1 ? void 0 : arguments[1], (arguments.length <= 2 ? void 0 : arguments[2]) || this._getAriaTarget());
    else {
      const e = (arguments.length <= 1 ? void 0 : arguments[1]) || this._getAriaTarget();
      y(arguments.length <= 0 ? void 0 : arguments[0], (t, n) => Xy(t, n, e));
    }
  }
  isReady() {
    return this._ready();
  }
  repaint() {
    this._refresh();
  }
  focus() {
    Tu.trigger(this._focusTarget());
  }
  registerKeyHandler(e, t) {
    const n = this._supportedKeys();
    this._supportedKeys = () => x(n, {
      [e]: t
    });
  }
}
const uj = ua();
class Dn extends Rt {
  _getDefaultOptions() {
    return I({}, super._getDefaultOptions(), {
      indicatorSrc: "",
      activeStateEnabled: !1,
      hoverStateEnabled: !1,
      _animatingSegmentCount: 1,
      _animatingSegmentInner: !1
    });
  }
  _defaultOptionsRules() {
    const e = pn();
    return super._defaultOptionsRules().concat([{
      device() {
        return z.real().platform === "android" && !/chrome/i.test(uj.userAgent);
      },
      options: {
        viaImage: !0
      }
    }, {
      device: () => Gn(e),
      options: {
        _animatingSegmentCount: 2,
        _animatingSegmentInner: !0
      }
    }, {
      device: () => m_(e),
      options: {
        _animatingSegmentCount: 7
      }
    }]);
  }
  _useTemplates() {
    return !1;
  }
  _init() {
    super._init(), this.$element().addClass("dx-loadindicator");
    const t = {
      role: "alert",
      label: S.format("Loading")
    };
    this.setAria(t);
  }
  _initMarkup() {
    super._initMarkup(), this._renderWrapper(), this._renderIndicatorContent(), this._renderMarkup();
  }
  _renderWrapper() {
    this._$wrapper = p("<div>").addClass("dx-loadindicator-wrapper"), this.$element().append(this._$wrapper);
  }
  _renderIndicatorContent() {
    this._$content = p("<div>").addClass("dx-loadindicator-content"), this._$wrapper.append(this._$content);
  }
  _renderMarkup() {
    const {
      viaImage: e,
      indicatorSrc: t
    } = this.option();
    tn.animation() && !e && !t ? this._renderMarkupForAnimation() : this._renderMarkupForImage();
  }
  _renderMarkupForAnimation() {
    const e = this.option("_animatingSegmentInner");
    this._$indicator = p("<div>").addClass("dx-loadindicator-icon"), this._$content.append(this._$indicator);
    for (let t = this.option("_animatingSegmentCount"); t >= 0; --t) {
      const n = p("<div>").addClass("dx-loadindicator-segment").addClass("dx-loadindicator-segment" + t);
      e && n.append(p("<div>").addClass("dx-loadindicator-segment-inner")), this._$indicator.append(n);
    }
  }
  _renderMarkupForImage() {
    const {
      indicatorSrc: e
    } = this.option();
    e ? (this._$wrapper.addClass("dx-loadindicator-image"), this._$wrapper.css("backgroundImage", `url(${e})`)) : tn.animation() && this._renderMarkupForAnimation();
  }
  _renderDimensions() {
    super._renderDimensions(), this._updateContentSizeForAnimation();
  }
  _updateContentSizeForAnimation() {
    if (!this._$indicator)
      return;
    let e = this.option("width"), t = this.option("height");
    if (e || t) {
      e = ne(this.$element()), t = le(this.$element());
      const n = Math.min(t, e);
      this._$wrapper.css({
        height: n,
        width: n,
        fontSize: n
      });
    }
  }
  _clean() {
    super._clean(), this._removeMarkupForAnimation(), this._removeMarkupForImage();
  }
  _removeMarkupForAnimation() {
    this._$indicator && (this._$indicator.remove(), delete this._$indicator);
  }
  _removeMarkupForImage() {
    this._$wrapper.css("backgroundImage", "none");
  }
  _optionChanged(e) {
    switch (e.name) {
      case "_animatingSegmentCount":
      case "_animatingSegmentInner":
      case "indicatorSrc":
        this._invalidate();
        break;
      default:
        super._optionChanged(e);
    }
  }
}
xe("dxLoadIndicator", Dn);
const Rl = "dxdragstart", oa = "dxdrag", Fl = "dxdragend", uh = "dxdragenter", ch = "dxdragleave", H_ = "dxdrop", Qi = [], $r = [], Rm = [], W_ = {
  setup(i, e) {
    Qi.includes(i) || (Qi.push(i), $r.push([]), Rm.push(e || {}));
  },
  add(i, e) {
    const t = Qi.indexOf(i);
    this.updateEventsCounter(i, e.type, 1);
    const {
      selector: n
    } = e;
    $r[t].includes(n) || $r[t].push(n);
  },
  updateEventsCounter(i, e, t) {
    if ([uh, ch, H_].includes(e)) {
      const n = tt(i, "dxDragEventsCount") || 0;
      tt(i, "dxDragEventsCount", Math.max(0, n + t));
    }
  },
  remove(i, e) {
    this.updateEventsCounter(i, e.type, -1);
  },
  teardown(i) {
    if (!tt(i, "dxDragEventsCount")) {
      const t = Qi.indexOf(i);
      Qi.splice(t, 1), $r.splice(t, 1), Rm.splice(t, 1), qc(i, "dxDragEventsCount");
    }
  }
};
Yn(uh, W_);
Yn(ch, W_);
Yn(H_, W_);
const cj = function(i) {
  const e = Qi.indexOf(i.get(0)), t = $r[e].filter((s) => s);
  let n = i.find(t.join(", "));
  return $r[e].includes(void 0) && (n = n.add(i)), n;
}, hj = function(i) {
  const e = Qi.indexOf(i.get(0));
  return Rm[e];
}, pj = function(i, e) {
  return i.itemPositionFunc ? i.itemPositionFunc(e) : e.offset();
}, gj = function(i, e) {
  return i.itemSizeFunc ? i.itemSizeFunc(e) : {
    width: e.get(0).getBoundingClientRect().width,
    height: e.get(0).getBoundingClientRect().height
  };
}, mj = ud.inherit({
  ctor(i) {
    this.callBase(i), this.direction = "both";
  },
  _init(i) {
    this._initEvent = i;
  },
  _start(i) {
    if (i = this._fireEvent("dxdragstart", this._initEvent), this._maxLeftOffset = i.maxLeftOffset, this._maxRightOffset = i.maxRightOffset, this._maxTopOffset = i.maxTopOffset, this._maxBottomOffset = i.maxBottomOffset, i.targetElements || i.targetElements === null) {
      const e = j4(i.targetElements || []);
      this._dropTargets = mt(e, (t) => p(t).get(0));
    } else
      this._dropTargets = Qi;
  },
  _move(i) {
    const e = st(i), t = this._calculateOffset(e);
    i = this._fireEvent("dxdrag", i, {
      offset: t
    }), this._processDropTargets(i), i._cancelPreventDefault || i.preventDefault();
  },
  _calculateOffset(i) {
    return {
      x: this._calculateXOffset(i),
      y: this._calculateYOffset(i)
    };
  },
  _calculateXOffset(i) {
    if (this.direction !== "vertical") {
      const e = i.x - this._startEventData.x;
      return this._fitOffset(e, this._maxLeftOffset, this._maxRightOffset);
    }
    return 0;
  },
  _calculateYOffset(i) {
    if (this.direction !== "horizontal") {
      const e = i.y - this._startEventData.y;
      return this._fitOffset(e, this._maxTopOffset, this._maxBottomOffset);
    }
    return 0;
  },
  _fitOffset(i, e, t) {
    return e != null && (i = Math.max(i, -e)), t != null && (i = Math.min(i, t)), i;
  },
  _processDropTargets(i) {
    const e = this._findDropTarget(i);
    e === this._currentDropTarget || (this._fireDropTargetEvent(i, ch), this._currentDropTarget = e, this._fireDropTargetEvent(i, uh));
  },
  _fireDropTargetEvent(i, e) {
    if (!this._currentDropTarget)
      return;
    const t = {
      type: e,
      originalEvent: i,
      draggingElement: this._$element.get(0),
      target: this._currentDropTarget
    };
    oo(t);
  },
  _findDropTarget(i) {
    const e = this;
    let t;
    return y(Qi, (n, s) => {
      if (!e._checkDropTargetActive(s))
        return;
      const o = p(s);
      y(cj(o), (r, a) => {
        const l = p(a);
        e._checkDropTarget(hj(o), l, p(t), i) && (t = a);
      });
    }), t;
  },
  _checkDropTargetActive(i) {
    let e = !1;
    return y(this._dropTargets, (t, n) => (e = e || n === i || Xs(n, i), !e)), e;
  },
  _checkDropTarget(i, e, t, n) {
    if (e.get(0) === p(n.target).get(0))
      return !1;
    const o = pj(i, e);
    if (n.pageX < o.left || n.pageY < o.top)
      return !1;
    const r = gj(i, e);
    return n.pageX > o.left + r.width || n.pageY > o.top + r.height || t.length && t.closest(e).length || i.checkDropTarget && !i.checkDropTarget(e, n) ? !1 : e;
  },
  _end(i) {
    const e = st(i);
    this._fireEvent("dxdragend", i, {
      offset: this._calculateOffset(e)
    }), this._fireDropTargetEvent(i, H_), delete this._currentDropTarget;
  }
});
ha({
  emitter: mj,
  events: ["dxdragstart", "dxdrag", "dxdragend"]
});
const fj = (i) => {
  const t = p(i).closest('[class^="dx-swatch-"], [class*=" dx-swatch-"]'), n = Ys();
  if (!t.length)
    return n;
  const s = new RegExp("(\\s|^)(dx-swatch-.*?)(\\s|$)"), o = t[0].className.match(s)[2];
  let r = n.children("." + o);
  return r.length || (r = p("<div>").addClass(o).appendTo(n)), r;
}, XT = {
  getSwatchContainer: fj
}, _j = $t.getWindow(), ZT = {
  top: {
    my: "top center",
    at: "top center"
  },
  bottom: {
    my: "bottom center",
    at: "bottom center"
  },
  right: {
    my: "right center",
    at: "right center"
  },
  left: {
    my: "left center",
    at: "left center"
  },
  center: {
    my: "center",
    at: "center"
  },
  "right bottom": {
    my: "right bottom",
    at: "right bottom"
  },
  "right top": {
    my: "right top",
    at: "right top"
  },
  "left bottom": {
    my: "left bottom",
    at: "left bottom"
  },
  "left top": {
    my: "left top",
    at: "left top"
  }
}, Zy = {
  h: 0,
  v: 0
};
class QT {
  constructor(e) {
    let {
      position: t,
      container: n,
      visualContainer: s,
      $root: o,
      $content: r,
      $wrapper: a,
      onPositioned: l,
      onVisualPositionChanged: d,
      restorePosition: u,
      _fixWrapperPosition: c,
      _skipContentPositioning: h
    } = e;
    this._props = {
      position: t,
      container: n,
      visualContainer: s,
      restorePosition: u,
      onPositioned: l,
      onVisualPositionChanged: d,
      _fixWrapperPosition: c,
      _skipContentPositioning: h
    }, this._$root = o, this._$content = r, this._$wrapper = a, this._$markupContainer = void 0, this._$visualContainer = void 0, this._shouldRenderContentInitialPosition = !0, this._visualPosition = void 0, this._initialPosition = void 0, this._previousVisualPosition = void 0, this.updateContainer(n), this.updatePosition(t), this.updateVisualContainer(s);
  }
  get $container() {
    return this.updateContainer(), this._$markupContainer;
  }
  get $visualContainer() {
    return this._$visualContainer;
  }
  get position() {
    return this._position;
  }
  set fixWrapperPosition(e) {
    this._props._fixWrapperPosition = e, this.styleWrapperPosition();
  }
  set restorePosition(e) {
    this._props.restorePosition = e;
  }
  restorePositionOnNextRender(e) {
    this._shouldRenderContentInitialPosition = e || !this._visualPosition;
  }
  openingHandled() {
    const e = this._props.restorePosition;
    this.restorePositionOnNextRender(e);
  }
  updatePosition(e) {
    this._props.position = e, this._position = this._normalizePosition(e), this.updateVisualContainer();
  }
  updateContainer() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : this._props.container;
    this._props.container = e, this._$markupContainer = e ? p(e) : XT.getSwatchContainer(this._$root), this.updateVisualContainer(this._props.visualContainer);
  }
  updateVisualContainer() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : this._props.visualContainer;
    this._props.visualContainer = e, this._$visualContainer = this._getVisualContainer();
  }
  detectVisualPositionChange(e) {
    this._updateVisualPositionValue(), this._raisePositionedEvents(e);
  }
  positionContent() {
    this._shouldRenderContentInitialPosition ? this._renderContentInitialPosition() : (Ot(this._$content, this._visualPosition), this.detectVisualPositionChange());
  }
  positionWrapper() {
    this._$visualContainer && Un.setup(this._$wrapper, {
      my: "top left",
      at: "top left",
      of: this._$visualContainer
    });
  }
  styleWrapperPosition() {
    const t = lt(this.$visualContainer.get(0)) || this._props._fixWrapperPosition ? "fixed" : "absolute";
    this._$wrapper.css("position", t);
  }
  _updateVisualPositionValue() {
    this._previousVisualPosition = this._visualPosition, this._visualPosition = Nn(this._$content);
  }
  _renderContentInitialPosition() {
    this._renderBoundaryOffset(), id(this._$content);
    const e = this._$wrapper.css("overflow");
    if (this._$wrapper.css("overflow", "hidden"), !this._props._skipContentPositioning) {
      const t = Un.setup(this._$content, this._position);
      this._initialPosition = t;
    }
    this._$wrapper.css("overflow", e), this.detectVisualPositionChange();
  }
  _raisePositionedEvents(e) {
    const t = this._previousVisualPosition, n = this._visualPosition;
    (t?.top !== n.top || t?.left !== n.left) && this._props.onVisualPositionChanged({
      previousPosition: t,
      position: n,
      event: e
    }), this._props.onPositioned({
      position: this._initialPosition
    });
  }
  _renderBoundaryOffset() {
    const e = this._position ?? {
      boundaryOffset: Zy
    };
    this._$content.css("margin", `${e.v}px ${e.h}px`);
  }
  _getVisualContainer() {
    var e, t;
    const n = this._props.container, s = this._props.visualContainer, o = aE((e = this._props.position) === null || e === void 0 ? void 0 : e.of) ? this._props.position.of.target : (t = this._props.position) === null || t === void 0 ? void 0 : t.of;
    return p(s || n || o || _j);
  }
  _normalizePosition(e) {
    const t = {
      boundaryOffset: Zy
    };
    return f(e) ? x(!0, {}, t, this._positionToObject(e)) : t;
  }
  _positionToObject(e) {
    return te(e) ? x({}, ZT[e]) : e;
  }
}
let Au = 1500, Ws = [];
const Cj = (i) => (Au = Qe(i, Au), Au), JT = function() {
  let i = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : Au;
  const {
    length: e
  } = Ws, t = (e ? Ws[e - 1] : i) + 1;
  return Ws.push(t), t;
}, Fm = (i) => {
  const e = Ws.indexOf(i);
  e >= 0 && Ws.splice(e, 1);
}, vj = (i) => Ws.length && Ws[Ws.length - 1] === i, xj = Bi.add, _r = $t.getWindow(), Qy = eh, km = [];
xj(() => {
  _.subscribeGlobal(O.getDocument(), ye.down, (i) => {
    for (let e = km.length - 1; e >= 0; e--)
      if (!km[e]._proxiedDocumentDownHandler(i))
        return;
  });
});
class Tn extends Rt {
  _supportedKeys() {
    return I({}, super._supportedKeys(), {
      escape() {
        this.hide();
      }
    });
  }
  _getDefaultOptions() {
    return I({}, super._getDefaultOptions(), {
      activeStateEnabled: !1,
      visible: !1,
      deferRendering: !0,
      shading: !0,
      shadingColor: "",
      wrapperAttr: {},
      position: x({}, ZT.center),
      width: "80vw",
      minWidth: null,
      maxWidth: null,
      height: "80vh",
      minHeight: null,
      maxHeight: null,
      animation: {
        show: {
          type: "pop",
          duration: 300,
          from: {
            scale: 0.55
          }
        },
        hide: {
          type: "pop",
          duration: 300,
          from: {
            opacity: 1,
            scale: 1
          },
          to: {
            opacity: 0,
            scale: 0.55
          }
        }
      },
      closeOnOutsideClick: !1,
      hideOnOutsideClick: !1,
      _ignorePreventScrollEventsDeprecation: !1,
      onShowing: null,
      onShown: null,
      onHiding: null,
      onHidden: null,
      contentTemplate: "content",
      innerOverlay: !1,
      restorePosition: !0,
      hideTopOverlayHandler: () => {
        this.hide();
      },
      hideOnParentScroll: !1,
      preventScrollEvents: !0,
      onPositioned: null,
      propagateOutsideClick: !1,
      ignoreChildEvents: !0,
      _checkParentVisibility: !0,
      _fixWrapperPosition: !1,
      _loopFocus: !1
    });
  }
  _defaultOptionsRules() {
    return super._defaultOptionsRules().concat([{
      device: () => !$t.hasWindow(),
      options: {
        width: null,
        height: null,
        animation: null,
        _checkParentVisibility: !1
      }
    }]);
  }
  _setOptionsByReference() {
    super._setOptionsByReference(), x(this._optionsByReference, {
      animation: !0
    });
  }
  $wrapper() {
    return this._$wrapper;
  }
  _eventBindingTarget() {
    return this._$content;
  }
  _setDeprecatedOptions() {
    super._setDeprecatedOptions(), x(this._deprecatedOptions, {
      closeOnOutsideClick: {
        since: "22.1",
        alias: "hideOnOutsideClick"
      }
    });
  }
  ctor(e, t) {
    super.ctor(e, t), t && "preventScrollEvents" in t && !t._ignorePreventScrollEventsDeprecation && this._logDeprecatedPreventScrollEventsInfo();
  }
  _logDeprecatedPreventScrollEventsInfo() {
    this._logDeprecatedOptionWarning("preventScrollEvents", {
      since: "23.1",
      message: "If you enable this option, end-users may experience scrolling issues."
    });
  }
  _init() {
    super._init(), this._initActions(), this._initHideOnOutsideClickHandler(), this._initTabTerminatorHandler(), this._customWrapperClass = null, this._$wrapper = p("<div>").addClass("dx-overlay-wrapper"), this._$content = p("<div>").addClass("dx-overlay-content"), this._initInnerOverlayClass(), this.$element().addClass("dx-overlay"), this._$wrapper.attr("data-bind", "dxControlsDescendantBindings: true"), this._toggleViewPortSubscription(!0);
    const {
      hideTopOverlayHandler: t
    } = this.option();
    this._initHideTopOverlayHandler(t), this._parentsScrollSubscriptionInfo = {
      handler: (n) => {
        this._hideOnParentsScrollHandler(n);
      }
    }, this.warnPositionAsFunction();
  }
  warnPositionAsFunction() {
    B(this.option("position")) && Ae.log("W0018");
  }
  _initInnerOverlayClass() {
    const {
      innerOverlay: e
    } = this.option();
    this._$content.toggleClass("dx-inner-overlay", e);
  }
  _initHideTopOverlayHandler(e) {
    this._hideTopOverlayHandler = e;
  }
  _getActionsList() {
    return ["onShowing", "onShown", "onHiding", "onHidden", "onPositioned", "onVisualPositionChanged"];
  }
  _initActions() {
    this._actions = {};
    const e = this._getActionsList();
    y(e, (t, n) => {
      this._actions[n] = this._createActionByOption(n, {
        excludeValidators: ["disabled", "readOnly"]
      }) || M;
    });
  }
  _initHideOnOutsideClickHandler() {
    var e = this;
    this._proxiedDocumentDownHandler = function() {
      return e._documentDownHandler(...arguments);
    };
  }
  _initMarkup() {
    super._initMarkup(), this._renderWrapperAttributes(), this._initPositionController();
  }
  _documentDownHandler(e) {
    this._showAnimationProcessing && this._stopAnimation();
    const t = p(_r.document).is(e.target) || li.contains(_r.document, e.target), n = p(e.target).closest(".dx-inner-overlay").length;
    t && !n && !(this._$content.is(e.target) || li.contains(this._$content.get(0), e.target)) && this._shouldHideOnOutsideClick(e) && this._outsideClickHandler(e);
    const {
      propagateOutsideClick: o
    } = this.option();
    return o;
  }
  _shouldHideOnOutsideClick(e) {
    const {
      hideOnOutsideClick: t
    } = this.option();
    return B(t) ? t(e) : t;
  }
  _outsideClickHandler(e) {
    this.option("shading") && e.preventDefault(), this.hide();
  }
  _getAnonymousTemplateName() {
    return "content";
  }
  _initTemplates() {
    this._templateManager.addDefaultTemplates({
      content: new Lo()
    }), super._initTemplates();
  }
  _isTopOverlay() {
    const e = this._overlayStack();
    for (let t = e.length - 1; t >= 0; t--) {
      const n = e[t]._findTabbableBounds();
      if (n.first || n.last)
        return e[t] === this;
    }
    return !1;
  }
  _overlayStack() {
    return km;
  }
  _zIndexInitValue() {
    return Tn.baseZIndex();
  }
  _toggleViewPortSubscription(e) {
    var t = this;
    Qy.remove(this._viewPortChangeHandle), e && (this._viewPortChangeHandle = function() {
      t._viewPortChangeHandler(...arguments);
    }, Qy.add(this._viewPortChangeHandle));
  }
  _viewPortChangeHandler() {
    this._positionController.updateContainer(this.option("container")), this._refresh();
  }
  _renderWrapperAttributes() {
    const {
      wrapperAttr: e
    } = this.option(), t = x({}, e), n = t.class;
    delete t.class, this.$wrapper().attr(t).removeClass(this._customWrapperClass).addClass(n), this._customWrapperClass = n;
  }
  _renderVisibilityAnimate(e) {
    return this._stopAnimation(), e ? this._show() : this._hide();
  }
  _getAnimationConfig() {
    return this._getOptionValue("animation", this);
  }
  _toggleBodyScroll(e) {
  }
  _animateShowing() {
    var e = this;
    const t = this._getAnimationConfig() ?? {}, n = this._normalizeAnimation(t.show, "to"), s = n?.start ?? M, o = n?.complete ?? M;
    this._animate(n, function() {
      if (!e._isAnimationPaused) {
        e.option("focusStateEnabled") && _.trigger(e._focusTarget(), "focus");
        for (var r = arguments.length, a = new Array(r), l = 0; l < r; l++)
          a[l] = arguments[l];
        o.call(e, ...a), e._showAnimationProcessing = !1, e._isHidden = !1, e._actions.onShown(), e._toggleSafariScrolling(), e._showingDeferred.resolve();
      }
    }, function() {
      if (!e._isAnimationPaused) {
        for (var r = arguments.length, a = new Array(r), l = 0; l < r; l++)
          a[l] = arguments[l];
        s.call(e, ...a), e._showAnimationProcessing = !0;
      }
    });
  }
  _processShowingHidingCancel(e, t, n) {
    no(e) ? e.then((s) => {
      s ? n() : t();
    }).catch(() => t()) : e ? n() : t();
  }
  _show() {
    if (this._showingDeferred = w(), this._parentHidden = this._isParentHidden(), this._showingDeferred.done(() => {
      delete this._parentHidden;
    }), this._parentHidden)
      return this._isHidden = !0, this._showingDeferred.resolve();
    if (this._currentVisible)
      return w().resolve().promise();
    if (this._currentVisible = !0, this._isHidingActionCanceled)
      delete this._isHidingActionCanceled, this._showingDeferred.reject();
    else {
      const e = () => {
        this._stopAnimation();
        const {
          enableBodyScroll: t
        } = this.option();
        this._toggleBodyScroll(t), this._toggleVisibility(!0), this._$content.css("visibility", "hidden"), this._$content.toggleClass("dx-state-invisible", !1), this._updateZIndexStackPosition(!0), this._positionController.openingHandled(), this._renderContent();
        const n = {
          cancel: !1
        };
        this._actions.onShowing(n), this._processShowingHidingCancel(n.cancel, () => {
          this._$content.css("visibility", ""), this._renderVisibility(!0), this._animateShowing();
        }, () => {
          this._toggleVisibility(!1), this._$content.css("visibility", ""), this._$content.toggleClass("dx-state-invisible", !0), this._isShowingActionCanceled = !0, this._moveFromContainer(), this._toggleBodyScroll(!0), this.option("visible", !1), this._showingDeferred.resolve();
        });
      };
      this.option("templatesRenderAsynchronously") ? (this._stopShowTimer(), this._asyncShowTimeout = setTimeout(e)) : e();
    }
    return this._showingDeferred.promise();
  }
  _normalizeAnimation(e, t) {
    return e && (e = x({
      type: "slide",
      skipElementInitialStyles: !0
    }, e), X(e[t]) && x(e[t], {
      position: this._positionController.position
    })), e;
  }
  _animateHiding() {
    var e = this;
    const t = this._getAnimationConfig() ?? {}, n = this._normalizeAnimation(t.hide, "from"), s = n?.start ?? M, o = n?.complete ?? M;
    this._animate(n, function() {
      var r;
      e._$content.css("pointerEvents", ""), e._renderVisibility(!1);
      for (var a = arguments.length, l = new Array(a), d = 0; d < a; d++)
        l[d] = arguments[d];
      o.call(e, ...l), e._hideAnimationProcessing = !1, (r = e._actions) === null || r === void 0 || r.onHidden(), e._hidingDeferred.resolve();
    }, function() {
      e._$content.css("pointerEvents", "none");
      for (var r = arguments.length, a = new Array(r), l = 0; l < r; l++)
        a[l] = arguments[l];
      s.call(e, ...a), e._hideAnimationProcessing = !0;
    });
  }
  _hide() {
    if (!this._currentVisible)
      return w().resolve().promise();
    this._currentVisible = !1, this._hidingDeferred = w();
    const e = {
      cancel: !1
    };
    if (this._isShowingActionCanceled)
      delete this._isShowingActionCanceled, this._hidingDeferred.reject();
    else {
      this._actions.onHiding(e), this._toggleSafariScrolling(), this._toggleBodyScroll(!0);
      const t = () => {
        this._isHidingActionCanceled = !0;
        const {
          enableBodyScroll: s
        } = this.option();
        this._toggleBodyScroll(s), this.option("visible", !0), this._hidingDeferred.resolve();
      }, n = () => {
        this._forceFocusLost(), this._toggleShading(!1), this._toggleSubscriptions(!1), this._stopShowTimer(), this._animateHiding();
      };
      this._processShowingHidingCancel(e.cancel, n, t);
    }
    return this._hidingDeferred.promise();
  }
  _forceFocusLost() {
    const e = O.getActiveElement();
    !!this._$content.find(e).length && li.resetActiveElement();
  }
  _animate(e, t, n) {
    e ? (n = n || e.start || M, Le.animate(this._$content, x({}, e, {
      start: n,
      complete: t
    }))) : t();
  }
  _stopAnimation() {
    Le.stop(this._$content, !0);
  }
  _renderVisibility(e) {
    e && this._isParentHidden() || (this._currentVisible = e, this._stopAnimation(), e || z4(this._$content), e ? (this._checkContainerExists(), this._moveToContainer(), this._renderGeometry(), D_(this._$content), Ii(this._$content)) : (this._toggleVisibility(e), this._$content.toggleClass("dx-state-invisible", !e), this._updateZIndexStackPosition(e), this._moveFromContainer()), this._toggleShading(e), this._toggleSubscriptions(e));
  }
  _updateZIndexStackPosition(e) {
    const t = this._overlayStack(), n = t.indexOf(this);
    e ? (n === -1 && (this._zIndex = JT(this._zIndexInitValue()), t.push(this)), this._$wrapper.css("zIndex", this._zIndex), this._$content.css("zIndex", this._zIndex)) : n !== -1 && (t.splice(n, 1), Fm(this._zIndex));
  }
  _toggleShading(e) {
    const {
      shading: t,
      shadingColor: n
    } = this.option();
    this._$wrapper.toggleClass("dx-overlay-shader", e && t), this._$wrapper.css("backgroundColor", t ? n : ""), this._toggleTabTerminator(e && t);
  }
  _initTabTerminatorHandler() {
    var e = this;
    this._proxiedTabTerminatorHandler = function() {
      e._tabKeyHandler(...arguments);
    };
  }
  _toggleTabTerminator(e) {
    const {
      _loopFocus: t
    } = this.option(), n = R("keydown", this.NAME);
    t || e ? _.on(O.getDocument(), n, this._proxiedTabTerminatorHandler) : _.off(O.getDocument(), n, this._proxiedTabTerminatorHandler);
  }
  _findTabbableBounds() {
    const e = this._$wrapper.find("*"), t = e.length - 1;
    let n = null, s = null;
    for (let o = 0; o <= t && (!n && e.eq(o).is(tm) && (n = e.eq(o)), !s && e.eq(t - o).is(tm) && (s = e.eq(t - o)), !(n && s)); o += 1)
      ;
    return {
      first: n,
      last: s
    };
  }
  _tabKeyHandler(e) {
    if (Ye(e) !== "tab" || !this._isTopOverlay())
      return;
    const t = this._$wrapper.get(0), n = O.getActiveElement(t), {
      first: s,
      last: o
    } = this._findTabbableBounds(), r = !e.shiftKey && n === o?.get(0), a = e.shiftKey && n === s?.get(0), l = !li.contains(t, n);
    if (r || a || l) {
      e.preventDefault();
      const u = e.shiftKey ? o : s;
      _.trigger(u, "focusin"), _.trigger(u, "focus");
    }
  }
  _toggleSubscriptions(e) {
    $t.hasWindow() && (this._toggleHideTopOverlayCallback(e), this._toggleHideOnParentsScrollSubscription(e));
  }
  _toggleHideTopOverlayCallback(e) {
    this._hideTopOverlayHandler && (e ? Fx.add(this._hideTopOverlayHandler) : Fx.remove(this._hideTopOverlayHandler));
  }
  _toggleHideOnParentsScrollSubscription(e) {
    const t = R("scroll", this.NAME), {
      prevTargets: n,
      handler: s
    } = this._parentsScrollSubscriptionInfo ?? {};
    _.off(n, t, s);
    const o = this.option("hideOnParentScroll");
    if (e && o) {
      let r = this._getHideOnParentScrollTarget().parents();
      z.real().deviceType === "desktop" && (r = r.add(_r)), _.on(r, t, s), this._parentsScrollSubscriptionInfo.prevTargets = r;
    }
  }
  _hideOnParentsScrollHandler(e) {
    let t = !1;
    const n = this.option("hideOnParentScroll");
    B(n) && (t = n(e)), !t && !this._showAnimationProcessing && this.hide();
  }
  _getHideOnParentScrollTarget() {
    const {
      _hideOnParentScrollTarget: e
    } = this.option(), t = p(e);
    return t.length ? t : this._$wrapper;
  }
  _render() {
    super._render(), this._appendContentToElement(), this._renderVisibilityAnimate(this.option("visible"));
  }
  _appendContentToElement() {
    this._$content.parent().is(this.$element()) || this._$content.appendTo(this.$element());
  }
  _renderContent() {
    const e = !this._currentVisible && this.option("deferRendering");
    if (this.option("visible") && this._isParentHidden()) {
      this._isHidden = !0;
      return;
    }
    this._contentAlreadyRendered || e || (this._contentAlreadyRendered = !0, this._appendContentToElement(), super._renderContent());
  }
  _isParentHidden() {
    if (!this.option("_checkParentVisibility"))
      return !1;
    if (this._parentHidden !== void 0)
      return this._parentHidden;
    const e = this.$element().parent();
    if (e.is(":visible"))
      return !1;
    let t = !1;
    return e.add(e.parents()).each((n, s) => {
      if (p(s).css("display") === "none")
        return t = !0, !1;
    }), t || !O.getBody().contains(e.get(0));
  }
  _renderContentImpl() {
    const e = w(), t = this.option("contentTemplate"), n = this._getTemplate(t), s = this._templateManager.anonymousTemplateName === t;
    n?.render({
      container: ee(this.$content()),
      noModel: !0,
      transclude: s,
      onRendered: () => {
        e.resolve(), this.option("templatesRenderAsynchronously") && this._dimensionChanged();
      }
    });
    const {
      preventScrollEvents: o
    } = this.option();
    return this._toggleWrapperScrollEventsSubscription(o), e.done(() => {
      this.option("visible") && this._moveToContainer();
    }), e.promise();
  }
  _getPositionControllerConfig() {
    const {
      container: e,
      visualContainer: t,
      _fixWrapperPosition: n,
      restorePosition: s,
      _skipContentPositioning: o
    } = this.option();
    return {
      container: e,
      visualContainer: t,
      $root: this.$element(),
      $content: this._$content,
      $wrapper: this._$wrapper,
      onPositioned: this._actions.onPositioned,
      onVisualPositionChanged: this._actions.onVisualPositionChanged,
      restorePosition: s,
      _fixWrapperPosition: n,
      _skipContentPositioning: o
    };
  }
  _initPositionController() {
    this._positionController = new QT(this._getPositionControllerConfig());
  }
  _toggleWrapperScrollEventsSubscription(e) {
    const t = R(oa, this.NAME);
    _.off(this._$wrapper, t), e && _.on(this._$wrapper, t, {
      validate: () => !0,
      getDirection: () => "both",
      _toggleGestureCover(n) {
        n || this._toggleGestureCoverImpl(n);
      },
      _clearSelection: M,
      isNative: !0
    }, (n) => {
      const {
        originalEvent: s
      } = n.originalEvent, {
        type: o
      } = s || {}, r = o === "wheel", a = o === "mousemove", l = r && !bt(n);
      n._cancelPreventDefault = !0, s && n.cancelable !== !1 && (!a && !r || l) && n.preventDefault();
    });
  }
  _moveFromContainer() {
    this._$content.appendTo(this.$element()), this._$wrapper.detach();
  }
  _checkContainerExists() {
    const e = this._positionController.$container;
    if (e === void 0)
      return;
    e.length > 0 || _e.log("W1021", this.NAME);
  }
  _moveToContainer() {
    const e = this._positionController.$container;
    this._$wrapper.appendTo(e), this._$content.appendTo(this._$wrapper);
  }
  _renderGeometry(e) {
    const {
      visible: t
    } = this.option();
    t && $t.hasWindow() && (this._stopAnimation(), this._renderGeometryImpl());
  }
  _renderGeometryImpl() {
    this._positionController.updatePosition(this._getOptionValue("position")), this._renderWrapper(), this._renderDimensions(), this._renderPosition();
  }
  _renderPosition(e) {
    this._positionController.positionContent();
  }
  _isAllWindowCovered() {
    const {
      shading: e
    } = this.option();
    return lt(this._positionController.$visualContainer.get(0)) && e;
  }
  _toggleSafariScrolling() {
    const e = this.option("visible"), t = p(O.getBody()), n = z.real().platform === "ios" && ze.safari, s = this._isAllWindowCovered(), o = t.hasClass("dx-prevent-safari-scrolling"), r = !o && e && s, a = o && (!e || !s || this._disposed);
    n && (a ? (t.removeClass("dx-prevent-safari-scrolling"), _r.scrollTo(0, this._cachedBodyScrollTop), this._cachedBodyScrollTop = void 0) : r && (this._cachedBodyScrollTop = _r.pageYOffset, t.addClass("dx-prevent-safari-scrolling")));
  }
  _renderWrapper() {
    this._positionController.styleWrapperPosition(), this._renderWrapperDimensions(), this._positionController.positionWrapper();
  }
  _renderWrapperDimensions() {
    const {
      $visualContainer: e
    } = this._positionController, t = O.getDocumentElement(), n = lt(e.get(0)), s = n ? t.clientWidth : Ee(e), o = n ? _r.innerHeight : he(e);
    this._$wrapper.css({
      width: s,
      height: o
    });
  }
  _renderDimensions() {
    const e = this._$content.get(0);
    this._$content.css({
      minWidth: this._getOptionValue("minWidth", e),
      maxWidth: this._getOptionValue("maxWidth", e),
      minHeight: this._getOptionValue("minHeight", e),
      maxHeight: this._getOptionValue("maxHeight", e),
      width: this._getOptionValue("width", e),
      height: this._getOptionValue("height", e)
    });
  }
  _focusTarget() {
    return this._$content;
  }
  _attachKeyboardEvents() {
    this._keyboardListenerId = oi.on(this._$content, null, (e) => this._keyboardHandler(e));
  }
  _keyboardHandler(e) {
    const t = e.originalEvent;
    (p(t.target).is(this._$content) || !this.option("ignoreChildEvents")) && super._keyboardHandler(...arguments);
  }
  _isVisible() {
    const {
      visible: e
    } = this.option();
    return e;
  }
  _visibilityChanged(e) {
    e ? this.option("visible") && this._renderVisibilityAnimate(e) : this._renderVisibilityAnimate(e);
  }
  _dimensionChanged() {
    this._renderGeometry();
  }
  _clean() {
    const {
      isRenovated: e
    } = this.option();
    !this._contentAlreadyRendered && !e && this.$content().empty(), this._renderVisibility(!1), this._stopShowTimer(), this._cleanFocusState();
  }
  _stopShowTimer() {
    this._asyncShowTimeout && clearTimeout(this._asyncShowTimeout), this._asyncShowTimeout = null;
  }
  _dispose() {
    Le.stop(this._$content, !1), this._toggleViewPortSubscription(!1), this._toggleSubscriptions(!1), this._updateZIndexStackPosition(!1), this._toggleTabTerminator(!1), this._actions = null, this._parentsScrollSubscriptionInfo = null, super._dispose(), this._toggleSafariScrolling(), this.option("visible") && Fm(this._zIndex), this._$wrapper.remove(), this._$content.remove();
  }
  _toggleRTLDirection(e) {
    this._$content.toggleClass("dx-rtl", e);
  }
  _optionChanged(e) {
    const {
      value: t,
      name: n
    } = e;
    if (this._getActionsList().includes(n)) {
      this._initActions();
      return;
    }
    switch (n) {
      case "animation":
      case "closeOnOutsideClick":
      case "hideOnOutsideClick":
      case "propagateOutsideClick":
        break;
      case "_loopFocus":
      case "shading": {
        const {
          visible: s
        } = this.option();
        this._toggleShading(s), this._toggleSafariScrolling();
        break;
      }
      case "shadingColor": {
        const {
          visible: s
        } = this.option();
        this._toggleShading(s);
        break;
      }
      case "width":
      case "height":
      case "minWidth":
      case "maxWidth":
      case "minHeight":
      case "maxHeight":
        this._renderGeometry();
        break;
      case "position":
        this._positionController.updatePosition(this.option("position")), this._positionController.restorePositionOnNextRender(!0), this._renderGeometry(), this._toggleSafariScrolling();
        break;
      case "visible":
        this._renderVisibilityAnimate(t).done(() => {
          var s;
          return (s = this._animateDeferred) === null || s === void 0 ? void 0 : s.resolveWith(this);
        }).fail(() => {
          var s;
          return (s = this._animateDeferred) === null || s === void 0 ? void 0 : s.reject();
        });
        break;
      case "container":
        this._positionController.updateContainer(t), this._invalidate(), this._toggleSafariScrolling();
        break;
      case "visualContainer":
        this._positionController.updateVisualContainer(t), this._renderWrapper(), this._toggleSafariScrolling();
        break;
      case "innerOverlay":
        this._initInnerOverlayClass();
        break;
      case "deferRendering":
      case "contentTemplate":
        this._contentAlreadyRendered = !1, this._clean(), this._invalidate();
        break;
      case "hideTopOverlayHandler":
        this._toggleHideTopOverlayCallback(!1), this._initHideTopOverlayHandler(t), this._toggleHideTopOverlayCallback(this.option("visible"));
        break;
      case "hideOnParentScroll":
      case "_hideOnParentScrollTarget": {
        const {
          visible: s
        } = this.option();
        this._toggleHideOnParentsScrollSubscription(s);
        break;
      }
      case "rtlEnabled":
        this._contentAlreadyRendered = !1, super._optionChanged(e);
        break;
      case "_fixWrapperPosition":
        this._positionController.fixWrapperPosition = t;
        break;
      case "wrapperAttr":
        this._renderWrapperAttributes();
        break;
      case "restorePosition":
        this._positionController.restorePosition = t;
        break;
      case "preventScrollEvents":
        this._logDeprecatedPreventScrollEventsInfo(), this._toggleWrapperScrollEventsSubscription(t);
        break;
      default:
        super._optionChanged(e);
    }
  }
  toggle(e) {
    e = e === void 0 ? !this.option("visible") : e;
    const t = w();
    if (e === this.option("visible"))
      return t.resolveWith(this, [e]).promise();
    const n = w();
    return this._animateDeferred = n, this.option("visible", e), n.promise().done(() => {
      delete this._animateDeferred, t.resolveWith(this, [this.option("visible")]);
    }).fail(() => {
      delete this._animateDeferred, t.reject();
    }), t.promise();
  }
  $content() {
    return this._$content;
  }
  show() {
    return this.toggle(!0);
  }
  hide() {
    return this.toggle(!1);
  }
  content() {
    return ee(this._$content);
  }
  repaint() {
    this._contentAlreadyRendered ? (this._positionController.restorePositionOnNextRender(!0), this._renderGeometry({
      forceStopAnimation: !0
    }), Ii(this._$content)) : super.repaint();
  }
}
Tn.baseZIndex = (i) => Cj(i);
xe("dxOverlay", Tn);
class z_ extends Tn {
  _supportedKeys() {
    return I({}, super._supportedKeys(), {
      escape: M
    });
  }
  _getDefaultOptions() {
    return I({}, super._getDefaultOptions(), {
      message: S.format("Loading"),
      width: 222,
      height: 90,
      animation: null,
      showIndicator: !0,
      indicatorSrc: "",
      showPane: !0,
      delay: 0,
      templatesRenderAsynchronously: !1,
      hideTopOverlayHandler: null,
      focusStateEnabled: !1,
      propagateOutsideClick: !0,
      preventScrollEvents: !1
    });
  }
  _defaultOptionsRules() {
    return super._defaultOptionsRules().concat([{
      device: {
        platform: "generic"
      },
      options: {
        shadingColor: "transparent"
      }
    }, {
      device: () => Zt(),
      options: {
        message: "",
        width: 60,
        height: 60,
        maxHeight: 60,
        maxWidth: 60
      }
    }, {
      device: () => nn(),
      options: {
        width: "auto",
        height: "auto"
      }
    }]);
  }
  _init() {
    super._init.apply(this, arguments);
  }
  _render() {
    super._render(), this.$element().addClass("dx-loadpanel"), this.$wrapper().addClass("dx-loadpanel-wrapper"), this._updateWrapperAria();
  }
  _updateWrapperAria() {
    if (this.$wrapper().removeAttr("aria-label").removeAttr("role"), !this.option("showIndicator")) {
      const t = this._getAriaAttributes();
      this.$wrapper().attr(t);
    }
  }
  _getAriaAttributes() {
    const {
      message: e
    } = this.option();
    return {
      role: "alert",
      "aria-label": e || S.format("Loading")
    };
  }
  _renderContentImpl() {
    super._renderContentImpl(), this.$content().addClass("dx-loadpanel-content"), this._$loadPanelContentWrapper = p("<div>").addClass("dx-loadpanel-content-wrapper"), this._$loadPanelContentWrapper.appendTo(this.$content()), this._togglePaneVisible(), this._cleanPreviousContent(), this._renderLoadIndicator(), this._renderMessage();
  }
  _show() {
    const {
      delay: e
    } = this.option();
    if (!e)
      return super._show();
    const t = w(), n = super._show.bind(this);
    return this._clearShowTimeout(), this._showTimeout = setTimeout(() => {
      n().done(() => {
        t.resolve();
      });
    }, e), t.promise();
  }
  _hide() {
    return this._clearShowTimeout(), super._hide();
  }
  _clearShowTimeout() {
    clearTimeout(this._showTimeout);
  }
  _renderMessage() {
    if (!this._$loadPanelContentWrapper)
      return;
    const {
      message: e
    } = this.option();
    if (!e)
      return;
    const t = p("<div>").addClass("dx-loadpanel-message").text(e);
    this._$loadPanelContentWrapper.append(t);
  }
  _renderLoadIndicator() {
    !this._$loadPanelContentWrapper || !this.option("showIndicator") || (this._$indicator || (this._$indicator = p("<div>").addClass("dx-loadpanel-indicator").appendTo(this._$loadPanelContentWrapper)), this._createComponent(this._$indicator, Dn, {
      elementAttr: this._getAriaAttributes(),
      indicatorSrc: this.option("indicatorSrc")
    }));
  }
  _cleanPreviousContent() {
    this.$content().find(".dx-loadpanel-message").remove(), this.$content().find(".dx-loadpanel-indicator").remove(), delete this._$indicator;
  }
  _togglePaneVisible() {
    this.$content().toggleClass("dx-loadpanel-pane-hidden", !this.option("showPane"));
  }
  _optionChanged(e) {
    switch (e.name) {
      case "delay":
        break;
      case "message":
      case "showIndicator":
        this._cleanPreviousContent(), this._renderLoadIndicator(), this._renderMessage(), this._updateWrapperAria();
        break;
      case "showPane":
        this._togglePaneVisible();
        break;
      case "indicatorSrc":
        this._renderLoadIndicator();
        break;
      default:
        super._optionChanged(e);
    }
  }
  _dispose() {
    this._clearShowTimeout(), super._dispose();
  }
}
xe("dxLoadPanel", z_);
const yj = ["year", "month", "day"], bj = ["year", "month", "day", "hour", "minute"], Vm = function(i) {
  return i === "date" || i === "datetime";
}, xp = function(i) {
  let e, t = [];
  const n = ["year", "month", "day", "hour", "minute", "second"], s = i.headerFilter && i.headerFilter.groupInterval, o = s === "quarter" ? "month" : s;
  if (Vm(i.dataType) && s !== null)
    return t = i.dataType === "datetime" ? bj : yj, e = n.indexOf(o), e >= 0 && (t = n.slice(0, e), t.push(s)), t;
  if (f(s))
    return Array.isArray(s) ? s : [s];
}, or = function() {
  const i = function(s, o) {
    let r = s.dataField || s.selector;
    return o === "search" && (r = s.displayField || s.calculateDisplayValue || r), r;
  }, e = function(s, o) {
    const r = this;
    let a, l, d;
    const u = i(r, o);
    if (Array.isArray(s) && f(s[0]) && f(s[1]))
      return l = [u, ">=", s[0]], d = [u, "<=", s[1]], Vm(r.dataType) && (c = s[1], c.getHours() + c.getMinutes() + c.getSeconds() + c.getMilliseconds() < 1) && (a = new Date(s[1].getTime()), r.dataType === "date" && a.setDate(s[1].getDate() + 1), d = [u, "<", a]), [l, "and", d];
    var c;
  }, t = function(s, o, r) {
    const a = this;
    let l, d, u;
    const c = function(g) {
      return cn(g) ? [g.getFullYear(), g.getMonth(), g.getDate(), g.getHours(), g.getMinutes(), g.getSeconds()] : mt(("" + g).split("/"), function(m, C) {
        return C === 1 ? Number(m) - 1 : Number(m);
      });
    }(s), h = i(a, r);
    switch (r === "headerFilter" ? u = xp(a)[c.length - 1] : a.dataType === "datetime" && (u = "minute"), u) {
      case "year":
        l = new Date(c[0], 0, 1), d = new Date(c[0] + 1, 0, 1);
        break;
      case "month":
        l = new Date(c[0], c[1], 1), d = new Date(c[0], c[1] + 1, 1);
        break;
      case "quarter":
        l = new Date(c[0], 3 * c[1], 1), d = new Date(c[0], 3 * c[1] + 3, 1);
        break;
      case "hour":
        l = new Date(c[0], c[1], c[2], c[3]), d = new Date(c[0], c[1], c[2], c[3] + 1);
        break;
      case "minute":
        l = new Date(c[0], c[1], c[2], c[3], c[4]), d = new Date(c[0], c[1], c[2], c[3], c[4] + 1);
        break;
      case "second":
        l = new Date(c[0], c[1], c[2], c[3], c[4], c[5]), d = new Date(c[0], c[1], c[2], c[3], c[4], c[5] + 1);
        break;
      default:
        l = new Date(c[0], c[1], c[2]), d = new Date(c[0], c[1], c[2] + 1);
    }
    switch (o) {
      case "<":
        return [h, "<", l];
      case "<=":
        return [h, "<", d];
      case ">":
        return [h, ">=", d];
      case ">=":
        return [h, ">=", l];
      case "<>":
        return [
          [h, "<", l],
          "or",
          [h, ">=", d]
        ];
      default:
        return [
          [h, ">=", l],
          "and",
          [h, "<", d]
        ];
    }
  }, n = function(s, o, r) {
    const a = i(this, r), l = xp(this);
    if (r === "headerFilter" && l && f(s)) {
      const d = ("" + s).split("/"), u = Number(d[d.length - 1]), c = l[d.length - 1], h = [a, ">=", u], g = [a, "<", u + c];
      return [h, "and", g];
    }
    return [a, o || "=", s];
  };
  return {
    defaultCalculateFilterExpression: function(s, o, r) {
      const a = this, l = i(a, r), d = a.calculateDisplayValue && r === "search", u = d && a.lookup && a.lookup.dataType || a.dataType;
      let c = null;
      if ((r === "headerFilter" || r === "filterBuilder") && s === null)
        c = [l, o || "=", null], u === "string" && (c = [c, o === "=" ? "or" : "and", [l, o || "=", ""]]);
      else if (u === "string" && (!a.lookup || d))
        c = [l, o || "contains", s];
      else {
        if (o === "between")
          return e.apply(a, [s, r]);
        if (Vm(u) && f(s))
          return t.apply(a, arguments);
        if (u === "number")
          return n.apply(a, arguments);
        c = [l, o || "=", s];
      }
      return c;
    },
    getGroupInterval: xp
  };
}(), wj = "scrolling.legacyMode", Sj = "scrolling.rowRenderingMode", Ej = {
  year: (i) => i && i.getFullYear(),
  month: (i) => i && i.getMonth() + 1,
  day: (i) => i && i.getDate(),
  quarter: (i) => i && Math.floor(i.getMonth() / 3) + 1,
  hour: (i) => i && i.getHours(),
  minute: (i) => i && i.getMinutes(),
  second: (i) => i && i.getSeconds()
}, Ij = function() {
  const i = arguments[1], e = this.calculateCellValue(i);
  if (!f(e))
    return null;
  if (eO(this.dataType)) {
    const t = arguments[0];
    return Ej[t](e);
  }
  if (this.dataType === "number") {
    const t = arguments[0];
    return Math.floor(Number(e) / t) * t;
  }
}, Dj = function(i, e) {
  return B(i) && B(e) && i.originalCallback && e.originalCallback ? i.originalCallback === e.originalCallback && i.columnIndex === e.columnIndex : i === e;
};
function eO(i) {
  return i === "date" || i === "datetime";
}
const Jy = function(i) {
  i.get(0).textContent = " ";
}, yp = function(i) {
  i = i || [];
  const e = hs(i);
  for (let t = 0; t < i.length; t++)
    i && i[t] && i[t].isExpanded !== void 0 && (e[t].isExpanded = i[t].isExpanded), i && i[t] && i[t].groupInterval !== void 0 && (e[t].groupInterval = i[t].groupInterval);
  return e;
}, tO = function(i, e) {
  const t = qT.format(i, e.format) || i && i.toString() || "", n = {
    value: i,
    valueText: e.getDisplayFormat ? e.getDisplayFormat(t) : t,
    target: e.target || "row",
    groupInterval: e.groupInterval
  };
  return e.customizeText ? e.customizeText.call(e, n) : n.valueText;
}, eb = function(i, e) {
  const t = i.displayFormat || i.columnCaption && e[`${i.summaryType}OtherColumn`] || e[i.summaryType];
  return tO(i.value, {
    format: i.valueFormat,
    getDisplayFormat: (n) => t ? Fi(t, n, i.columnCaption) : n,
    customizeText: i.customizeText
  });
}, tb = function(i) {
  const e = i.data && i.data(), t = e && e.dxComponents, n = t && t[0];
  return n && e[n];
}, nO = function(i, e, t) {
  if (Array.isArray(i) && Array.isArray(e)) {
    if (i.length !== e.length)
      return !1;
    for (let n = 0; n < i.length; n++)
      if (!nO(i[n], e[n], t))
        return !1;
    return !0;
  }
  return B(i) && i.columnIndex >= 0 && B(e) && e.columnIndex >= 0 ? i.columnIndex === e.columnIndex && Mt(i.filterValue, void 0, t) === Mt(e.filterValue, void 0, t) && Mt(i.selectedFilterOperation, void 0, t) === Mt(e.selectedFilterOperation, void 0, t) : Mt(i, void 0, t) == Mt(e, void 0, t);
}, Tj = (i) => ({
  index: i.index,
  columnIndex: i.columnIndex,
  x: i.x,
  y: i.y
}), nb = (i, e, t) => {
  let n = !1;
  if (t && (n = t(e)), !n) {
    const s = Tj(e);
    i.push(s);
  }
};
function Oj(i) {
  return Array.isArray(i) || (i = [i]), i.map((e, t) => te(e) ? {
    selector: e,
    isExpanded: t < i.length - 1
  } : e);
}
const F = {
  renderNoDataText(i) {
    const e = this;
    if (i = i || this.element(), !i)
      return;
    const t = e.addWidgetPrefix("nodata");
    let n = i.find(`.${t}`).last();
    const s = this._dataController.isEmpty(), o = this._dataController.isLoading();
    n.length || (n = p("<span>").addClass(t)), n.parent().is(i) || n.appendTo(i), s && !o ? n.removeClass("dx-hidden").text(e._getNoDataText()) : n.addClass("dx-hidden");
  },
  renderLoadPanel(i, e, t) {
    const n = this;
    let s;
    n._loadPanel && n._loadPanel.$element().remove(), s = n.option("loadPanel"), s && (s.enabled === "auto" ? !t : s.enabled) ? (s = x({
      shading: !1,
      message: s.text,
      container: e
    }, s), n._loadPanel = n._createComponent(p("<div>").appendTo(e), z_, s)) : n._loadPanel = null;
  },
  calculateLoadPanelPosition(i) {
    const e = p(fe());
    return le(i) > le(e) ? {
      of: e,
      boundary: i,
      collision: "fit"
    } : {
      of: i
    };
  },
  getIndexByKey(i, e, t) {
    let n = -1;
    if (i !== void 0 && Array.isArray(e)) {
      t = arguments.length <= 2 ? "key" : t;
      for (let s = 0; s < e.length; s++) {
        const o = f(t) ? e[s][t] : e[s];
        if (He(i, o)) {
          n = s;
          break;
        }
      }
    }
    return n;
  },
  combineFilters(i, e) {
    let t = [];
    e = e || "and";
    for (let s = 0; s < i.length; s++) {
      var n;
      if (i[s]) {
        if (((n = i[s]) === null || n === void 0 ? void 0 : n.length) === 1 && i[s][0] === "!") {
          if (e === "and")
            return ["!"];
          if (e === "or")
            continue;
        }
        t.length && t.push(e), t.push(i[s]);
      }
    }
    if (t.length === 1 && (t = t[0]), t.length)
      return t;
  },
  checkChanges(i, e) {
    let t = 0;
    for (let n = 0; n < e.length; n++)
      i[e[n]] && t++;
    return i.length && i.length === t;
  },
  equalFilterParameters: nO,
  proxyMethod(i, e, t) {
    i[e] || (i[e] = function() {
      const n = this._dataSource;
      return n ? n[e].apply(n, arguments) : t;
    });
  },
  formatValue: tO,
  getFormatOptionsByColumn: (i, e) => ({
    format: i.format,
    getDisplayFormat: i.getDisplayFormat,
    customizeText: i.customizeText,
    target: e,
    trueText: i.trueText,
    falseText: i.falseText
  }),
  getDisplayValue(i, e, t, n) {
    return i.displayValueMap && i.displayValueMap[e] !== void 0 ? i.displayValueMap[e] : i.calculateDisplayValue && t && n !== "group" ? i.calculateDisplayValue(t) : i.lookup && !(n === "group" && (i.calculateGroupValue || i.calculateDisplayValue)) ? i.lookup.calculateCellValue(e) : e;
  },
  getGroupRowSummaryText(i, e) {
    let t = "(";
    for (let n = 0; n < i.length; n++) {
      const s = i[n];
      t += (n > 0 ? ", " : "") + eb(s, e);
    }
    return t + ")";
  },
  getSummaryText: eb,
  normalizeSortingInfo: yp,
  getFormatByDataType(i) {
    switch (i) {
      case "date":
        return "shortDate";
      case "datetime":
        return "shortDateShortTime";
      default:
        return;
    }
  },
  getHeaderFilterGroupParameters(i, e) {
    let t = [];
    const n = i.dataField || i.name, s = or.getGroupInterval(i);
    return s ? (y(s, (o, r) => {
      t.push(e ? {
        selector: n,
        groupInterval: r,
        isExpanded: o < s.length - 1
      } : Ij.bind(i, r));
    }), t) : (e ? t = [{
      selector: n,
      isExpanded: !1
    }] : (t = function(o) {
      let r = i.calculateCellValue(o);
      return (r === void 0 || r === "") && (r = null), r;
    }, i.sortingMethod && (t = [{
      selector: t,
      compare: i.sortingMethod.bind(i)
    }])), t);
  },
  equalSortParameters(i, e, t) {
    if (i = yp(i), e = yp(e), Array.isArray(i) && Array.isArray(e)) {
      if (i.length !== e.length)
        return !1;
      for (let n = 0; n < i.length; n++)
        if (!Dj(i[n].selector, e[n].selector) || i[n].desc !== e[n].desc || i[n].groupInterval !== e[n].groupInterval || !t && !!i[n].isExpanded != !!e[n].isExpanded)
          return !1;
      return !0;
    }
    return (!i || !i.length) == (!e || !e.length);
  },
  getPointsByColumns(i, e) {
    let t = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : !1, n = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : 0, s = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : !1;
    const o = [], r = i.length;
    let a, l = {
      left: 0,
      top: 0
    }, d = {
      width: 0,
      height: 0
    }, u = n, c;
    for (let g = 0; g <= r; g++) {
      var h;
      g < r && (a = i.eq(g), l = a.offset(), d = Ge(a.get(0)), c = a.css("direction") === "rtl");
      const m = l.left + d.width, C = l.top + d.height, v = {
        index: u,
        columnIndex: u,
        item: (h = a) === null || h === void 0 ? void 0 : h.get(0),
        x: !t && c !== (g === r) ? m : l.left,
        y: t && g === r ? C : l.top
      };
      if (!t && g > 0) {
        const E = i.eq(g - 1).offset(), {
          width: T
        } = Ge(i[g - 1]), V = c ? E.left : E.left + T;
        if (E.top < v.y && (v.y = E.top), s && Math.round(V) !== Math.round(v.x)) {
          const $ = I({}, v, {
            item: i[g - 1],
            x: V
          });
          c ? (v.isRightBoundary = !0, $.isLeftBoundary = !0) : (v.isLeftBoundary = !0, $.isRightBoundary = !0), nb(o, $, e);
        }
      }
      nb(o, v, e), u++;
    }
    return o;
  },
  getExpandCellTemplate: () => ({
    allowRenderToDetachedContainer: !0,
    render(i, e) {
      const t = p(i);
      if (f(e.value) && !(e.data && e.data.isContinuation) && !e.row.isNewRow) {
        const n = e.component.getView("rowsView");
        t.addClass("dx-datagrid-expand").addClass("dx-selection-disabled"), p("<div>").addClass(e.value ? "dx-datagrid-group-opened" : "dx-datagrid-group-closed").appendTo(t), n.setAria("label", e.value ? n.localize("dxDataGrid-ariaCollapse") : n.localize("dxDataGrid-ariaExpand"), t);
      } else
        Jy(t);
    }
  }),
  setEmptyText: Jy,
  isDateType: eO,
  getSelectionRange(i) {
    try {
      if (i)
        return {
          selectionStart: i.selectionStart,
          selectionEnd: i.selectionEnd
        };
    } catch {
    }
    return {};
  },
  setSelectionRange(i, e) {
    try {
      i && i.setSelectionRange && i.setSelectionRange(e.selectionStart, e.selectionEnd);
    } catch {
    }
  },
  focusAndSelectElement(i, e) {
    const t = e.is(":focus");
    _.trigger(e, "focus");
    const n = i.option("editing.selectTextOnEditStart"), s = e.get(0);
    if (!t && n && e.is(".dx-texteditor-input") && !e.is("[readonly]")) {
      const o = tb(e.closest(".dx-texteditor"));
      W(o && o._loadItemDeferred).done(() => {
        s.select();
      });
    }
  },
  getWidgetInstance: tb,
  getLastResizableColumnIndex(i, e) {
    const t = i.some((s) => s && !s.command && !s.fixed && s.allowResizing !== !1);
    let n;
    for (n = i.length - 1; i[n]; n--) {
      const s = i[n], o = e && e[n], r = !t || s.allowResizing !== !1;
      if (!s.command && !s.fixed && o !== "adaptiveHidden" && r)
        break;
    }
    return n;
  },
  isElementInCurrentGrid(i, e) {
    return e && e.length ? e.closest(`.${i.getWidgetContainerClass()}`).parent().is(i.component.$element()) : !1;
  },
  isVirtualRowRendering(i) {
    const e = i.option(Sj), t = i.option("scrolling.mode") === "virtual", n = i.option("scrolling.mode") === "infinite";
    return i.option(wj) === !1 && (t || n) ? !0 : e === "virtual";
  },
  getPixelRatio: (i) => i.devicePixelRatio || 1,
  getContentHeightLimit(i) {
    return i.mozilla ? 8e6 : 15e6 / this.getPixelRatio(fe());
  },
  normalizeLookupDataSource(i) {
    let e;
    return i.items ? e = i.items : (e = i.dataSource, B(e) && !Bt.isWrapped(e) && (e = e({}))), lo(e);
  },
  getWrappedLookupDataSource(i, e, t) {
    if (!e)
      return [];
    const n = this.normalizeLookupDataSource(i.lookup);
    if (i.calculateCellValue !== i.defaultCalculateCellValue)
      return n;
    const s = e.remoteOperations().groupPaging, o = i.displayField && te(i.displayField);
    let r, a, l;
    const d = (c, h) => {
      const g = h.skip ?? 0, m = h.take ? g + h.take : c.length;
      return c.slice(g, m);
    };
    return I({}, n, {
      __dataGridSourceFilter: t,
      load: (c) => {
        const h = new w();
        return ((g) => {
          const m = Oj(o ? [i.dataField, i.displayField] : i.dataField), C = new w();
          return r && (!s || g.skip === l && g.take === a) ? C.resolve(d(r, g)) : (l = g.skip, a = g.take, e.load({
            filter: t,
            group: m,
            take: s ? g.take : void 0,
            skip: s ? g.skip : void 0
          }).done((E) => {
            r = E, C.resolve(s ? E : d(E, g));
          }).fail(C.fail)), C;
        })(c).done((g) => {
          if (g.length === 0) {
            h.resolve([]);
            return;
          }
          const m = this.combineFilters(g.flatMap((v) => v.key).map((v) => [i.lookup.valueExpr, v]), "or");
          new In(I({}, n, c, {
            filter: this.combineFilters([m, c.filter], "and"),
            paginate: !1
          })).load().done(h.resolve).fail(h.fail);
        }).fail(h.fail), h;
      },
      key: i.lookup.valueExpr,
      byKey(c) {
        const h = w();
        return this.load({
          filter: [i.lookup.valueExpr, "=", c]
        }).done((g) => {
          h.resolve(g[0]);
        }), h.promise();
      }
    });
  },
  logHeaderFilterDeprecatedWarningIfNeed(i) {
    const e = i._logDeprecatedOptionWarning.bind(i);
    f(i.option("headerFilter.allowSearch")) && e("headerFilter.allowSearch", {
      since: "23.1",
      alias: "headerFilter.search.enabled"
    }), f(i.option("headerFilter.searchTimeout")) && e("headerFilter.searchTimeout", {
      since: "23.1",
      alias: "headerFilter.search.timeout"
    });
    const t = i.NAME === "dxPivotGrid" ? "dataSource.fields" : "columns", n = i.option(t);
    if (!Array.isArray(n))
      return;
    const s = (o) => {
      o.forEach((r) => {
        var a;
        const l = r.headerFilter || {};
        f(l.allowSearch) && e(`${t}[].headerFilter.allowSearch`, {
          since: "23.1",
          alias: `${t}[].headerFilter.search.enabled`
        }), f(l.searchMode) && e(`${t}[].headerFilter.searchMode`, {
          since: "23.1",
          alias: `${t}[].headerFilter.search.mode`
        }), (a = r.columns) !== null && a !== void 0 && a.length && s(r.columns);
      });
    };
    s(n);
  },
  getComponentBorderWidth(i, e) {
    return i.option("showBorders") ? Math.ceil(Ee(e) - Kg(e)) : 0;
  },
  isCustomCommandColumn(i, e) {
    return !!i.filter((n) => n.type === e.type).length;
  }
}, bp = "dx-master-detail-row", wp = "dxCellHintVisible", Aj = {
  render(i) {
    i.container.append(i.content);
  }
}, Rj = function(i, e) {
  let t, n, s;
  function o(r) {
    return setTimeout(() => {
      t = n = null;
    }, r);
  }
  _.on(e, "touchstart touchend", ".dx-row", (r) => {
    clearTimeout(s), r.type === "touchstart" ? (t = r.target, n = r.currentTarget, s = o(1e3)) : s = o();
  }), _.on(e, [Te, pd, ye.down].join(" "), ".dx-row", i.createAction((r) => {
    const {
      event: a
    } = r;
    t && (a.target = t, a.currentTarget = n), p(a.target).closest("a").length || (r.rowIndex = i.getRowIndex(a.currentTarget), r.rowIndex >= 0 && (r.rowElement = ee(p(a.currentTarget)), r.columns = i.getColumns(), a.type === ye.down ? i._rowPointerDown(r) : a.type === Te ? i._rowClick(r) : i._rowDblClick(r)));
  }));
}, Wd = function(i) {
  return i === "auto" ? "" : $e(i) ? `${i}px` : i;
}, Fj = function(i, e, t) {
  i.style.width = i.style.maxWidth = e.width === "auto" ? "" : t;
}, kj = function(i, e) {
  if (!i || !e)
    return;
  const t = i.attributes, n = e.attributes;
  let s;
  for (s = 0; s < t.length; s++) {
    const o = t[s].nodeName;
    e.hasAttribute(o) || i.removeAttribute(o);
  }
  for (s = 0; s < n.length; s++)
    i.setAttribute(n[s].nodeName, n[s].nodeValue);
}, Vj = function(i) {
  i.resolve();
}, iO = (i) => typeof i == "number" ? `${i.toFixed(3)}px` : i === "adaptiveHidden" ? "0.0001px" : i;
class Cd extends vU(Ue.View) {
  init() {
    this._scrollLeft = -1, this._columnsController = this.getController("columns"), this._dataController = this.getController("data"), this._adaptiveColumnsController = this.getController("adaptiveColumns"), this._columnChooserController = this.getController("columnChooser"), this._editorFactoryController = this.getController("editorFactory"), this._selectionController = this.getController("selection"), this._columnChooserView = this.getView("columnChooserView"), this._delayedTemplates = [], this._templateDeferreds = /* @__PURE__ */ new Set(), this._templatesCache = {}, this._templateTimeouts = /* @__PURE__ */ new Set(), this.createAction("onCellClick"), this.createAction("onRowClick"), this.createAction("onCellDblClick"), this.createAction("onRowDblClick"), this.createAction("onCellHoverChanged", {
      excludeValidators: ["disabled", "readOnly"]
    }), this.createAction("onCellPrepared", {
      excludeValidators: ["disabled", "readOnly"],
      category: "rendering"
    }), this.createAction("onRowPrepared", {
      excludeValidators: ["disabled", "readOnly"],
      category: "rendering",
      afterExecute: (e) => {
        this._afterRowPrepared(e);
      }
    }), this._columnsController.columnsChanged.add(this._columnOptionChanged.bind(this)), this._dataController && this._dataController.changed.add(this._handleDataChanged.bind(this));
  }
  dispose() {
    if (ae()) {
      var e, t;
      const n = fe();
      (e = this._templateTimeouts) === null || e === void 0 || e.forEach((s) => n.clearTimeout(s)), (t = this._templateTimeouts) === null || t === void 0 || t.clear();
    }
  }
  optionChanged(e) {
    switch (super.optionChanged(e), e.name) {
      case "cellHintEnabled":
      case "onCellPrepared":
      case "onRowPrepared":
      case "onCellHoverChanged":
        this._invalidate(!0, !0), e.handled = !0;
        break;
      case "keyboardNavigation":
        e.fullName === "keyboardNavigation.enabled" && this._invalidate(!0, !0), e.handled = !0;
    }
  }
  _createScrollableOptions() {
    const e = this.option("scrolling");
    let t = this.option("scrolling.useNative");
    const n = x({}, e, {
      direction: "both",
      bounceEnabled: !1,
      useKeyboard: !1
    });
    return t === void 0 && (t = !0), t === "auto" ? (delete n.useNative, delete n.useSimulatedScrollbar) : (n.useNative = !!t, n.useSimulatedScrollbar = !t), n;
  }
  _updateCell(e, t) {
    t.rowType && this._cellPrepared(e, t);
  }
  _needToSetCellWidths() {
    return this.option("columnAutoWidth");
  }
  _createCell(e) {
    const {
      column: t
    } = e, n = t.alignment || ro(this.option("rtlEnabled")), s = this._needToSetCellWidths(), o = O.createElement("td");
    o.style.textAlign = n;
    const r = p(o);
    return e.rowType === "data" && t.headerId && !t.type && this.component.option("showColumnHeaders") && this.setAria("describedby", t.headerId, r), t.cssClass && r.addClass(t.cssClass), Array.isArray(t.elementAttr) && t.elementAttr.forEach((a) => {
      let {
        name: l,
        value: d
      } = a;
      r.attr(l, d);
    }), t.command === "expand" && (r.addClass(t.cssClass), r.addClass(this.addWidgetPrefix("group-space"))), t.colspan > 1 ? r.attr("colSpan", t.colspan) : !t.isBand && t.visibleWidth !== "auto" && s && ((t.width || t.minWidth) && (o.style.minWidth = Wd(t.minWidth || t.width)), t.width && Fj(o, t, Wd(t.width))), r;
  }
  _createRow(e, t) {
    t = t || "tr";
    const n = p(`<${t}>`).addClass("dx-row");
    return t === "tr" && this.setAria("role", "row", n), n;
  }
  _isAltRow(e) {
    return e && e.dataIndex % 2 === 1;
  }
  _createTable(e, t) {
    const n = p("<table>").addClass(this.addWidgetPrefix("table")).addClass(this.addWidgetPrefix("table-fixed"));
    if (e && !t ? (n.attr("id", `dx-${new Xe()}`).append(this._createColGroup(e)), ze.safari && n.append(p("<thead>").append("<tr>")), this.setAria("role", "presentation", n)) : this.setAria("hidden", !0, n), this.setAria("role", "presentation", p("<tbody>").appendTo(n)), t)
      return n;
    ze.mozilla && _.on(n, "mousedown", "td", (o) => {
      o.ctrlKey && o.preventDefault();
    }), this.option("cellHintEnabled") && _.on(n, "mousemove", ".dx-row > td", this.createAction((o) => {
      const r = o.event, a = p(r.target), l = p(r.currentTarget), d = l.parent(), u = this._columnsController.getVisibleColumns(), c = d.data("options"), h = l.index(), g = c && c.cells && c.cells[h], m = g ? g.column : u[h], C = d.hasClass("dx-header-row"), v = d.hasClass("dx-data-row"), E = d.hasClass(bp), T = d.hasClass("dx-group-row"), V = d.hasClass(this.addWidgetPrefix("filter-row")), $ = v && (!m || m.cellTemplate), G = v && g && (c.isEditing || g.isEditing || m?.showEditorAlways), H = C && (!m || m.headerCellTemplate), ce = T && (!m || m.groupIndex && m.groupCellTemplate);
      !E && !V && !G && !$ && !H && !ce && (a.data(wp) && (a.removeAttr("title"), a.data(wp, !1)), a[0].scrollWidth - a[0].clientWidth > 0 && !f(a.attr("title")) && (a.attr("title", a.text()), a.data(wp, !0)));
    }));
    const s = (o) => {
      const r = p(o.currentTarget), a = p(o.target).closest(".dx-field-item-content"), l = r.parent(), d = l.data("options"), u = d && d.cells && d.cells[r.index()];
      if (!r.closest("table").is(o.delegateTarget))
        return;
      const c = x({}, u, {
        cellElement: ee(r),
        event: o,
        eventType: o.type
      });
      if (c.rowIndex = this.getRowIndex(l), a.length) {
        const h = a.data("dx-form-item");
        h.column && (c.column = h.column, c.columnIndex = this._columnsController.getVisibleIndex(c.column.index));
      }
      return c;
    };
    return _.on(n, "mouseover", ".dx-row > td", (o) => {
      const r = s(o);
      r && this.executeAction("onCellHoverChanged", r);
    }), _.on(n, "mouseout", ".dx-row > td", (o) => {
      const r = s(o);
      r && this.executeAction("onCellHoverChanged", r);
    }), _.on(n, Te, ".dx-row > td", (o) => {
      const r = s(o);
      r && this.executeAction("onCellClick", r);
    }), _.on(n, pd, ".dx-row > td", (o) => {
      const r = s(o);
      r && this.executeAction("onCellDblClick", r);
    }), Rj(this, n), n;
  }
  _rowPointerDown(e) {
  }
  _rowClick() {
  }
  _rowDblClick() {
  }
  _createColGroup(e) {
    const t = p("<colgroup>");
    for (let n = 0; n < e.length; n++) {
      const s = e[n].colspan || 1;
      for (let o = 0; o < s; o++)
        t.append(this._createCol(e[n]));
    }
    return t;
  }
  _createCol(e) {
    let t = e.visibleWidth || e.width;
    t === "adaptiveHidden" && (t = "0.0001px");
    const n = p("<col>");
    return qg(n, t), n;
  }
  renderDelayedTemplates(e) {
    const t = this._delayedTemplates, n = t.filter((o) => !o.async), s = t.filter((o) => o.async);
    this._delayedTemplates = [], this._renderDelayedTemplatesCore(n, !1, e), this._renderDelayedTemplatesCoreAsync(s);
  }
  _renderDelayedTemplatesCoreAsync(e) {
    if (e.length) {
      const t = fe().setTimeout(() => {
        this._templateTimeouts.delete(t), this._renderDelayedTemplatesCore(e, !0);
      });
      this._templateTimeouts.add(t);
    }
  }
  _renderDelayedTemplatesCore(e, t, n) {
    const s = /* @__PURE__ */ new Date();
    for (; e.length; ) {
      const o = e.shift(), {
        options: r
      } = o, a = O.getRootNode(p(r.container).get(0)), l = this.needWaitAsyncTemplates();
      if ((!t || p(r.container).closest(a).length || l) && (n && (r.change = n), o.template.render(r)), t && /* @__PURE__ */ new Date() - s > 30) {
        this._renderDelayedTemplatesCoreAsync(e);
        break;
      }
    }
    !e.length && this._delayedTemplates.length && this.renderDelayedTemplates();
  }
  _processTemplate(e, t) {
    const n = this;
    let s;
    if (e && e.render && !zn(e))
      s = {
        allowRenderToDetachedContainer: e.allowRenderToDetachedContainer,
        render(o) {
          e.render(o.container, o.model, o.change), o.deferred && o.deferred.resolve();
        }
      };
    else if (B(e))
      s = {
        render(o) {
          const r = e(ee(o.container), o.model, o.change);
          r && (r.nodeType || zn(r)) && o.container.append(r), o.deferred && o.deferred.resolve();
        }
      };
    else {
      const o = te(e) ? e : p(e).attr("id");
      o ? (n._templatesCache[o] || (n._templatesCache[o] = n.getTemplate(e)), s = n._templatesCache[o]) : s = n.getTemplate(e);
    }
    return s;
  }
  renderTemplate(e, t, n, s, o) {
    const r = this._processTemplate(t, n), {
      column: a
    } = n, l = n.rowType === "data", d = new w(), u = {
      container: e,
      model: n,
      deferred: d,
      onRendered: () => {
        this.isDisposed() ? d.reject() : d.resolve();
      }
    };
    if (r) {
      n.component = this.component;
      const c = a && (a.renderAsync && l || this.option("renderAsync") && (a.renderAsync !== !1 && (a.command || a.showEditorAlways) && l || n.rowType === "filter")), h = n.renderAsync ?? c;
      (r.allowRenderToDetachedContainer || s) && !h ? r.render(u) : this._delayedTemplates.push({
        template: r,
        options: u,
        async: h
      }), this._templateDeferreds.add(d), _.on(e, On, Vj.bind(null, d));
    } else
      d.reject();
    return d.promise().always(() => {
      this._templateDeferreds.delete(d);
    });
  }
  _getBodies(e) {
    return p(e).children("tbody").not(".dx-header").not(".dx-footer");
  }
  _needWrapRow(e) {
    var t;
    return !!this.option().rowTemplate && !!((t = this._getBodies(e)) !== null && t !== void 0 && t.filter(".dx-row").length);
  }
  _wrapRowIfNeed(e, t, n) {
    const s = n ? e || this._tableElement : this._tableElement || e;
    if (this._needWrapRow(s)) {
      const r = p("<tbody>").addClass(t.attr("class"));
      return this.setAria("role", "presentation", r), r.append(t);
    }
    return t;
  }
  _appendRow(e, t, n) {
    n = n || Aj, n.render({
      content: t,
      container: e
    });
  }
  _resizeCore() {
    const e = this._scrollLeft;
    e >= 0 && (this._scrollLeft = 0, this.scrollTo({
      left: e
    }));
  }
  _renderCore(e) {
    const t = this.element().parent();
    return (!t || t.parent().length) && this.renderDelayedTemplates(e), new w().resolve();
  }
  _renderTable(e) {
    e = e || {}, e.columns = this._columnsController.getVisibleColumns();
    const t = e.change && e.change.changeType, n = this._createTable(e.columns, t === "append" || t === "prepend" || t === "update");
    return this._renderRows(n, e), n;
  }
  _renderRows(e, t) {
    const n = this, s = n._getRows(t.change), o = t.change && t.change.columnIndices || [], r = t.change && t.change.changeTypes || [];
    for (let a = 0; a < s.length; a++)
      n._renderRow(e, x({
        row: s[a],
        columnIndices: o[a],
        changeType: r[a]
      }, t));
  }
  _renderRow(e, t) {
    t.columnIndices || (t.row.cells = []);
    const n = this._createRow(t.row), s = this._wrapRowIfNeed(e, n);
    t.changeType !== "remove" && this._renderCells(n, t), this._appendRow(e, s);
    const o = x({
      columns: t.columns
    }, t.row);
    this._addWatchMethod(o, t.row), this._rowPrepared(s, o, t.row);
  }
  _needRenderCell(e, t) {
    return !t || t.indexOf(e) >= 0;
  }
  _renderCells(e, t) {
    const n = this;
    let s = 0;
    const {
      row: o
    } = t, {
      columns: r
    } = t;
    for (let a = 0; a < r.length; a++)
      this._needRenderCell(a, t.columnIndices) && n._renderCell(e, x({
        column: r[a],
        columnIndex: s,
        value: o.values && o.values[s],
        oldValue: o.oldValues && o.oldValues[s]
      }, t)), r[a].colspan > 1 ? s += r[a].colspan : s++;
  }
  _updateCells(e, t, n, s) {
    var o;
    const r = this, a = e.children(), l = t.children(), d = this.option("highlightChanges"), u = this.addWidgetPrefix("cell-updated-animation");
    s != null && (o = s.node) !== null && o !== void 0 && o.hasChildren && a.each(function() {
      r.setAria("expanded", s.isExpanded, p(this));
    }), n.forEach((c, h) => {
      const g = a.eq(c), m = l.eq(h);
      g.replaceWith(m), d && !m.hasClass("dx-command-expand") && m.addClass(u);
    }), kj(e.get(0), t.get(0));
  }
  _setCellAriaAttributes(e, t, n) {
    var s;
    const {
      row: o
    } = n, r = t.rowType === "freeSpace", a = t.rowType === "group", l = o == null || (s = o.node) === null || s === void 0 ? void 0 : s.hasChildren;
    if (r)
      return;
    this.setAria("role", "gridcell", e), l && this.setAria("expanded", o.isExpanded, e);
    const d = this._columnsController.getColumnIndexOffset(), u = a ? t.columnIndex + 1 : t.columnIndex + d + 1;
    this.setAria("colindex", u, e);
  }
  _renderCell(e, t) {
    const n = this._getCellOptions(t);
    if (t.columnIndices) {
      if (t.row.cells) {
        const o = t.row.cells.findIndex((r) => r.columnIndex === n.columnIndex);
        t.row.cells[o] = n;
      }
    } else
      t.row.cells.push(n);
    const s = this._createCell(n);
    return this._setCellAriaAttributes(s, n, t), this._renderCellContent(s, n, t), e.get(0).appendChild(s.get(0)), s;
  }
  _renderCellContent(e, t, n) {
    const s = this._getCellTemplate(t);
    W(!s || this.renderTemplate(e, s, t, void 0, n.change)).done(() => {
      this._updateCell(e, t);
    });
  }
  _getCellTemplate(e) {
  }
  _getRows(e) {
    return [];
  }
  _getCellOptions(e) {
    const t = {
      column: e.column,
      columnIndex: e.columnIndex,
      rowType: e.row.rowType,
      rowIndex: e.row.rowIndex,
      isAltRow: this._isAltRow(e.row)
    };
    return this._addWatchMethod(t), t;
  }
  _addWatchMethod(e, t) {
    if (!this.option("repaintChangesOnly"))
      return;
    const n = [];
    return t = t || e, t.watch = t.watch || function(s, o, r) {
      let a = s(t.data);
      const l = function(d) {
        d && r && r(d);
        const u = s(t.data);
        JSON.stringify(a) !== JSON.stringify(u) && (d && o(u), a = u);
      };
      return n.push(l), function() {
        const d = n.indexOf(l);
        d >= 0 && n.splice(d, 1);
      };
    }, t.update = t.update || function(s, o) {
      s && (this.data = e.data = s.data, this.rowIndex = e.rowIndex = s.rowIndex, this.dataIndex = e.dataIndex = s.dataIndex, this.isExpanded = e.isExpanded = s.isExpanded, e.row && !o && (e.row = s)), n.forEach((r) => {
        r(s);
      });
    }, t !== e && (e.watch = t.watch.bind(t)), e;
  }
  _cellPrepared(e, t) {
    t.cellElement = ee(p(e)), this.executeAction("onCellPrepared", t);
  }
  _rowPrepared(e, t, n) {
    tt(e.get(0), "options", t), t.rowElement = ee(e), this.executeAction("onRowPrepared", t);
  }
  _columnOptionChanged(e) {
    const {
      optionNames: t
    } = e;
    if (F.checkChanges(t, ["width", "visibleWidth"])) {
      const s = this._columnsController.getVisibleColumns().map((o) => o.visibleWidth || o.width);
      this.setColumnWidths({
        widths: s,
        optionNames: t
      });
      return;
    }
    this._requireReady || this.render();
  }
  getCellIndex(e, t) {
    return e.length ? e[0].cellIndex : -1;
  }
  getTableElements() {
    return this._tableElement || p();
  }
  getTableElement(e) {
    return this._tableElement;
  }
  setTableElement(e, t) {
    this._tableElement = e;
  }
  _afterRowPrepared(e) {
  }
  _handleDataChanged(e) {
  }
  callbackNames() {
    return ["scrollChanged"];
  }
  _updateScrollLeftPosition() {
    const e = this._scrollLeft;
    e >= 0 && (this._scrollLeft = 0, this.scrollTo({
      left: e
    }));
  }
  scrollTo(e) {
    const t = this.element(), n = t && t.children(`.${this.addWidgetPrefix("scroll-container")}`).not(`.${this.addWidgetPrefix("content-fixed")}`);
    f(e) && f(e.left) && this._scrollLeft !== e.left && (this._scrollLeft = e.left, n && n.scrollLeft(e.left));
  }
  getContent(e) {
    var t;
    return (t = this._tableElement) === null || t === void 0 ? void 0 : t.parent();
  }
  _removeContent(e) {
    const t = this.getContent(e);
    t != null && t.length && t.remove();
  }
  _wrapTableInScrollContainer(e, t) {
    const n = p("<div>"), s = this.option("scrolling.useNative");
    return (s === !1 || s === "auto" && !tn.nativeScrolling) && n.addClass(this.addWidgetPrefix("scrollable-simulated")), _.on(n, "scroll", () => {
      const o = n.scrollLeft();
      o !== this._scrollLeft && this.scrollChanged.fire({
        left: o
      }, this.name);
    }), n.addClass(this.addWidgetPrefix("content")).addClass(this.addWidgetPrefix("scroll-container")).append(e).appendTo(this.element()), this.setAria("role", "presentation", n), n;
  }
  needWaitAsyncTemplates() {
    return this.option("templatesRenderAsynchronously") && this.option("renderAsync") === !1;
  }
  waitAsyncTemplates() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : !1;
    const t = new w();
    if (!(e || this.needWaitAsyncTemplates()) || !f(this._templateDeferreds))
      return t.resolve();
    const s = () => W.apply(this, Array.from(this._templateDeferreds)).done(() => {
      this.isDisposed() ? t.reject() : this._templateDeferreds.size > 0 ? s() : t.resolve();
    }).fail(t.reject);
    return s(), t.promise();
  }
  _updateContent(e, t, n) {
    return this.waitAsyncTemplates().done(() => {
      this._removeContent(n), this.setTableElement(e, n), this._wrapTableInScrollContainer(e, n);
    });
  }
  _findContentElement(e) {
  }
  _getWidths(e) {
    if (!e)
      return [];
    const t = [];
    return e.toArray().forEach((s) => {
      let o = s.offsetWidth;
      if (s.getBoundingClientRect) {
        const r = Ge(s);
        r.width > s.offsetWidth - 1 && (o = r.width);
      }
      t.push(o);
    }), t;
  }
  getColumnWidths(e, t) {
    if ((this.option("forceApplyBindings") || M)(), e = e ?? this.getTableElement(), e) {
      const n = e.children("tbody:not(.dx-header)").children();
      for (let s = 0; s < n.length; s++) {
        const o = n.eq(s), r = o.hasClass("dx-group-row"), a = o.hasClass(bp), l = o.hasClass("dx-error-row");
        if (o.get(0).style.display !== "none" && !o.hasClass("dx-state-invisible") && (!r && !a && !l)) {
          const c = o.children("td");
          return this._getWidths(c);
        }
      }
    }
    return [];
  }
  getVisibleColumnIndex(e, t) {
    return e;
  }
  setCellPropertiesCore(e, t, n) {
    const s = t.hasClass("dx-group-row") ? t.find(`td[aria-colindex='${n + 1}']:not(.dx-group-cell)`) : t.find("td").eq(n);
    for (let o = 0; o < s.length; o += 1) {
      const r = s.get(o);
      Object.assign(r.style, e);
    }
  }
  setCellProperties(e, t, n) {
    const s = this.getTableElement();
    if (!(s != null && s.length))
      return;
    const o = s.children().children(".dx-row").not(`.${bp}`);
    if (f(n))
      this.setCellPropertiesCore(e, o.eq(n), t);
    else
      for (let r = 0; r < o.length; r++) {
        const a = this.getVisibleColumnIndex(t, r);
        a >= 0 && this.setCellPropertiesCore(e, o.eq(r), a);
      }
  }
  setColumnWidths(e) {
    let {
      widths: t,
      optionNames: n
    } = e;
    const s = this.getTableElement();
    if (!(s != null && s.length) || !t)
      return;
    const o = this.getColumns(), r = this._needToSetCellWidths(), a = s.children("colgroup").children("col");
    a.toArray().forEach((l) => l.removeAttribute("style")), o.forEach((l, d) => {
      if (r && l.width && !l.command) {
        const c = {}, h = Wd(l.visibleWidth || l.width), g = Wd(l.minWidth || h);
        c.width = l.width === "auto" ? "" : h, c.maxWidth = c.width, c.minWidth = g, this.setCellProperties(c, d);
      }
      const u = iO(t[d]);
      f(u) && qg(a.eq(d), u);
    });
  }
  getCellElements(e) {
    return this._getCellElementsCore(e);
  }
  _getCellElementsCore(e) {
    return e < 0 ? void 0 : this._getRowElements().eq(e).children();
  }
  _getCellElement(e, t) {
    const n = this.getCellElements(e), s = this._getVisibleColumnIndex(n, e, t);
    if (!(n != null && n.length) || s < 0)
      return;
    const o = n.eq(s);
    return o.length > 0 ? o : void 0;
  }
  _getRowElement(e) {
    const t = this;
    let n = p();
    const s = t.getTableElements();
    if (y(s, (o, r) => {
      n = n.add(t._getRowElements(p(r)).eq(e));
    }), n.length)
      return n;
  }
  getCellElement(e, t) {
    const n = this._getCellElement(e, t);
    if (n)
      return ee(n);
  }
  getRowElement(e) {
    const t = this._getRowElement(e);
    let n = [];
    if (t && !ee(t).get)
      for (let s = 0; s < t.length; s++)
        n.push(t[s]);
    else
      n = t;
    return n;
  }
  _getVisibleColumnIndex(e, t, n) {
    if (te(n)) {
      const s = this._columnsController.columnOption(n, "index");
      return this._columnsController.getVisibleIndex(s);
    }
    return n;
  }
  getColumnElements() {
  }
  getColumns(e, t) {
    return this._columnsController.getVisibleColumns(e);
  }
  getCell(e, t, n) {
    const s = t || this._getRowElements();
    let o;
    if (s.length > 0 && e.rowIndex >= 0) {
      var r;
      if (this.option("scrolling.mode") !== "virtual" && this.option("scrolling.rowRenderingMode") !== "virtual" && (e.rowIndex = e.rowIndex < s.length ? e.rowIndex : s.length - 1), o = n || this.getCellElements(e.rowIndex), ((r = o) === null || r === void 0 ? void 0 : r.length) > 0)
        return o.eq(o.length > e.columnIndex ? e.columnIndex : o.length - 1);
    }
  }
  getRowsCount() {
    const e = this.getTableElement();
    return e && e.length === 1 ? e[0].rows.length : 0;
  }
  _getRowElementsCore(e) {
    if (e = e || this.getTableElement(), e) {
      const n = (this.option().rowTemplate || this.option("dataRowTemplate")) && e.find("> tbody.dx-row");
      return n && n.length ? n : e.find("> tbody > .dx-row, > .dx-row");
    }
    return p();
  }
  _getRowElements(e) {
    return this._getRowElementsCore(e);
  }
  getRowIndex(e) {
    return this._getRowElements().index(e);
  }
  getBoundingRect() {
  }
  getName() {
  }
  setScrollerSpacing(e) {
    const t = this.element(), n = this.option("rtlEnabled");
    t && t.css({
      paddingLeft: n ? e : "",
      paddingRight: n ? "" : e
    });
  }
  isScrollbarVisible(e) {
    const t = this.element(), n = this._tableElement;
    return t && n ? e ? Ee(n) - ne(t) > 0 : he(n) - le(t) > 0 : !1;
  }
  isDisposed() {
    var e;
    return (e = this.component) === null || e === void 0 ? void 0 : e._disposed;
  }
}
const Pj = "dx-link", Sp = function(i, e, t) {
  const n = p("<div>").addClass(i.addWidgetPrefix("text-content"));
  i.setAria("role", "presentation", n), sO(i, e, t.column, n);
  const s = i.option("showColumnLines"), o = i.getController("columns").getHeaderContentAlignment(t.column.alignment);
  return n[s || o === "right" ? "appendTo" : "prependTo"](e);
};
function sO(i, e, t, n) {
  const s = i._getIndicatorElements(e, !0), o = i._getIndicatorElements(e), r = s && s.length, a = i._getColumnAlignment(t.alignment), l = `.${i._getIndicatorClassName("sort")}`, d = `.${i._getIndicatorClassName("sortIndex")}`, u = o.filter(l), c = o.children().filter(d);
  n = n || e.children(`.${i.addWidgetPrefix("text-content")}`), n.toggleClass("dx-text-content-alignment-" + a, r > 0).toggleClass("dx-text-content-alignment-" + (a === "left" ? "right" : "left"), r > 0 && t.alignment === "center").toggleClass("dx-sort-indicator", !!u.length).toggleClass("dx-sort-index-indicator", !!c.length).toggleClass("dx-header-filter-indicator", !!o.filter(`.${i._getIndicatorClassName("headerFilter")}`).length);
}
class Mj extends Cd {
  init() {
    super.init(), this._headerPanelView = this.getView("headerPanel"), this._headerFilterController = this.getController("headerFilter"), this._dataController = this.getController("data");
  }
  _createTable() {
    const e = super._createTable.apply(this, arguments);
    return _.on(e, "mousedown selectstart", this.createAction((t) => {
      const {
        event: n
      } = t;
      n.shiftKey && n.preventDefault();
    })), e;
  }
  _isLegacyKeyboardNavigation() {
    return this.option("useLegacyKeyboardNavigation");
  }
  _getDefaultTemplate(e) {
    const t = this;
    return function(n, s) {
      const {
        caption: o
      } = e, r = !e.command || o && e.command !== "expand";
      e.command === "empty" ? t._renderEmptyMessage(n, s) : r ? Sp(t, n, s).text(o) : e.command && n.html("&nbsp;");
    };
  }
  _renderEmptyMessage(e, t) {
    const n = this._getEmptyHeaderText();
    if (!n) {
      e.html("&nbsp;");
      return;
    }
    const s = Sp(this, e, t);
    if (n.includes("{0}")) {
      const [r, a] = n.split("{0}"), l = S.format("dxDataGrid-emptyHeaderColumnChooserText"), d = this._columnChooserView, u = p("<a>").text(l).addClass(Pj);
      _.on(u, "click", this.createAction(() => d.showColumnChooser())), s.append(O.createTextNode(r)).append(u).append(O.createTextNode(a));
    } else
      s.text(n);
  }
  _getEmptyHeaderText() {
    const e = !!this._columnChooserView.hasHiddenColumns(), t = !!this._headerPanelView.hasGroupedColumns();
    switch (!0) {
      case (e && t):
        return S.format("dxDataGrid-emptyHeaderWithColumnChooserAndGroupPanelText");
      case t:
        return S.format("dxDataGrid-emptyHeaderWithGroupPanelText");
      case e:
        return S.format("dxDataGrid-emptyHeaderWithColumnChooserText");
      default:
        return "";
    }
  }
  _getHeaderTemplate(e) {
    return e.headerCellTemplate || {
      allowRenderToDetachedContainer: !0,
      render: this._getDefaultTemplate(e)
    };
  }
  _processTemplate(e, t) {
    const n = this;
    let s;
    const {
      column: o
    } = t, r = super._processTemplate(e);
    return t.rowType === "header" && r && o.headerCellTemplate && !o.command ? s = {
      render(a) {
        const l = Sp(n, a.container, a.model);
        r.render(x({}, a, {
          container: l
        }));
      }
    } : s = r, s;
  }
  _handleDataChanged(e) {
    e.changeType === "refresh" && (this._isGroupingChanged || this._requireReady) && (this._isGroupingChanged = !1, this.render());
  }
  _renderCell(e, t) {
    const n = super._renderCell(e, t);
    return t.row.rowType === "header" && (n.addClass("dx-cell-focus-disabled"), this._isLegacyKeyboardNavigation() || t.column && !t.column.type && n.attr("tabindex", this.option("tabindex") || 0)), n;
  }
  _setCellAriaAttributes(e, t, n) {
    super._setCellAriaAttributes(e, t, n), t.rowType === "header" && (t.column.type || this.setAria("role", "columnheader", e), t.column && !t.column.command && !t.column.isBand && (e.attr("id", t.column.headerId), this.setAria("label", `${S.format("dxDataGrid-ariaColumn")} ${t.column.caption}`, e)));
  }
  _createRow(e) {
    const t = super._createRow.apply(this, arguments);
    return t.toggleClass("dx-column-lines", this.option("showColumnLines")), e.rowType === "header" && (t.addClass("dx-header-row"), this._isLegacyKeyboardNavigation() || rl("columnHeaders", this, t, "td", this._handleActionKeyDown.bind(this))), t;
  }
  _processHeaderAction(e, t) {
  }
  _handleActionKeyDown(e) {
    const {
      event: t
    } = e, n = p(t.target);
    if (this._lastActionElement = t.target, n.is(".dx-header-filter")) {
      const s = this._headerFilterController, o = n.closest("td"), r = this.getColumnIndexByElement(o);
      r >= 0 && s.showHeaderFilterMenu(r, !1);
    } else {
      const s = n.closest(".dx-row");
      this._processHeaderAction(t, s);
    }
    t.preventDefault();
  }
  _renderCore() {
    const e = this.element(), t = {};
    if (this._tableElement && !this._dataController.isLoaded() && !this._hasRowElements)
      return new w().resolve();
    e.addClass(this.addWidgetPrefix("headers")).toggleClass(this.addWidgetPrefix("nowrap"), !this.option("wordWrapEnabled")), this.setAria("role", "presentation", e);
    const n = this._updateContent(this._renderTable({
      change: t
    }), t);
    return e.toggleClass("dx-header-multi-row", this.getRowCount() > 1), super._renderCore.apply(this, arguments), n;
  }
  _renderRows() {
    const e = this;
    (e._dataController.isLoaded() || e._hasRowElements) && (super._renderRows.apply(e, arguments), e._hasRowElements = !0);
  }
  _renderRow(e, t) {
    const n = this.getRowCount() === 1 ? null : t.row.rowIndex;
    t.columns = this.getColumns(n), super._renderRow(e, t);
  }
  _createCell(e) {
    const {
      column: t
    } = e, n = super._createCell.apply(this, arguments);
    return t.rowspan > 1 && e.rowType === "header" && n.attr("rowSpan", t.rowspan), n;
  }
  _getRows() {
    const e = [], t = this.getRowCount();
    if (this.option("showColumnHeaders"))
      for (let n = 0; n < t; n++)
        e.push({
          rowType: "header",
          rowIndex: n
        });
    return e;
  }
  _getCellTemplate(e) {
    if (e.rowType === "header")
      return this._getHeaderTemplate(e.column);
  }
  _columnOptionChanged(e) {
    const {
      changeTypes: t
    } = e, {
      optionNames: n
    } = e;
    if (t.grouping || t.groupExpanding) {
      t.grouping && (this._isGroupingChanged = !0);
      return;
    }
    super._columnOptionChanged(e), (n.width || n.visible) && this.resizeCompleted.fire();
  }
  _isElementVisible(e) {
    return e && e.visible;
  }
  _alignCaptionByCenter(e) {
    let t = this._getIndicatorContainer(e, !0);
    t && t.length && (t.filter(".dx-visibility-hidden").remove(), t = this._getIndicatorContainer(e), t.clone().addClass("dx-visibility-hidden").css("float", "").insertBefore(e.children(`.${this.addWidgetPrefix("text-content")}`)));
  }
  _updateCell(e, t) {
    t.rowType === "header" && t.column.alignment === "center" && this._alignCaptionByCenter(e), super._updateCell.apply(this, arguments);
  }
  _updateIndicator(e, t, n) {
    const s = super._updateIndicator.apply(this, arguments);
    return t.alignment === "center" && this._alignCaptionByCenter(e), sO(this, e, t), s;
  }
  _getIndicatorContainer(e, t) {
    const n = super._getIndicatorContainer(e);
    return t ? n : n.filter(":not(.dx-visibility-hidden)");
  }
  _isSortableElement(e) {
    return !0;
  }
  getHeadersRowHeight() {
    const e = this.getTableElement(), t = e && e.find(".dx-header-row");
    return t && t.toArray().reduce((n, s) => n + le(s), 0) || 0;
  }
  getHeaderElement(e) {
    const t = this.getColumnElements();
    return t?.eq(e) ?? p("");
  }
  getColumnElements(e, t) {
    const n = this;
    let s;
    const o = n._columnsController, r = n.getRowCount();
    if (n.option("showColumnHeaders")) {
      if (r > 1 && (!f(e) || f(t))) {
        const a = [], l = f(t) ? o.getChildrenByBandColumn(t, !0) : o.getVisibleColumns();
        return y(l, (d, u) => {
          const c = f(e) ? e : o.getRowIndex(u.index);
          s = n._getCellElement(c, o.getVisibleIndex(u.index, c)), s && a.push(s.get(0));
        }), p(a);
      }
      if (!e || e < r)
        return n.getCellElements(e || 0);
    }
  }
  getColumnIndexByElement(e) {
    const t = this.getCellIndex(e), n = e.closest(".dx-row"), {
      rowIndex: s
    } = n[0], o = this.getColumns(s)[t];
    return o ? o.index : -1;
  }
  getVisibleColumnIndex(e, t) {
    const n = this.getColumns()[e];
    return n ? this._columnsController.getVisibleIndex(n.index, t) : -1;
  }
  getColumnWidths(e, t) {
    const n = this.getColumnElements(t);
    return n && n.length ? this._getWidths(n) : super.getColumnWidths.apply(this, arguments);
  }
  allowDragging(e) {
    const t = e && this._columnsController.getRowIndex(e.index), n = this.getColumns(t);
    return (this.option("allowColumnReordering") ?? this._columnsController.isColumnOptionUsed("allowReordering")) && e.allowReordering && n.length > 1;
  }
  getBoundingRect() {
    const e = this, t = e.getColumnElements();
    return t && t.length ? {
      top: e.getTableElement().offset().top
    } : null;
  }
  getName() {
    return "headers";
  }
  getColumnCount() {
    const e = this.getColumnElements();
    return e ? e.length : 0;
  }
  isVisible() {
    return this.option("showColumnHeaders");
  }
  optionChanged(e) {
    const t = this;
    switch (e.name) {
      case "showColumnHeaders":
      case "wordWrapEnabled":
      case "showColumnLines":
        t._invalidate(!0, !0), e.handled = !0;
        break;
      default:
        super.optionChanged(e);
    }
  }
  getHeight() {
    return this.getElementHeight();
  }
  getContextMenuItems(e) {
    const t = this, {
      column: n
    } = e;
    if (e.row && (e.row.rowType === "header" || e.row.rowType === "detailAdaptive")) {
      const s = t.option("sorting");
      if (s && s.mode !== "none" && n && n.allowSorting) {
        const o = function(r) {
          setTimeout(() => {
            t._columnsController.changeSortOrder(n.index, r.itemData.value);
          });
        };
        return [{
          text: s.ascendingText,
          value: "asc",
          disabled: n.sortOrder === "asc",
          icon: "context-menu-sort-asc",
          onItemClick: o
        }, {
          text: s.descendingText,
          value: "desc",
          disabled: n.sortOrder === "desc",
          icon: "context-menu-sort-desc",
          onItemClick: o
        }, {
          text: s.clearText,
          value: "none",
          disabled: !n.sortOrder,
          icon: "context-menu-sort-none",
          onItemClick: o
        }];
      }
    }
  }
  getRowCount() {
    return this._columnsController && this._columnsController.getRowCount();
  }
  toggleDraggableColumnClass(e, t, n) {
    let s, o;
    const r = this.getRowCount(), a = this._columnsController.getColumns(), l = a && a[e], d = l && l.isBand && l.index, u = (c, h) => {
      c.ownerBand === d && (o.eq(h).toggleClass(this.addWidgetPrefix(gc.draggableColumn), t), c.isBand && this.toggleDraggableColumnClass(c.index, t, s + 1));
    };
    if (f(d))
      for (n = n || 0, s = n; s < r; s++)
        o = this.getCellElements(s), o && this.getColumns(s).forEach(u);
  }
}
const oO = {
  defaultOptions: () => ({
    showColumnHeaders: !0,
    cellHintEnabled: !0
  }),
  views: {
    columnHeadersView: Mj
  }
}, J = I({}, Ue, F, {
  modules: []
});
oO.views.columnHeadersView;
J.registerModule("columnHeaders", oO);
const Bj = 2;
var je;
(function(i) {
  i.Left = "left", i.Right = "right", i.Sticky = "sticky";
})(je || (je = {}));
const Je = {
  stickyColumn: "sticky-column",
  stickyColumnLeft: "sticky-column-left",
  stickyColumnRight: "sticky-column-right",
  stickyColumnBorderRight: "sticky-column-border-right",
  stickyColumnBorderLeft: "sticky-column-border-left",
  stickyColumns: "sticky-columns",
  firstHeader: "first-header",
  columnNoBorder: "column-no-border",
  groupRowContainer: "group-row-container",
  focusedFixedElement: "dx-focused-fixed-element",
  focused: "dx-focused",
  hidden: "dx-hidden"
}, rO = ["filterValues", "filterType", "fixed", "fixedPosition"], Cc = ["visibleIndex", "dataField", "name", "dataType", "width", "visible", "sortOrder", "lastSortOrder", "sortIndex", "groupIndex", "filterValue", "bufferedFilterValue", "selectedFilterOperation", "bufferedSelectedFilterOperation", "added"].concat(rO), $j = {
  visibleWidth: !0,
  bestFitWidth: !0,
  bufferedFilterValue: !0
}, Nj = "dx-command-expand", ib = Number.MAX_SAFE_INTEGER || 9007199254740991, zs = "groupExpand", Lj = "detailExpand", Ep = /columns\[(\d+)\]\.?/gi, Hj = {
  visible: !0,
  showInColumnChooser: !0
}, Wj = {
  number: ["=", "<>", "<", ">", "<=", ">=", "between"],
  string: ["contains", "notcontains", "startswith", "endswith", "=", "<>"],
  date: ["=", "<>", "<", ">", "<=", ">=", "between"],
  datetime: ["=", "<>", "<", ">", "<=", ">=", "between"]
}, zj = {
  visibleIndex: !0,
  groupIndex: !0,
  grouped: !0,
  sortIndex: !0,
  sortOrder: !0
}, Or = "group", Ar = "columnChooser", K_ = "adaptiveHidden", ra = (i, e) => {
  const {
    fixedPosition: t
  } = e, n = i.option("rtlEnabled"), s = e.command && e.command === "expand";
  return e.command && !F.isCustomCommandColumn(i._columns, e) && n && !s ? t === je.Right ? je.Left : je.Right : t ?? je.Left;
}, G_ = function(i, e) {
  return i.isVirtualMode() && !!e.fixed && e.fixedPosition === je.Sticky;
}, sb = function(i, e) {
  return e.map((t) => G_(i, t) ? I({}, t, {
    fixed: !1,
    fixedPosition: ""
  }) : t);
}, U_ = function(i, e) {
  return e.visibleWidth !== K_ && (!e.isBand || !!i.getVisibleDataColumnsByBandColumn(e.index).length);
}, ob = function(i, e) {
  return !e.some((t) => !t.fixed && U_(i, t));
}, zd = function(i, e, t, n, s, o) {
  const r = e[n], a = f(r.ownerBand), l = s === je.Right, d = r.fixedPosition === je.Sticky, u = l ? e.slice(n + 1) : e.slice(0, n).reverse(), c = l ? t.slice(n + 1) : t.slice(0, n).reverse();
  let h = 0, g = 0, m = !ob(i, u) && d && u.length ? 1 : 0;
  if (u.forEach((v, E) => {
    if (v.fixed && (!f(o) || r.ownerBand === v.ownerBand)) {
      const T = v.fixedPosition === je.Sticky;
      h += c[E], d && T && !ob(i, u.slice(E + 1)) && (E !== g ? (m += 1, g = E + 1) : g += 1);
    } else
      U_(i, v) || (g += 1);
  }), a && f(o)) {
    var C;
    return h += (o == null || (C = o[r.ownerBand]) === null || C === void 0 ? void 0 : C[s]) ?? 0, h;
  }
  return h - m * Bj;
}, aO = function(i, e, t) {
  let n = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : !1, s = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : !1, o = arguments.length > 5 ? arguments[5] : void 0;
  const a = i.option("rtlEnabled") !== s ? "isLastColumn" : "isFirstColumn";
  if (e.fixedPosition === je.Sticky) {
    const l = i.getParentColumn(e) ?? e;
    if (i[a](l, 0))
      return !1;
  }
  return i[a](e, t, n, o);
}, Kj = function(i, e, t, n) {
  const s = i.getVisibleIndex(e.index, n);
  return t?.slice(0, s).reverse().find((o) => U_(i, o));
}, lO = function(i, e, t, n, s) {
  const o = {}, r = e[n];
  if (r)
    switch (ra(i, r)) {
      case je.Sticky: {
        const l = zd(i, e, t, n, je.Left, s), d = zd(i, e, t, n, je.Right, s);
        o.left = l, o.right = d;
        break;
      }
      case je.Right: {
        const l = zd(i, e, t, n, je.Right, s);
        o.right = l;
        break;
      }
      default: {
        const l = zd(i, e, t, n, je.Left, s);
        o.left = l;
      }
    }
  return o;
}, rb = function(i, e, t, n) {
  const s = Kj(i, e, t, n), o = ra(i, e), r = s && ra(i, s);
  return !!(s != null && s.fixed) && !G_(i, s) && (!e.fixed || o === je.Sticky || r === je.Sticky);
}, Gj = function(i, e, t) {
  let n = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : !1;
  const s = i.getVisibleColumns(n ? null : t), o = i.getParentColumn(e);
  return o ? i.isFirstColumn(e, t, !0) && rb(i, o, i.getVisibleColumns(0), 0) : rb(i, e, s, t);
}, dO = function(i) {
  const e = {};
  return f(i.left) && (e.left = `${i.left}px`), f(i.right) && (e.right = `${i.right}px`), e;
}, Uj = function(i, e, t) {
  let n = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : !1, s = arguments.length > 4 ? arguments[4] : void 0;
  return aO(i, e, t, n, !1, s);
}, jj = function(i, e, t) {
  let n = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : !1, s = arguments.length > 4 ? arguments[4] : void 0;
  return aO(i, e, t, n, !0, s);
}, uO = function(i, e, t) {
  return !(f(i.isLeftBoundary) || f(i.isRightBoundary)) && !!e && !!t && e.fixed !== t.fixed;
}, cO = function(i) {
  i.filterOperations = i.defaultFilterOperations;
};
let qj = 1;
const hh = function(i, e, t, n) {
  let s = {};
  if (e) {
    te(e) && (e = {
      dataField: e
    }), i.setName(e);
    let o = {};
    if (e.command)
      o = an(s, e);
    else {
      s = i.getCommonSettings(e), t && t.name && t.dataField && (e = x({}, e, {
        dataField: t.dataField
      }));
      const r = i._createCalculatedColumnOptions(e, n);
      e.type || (o = {
        headerId: "dx-col-" + qj++
      }), o = an(o, Hj, !1, !0), an(o, s, !1, !0), an(o, r, !1, !0), an(o, e, !1, !0), an(o, {
        selector: null
      }, !1, !0);
    }
    return e.filterOperations === e.defaultFilterOperations && cO(o), o;
  }
}, bo = function(i, e, t, n) {
  let s = [];
  return e && y(e, (o, r) => {
    const a = (n ?? 0) + s.length, l = i._columnsUserState && j_(r, i._columnsUserState[a]) && i._columnsUserState[a], d = hh(i, r, l, t);
    d && (t && (d.ownerBand = t), s.push(d), d.columns && (s = s.concat(bo(i, d.columns, d, s.length)), delete d.columns, d.hasColumns = !0));
  }), s;
}, Ji = function(i, e) {
  const t = [];
  let n = e[i];
  for (; n; )
    t.unshift(n), i = n.index, n = e[i];
  return t;
}, hO = function(i, e, t) {
  let n = [];
  const s = e[i];
  if (s)
    for (let o = 0; o < s.length; o++) {
      const r = s[o];
      (!f(r.groupIndex) || r.showWhenGrouped) && (n.push(r), t && r.isBand && (n = n.concat(hO(r.index, e, t))));
    }
  return n;
}, Yj = function(i, e) {
  let t, n;
  const s = i.getBandColumnsCache(), o = function(r) {
    const a = t ? t.index : void 0;
    return r.ownerBand === a;
  };
  if (s.isPlain)
    t = i._columns[e[0]];
  else {
    n = i._columns.filter(o);
    for (let r = 0; r < e.length; r++)
      t = n[e[r]], t && (n = i._columns.filter(o));
  }
  return t;
}, Xj = function(i, e) {
  let t = [], n;
  const s = i.getBandColumnsCache(), o = function(r) {
    return r.ownerBand === e.ownerBand;
  };
  if (s.isPlain) {
    const r = i._columns.indexOf(e);
    r >= 0 && (t = [`columns[${r}]`]);
  } else
    for (n = i._columns.filter(o); n.length && n.indexOf(e) !== -1; )
      t.unshift(`columns[${n.indexOf(e)}]`), e = s.columnParentByIndex[e.index], n = e ? i._columns.filter(o) : [];
  return t.join(".");
}, pO = function(i, e) {
  let t = 0;
  const n = i.getChildrenByBandColumn(e, !0);
  return y(n, (s, o) => {
    o.isBand ? (o.colspan = o.colspan || pO(i, o.index), t += o.colspan || 1) : t += 1;
  }), t;
}, Zj = function(i, e, t) {
  let n;
  for (let s = 0; s < e.length; s++) {
    const o = e[s];
    (o.visible || o.command) && (o.isBand && (o.colspan = o.colspan || pO(i, o.index)), (!o.isBand || !o.colspan) && (n = i.getRowCount(), !o.command && (!f(o.groupIndex) || o.showWhenGrouped) && (n -= Ji(o.index, t.columnParentByIndex).length), n > 1 && (o.rowspan = n)));
  }
}, Ip = function(i) {
  let e = yn(i);
  return e !== "string" && e !== "boolean" && e !== "number" && e !== "date" && e !== "object" && (e = void 0), e;
}, ab = function(i, e) {
  switch (i) {
    case "date":
    case "datetime":
      return pt.getDateSerializationFormat(e);
    case "number":
      if (te(e))
        return "string";
      if ($e(e))
        return null;
  }
}, lb = function(i, e) {
  i.deserializeValue || (F.isDateType(e) && (i.deserializeValue = function(t) {
    return pt.deserializeDate(t);
  }, i.serializeValue = function(t) {
    return te(t) ? t : pt.serializeDate(t, this.serializationFormat);
  }), e === "number" && (i.deserializeValue = function(t) {
    const n = parseFloat(t);
    return isNaN(n) ? t : n;
  }, i.serializeValue = function(t, n) {
    return n === "filter" ? t : f(t) && this.serializationFormat === "string" ? t.toString() : t;
  }));
}, Qj = function(i, e) {
  switch (i) {
    case "number":
      return "right";
    case "boolean":
      return "center";
    default:
      return ro(e);
  }
}, Jj = function(i) {
  return i.value === !0 ? this.trueText || "true" : i.value === !1 ? this.falseText || "false" : i.valueText || "";
}, db = function(i) {
  if (i === "boolean")
    return Jj;
}, eq = function(i, e) {
  const t = i._getFirstItems(e);
  let n;
  const s = {}, o = [];
  for (let r = 0; r < t.length; r++)
    if (t[r])
      for (n in t[r])
        (!B(t[r][n]) || Bt.isWrapped(t[r][n])) && (s[n] = !0);
  for (n in s)
    if (n.indexOf("__") !== 0) {
      const r = hh(i, n);
      o.push(r);
    }
  return o;
}, gO = function(i) {
  y(i._columns, (e, t) => {
    t.index = e;
  }), y(i._columns, (e, t) => {
    X(t.ownerBand) && (t.ownerBand = t.ownerBand.index);
  }), y(i._commandColumns, (e, t) => {
    t.index = -(e + 1);
  });
}, mO = function(i, e) {
  Al(i._columns, "groupIndex", e, (t) => {
    const {
      grouped: n
    } = t;
    return delete t.grouped, n;
  });
}, tq = function(i, e) {
  y(i._columns, (t, n) => {
    f(n.sortIndex) && !vc(n.sortOrder) && delete n.sortIndex;
  }), Al(i._columns, "sortIndex", e, (t) => !f(t.groupIndex) && vc(t.sortOrder));
}, nq = function(i, e) {
  let t;
  const n = [], s = i.getBandColumnsCache(), o = [], r = i._columns.filter((a) => !a.command);
  for (let a = 0; a < r.length; a++)
    t = r[a], Ji(a, s.columnParentByIndex).length ? o.push(t) : n.push(t);
  Al(o, "visibleIndex", e), Al(n, "visibleIndex", e);
}, Dp = function(i, e, t) {
  const n = X(e) ? e.rowIndex : null, s = t === Or ? i.getGroupColumns() : t === Ar ? i.getChooserColumns() : i.getVisibleColumns(n);
  let o;
  return e = X(e) ? e.columnIndex : e, o = s[e], o && o.type === zs && (o = i._columns.filter((r) => o.type === r.type)[0] || o), o && f(o.index) ? o.index : -1;
}, iq = function(i, e, t) {
  const n = i.getGroupColumns();
  let s;
  if (t >= 0)
    for (s = 0; s < n.length; s++)
      n[s].groupIndex >= t && n[s].groupIndex++;
  else
    for (t = 0, s = 0; s < n.length; s++)
      t = Math.max(t, n[s].groupIndex + 1);
  return t;
};
function j_(i, e) {
  return i && e && e.name === (i.name || i.dataField) && (e.dataField === i.dataField || i.name);
}
const ub = function(i) {
  const e = i._columnsUserState, t = i._ignoreColumnOptionNames || [], n = i._columns, s = {};
  let o = [], r = !0;
  const a = [];
  let l, d, u;
  function c(g, m) {
    if (m)
      for (let C = 0; C < Cc.length; C++) {
        const v = Cc[C];
        t.includes(v) || (v === "dataType" ? g[v] = g[v] || m[v] : rO.includes(v) ? v in m && (g[v] = m[v]) : (v === "selectedFilterOperation" && m[v] && (g.defaultSelectedFilterOperation = g[v] || null), g[v] = m[v]));
      }
  }
  function h(g, m) {
    const C = m.name || m.dataField;
    let v = s[C] || 0;
    for (let E = 0; E < g.length; E++)
      if (j_(m, g[E]))
        if (v)
          v--;
        else
          return s[C] = s[C] || 0, s[C]++, E;
    return -1;
  }
  if (e) {
    for (u = 0; u < n.length; u++)
      d = h(e, n[u]), r = r && d >= 0, a.push(d);
    for (u = 0; u < n.length; u++)
      l = n[u], d = a[u], (i._hasUserState || r) && c(l, e[d]), d >= 0 && f(e[d].initialIndex) ? o[d] = l : o.push(l);
    let g = !1;
    for (u = 0; u < e.length; u++) {
      const m = e[u];
      m.added && h(n, m) < 0 && (l = hh(i, m.added), c(l, m), o.push(l), m.added.columns && (g = !0));
    }
    g && (gO(i), o = bo(i, o)), Rr(i, o);
  }
}, xo = function(i, e) {
  gO(i), mO(i, e), tq(i, e), _O(i), nq(i, e);
}, ph = function(i) {
  i.resetColumnsCache();
};
function Rr(i, e) {
  i._previousColumns = i._columns, i._columns = e, ph(i), i.updateColumnDataTypes();
}
const vi = function(i, e, t, n) {
  const s = i._columnChanges || {
    optionNames: {
      length: 0
    },
    changeTypes: {
      length: 0
    },
    columnIndex: n
  };
  t = t || "all", t = t.split(".")[0];
  const {
    changeTypes: o
  } = s;
  e && !o[e] && (o[e] = !0, o.length++);
  const {
    optionNames: r
  } = s;
  t && !r[t] && (r[t] = !0, r.length++), (n === void 0 || n !== s.columnIndex) && (f(n) && (s.columnIndices ?? (s.columnIndices = []), f(s.columnIndex) && s.columnIndices.push(s.columnIndex), s.columnIndices.push(n)), delete s.columnIndex), i._columnChanges = s, ph(i);
}, Oa = function(i) {
  const e = i.option("onColumnsChanging"), t = i._columnChanges, n = ["dataField", "lookup", "dataType", "columns"];
  i.isInitialized() && !i._updateLockCount && t && (e && (i._updateLockCount++, e(x({
    component: i.component
  }, t)), i._updateLockCount--), i._columnChanges = void 0, s = t.optionNames, s && n.some((o) => s[o]) ? (i._reinitAfterLookupChanges = t?.optionNames.lookup, i.reinit(), i._reinitAfterLookupChanges = void 0) : i.columnsChanged.fire(t));
  var s;
}, sq = function(i, e, t, n) {
  const s = n >= 0;
  if (t >= 0)
    s || (e.lastSortOrder = e.sortOrder);
  else {
    const o = i.option("sorting.mode");
    let r = e.lastSortOrder;
    o === "single" && i._columns.some((l) => l !== e && f(l.sortIndex)) && (r = void 0), e.sortOrder = r;
  }
}, oq = function(i, e) {
  const {
    value: t
  } = e, {
    optionName: n
  } = e, {
    prevValue: s
  } = e, {
    fullOptionName: o
  } = e, r = `${o}.${n}`;
  !$j[n] && i._skipProcessingColumnsChange !== r && (i._skipProcessingColumnsChange = r, i.component._notifyOptionChanged(r, t, s), i._skipProcessingColumnsChange = !1);
}, Tp = function(i, e, t, n, s) {
  const o = Be(t), r = e.index;
  let a, l, d;
  if (arguments.length === 3)
    return o(e, {
      functionsAsIs: !0
    });
  const u = o(e, {
    functionsAsIs: !0
  });
  if (!He(u, n, {
    maxDepth: 5
  })) {
    t === "groupIndex" || t === "calculateGroupValue" ? (l = "grouping", sq(i, e, n, u)) : t === "sortIndex" || t === "sortOrder" || t === "calculateSortValue" ? l = "sorting" : l = "columns";
    const c = $f(t);
    c(e, n, {
      functionsAsIs: !0
    });
    const h = Xj(i, e);
    zj[t] && (xo(i, e), n = o(e)), (t === "name" || t === "allowEditing") && i._checkColumns(), !f(u) && !f(n) && t.indexOf("buffer") !== 0 && s !== !1 && (s = !0), s ? ph(i) : (!Cc.includes(t) && t !== "visibleWidth" && (a = i.option("columns"), d = i.getColumnByPath(h, a), te(d) && (d = a[r] = {
      dataField: d
    }), d && j_(d, e) && c(d, n, {
      functionsAsIs: !0
    })), vi(i, l, t, r)), h && oq(i, {
      fullOptionName: h,
      optionName: t,
      value: n,
      prevValue: u
    });
  }
};
function vc(i) {
  return i === "asc" || i === "desc";
}
const rq = function(i) {
  const e = i._getExpandColumnOptions();
  i.addCommandColumn(e);
}, aq = function(i, e) {
  if (!this.dataField)
    return;
  const t = this.dataField.split("."), n = t.length - 1;
  this.serializeValue && (e = this.serializeValue(e));
  for (let s = 0; s < n; s++) {
    const o = t[s];
    i = i[o] = i[o] || {};
  }
  i[t[n]] = e;
}, fO = function(i, e, t) {
  const n = [];
  return e = e || 0, i[e] && y(i[e], (s, o) => {
    (o.ownerBand === t || o.type === zs) && (!o.isBand || !o.colspan ? (!o.command || e < 1) && n.push(o) : n.push.apply(n, fO(i, e + 1, o.index)));
  }), n;
}, lq = function(i) {
  let e = 1;
  const t = i.getBandColumnsCache(), {
    columnParentByIndex: n
  } = t;
  return i._columns.forEach((s) => {
    const o = Ji(s.index, n), r = o.filter((a) => !a.visible);
    s.visible && !r.length && (e = Math.max(e, o.length + 1));
  }), e;
}, cb = function(i, e) {
  const t = i.option("rtlEnabled");
  return e.command && !F.isCustomCommandColumn(i._columns, e) || !e.fixedPosition ? t ? "right" : "left" : e.fixedPosition;
}, hb = function(i, e, t, n) {
  let s;
  const o = this.getRowCount();
  let r = i[n] && i[n].rowspan, a = e.filter((l) => l.type === t);
  return i.forEach((l, d) => {
    l.type === t && (s = d, r = i[d + 1] ? i[d + 1].rowspan : o);
  }), r > 1 && (a = mt(a, (l) => x({}, l, {
    rowspan: r
  }))), a.unshift.apply(a, f(s) ? [s, 1] : [n, 0]), i.splice.apply(i, a), r || 1;
}, dq = function(i) {
  let e;
  for (e = 0; i > 1; e++)
    i /= 10;
  return e;
}, pb = function(i, e) {
  let t = i ? i.toString() : "0";
  for (; t.length < e; )
    t = `0${t}`;
  return t;
}, gb = (i, e, t, n) => {
  let s, o, r = e.slice().map((c) => x({}, c));
  const a = i._isColumnFixing();
  let l = t.slice().map((c) => x({
    fixed: a
  }, c));
  const d = (c) => t.reduce((h, g, m) => {
    const C = n && c.type === zs ? "expand" : c.type;
    return g.type === C || g.command === c.command ? m : h;
  }, -1), u = (c) => c.command !== t[o].command;
  for (let c = 0; c < e.length; c++)
    if (s = e[c], o = s && (s.type || s.command) ? d(s) : -1, o >= 0)
      if (n)
        r[c] = x({
          fixed: a
        }, t[o], s), s.type !== zs && (l = l.filter(u));
      else {
        const h = {
          visibleIndex: s.visibleIndex,
          index: s.index,
          headerId: s.headerId,
          allowFixing: s.groupIndex === 0,
          allowReordering: s.groupIndex === 0,
          groupIndex: s.groupIndex
        };
        r[c] = x({}, s, t[o], s.type === zs && h);
      }
  return e.length && n && l.length && (r = r.concat(l)), r;
}, mb = (i, e) => f(e.fixed) || !e.type ? e.fixed && e.fixedPosition !== je.Sticky : i._isColumnFixing(), uq = (i) => {
  i.forEach((e) => {
    f(e.ownerBand) && (e.ownerBand = i[e.ownerBand]);
  });
}, _O = (i) => {
  i._bandColumnsCache = void 0;
}, fb = (i, e) => {
  const t = te(e) && e.substr(0, e.indexOf(":"));
  let n;
  if (e !== void 0)
    return t && (e = e.substr(t.length + 1)), t ? n = i.filter((s) => `${s[t]}` === e)[0] : ["index", "name", "dataField", "caption"].some((s) => (n = i.filter((o) => o[s] === e)[0], !!n)), n;
}, cq = (i, e) => {
  if (e !== "asc" && e !== "desc")
    return i;
  const t = e === "asc" ? 1 : -1;
  return i.sort((n, s) => {
    const o = n.caption || "", r = s.caption || "";
    return t * o.localeCompare(r);
  }), i;
}, hq = function(i, e) {
  const t = We.parse(i);
  if ($e(t)) {
    const n = We.format(t, e), s = We.format(t, "decimal");
    if (n === i || s === i)
      return t;
  }
}, pq = function(i, e) {
  let t = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : !1, n = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : !1, s = arguments.length > 4 ? arguments[4] : void 0;
  return e.every((o, r) => t && r === 0 || CO(i, o, r, t, n, s));
}, CO = function(i, e, t) {
  var n, s;
  let o = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : !1, r = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : !1, a = arguments.length > 5 ? arguments[5] : void 0;
  const l = e.index, d = (u = t, i.getVisibleColumns(u).filter((h) => {
    let g = !0;
    return h.visibleWidth === K_ ? !1 : (o && e ? g && (g = h.ownerBand === e.ownerBand) : a && g && (g = h.fixed && ra(i, h) === a), g);
  }));
  var u;
  const c = i.getVisibleIndex(l, t);
  return r ? c === i.getVisibleIndex((n = d[d.length - 1]) === null || n === void 0 ? void 0 : n.index, t) : c === i.getVisibleIndex((s = d[0]) === null || s === void 0 ? void 0 : s.index, t);
}, _b = function(i, e, t) {
  let n = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : !1, s = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : !1, o = arguments.length > 5 ? arguments[5] : void 0;
  const r = e.index, a = i.getBandColumnsCache(), l = Ji(r, a.columnParentByIndex);
  return l != null && l.length ? pq(i, l.concat([e]), n, s, o) : n || CO(i, e, t, n, s, o);
};
class gq extends Ue.Controller {
  init(e) {
    this._dataController = this.getController("data"), this._focusController = this.getController("focus"), this._stateStoringController = this.getController("stateStoring");
    const t = this.option("columns");
    this._commandColumns = this._commandColumns || [], this._columns = this._columns || [], this._isColumnsFromOptions = !!t, this._isColumnsFromOptions ? (Rr(this, t ? bo(this, t) : []), ub(this)) : Rr(this, this._columnsUserState ? bo(this, this._columnsUserState) : this._columns), rq(this), this._dataSourceApplied ? this.applyDataSource(this._dataSource, !0, e) : xo(this), this._checkColumns();
  }
  _getExpandColumnOptions() {
    return {
      type: "expand",
      command: "expand",
      width: "auto",
      cssClass: Nj,
      allowEditing: !1,
      allowGrouping: !1,
      allowSorting: !1,
      allowResizing: !1,
      allowReordering: !1,
      allowHiding: !1
    };
  }
  _getFirstItems(e) {
    let t, n = [];
    const s = function(o, r) {
      if (!o || !r)
        return o;
      for (let a = 0; a < o.length; a++) {
        const l = s(o[a].items || o[a].collapsedItems, r - 1);
        if (l && l.length)
          return l;
      }
    };
    return e && e.items().length > 0 && (t = F.normalizeSortingInfo(e.group()).length, n = s(e.items(), t) || []), n;
  }
  _endUpdateCore() {
    !this._skipProcessingColumnsChange && Oa(this);
  }
  callbackNames() {
    return ["columnsChanged"];
  }
  getColumnByPath(e, t) {
    const n = this;
    let s;
    const o = [];
    return e.replace(Ep, (r, a) => (o.push(parseInt(a)), "")), o.length && (t ? s = o.reduce((r, a) => r && r.columns && r.columns[a], {
      columns: t
    }) : s = Yj(n, o)), s;
  }
  optionChanged(e) {
    let t;
    switch (e.name) {
      case "adaptColumnWidthByRatio":
        e.handled = !0;
        break;
      case "dataSource":
        e.value !== e.previousValue && !this.option("columns") && (!Array.isArray(e.value) || !Array.isArray(e.previousValue)) && (this._columns = []);
        break;
      case "columns":
        t = this._skipProcessingColumnsChange, e.handled = !0, this._skipProcessingColumnsChange || (e.name === e.fullName ? (this._columnsUserState = null, this._ignoreColumnOptionNames = null, this.init()) : (this._columnOptionChanged(e), t = !0)), t && this._updateRequireResize(e);
        break;
      case "commonColumnSettings":
      case "columnAutoWidth":
      case "allowColumnResizing":
      case "allowColumnReordering":
      case "columnFixing":
      case "grouping":
      case "groupPanel":
      case "regenerateColumnsByVisibleItems":
      case "customizeColumns":
      case "columnHidingEnabled":
      case "dateSerializationFormat":
      case "columnResizingMode":
      case "columnMinWidth":
      case "columnWidth": {
        e.handled = !0;
        const n = e.fullName === "columnWidth" && ["width"];
        this.reinit(n);
        break;
      }
      case "rtlEnabled":
        this.reinit();
        break;
      default:
        super.optionChanged(e);
    }
  }
  _columnOptionChanged(e) {
    let t = {};
    const n = this.getColumnByPath(e.fullName), s = e.fullName.replace(Ep, "");
    n && (s ? t[s] = e.value : t = e.value, this._skipProcessingColumnsChange = e.fullName, this.columnOption(n.index, t), this._skipProcessingColumnsChange = !1);
  }
  _updateRequireResize(e) {
    const {
      component: t
    } = this;
    e.fullName.replace(Ep, "") === "width" && t._updateLockCount && (t._requireResize = !0);
  }
  publicMethods() {
    return ["addColumn", "deleteColumn", "columnOption", "columnCount", "clearSorting", "clearGrouping", "getVisibleColumns", "getVisibleColumnIndex", "getColumns"];
  }
  applyDataSource(e, t, n) {
    const s = this, o = e && e.isLoaded();
    if (s._dataSource = e, !s._dataSourceApplied || s._dataSourceColumnsCount === 0 || t || s.option("regenerateColumnsByVisibleItems")) {
      if (o) {
        if (!s._isColumnsFromOptions) {
          const r = eq(s, e);
          r.length && (Rr(s, r), s._dataSourceColumnsCount = s._columns.length, ub(s));
        }
        return s.updateColumns(e, t, n);
      }
      s._dataSourceApplied = !1, xo(s);
    } else if (o && !s.isAllDataTypesDefined(!0) && s.updateColumnDataTypes(e))
      return vi(s, "columns"), Oa(s), new w().reject().promise();
  }
  reset() {
    this._dataSource = null, this._dataSourceApplied = !1, this._dataSourceColumnsCount = void 0, this.reinit();
  }
  resetColumnsCache() {
    this._visibleColumns = void 0, this._fixedColumns = void 0, this._rowCount = void 0, _O(this);
  }
  reinit(e) {
    this._columnsUserState = this.getUserState(), this._ignoreColumnOptionNames = e || null, this.init(), e && (this._ignoreColumnOptionNames = null);
  }
  isInitialized() {
    return !!this._columns.length || !!this.option("columns");
  }
  isDataSourceApplied() {
    return this._dataSourceApplied;
  }
  getCommonSettings(e) {
    const t = (!e || !e.type) && this.option("commonColumnSettings") || {}, n = this.option("grouping") ?? {}, s = this.option("groupPanel") ?? {};
    return x({
      allowFixing: this.option("columnFixing.enabled"),
      allowResizing: this.option("allowColumnResizing") || void 0,
      allowReordering: this.option("allowColumnReordering"),
      minWidth: this.option("columnMinWidth"),
      width: this.option("columnWidth"),
      autoExpandGroup: n.autoExpandAll,
      allowCollapsing: n.allowCollapsing,
      allowGrouping: s.allowColumnDragging && s.visible || n.contextMenuEnabled
    }, t);
  }
  isColumnOptionUsed(e) {
    for (let t = 0; t < this._columns.length; t++)
      if (this._columns[t][e])
        return !0;
  }
  isAllDataTypesDefined(e) {
    const t = this._columns;
    if (!t.length)
      return !1;
    for (let n = 0; n < t.length; n++)
      if (!(!t[n].dataField && t[n].calculateCellValue === t[n].defaultCalculateCellValue) && (!t[n].dataType || e && t[n].deserializeValue && t[n].serializationFormat === void 0))
        return !1;
    return !0;
  }
  getColumns() {
    return this._columns;
  }
  isBandColumnsUsed() {
    return this.getColumns().some((e) => e.isBand);
  }
  getGroupColumns() {
    const e = [];
    return y(this._columns, function() {
      const t = this;
      f(t.groupIndex) && (e[t.groupIndex] = t);
    }), e;
  }
  _shouldReturnVisibleColumns() {
    return !0;
  }
  _compileVisibleColumns(e) {
    return this._visibleColumns = this._visibleColumns || this._compileVisibleColumnsCore(), e = f(e) ? e : this._visibleColumns.length - 1, this._visibleColumns[e] || [];
  }
  getVisibleColumns(e, t) {
    return this._shouldReturnVisibleColumns() ? this._compileVisibleColumns.apply(this, arguments) : [];
  }
  getFixedColumns(e) {
    return this._fixedColumns = this._fixedColumns || this._getFixedColumnsCore(), e = f(e) ? e : this._fixedColumns.length - 1, this._fixedColumns[e] || [];
  }
  getFilteringColumns() {
    return this.getColumns().filter((e) => (e.dataField || e.name) && (e.allowFiltering || e.allowHeaderFiltering)).map((e) => {
      const t = x(!0, {}, e);
      return f(t.dataField) || (t.dataField = t.name), t.filterOperations = e.filterOperations !== e.defaultFilterOperations ? t.filterOperations : null, t;
    });
  }
  getColumnIndexOffset() {
    return 0;
  }
  getStickyColumns(e) {
    return this.getVisibleColumns(e, !0).filter((n) => n.fixed);
  }
  _getFixedColumnsCore() {
    const e = this, t = [], n = e.getRowCount(), s = e._isColumnFixing(), o = {
      command: "transparent"
    };
    let r = 0, a, l, d;
    if (s)
      for (let u = 0; u <= n; u++) {
        a = 0, d = null, l = null;
        const c = e.getVisibleColumns(u, !0);
        for (let h = 0; h < c.length; h++) {
          const g = c[h - 1], m = c[h];
          !m.fixed || m.fixedPosition === je.Sticky ? (u === 0 && (m.isBand && m.colspan ? r += m.colspan : r++), a++, f(l) || (l = h)) : g && g.fixed && cb(e, g) !== cb(e, m) ? f(l) || (l = h) : d = m.fixedPosition;
        }
        if (u === 0 && (a === 0 || a >= c.length))
          return [];
        f(l) || (l = d === "right" ? 0 : c.length), t[u] = c.slice(0), o.colspan || (o.colspan = r), t[u].splice(l, a, o);
      }
    return t.map((u) => u.map((c) => {
      const h = I({}, c);
      return h.headerId && (h.headerId += "-fixed"), h;
    }));
  }
  _isColumnFixing() {
    let e = this.option("columnFixing.enabled");
    return !e && y(this._columns, (t, n) => {
      if (n.fixed)
        return e = !0, !1;
    }), e;
  }
  _getExpandColumnsCore() {
    return this.getGroupColumns();
  }
  getExpandColumns() {
    let e = this._getExpandColumnsCore(), t;
    const n = e.filter((a) => a.groupIndex === 0)[0], s = n && n.fixed, o = this._isColumnFixing(), r = this.option("rtlEnabled");
    return e.length && (t = this.columnOption("command:expand")), e = mt(e, (a) => x({}, a, {
      visibleWidth: null,
      minWidth: null,
      cellTemplate: f(a.groupIndex) ? null : a.cellTemplate,
      headerCellTemplate: null,
      fixed: !f(a.groupIndex) || !s ? o : !0,
      fixedPosition: r ? "right" : "left"
    }, t, {
      index: a.index,
      type: a.type || zs
    })), e;
  }
  getBandColumnsCache() {
    if (!this._bandColumnsCache) {
      const e = this._columns, t = {}, n = {};
      let s = !0;
      e.forEach((o) => {
        const {
          ownerBand: r
        } = o;
        let a = X(r) ? r.index : r;
        const l = e[a];
        o.hasColumns && (s = !1), o.colspan && (o.colspan = void 0), o.rowspan && (o.rowspan = void 0), l ? n[o.index] = l : a = -1, t[a] = t[a] || [], t[a].push(o);
      }), this._bandColumnsCache = {
        isPlain: s,
        columnChildrenByIndex: t,
        columnParentByIndex: n
      };
    }
    return this._bandColumnsCache;
  }
  _isColumnVisible(e) {
    return e.visible && this.isParentColumnVisible(e.index);
  }
  _isColumnInGroupPanel(e) {
    return f(e.groupIndex) && !e.showWhenGrouped;
  }
  hasVisibleDataColumns() {
    return this._columns.some((t) => {
      const n = this._isColumnVisible(t), s = this._isColumnInGroupPanel(t), o = !!t.command;
      return n && !s && !o;
    });
  }
  _compileVisibleColumnsCore() {
    const e = this.getBandColumnsCache(), t = gb(this, this._columns, this._commandColumns, !0);
    Zj(this, t, e);
    const n = this._getIndexedColumns(t), s = this._getVisibleColumnsFromIndexed(n);
    return !this.hasVisibleDataColumns() && this._columns.length && s[s.length - 1].push({
      command: "empty"
    }), s;
  }
  _getIndexedColumns(e) {
    const t = this.option("rtlEnabled"), n = this.getRowCount(), s = dq(e.length), o = this.getBandColumnsCache(), r = [], a = [];
    for (let l = 0; l < n; l += 1)
      a[l] = [{}], r[l] = [{}, {}, {}];
    return e.forEach((l) => {
      let {
        visibleIndex: d
      } = l, u;
      const c = Ji(l.index, o.columnParentByIndex), h = this._isColumnVisible(l), g = this._isColumnInGroupPanel(l);
      if (h && !g) {
        const v = c.length;
        if (d < 0)
          d = -d, u = a[v];
        else {
          var m, C;
          if (l.fixed = ((m = c[0]) === null || m === void 0 ? void 0 : m.fixed) ?? l.fixed, l.fixedPosition = ((C = c[0]) === null || C === void 0 ? void 0 : C.fixedPosition) ?? l.fixedPosition, l.fixed && l.fixedPosition !== je.Sticky) {
            const E = !!l.command && !F.isCustomCommandColumn(this._columns, l);
            let T = l.fixedPosition === "right";
            t && !E && (T = !T), u = T ? r[v][2] : r[v][0];
          } else
            u = r[v][1];
        }
        if (c.length) {
          d = pb(d, s);
          for (let E = c.length - 1; E >= 0; E -= 1)
            d = pb(c[E].visibleIndex, s) + d;
        }
        u[d] = u[d] || [], u[d].push(l);
      }
    }), {
      positiveIndexedColumns: r,
      negativeIndexedColumns: a
    };
  }
  _getVisibleColumnsFromIndexed(e) {
    let {
      positiveIndexedColumns: t,
      negativeIndexedColumns: n
    } = e;
    const s = [], o = this.getRowCount(), r = gb(this, this.getExpandColumns(), this._columns);
    let a = 0, l = 0;
    for (let d = 0; d < o; d += 1) {
      s.push([]), Bg(n[d], (h, g) => {
        s[d].unshift.apply(s[d], g);
      });
      const u = s[d].length;
      t[d].forEach((h) => {
        Bg(h, (g, m) => {
          s[d].push.apply(s[d], m);
        });
      }), l <= d && (l += hb.call(this, s[d], r, Lj, u)), a <= d && (a += hb.call(this, s[d], r, zs, u));
    }
    return s.push(fO(s)), s;
  }
  getInvisibleColumns(e, t) {
    const n = this;
    let s = [], o;
    return e = e || n._columns, y(e, (r, a) => {
      if (a.ownerBand === t) {
        if (a.isBand) {
          a.visible ? o = n.getInvisibleColumns(n.getChildrenByBandColumn(a.index), a.index) : o = n.getChildrenByBandColumn(a.index), o.length && (s.push(a), s = s.concat(o));
          return;
        }
        a.visible || s.push(a);
      }
    }), s;
  }
  getChooserColumns(e) {
    const n = (e ? this.getColumns() : this.getInvisibleColumns()).filter((o) => o.showInColumnChooser), s = this.option("columnChooser.sortOrder");
    return cq(n, s);
  }
  allowMoveColumn(e, t, n, s) {
    const o = Dp(this, e, n), r = this._columns[o];
    return r && (r.allowReordering || r.allowGrouping || r.allowHiding) ? n === s ? n === Ar ? !1 : (e = X(e) ? e.columnIndex : e, t = X(t) ? t.columnIndex : t, e !== t && e + 1 !== t) : n === Or && s !== Ar || s === Or ? r && r.allowGrouping : n === Ar || s === Ar ? r && r.allowHiding : !0 : !1;
  }
  moveColumn(e, t, n, s) {
    const o = this, r = {};
    let a;
    const l = Dp(o, e, n), d = Dp(o, t, s);
    let u;
    if (l >= 0) {
      const c = o._columns[l];
      if (t = X(t) ? t.columnIndex : t, u = d >= 0 ? o._columns[d].groupIndex : -1, f(c.groupIndex) && n === Or && (u > c.groupIndex && u--, s !== Or ? r.groupIndex = void 0 : (a = c.groupIndex, delete c.groupIndex, mO(o))), s === Or)
        r.groupIndex = iq(o, c, u), c.groupIndex = a;
      else if (t >= 0) {
        const g = o._columns[d];
        !g || c.ownerBand !== g.ownerBand || mb(o, c) ^ mb(o, g) ? r.visibleIndex = ib : r.visibleIndex = g.visibleIndex;
      }
      const h = s !== Ar;
      c.visible !== h && (r.visible = h), o.columnOption(c.index, r);
    }
  }
  changeSortOrder(e, t) {
    const n = this, s = {}, o = n.option("sorting"), r = o && o.mode, a = r === "single" || !t, l = r === "single" || r === "multiple", d = n._columns[e];
    l && d && d.allowSorting && (a && !f(d.groupIndex) && y(n._columns, function(u) {
      u !== e && this.sortOrder && (f(this.groupIndex) || delete this.sortOrder, delete this.sortIndex);
    }), vc(t) ? d.sortOrder !== t && (s.sortOrder = t) : t === "none" ? d.sortOrder && (s.sortIndex = void 0, s.sortOrder = void 0) : function(u) {
      if (t === "ctrl") {
        if (!("sortOrder" in u && "sortIndex" in u))
          return !1;
        s.sortOrder = void 0, s.sortIndex = void 0;
      } else
        f(u.groupIndex) || f(u.sortIndex) ? s.sortOrder = u.sortOrder === "desc" ? "asc" : "desc" : s.sortOrder = "asc";
      return !0;
    }(d)), n.columnOption(d.index, s);
  }
  getSortDataSourceParameters(e) {
    const t = [], n = [];
    return y(this._columns, function() {
      (this.dataField || this.selector || this.calculateCellValue) && f(this.sortIndex) && !f(this.groupIndex) && (t[this.sortIndex] = this);
    }), y(t, function() {
      const s = this && this.sortOrder;
      if (vc(s)) {
        const o = {
          selector: this.calculateSortValue || this.displayField || this.calculateDisplayValue || e && this.selector || this.dataField || this.calculateCellValue,
          desc: this.sortOrder === "desc"
        };
        this.sortingMethod && (o.compare = this.sortingMethod.bind(this)), n.push(o);
      }
    }), n.length > 0 ? n : null;
  }
  getGroupDataSourceParameters(e) {
    const t = [];
    return y(this.getGroupColumns(), function() {
      const n = this.calculateGroupValue || this.displayField || this.calculateDisplayValue || e && this.selector || this.dataField || this.calculateCellValue;
      if (n) {
        const s = {
          selector: n,
          desc: this.sortOrder === "desc",
          isExpanded: !!this.autoExpandGroup
        };
        this.sortingMethod && (s.compare = this.sortingMethod.bind(this)), t.push(s);
      }
    }), t.length > 0 ? t : null;
  }
  refresh(e) {
    const t = [];
    return y(this._columns, function() {
      const {
        lookup: n
      } = this;
      if (n && !this.calculateDisplayValue) {
        if (e && n.valueMap)
          return;
        n.update && t.push(n.update());
      }
    }), W.apply(p, t).done(ph.bind(null, this));
  }
  _updateColumnOptions(e, t) {
    var n, s;
    const o = this._reinitAfterLookupChanges && ((n = this._previousColumns) === null || n === void 0 ? void 0 : n[t]);
    e.selector = e.selector ?? ((l) => e.calculateCellValue(l)), e.selector.columnIndex = t, e.selector.originalCallback = o ? ((s = this._previousColumns[t].selector) === null || s === void 0 ? void 0 : s.originalCallback) ?? e.selector : e.selector, y(["calculateSortValue", "calculateGroupValue", "calculateDisplayValue"], (l, d) => {
      const u = e[d];
      if (B(u))
        if (u.originalCallback)
          e[d].context.column = e;
        else {
          const c = {
            column: e
          };
          e[d] = function(h) {
            return u.call(c.column, h);
          }, e[d].originalCallback = u, e[d].columnIndex = t, e[d].context = c;
        }
    }), te(e.calculateDisplayValue) && (e.displayField = e.calculateDisplayValue, e.calculateDisplayValue = Be(e.displayField)), e.calculateDisplayValue && (e.displayValueMap = e.displayValueMap || {}), lb(e, e.dataType);
    const {
      lookup: r
    } = e;
    r && lb(r, r.dataType);
    const a = r ? r.dataType : e.dataType;
    a && (e.alignment = e.alignment || Qj(a, this.option("rtlEnabled")), e.format = e.format || F.getFormatByDataType(a), e.customizeText = e.customizeText || db(a), e.defaultFilterOperations = e.defaultFilterOperations || !r && Wj[a] || [], f(e.filterOperations) || cO(e), e.defaultFilterOperation = e.filterOperations && e.filterOperations[0] || "=", e.showEditorAlways = f(e.showEditorAlways) ? e.showEditorAlways : a === "boolean" && !e.cellTemplate && !e.lookup);
  }
  updateColumnDataTypes(e) {
    const t = this, n = t.option("dateSerializationFormat"), s = t._getFirstItems(e);
    let o = !1;
    return y(t._columns, (r, a) => {
      let l, d, u, c, h;
      const {
        lookup: g
      } = a;
      if (F.isDateType(a.dataType) && a.serializationFormat === void 0 && (a.serializationFormat = n), g && F.isDateType(g.dataType) && a.serializationFormat === void 0 && (g.serializationFormat = n), a.calculateCellValue && s.length) {
        if (!a.dataType || g && !g.dataType) {
          for (l = 0; l < s.length; l++)
            d = a.calculateCellValue(s[l]), a.dataType || (h = Ip(d), u = u || h, u && h && u !== h && (u = "string")), g && !g.dataType && (h = Ip(F.getDisplayValue(a, d, s[l])), c = c || h, c && h && c !== h && (c = "string"));
          (u || c) && (u && (a.dataType = u), g && c && (g.dataType = c), o = !0);
        }
        if (a.serializationFormat === void 0 || g && g.serializationFormat === void 0)
          for (l = 0; l < s.length; l++)
            d = a.calculateCellValue(s[l], !0), a.serializationFormat === void 0 && (a.serializationFormat = ab(a.dataType, d)), g && g.serializationFormat === void 0 && (g.serializationFormat = ab(g.dataType, g.calculateCellValue(d, !0)));
      }
      t._updateColumnOptions(a, r);
    }), o;
  }
  _customizeColumns(e) {
    const t = this, n = t.option("customizeColumns");
    n && (e.some((o) => X(o.ownerBand)) && xo(t), n(e), Rr(t, bo(t, e)));
  }
  updateColumns(e, t, n) {
    if (t || this.updateSortingGrouping(e), !e || e.isLoaded()) {
      const s = e ? e.sort() || [] : this.getSortDataSourceParameters(), o = e ? e.group() || [] : this.getGroupDataSourceParameters(), r = e?.lastLoadOptions().filter;
      n || this._customizeColumns(this._columns), xo(this);
      const a = this._columns;
      return W(this.refresh(!0)).always(() => {
        this._columns === a && (this._updateChanges(e, {
          sorting: s,
          grouping: o,
          filtering: r
        }), Oa(this));
      });
    }
  }
  _updateChanges(e, t) {
    var n;
    const s = e == null || (n = e.loadOptions) === null || n === void 0 || (n = n.call(e)) === null || n === void 0 ? void 0 : n.langParams;
    e && (this.updateColumnDataTypes(e), this._dataSourceApplied = !0), F.equalSortParameters(t.sorting, this.getSortDataSourceParameters()) || vi(this, "sorting"), F.equalSortParameters(t.grouping, this.getGroupDataSourceParameters()) || vi(this, "grouping"), this._dataController && !F.equalFilterParameters(t.filtering, this._dataController.getCombinedFilter(), s) && vi(this, "filtering"), vi(this, "columns");
  }
  updateSortingGrouping(e, t) {
    const n = this;
    let s;
    const o = function(a, l, d) {
      y(a, (u, c) => {
        if (delete c[d], l)
          for (let h = 0; h < l.length; h++) {
            const {
              selector: g
            } = l[h], {
              isExpanded: m
            } = l[h];
            if (g === c.dataField || g === c.name || g === c.displayField || g === c.selector || g === c.calculateCellValue || g === c.calculateGroupValue || g === c.calculateDisplayValue) {
              t ? c.sortOrder = "sortOrder" in c ? c.sortOrder : l[h].desc ? "desc" : "asc" : c.sortOrder = c.sortOrder || (l[h].desc ? "desc" : "asc"), m !== void 0 && (c.autoExpandGroup = m), c[d] = h;
              break;
            }
          }
      });
    };
    if (e) {
      var r;
      const a = F.normalizeSortingInfo(e.sort()), l = F.normalizeSortingInfo(e.group()), d = n.getGroupDataSourceParameters(), u = n.getSortDataSourceParameters(), c = (r = this._columnChanges) === null || r === void 0 ? void 0 : r.changeTypes, h = !F.equalSortParameters(a, u), g = t && !(c != null && c.sorting), m = t && !(c != null && c.grouping), C = !F.equalSortParameters(l, d, !0), v = !C && !F.equalSortParameters(l, d);
      n._columns.length || (y(l, (E, T) => {
        n._columns.push(T.selector);
      }), y(a, (E, T) => {
        B(T.selector) || n._columns.push(T.selector);
      }), Rr(n, bo(n, n._columns))), (m || !d && !n._hasUserState) && (C || v) && (o(n._columns, l, "groupIndex"), t && (C && vi(n, "grouping"), v && vi(n, "groupExpanding"), s = !0)), (g || !u && !n._hasUserState) && h && (o(n._columns, a, "sortIndex"), t && (vi(n, "sorting"), s = !0)), s && Oa(n);
    }
  }
  updateFilter(e, t, n, s) {
    const o = this;
    if (!Array.isArray(e))
      return e;
    if (e = x([], e), n = e.columnIndex !== void 0 ? e.columnIndex : n, s = e.filterValue !== void 0 ? e.filterValue : s, te(e[0]) && e[0] !== "!") {
      const r = o.columnOption(e[0]);
      t ? Pe().forceIsoDateParsing && r && r.serializeValue && e.length > 1 && (e[e.length - 1] = r.serializeValue(e[e.length - 1], "filter")) : r && r.selector && (e[0] = r.selector, e[0].columnIndex = r.index);
    } else
      B(e[0]) && (e[0].columnIndex = n, e[0].filterValue = s, e[0].selectedFilterOperation = e.selectedFilterOperation);
    for (let r = 0; r < e.length; r++)
      e[r] = o.updateFilter(e[r], t, n, s);
    return e;
  }
  columnCount() {
    return this._columns ? this._columns.length : 0;
  }
  columnOption(e, t, n, s) {
    const o = this, r = o._columns.concat(o._commandColumns), a = fb(r, e);
    if (a) {
      if (arguments.length === 1)
        return x({}, a);
      if (te(t)) {
        if (arguments.length === 2)
          return Tp(o, a, t);
        Tp(o, a, t, n, s);
      } else
        X(t) && y(t, (l, d) => {
          Tp(o, a, l, d, s);
        });
      Oa(o);
    }
  }
  clearSorting() {
    const e = this, t = this.columnCount();
    e.beginUpdate();
    for (let n = 0; n < t; n++)
      e.columnOption(n, "sortOrder", void 0), delete fb(e._columns, n).sortOrder;
    e.endUpdate();
  }
  clearGrouping() {
    const e = this, t = this.columnCount();
    e.beginUpdate();
    for (let n = 0; n < t; n++)
      e.columnOption(n, "groupIndex", void 0);
    e.endUpdate();
  }
  getVisibleIndex(e, t) {
    const n = this.getVisibleColumns(t);
    for (let s = n.length - 1; s >= 0; s--)
      if (n[s].index === e)
        return s;
    return -1;
  }
  getVisibleIndexByColumn(e, t) {
    const n = this.getVisibleColumns(t), s = n.filter((o) => o.index === e.index && o.command === e.command)[0];
    return n.indexOf(s);
  }
  getVisibleColumnIndex(e, t) {
    const n = this.columnOption(e, "index");
    return this.getVisibleIndex(n, t);
  }
  addColumn(e) {
    const t = this;
    let n = hh(t, e);
    const s = t._columns.length;
    t._columns.push(n), n.isBand && (t._columns = bo(t, t._columns), n = t._columns[s]), n.added = e, xo(t, n), t.updateColumns(t._dataSource), t._checkColumns();
  }
  deleteColumn(e) {
    const t = this, n = t.columnOption(e);
    if (n && n.index >= 0) {
      if (uq(t._columns), t._columns.splice(n.index, 1), n.isBand) {
        const s = t.getChildrenByBandColumn(n.index).map((o) => o.index);
        t._columns = t._columns.filter((o) => s.indexOf(o.index) < 0);
      }
      xo(t), t.updateColumns(t._dataSource);
    }
  }
  addCommandColumn(e) {
    let t = this._commandColumns.filter((n) => n.command === e.command)[0];
    t || (t = e, this._commandColumns.push(t));
  }
  getUserState() {
    const e = this._columns, t = [];
    let n;
    function s(o, r) {
      e[n][r] !== void 0 && (t[n][r] = e[n][r]);
    }
    for (n = 0; n < e.length; n++)
      t[n] = {}, y(Cc, s);
    return t;
  }
  setName(e) {
    e.name = e.name || e.dataField || e.type;
  }
  setUserState(e) {
    const t = this, n = t._dataSource;
    let s = t.option("stateStoring.ignoreColumnOptionNames");
    if (e?.forEach(this.setName), !s) {
      s = [];
      const o = t.getCommonSettings();
      t.option("columnChooser.enabled") || s.push("visible"), t.option("sorting.mode") === "none" && s.push("sortIndex", "sortOrder"), o.allowGrouping || s.push("groupIndex"), o.allowFixing || s.push("fixed", "fixedPosition"), o.allowResizing || s.push("width", "visibleWidth");
      const r = !t.option("filterPanel.visible");
      !t.option("filterRow.visible") && r && s.push("filterValue", "selectedFilterOperation"), !t.option("headerFilter.visible") && r && s.push("filterValues", "filterType");
    }
    t._columnsUserState = e, t._ignoreColumnOptionNames = s, t._hasUserState = !!e, vi(t, "filtering"), t.init(!0), n && (n.sort(t.getSortDataSourceParameters()), n.group(t.getGroupDataSourceParameters()));
  }
  _checkColumns() {
    const e = {};
    let t = !1;
    const n = [];
    this._columns.forEach((s) => {
      var o;
      const {
        name: r
      } = s, a = (o = s.columns) === null || o === void 0 ? void 0 : o.length, l = s.allowEditing && (s.dataField || s.setCellValue) && !a;
      r ? (e[r] && n.push(`"${r}"`), e[r] = !0) : l && (t = !0);
    }), n.length && _e.log("E1059", n.join(", ")), t && _e.log("E1060");
  }
  _createCalculatedColumnOptions(e, t) {
    let n = {}, {
      dataField: s
    } = e;
    if ((Array.isArray(e.columns) && e.columns.length || e.isBand) && (n.isBand = !0, s = null), s) {
      if (te(s)) {
        const o = Be(s);
        n = {
          caption: ZE.captionize(s),
          calculateCellValue(r, a) {
            const l = o(r);
            return this.deserializeValue && !a ? this.deserializeValue(l) : l;
          },
          setCellValue: aq,
          parseValue(r) {
            const a = this;
            let l, d;
            return a.dataType === "number" ? te(r) && a.format ? l = hq(r.trim(), a.format) : f(r) && $e(r) && (l = Number(r)) : a.dataType === "boolean" ? r === a.trueText ? l = !0 : r === a.falseText && (l = !1) : F.isDateType(a.dataType) ? (d = ue.parse(r, a.format), d && (l = d)) : l = r, l;
          }
        };
      }
      n.allowFiltering = !0;
    } else
      n.allowFiltering = !!e.calculateFilterExpression;
    return n.calculateFilterExpression = function() {
      return or.defaultCalculateFilterExpression.apply(this, arguments);
    }, n.defaultFilterOperation = "=", n.createFilterExpression = function(o, r) {
      let a;
      return this.calculateFilterExpression && (a = this.calculateFilterExpression.apply(this, arguments)), B(a) && (a = [a, "=", !0]), a && (a.columnIndex = this.index, a.filterValue = o, a.selectedFilterOperation = r), a;
    }, (!s || !te(s)) && x(!0, n, {
      allowSorting: !1,
      allowGrouping: !1,
      calculateCellValue: () => null
    }), t && (n.allowFixing = !1), e.dataType && (n.userDataType = e.dataType), e.selectedFilterOperation && !("defaultSelectedFilterOperation" in n) && (n.defaultSelectedFilterOperation = e.selectedFilterOperation), e.lookup && (n.lookup = {
      calculateCellValue(o, r) {
        return this.valueExpr && (o = this.valueMap && this.valueMap[o]), this.deserializeValue && !r ? this.deserializeValue(o) : o;
      },
      updateValueMap() {
        if (this.valueMap = {}, this.items) {
          const o = Be(this.valueExpr), r = Be(this.displayExpr);
          for (let a = 0; a < this.items.length; a++) {
            const l = this.items[a], d = r(l);
            this.valueMap[o(l)] = d, this.dataType = this.dataType || Ip(d);
          }
        }
      },
      update() {
        const o = this;
        let {
          dataSource: r
        } = o;
        if (r)
          if (B(r) && !Bt.isWrapped(r) && (r = r({})), pe(r) || r instanceof Oi || Array.isArray(r)) {
            if (o.valueExpr) {
              const a = lo(r);
              return a.paginate = !1, r = new In(a), r.load().done((l) => {
                o.items = l, o.updateValueMap && o.updateValueMap();
              });
            }
          } else
            _e.log("E1016");
        else
          o.updateValueMap && o.updateValueMap();
      }
    }), n.resizedCallbacks = Ie(), e.resized && n.resizedCallbacks.add(e.resized.bind(e)), y(n, (o) => {
      if (B(n[o]) && o.indexOf("default") !== 0) {
        const r = `default${o.charAt(0).toUpperCase()}${o.substr(1)}`;
        n[r] = n[o];
      }
    }), n;
  }
  getRowCount() {
    return this._rowCount = this._rowCount || lq(this), this._rowCount;
  }
  getRowIndex(e, t) {
    const n = this._columns[e], s = this.getBandColumnsCache();
    return n && (t || n.visible && !(n.command || f(n.groupIndex))) ? Ji(e, s.columnParentByIndex).length : 0;
  }
  getChildrenByBandColumn(e, t) {
    const n = this.getBandColumnsCache(), s = hO(e, n.columnChildrenByIndex, !t);
    return t ? s.filter((o) => o.visible && !o.command).sort((o, r) => o.visibleIndex - r.visibleIndex) : s;
  }
  getVisibleDataColumnsByBandColumn(e) {
    const t = this.getBandColumnsCache();
    return this.getChildrenByBandColumn(e, t.columnChildrenByIndex).filter((s) => !s.isBand && s.visible);
  }
  isParentBandColumn(e, t) {
    let n = !1;
    const s = this._columns[e], o = this.getBandColumnsCache(), r = s && Ji(e, o.columnParentByIndex);
    return r && y(r, (a, l) => {
      if (l.index === t)
        return n = !0, !1;
    }), n;
  }
  isParentColumnVisible(e) {
    let t = !0;
    const n = this.getBandColumnsCache(), s = e >= 0 && Ji(e, n.columnParentByIndex);
    return s && y(s, (o, r) => (t = t && r.visible, t)), t;
  }
  getParentColumn(e) {
    const t = this.getBandColumnsCache();
    return Ji(e.index, t.columnParentByIndex)[0];
  }
  isFirstColumn(e, t) {
    let n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : !1, s = arguments.length > 3 ? arguments[3] : void 0;
    return _b(this, e, t, n, !1, s);
  }
  isLastColumn(e, t) {
    let n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : !1, s = arguments.length > 3 ? arguments[3] : void 0;
    return _b(this, e, t, n, !0, s);
  }
  getColumnId(e) {
    return e.command && e.type === zs ? F.isCustomCommandColumn(this._columns, e) ? `type:${e.type}` : `command:${e.command}` : e.index;
  }
  getCustomizeTextByDataType(e) {
    return db(e);
  }
  getHeaderContentAlignment(e) {
    return this.option("rtlEnabled") ? e === "left" ? "right" : "left" : e;
  }
  isVirtualMode() {
    return !1;
  }
}
const Cb = {
  defaultOptions: () => ({
    commonColumnSettings: {
      allowFiltering: !0,
      allowHiding: !0,
      allowSorting: !0,
      allowEditing: !0,
      encodeHtml: !0,
      trueText: S.format("dxDataGrid-trueText"),
      falseText: S.format("dxDataGrid-falseText")
    },
    allowColumnReordering: !1,
    allowColumnResizing: !1,
    columnResizingMode: "nextColumn",
    columnMinWidth: void 0,
    columnWidth: void 0,
    adaptColumnWidthByRatio: !0,
    columns: void 0,
    regenerateColumnsByVisibleItems: !1,
    customizeColumns: null,
    dateSerializationFormat: void 0
  }),
  controllers: {
    columns: gq
  }
};
J.registerModule("columns", {
  defaultOptions: () => x(!0, {}, Cb.defaultOptions(), {
    commonColumnSettings: {
      allowExporting: !0
    }
  }),
  controllers: Cb.controllers
});
const Ru = function(i, e) {
  const t = e(i);
  if (X(t))
    try {
      return JSON.stringify(t);
    } catch {
      return t;
    }
  return t;
}, mq = function(i, e, t, n) {
  const s = Ru(i, n);
  return e[t[s]];
}, fq = function(i, e) {
  if (i.length !== e.length)
    return !1;
  for (let t = 0; t < e.length; t++)
    if (i[t] !== e[t])
      return !1;
  return !0;
}, vO = function(i, e, t, n) {
  const s = {}, o = {};
  let r = 0, a = 0;
  const l = [];
  i.forEach(function(u, c) {
    const h = Ru(u, t);
    s[h] = c;
  }), e.forEach(function(u, c) {
    const h = Ru(u, t);
    o[h] = c;
  });
  const d = Math.max(i.length, e.length);
  for (let u = 0; u < d + r; u++) {
    const c = e[u], h = u - r + a, g = i[h];
    if (!c || g && !mq(g, e, o, t))
      g && (l.push({
        type: "remove",
        key: t(g),
        index: u,
        oldItem: g
      }), a++, u--);
    else {
      const C = Ru(c, t), v = s[C], E = i[v];
      if (!E)
        r++, l.push({
          type: "insert",
          data: c,
          index: u
        });
      else if (v === h)
        n(E, c) || l.push({
          type: "update",
          data: c,
          key: t(c),
          index: u,
          oldItem: E
        });
      else
        return;
    }
  }
  return l;
}, _q = {
  load: () => w().reject(),
  loadSingle: () => w().reject(),
  loadFromStore: () => w().reject(),
  loadNextPage: () => w().reject(),
  loadOptions: M,
  userData: M,
  cancel: M,
  cancelAll: M,
  filter: M,
  addSearchFilter: M,
  group: M,
  paginate: M,
  pageSize: M,
  pageIndex: M,
  resetDataSourcePageIndex: M,
  totalCount: M,
  isLastPage: M,
  isLoading: M,
  isLoaded: M,
  searchValue: M,
  searchOperation: M,
  searchExpr: M,
  select: M,
  key: M,
  keyOf: M,
  store: M,
  items: M,
  applyMapFunction: M,
  getDataSource: M,
  reload: M,
  on: M,
  off: M
};
let xO = class {
  constructor(e) {
    if (!e)
      return _q;
    this._dataSource = e;
  }
  load() {
    return this._dataSource.load();
  }
  loadSingle(e, t) {
    return arguments.length < 2 && (t = e, e = this.key()), this._dataSource.loadSingle(e, t);
  }
  loadFromStore(e) {
    return this.store().load(e);
  }
  loadNextPage() {
    return this.pageIndex(1 + this.pageIndex()), this.load();
  }
  loadOptions() {
    return this._dataSource.loadOptions();
  }
  userData() {
    return this._dataSource._userData;
  }
  cancel(e) {
    this._dataSource.cancel(e);
  }
  cancelAll() {
    this._dataSource.cancelAll();
  }
  filter(e) {
    return this._dataSource.filter(e);
  }
  addSearchFilter(e) {
    this._dataSource._addSearchFilter(e);
  }
  group(e) {
    return this._dataSource.group(e);
  }
  paginate() {
    return this._dataSource.paginate();
  }
  pageSize() {
    return this._dataSource._pageSize;
  }
  pageIndex(e) {
    return this._dataSource.pageIndex(e);
  }
  resetDataSourcePageIndex() {
    this.pageIndex() && (this.pageIndex(0), this.load());
  }
  totalCount() {
    return this._dataSource.totalCount();
  }
  isLastPage() {
    return this._dataSource.isLastPage() || !this._dataSource._pageSize;
  }
  isLoading() {
    return this._dataSource.isLoading();
  }
  isLoaded() {
    return this._dataSource.isLoaded();
  }
  searchValue(e) {
    return arguments.length ? this._dataSource.searchValue(e) : this._dataSource.searchValue();
  }
  searchOperation(e) {
    return this._dataSource.searchOperation(e);
  }
  searchExpr(e) {
    return arguments.length ? this._dataSource.searchExpr(e) : this._dataSource.searchExpr();
  }
  select() {
    return this._dataSource.select(...arguments);
  }
  key() {
    return this._dataSource.key();
  }
  keyOf(e) {
    return this.store().keyOf(e);
  }
  store() {
    return this._dataSource.store();
  }
  items() {
    return this._dataSource.items();
  }
  applyMapFunction(e) {
    return this._dataSource._applyMapFunction(e);
  }
  getDataSource() {
    return this._dataSource || null;
  }
  reload() {
    return this._dataSource.reload();
  }
  on(e, t) {
    this._dataSource.on(e, t);
  }
  off(e, t) {
    this._dataSource.off(e, t);
  }
};
const vb = "_dataSourceChangedHandler", xb = "_getSpecificDataSourceOption", yb = "_normalizeDataSource", Cq = (i) => class extends i {
  postCtor() {
    this.on("disposing", () => {
      this._disposeDataSource();
    });
  }
  _refreshDataSource() {
    this._initDataSource(), this._loadDataSource();
  }
  _initDataSource() {
    let e = xb in this ? this[xb]() : this.option("dataSource"), t, n;
    this._disposeDataSource(), e && (e instanceof In ? (this._isSharedDataSource = !0, this._dataSource = e) : (t = "_dataSourceOptions" in this ? this._dataSourceOptions() : {}, n = this._dataSourceType ? this._dataSourceType() : In, e = lo(e, {
      fromUrlLoadMode: "_dataSourceFromUrlLoadMode" in this && this._dataSourceFromUrlLoadMode()
    }), this._dataSource = new n(x(!0, {}, t, e))), yb in this && (this._dataSource = this[yb](this._dataSource)), this._addDataSourceHandlers(), this._initDataController());
  }
  _initDataController() {
    var e;
    const t = (e = this.option) === null || e === void 0 ? void 0 : e.call(this, "_dataController"), n = this._dataSource;
    t ? this._dataController = t : this._dataController = new xO(n);
  }
  _addDataSourceHandlers() {
    vb in this && this._addDataSourceChangeHandler(), "_dataSourceLoadErrorHandler" in this && this._addDataSourceLoadErrorHandler(), "_dataSourceLoadingChangedHandler" in this && this._addDataSourceLoadingChangedHandler(), this._addReadyWatcher();
  }
  _addReadyWatcher() {
    this.readyWatcher = function(e) {
      this._ready && this._ready(!e);
    }.bind(this), this._dataSource.on("loadingChanged", this.readyWatcher);
  }
  _addDataSourceChangeHandler() {
    const e = this._dataSource;
    this._proxiedDataSourceChangedHandler = function(t) {
      this[vb](e.items(), t);
    }.bind(this), e.on("changed", this._proxiedDataSourceChangedHandler);
  }
  _addDataSourceLoadErrorHandler() {
    this._proxiedDataSourceLoadErrorHandler = this._dataSourceLoadErrorHandler.bind(this), this._dataSource.on("loadError", this._proxiedDataSourceLoadErrorHandler);
  }
  _addDataSourceLoadingChangedHandler() {
    this._proxiedDataSourceLoadingChangedHandler = this._dataSourceLoadingChangedHandler.bind(this), this._dataSource.on("loadingChanged", this._proxiedDataSourceLoadingChangedHandler);
  }
  _loadDataSource() {
    const e = this._dataSource;
    e && (e.isLoaded() ? this._proxiedDataSourceChangedHandler && this._proxiedDataSourceChangedHandler() : e.load());
  }
  _loadSingle(e, t) {
    return e = e === "this" ? this._dataSource.key() || "this" : e, this._dataSource.loadSingle(e, t);
  }
  _isLastPage() {
    return !this._dataSource || this._dataSource.isLastPage() || !this._dataSource._pageSize;
  }
  _isDataSourceLoading() {
    return this._dataSource && this._dataSource.isLoading();
  }
  _disposeDataSource() {
    this._dataSource && (this._isSharedDataSource ? (delete this._isSharedDataSource, this._proxiedDataSourceChangedHandler && this._dataSource.off("changed", this._proxiedDataSourceChangedHandler), this._proxiedDataSourceLoadErrorHandler && this._dataSource.off("loadError", this._proxiedDataSourceLoadErrorHandler), this._proxiedDataSourceLoadingChangedHandler && this._dataSource.off("loadingChanged", this._proxiedDataSourceLoadingChangedHandler), this._dataSource._eventsStrategy && this._dataSource._eventsStrategy.off("loadingChanged", this.readyWatcher)) : this._dataSource.dispose(), delete this._dataSource, delete this._proxiedDataSourceChangedHandler, delete this._proxiedDataSourceLoadErrorHandler, delete this._proxiedDataSourceLoadingChangedHandler);
  }
  getDataSource() {
    return this._dataSource || null;
  }
}, bb = function(i, e, t) {
  const n = i._dataSource;
  if (n) {
    if (t !== void 0) {
      if (i._getPagingOptionValue(e) !== t) {
        e === "pageSize" && n.pageIndex(0), n[e](t), i._skipProcessingPagingChange = !0, i.option(`paging.${e}`, t), i._skipProcessingPagingChange = !1;
        const o = n.pageIndex();
        return i._isPaging = e === "pageIndex", n[e === "pageIndex" ? "load" : "reload"]().done(() => {
          i._isPaging = !1, i.pageChanged.fire(o);
        });
      }
      return w().resolve().promise();
    }
    return n[e]();
  }
  return e === "pageIndex" && t !== void 0 ? w().resolve().promise() : 0;
};
let yO = class extends Cq(Ue.Controller) {
  init() {
    this._items = [], this._cachedProcessedItems = null, this._columnsController = this.getController("columns"), this._adaptiveColumnsController = this.getController("adaptiveColumns"), this._editingController = this.getController("editing"), this._editorFactoryController = this.getController("editorFactory"), this._errorHandlingController = this.getController("errorHandling"), this._filterSyncController = this.getController("filterSync"), this._applyFilterController = this.getController("applyFilter"), this._keyboardNavigationController = this.getController("keyboardNavigation"), this._focusController = this.getController("focus"), this._headerFilterController = this.getController("headerFilter"), this._selectionController = this.getController("selection"), this._stateStoringController = this.getController("stateStoring"), this._validatingController = this.getController("validating"), this._isPaging = !1, this._currentOperationTypes = null, this._dataChangedHandler = (e) => {
      this._currentOperationTypes = this._dataSource.operationTypes(), this._handleDataChanged(e), this._currentOperationTypes = null;
    }, this._columnsChangedHandler = this._handleColumnsChanged.bind(this), this._loadingChangedHandler = this._handleLoadingChanged.bind(this), this._loadErrorHandler = this._handleLoadError.bind(this), this._customizeStoreLoadOptionsHandler = this._handleCustomizeStoreLoadOptions.bind(this), this._changingHandler = this._handleChanging.bind(this), this._dataPushedHandler = this._handleDataPushed.bind(this), this._columnsController.columnsChanged.add(this._columnsChangedHandler), this._isLoading = !1, this._isCustomLoading = !1, this._repaintChangesOnly = void 0, this._changes = [], this.createAction("onDataErrorOccurred"), this.dataErrorOccurred.add((e) => this.executeAction("onDataErrorOccurred", {
      error: e
    })), this._refreshDataSource(), this.postCtor();
  }
  _getPagingOptionValue(e) {
    return this._dataSource[e]();
  }
  callbackNames() {
    return ["changed", "loadingChanged", "dataErrorOccurred", "pageChanged", "dataSourceChanged", "pushed"];
  }
  callbackFlags(e) {
    if (e === "dataErrorOccurred")
      return {
        stopOnFalse: !0
      };
  }
  publicMethods() {
    return ["_disposeDataSource", "beginCustomLoading", "byKey", "clearFilter", "endCustomLoading", "filter", "getCombinedFilter", "getDataByKeys", "getDataSource", "getKeyByRowIndex", "getRowIndexByKey", "getVisibleRows", "keyOf", "pageCount", "pageIndex", "pageSize", "refresh", "repaintRows", "totalCount"];
  }
  reset() {
    this._columnsController.reset(), this._items = [], this._refreshDataSource();
  }
  _handleDataSourceChange(e) {
    if (e.value === e.previousValue || this.option("columns") && Array.isArray(e.value) && Array.isArray(e.previousValue)) {
      if (e.value !== e.previousValue) {
        const n = this.store();
        n && (n._array = e.value);
      }
      return this.needToRefreshOnDataSourceChange(e) && this.refresh(this.option("repaintChangesOnly")), !0;
    }
    return !1;
  }
  needToRefreshOnDataSourceChange(e) {
    return !0;
  }
  optionChanged(e) {
    const t = this;
    let n, s;
    function o() {
      e.handled = !0;
    }
    if (e.name === "dataSource" && e.name === e.fullName && this._handleDataSourceChange(e)) {
      o();
      return;
    }
    switch (e.name) {
      case "cacheEnabled":
      case "repaintChangesOnly":
      case "highlightChanges":
      case "loadingTimeout":
        o();
        break;
      case "remoteOperations":
      case "keyExpr":
      case "dataSource":
      case "scrolling":
        o(), t.reset();
        break;
      case "paging":
        if (n = t.dataSource(), n && (s = t._setPagingOptions(n), s)) {
          const r = n.pageIndex();
          this._isPaging = s.isPageIndexChanged, n.load().done(() => {
            this._isPaging = !1, t.pageChanged.fire(r);
          });
        }
        o();
        break;
      case "rtlEnabled":
        t.reset();
        break;
      case "columns":
        n = t.dataSource(), n && n.isLoading() && e.name === e.fullName && (this._useSortingGroupingFromColumns = !0, n.load());
        break;
      default:
        super.optionChanged(e);
    }
  }
  isReady() {
    return !this._isLoading;
  }
  getDataSource() {
    return this._dataSource && this._dataSource._dataSource;
  }
  getCombinedFilter(e) {
    return this.combinedFilter(void 0, e);
  }
  combinedFilter(e, t) {
    if (!this._dataSource)
      return e;
    let n = e ?? this._dataSource.filter();
    if (this._columnsController.isDataSourceApplied() || this._columnsController.isAllDataTypesDefined()) {
      const r = this._calculateAdditionalFilter();
      n = r ? F.combineFilters([r, n]) : n;
    }
    const o = this._dataSource.remoteOperations().filtering || t;
    return n = this._columnsController.updateFilter(n, o), n;
  }
  waitReady() {
    return this._updateLockCount ? (this._readyDeferred = new w(), this._readyDeferred) : W();
  }
  _endUpdateCore() {
    const e = this._changes;
    if (e.length) {
      this._changes = [];
      const t = e.every((n) => n.repaintChangesOnly);
      this.updateItems(e.length === 1 ? e[0] : {
        repaintChangesOnly: t
      });
    }
    this._readyDeferred && (this._readyDeferred.resolve(), this._readyDeferred = null);
  }
  _handleCustomizeStoreLoadOptions(e) {
    var t;
    const n = this._columnsController, s = this._dataSource, {
      storeLoadOptions: o
    } = e;
    e.isCustomLoading && !o.isLoadingAll || (o.filter = this.combinedFilter(o.filter), ((t = o.filter) === null || t === void 0 ? void 0 : t.length) === 1 && o.filter[0] === "!" && (e.data = [], e.extra = e.extra || {}, e.extra.totalCount = 0), n.isDataSourceApplied() || n.updateColumnDataTypes(s), this._columnsUpdating = !0, n.updateSortingGrouping(s, !this._useSortingGroupingFromColumns), this._columnsUpdating = !1, o.sort = n.getSortDataSourceParameters(), o.group = n.getGroupDataSourceParameters(), s.sort(o.sort), s.group(o.group), o.sort = n.getSortDataSourceParameters(!s.remoteOperations().sorting), e.group = n.getGroupDataSourceParameters(!s.remoteOperations().grouping));
  }
  _handleColumnsChanged(e) {
    const t = this, {
      changeTypes: n
    } = e, {
      optionNames: s
    } = e;
    let o, r, a;
    const l = function(d) {
      var u, c;
      t._columnsController.columnsChanged.remove(l), t.updateItems({
        repaintChangesOnly: !1,
        event: d == null || (u = d.changeTypes) === null || u === void 0 ? void 0 : u.event,
        virtualColumnsScrolling: d == null || (c = d.changeTypes) === null || c === void 0 ? void 0 : c.virtualColumnsScrolling
      });
    };
    if (n.sorting || n.grouping)
      t._dataSource && !t._columnsUpdating && (t._dataSource.group(t._columnsController.getGroupDataSourceParameters()), t._dataSource.sort(t._columnsController.getSortDataSourceParameters()), t.reload());
    else if (n.columns && (r = t._columnsController.columnOption(e.columnIndex, "filterValues"), (s.filterValues || s.filterType && Array.isArray(r) || s.filterValue || s.selectedFilterOperation || s.allowFiltering) && (o = t._columnsController.columnOption(e.columnIndex, "filterValue"), (Array.isArray(r) || e.columnIndex === void 0 || f(o) || !s.selectedFilterOperation || s.filterValue) && (t._applyFilter(), a = !0)), !t._needApplyFilter && !F.checkChanges(s, ["width", "visibleWidth", "filterValue", "bufferedFilterValue", "selectedFilterOperation", "filterValues", "filterType"]) && t._columnsController.columnsChanged.add(l), f(s.visible))) {
      const d = t._columnsController.columnOption(e.columnIndex);
      d && (f(d.filterValue) || f(d.filterValues)) && (t._applyFilter(), a = !0);
    }
    !a && n.filtering && !this._needApplyFilter && t.reload();
  }
  _handleDataChanged(e) {
    const t = this, n = t._dataSource, s = t._columnsController;
    let o = !1;
    this._useSortingGroupingFromColumns = !1, n && !t._isDataSourceApplying && (t._isDataSourceApplying = !0, W(t._columnsController.applyDataSource(n)).done(() => {
      t._isLoading && t._handleLoadingChanged(!1), o && e && e.isDelayed && (e.isDelayed = !1), t._isDataSourceApplying = !1;
      const r = t._needApplyFilter;
      t._needApplyFilter = !1, r && !t._isAllDataTypesDefined && (() => {
        const a = t._calculateAdditionalFilter();
        return a && a.length;
      })() ? (_e.log("W1005", t.component.NAME), t._applyFilter()) : t.updateItems(e, !0);
    }).fail(() => {
      t._isDataSourceApplying = !1;
    }), t._isDataSourceApplying && (o = !0, t._handleLoadingChanged(!0)), t._needApplyFilter = !t._columnsController.isDataSourceApplied(), t._isAllDataTypesDefined = s.isAllDataTypesDefined());
  }
  _handleLoadingChanged(e) {
    this._isLoading = e, this._fireLoadingChanged();
  }
  _handleLoadError(e) {
    this.dataErrorOccurred.fire(e);
  }
  _handleDataPushed(e) {
    this.pushed.fire(e);
  }
  fireError() {
    for (var e = arguments.length, t = new Array(e), n = 0; n < e; n++)
      t[n] = arguments[n];
    this.dataErrorOccurred.fire(_e.Error.apply(_e, t));
  }
  _setPagingOptions(e) {
    const t = this.option("paging.pageIndex"), n = this.option("paging.pageSize"), s = this.option("paging.enabled"), o = this.option("scrolling.mode"), r = o === "infinite", l = s || o === "virtual" || r;
    let d = !1, u = !1, c = !1;
    return e.requireTotalCount(!r), s !== void 0 && e.paginate() !== l && (e.paginate(l), d = !0), n !== void 0 && e.pageSize() !== n && (e.pageSize(n), u = !0), t !== void 0 && e.pageIndex() !== t && (e.pageIndex(t), c = !0), d || u || c ? {
      isPaginateChanged: d,
      isPageSizeChanged: u,
      isPageIndexChanged: c
    } : !1;
  }
  _getSpecificDataSourceOption() {
    const e = this.option("dataSource");
    return Array.isArray(e) ? {
      store: {
        type: "array",
        data: e,
        key: this.option("keyExpr")
      }
    } : e;
  }
  _initDataSource() {
    const e = this, t = this._dataSource;
    super._initDataSource();
    const n = e._dataSource;
    if (e._useSortingGroupingFromColumns = !0, e._cachedProcessedItems = null, n) {
      const s = e._setPagingOptions(n);
      this._isPaging = s?.isPageIndexChanged, e.setDataSource(n);
    } else
      t && e.updateItems();
  }
  _loadDataSource() {
    const e = this, t = e._dataSource, n = new w();
    return W(this._columnsController.refresh(!0)).always(() => {
      t ? t.load().done(function() {
        e._isPaging = !1, n.resolve.apply(n, arguments);
      }).fail(n.reject) : n.resolve();
    }), n.promise();
  }
  _beforeProcessItems(e) {
    return e.slice(0);
  }
  getRowIndexDelta() {
    return 0;
  }
  getDataIndex(e) {
    const t = this._items, n = e.changeType === "append" && t.length > 0 ? t[t.length - 1] : null;
    return f(n?.dataIndex) ? n.dataIndex + 1 : 0;
  }
  _processItems(e, t) {
    const n = this, s = n.getRowIndexDelta(), {
      changeType: o
    } = t, r = n._columnsController.getVisibleColumns(null, o === "loadingAll"), a = this.getDataIndex(t), l = {
      visibleColumns: r,
      dataIndex: a
    }, d = [];
    return y(e, (u, c) => {
      f(c) && (l.rowIndex = u - s, c = n._processItem(c, l), d.push(c));
    }), d;
  }
  _processItem(e, t) {
    return e = this._generateDataItem(e, t), e = this._processDataItem(e, t), e.dataIndex = t.dataIndex++, e;
  }
  _generateDataItem(e, t) {
    return {
      rowType: "data",
      data: e,
      key: this.keyOf(e)
    };
  }
  _processDataItem(e, t) {
    return e.values = this.generateDataValues(e.data, t.visibleColumns), e;
  }
  generateDataValues(e, t, n) {
    const s = [];
    let o;
    for (let r = 0; r < t.length; r++) {
      const a = t[r];
      o = n ? void 0 : null, a.command || (a.calculateCellValue ? o = a.calculateCellValue(e) : a.dataField && (o = e[a.dataField])), s.push(o);
    }
    return s;
  }
  _applyChange(e) {
    const t = this;
    e.changeType === "update" ? t._applyChangeUpdate(e) : t.items().length && e.repaintChangesOnly && e.changeType === "refresh" ? t._applyChangesOnly(e) : e.changeType === "refresh" && t._applyChangeFull(e);
  }
  _applyChangeFull(e) {
    this._items = e.items.slice(0);
  }
  _getRowIndices(e) {
    const t = e.rowIndices.slice(0), n = this.getRowIndexDelta();
    t.sort((s, o) => s - o);
    for (let s = 0; s < t.length; s++) {
      let o = t[s];
      e.allowInvisibleRowIndices && (o += n), o < 0 && (t.splice(s, 1), s--);
    }
    return t;
  }
  _applyChangeUpdate(e) {
    const t = this, {
      items: n
    } = e, s = t._getRowIndices(e), o = t.getRowIndexDelta(), r = t.option("repaintChangesOnly");
    let a = -1, l = 0, d;
    e.items = [], e.rowIndices = [], e.columnIndices = [], e.changeTypes = [];
    const u = function(c, h, g) {
      let m = c && h && He(c.key, h.key);
      return m && g && (m = c.rowType === h.rowType && (h.rowType !== "detail" || c.isEditing === h.isEditing)), m;
    };
    y(s, (c, h) => {
      let g;
      if (h += l + o, a === h)
        return;
      a = h;
      const m = t._items[h], C = t._items[h + 1], v = n[h], E = n[h + 1], T = u(m, C) || u(v, E);
      if (v && (v.rowIndex = h, e.items.push(v)), m && v && u(m, v, T))
        d = "update", t._items[h] = v, m.visible !== v.visible ? e.items.splice(-1, 1, {
          visible: v.visible
        }) : r && !e.isFullUpdate && (g = t._partialUpdateRow(m, v, h - o));
      else if (v && !m || E && u(m, E, T))
        d = "insert", t._items.splice(h, 0, v), l++;
      else if (m && !v || C && u(v, C, T))
        d = "remove", t._items.splice(h, 1), l--, a = -1;
      else if (v)
        d = "update", t._items[h] = v;
      else
        return;
      e.rowIndices.push(h - o), e.changeTypes.push(d), e.columnIndices.push(g);
    });
  }
  _isCellChanged(e, t, n, s, o) {
    if (JSON.stringify(e.values[s]) !== JSON.stringify(t.values[s]))
      return !0;
    function r(a, l) {
      return a.modifiedValues ? a.modifiedValues[l] !== void 0 : !1;
    }
    return r(e, s) !== r(t, s);
  }
  _getChangedColumnIndices(e, t, n, s) {
    let o;
    if (e.rowType === t.rowType) {
      if (t.rowType !== "group" && t.rowType !== "groupFooter" && (o = [], t.rowType !== "detail"))
        for (let r = 0; r < e.values.length; r++)
          this._isCellChanged(e, t, n, r, s) && o.push(r);
      t.rowType === "group" && e.cells && t.isExpanded === e.isExpanded && t.data.isContinuation === e.data.isContinuation && t.data.isContinuationOnNextPage === e.data.isContinuationOnNextPage && (o = e.cells.map((a, l) => {
        var d;
        return ((d = a.column) === null || d === void 0 ? void 0 : d.type) !== "groupExpand" ? l : -1;
      }).filter((a) => a >= 0));
    }
    return o;
  }
  _partialUpdateRow(e, t, n, s) {
    var o;
    let r = this._getChangedColumnIndices(e, t, n, s);
    return (o = r) !== null && o !== void 0 && o.length && this.option("dataRowTemplate") && (r = void 0), r && (e.cells && e.cells.forEach((a, l) => {
      !(r.indexOf(l) >= 0) && a && a.update && a.update(t);
    }), t.update = e.update, t.watch = e.watch, t.cells = e.cells, s && (t.oldValues = e.values), e.update && e.update(t)), r;
  }
  _isItemEquals(e, t) {
    if (JSON.stringify(e.values) !== JSON.stringify(t.values) || ["modified", "isNewRow", "removed", "isEditing"].some((a) => e[a] !== t[a]))
      return !1;
    if (e.rowType === "group" || e.rowType === "groupFooter") {
      var n, s, o, r;
      const a = e.isExpanded === t.isExpanded, l = JSON.stringify(e.summaryCells) === JSON.stringify(t.summaryCells), d = ((n = e.data) === null || n === void 0 ? void 0 : n.isContinuation) === ((s = t.data) === null || s === void 0 ? void 0 : s.isContinuation) && ((o = e.data) === null || o === void 0 ? void 0 : o.isContinuationOnNextPage) === ((r = t.data) === null || r === void 0 ? void 0 : r.isContinuationOnNextPage);
      if (!a || !l || !d)
        return !1;
    }
    return !0;
  }
  _applyChangesOnly(e) {
    const t = [], n = [], s = [], o = [], r = {}, a = e?.isLiveUpdate ?? !0;
    function l(h) {
      if (h)
        return `${h.rowType},${JSON.stringify(h.key)}`;
    }
    const d = this._items, u = d.slice();
    e.items.forEach((h, g) => {
      const m = l(h);
      r[m] = g, h.rowIndex = g;
    });
    const c = vO(u, e.items, l, (h, g) => this._isItemEquals(h, g) ? (h.cells && (h.update && h.update(g), h.cells.forEach((m) => {
      m && m.update && m.update(g, !0);
    })), !0) : !1);
    if (!c) {
      this._applyChangeFull(e);
      return;
    }
    c.forEach((h) => {
      switch (h.type) {
        case "update": {
          const {
            index: g
          } = h, m = h.data, {
            oldItem: C
          } = h, v = this._partialUpdateRow(C, m, g, a);
          t.push(g), s.push("update"), o.push(m), d[g] = m, n.push(v);
          break;
        }
        case "insert":
          t.push(h.index), s.push("insert"), o.push(h.data), n.push(void 0), d.splice(h.index, 0, h.data);
          break;
        case "remove":
          t.push(h.index), s.push("remove"), d.splice(h.index, 1), o.push(h.oldItem), n.push(void 0);
      }
    }), e.repaintChangesOnly = !0, e.changeType = "update", e.rowIndices = t, e.columnIndices = n, e.changeTypes = s, e.items = o, u.length && (e.isLiveUpdate = !0), this._correctRowIndices((h) => {
      const g = this._rowIndexOffset || 0, m = this.getRowIndexOffset(), C = u[h - g], v = l(C), E = r[v];
      return E >= 0 ? E + m - h : 0;
    });
  }
  _correctRowIndices(e) {
  }
  _afterProcessItems(e, t) {
    return e;
  }
  _updateItemsCore(e) {
    let t;
    const n = this._dataSource, s = e.changeType || "refresh";
    if (e.changeType = s, n) {
      const o = this._cachedProcessedItems;
      e.useProcessedItemsCache && o ? t = o : (t = e.items || n.items(), t = this._beforeProcessItems(t), t = this._processItems(t, e), this._cachedProcessedItems = t), t = this._afterProcessItems(t, e), e.items = t;
      const r = this._items.length === t.length && this._items;
      this._applyChange(e);
      const a = this.getRowIndexDelta();
      y(this._items, (l, d) => {
        d.rowIndex = l - a, r && (d.cells = r[l].cells ?? []);
        const u = t[l];
        u && (d.loadIndex = u.loadIndex);
      }), this._rowIndexOffset = this.getRowIndexOffset();
    } else
      this._items = [];
  }
  _handleChanging(e) {
    const t = this.getVisibleRows();
    this.dataSource() && e.changes.forEach((s) => {
      if (s.type === "insert" && s.index >= 0) {
        let o = 0;
        for (let r = 0; r < s.index; r++) {
          const a = t[r];
          a && (a.rowType === "data" || a.rowType === "group") && o++;
        }
        s.index = o;
      }
    });
  }
  updateItems(e, t) {
    e = e || {};
    const n = this;
    if (n._repaintChangesOnly !== void 0)
      e.repaintChangesOnly = e.repaintChangesOnly ?? n._repaintChangesOnly, e.needUpdateDimensions = e.needUpdateDimensions || n._needUpdateDimensions;
    else if (e.changes)
      e.repaintChangesOnly = n.option("repaintChangesOnly");
    else if (t) {
      const s = n.dataSource().operationTypes();
      e.repaintChangesOnly = s && !s.grouping && !s.filtering && n.option("repaintChangesOnly"), e.isDataChanged = !0, s && (s.reload || s.paging || s.groupExpanding) && (e.needUpdateDimensions = !0);
    }
    if (n._updateLockCount && !e.cancel) {
      n._changes.push(e);
      return;
    }
    n._updateItemsCore(e), !e.cancel && n._fireChanged(e);
  }
  loadingOperationTypes() {
    const e = this.dataSource();
    return e && e.loadingOperationTypes() || {};
  }
  _fireChanged(e) {
    this._currentOperationTypes && (e.operationTypes = this._currentOperationTypes, this._currentOperationTypes = null), ft(() => {
      this.changed.fire(e);
    });
  }
  isLoading() {
    return this._isLoading || this._isCustomLoading;
  }
  _fireLoadingChanged() {
    this.loadingChanged.fire(this.isLoading(), this._loadingText);
  }
  _calculateAdditionalFilter() {
    return null;
  }
  _applyFilter() {
    const e = this._dataSource;
    return e ? (e.pageIndex(0), this._isFilterApplying = !0, this.reload().done(() => {
      this._isFilterApplying && this.pageChanged.fire();
    })) : new w().resolve();
  }
  resetFilterApplying() {
    this._isFilterApplying = !1;
  }
  filter(e) {
    var t;
    const n = this._dataSource, s = n?.filter(), o = n == null || (t = n.loadOptions) === null || t === void 0 || (t = t.call(n)) === null || t === void 0 ? void 0 : t.langParams;
    if (arguments.length === 0)
      return s;
    e = arguments.length > 1 ? Array.prototype.slice.call(arguments, 0) : e, !F.equalFilterParameters(s, e, o) && (n && n.filter(e), this._applyFilter());
  }
  clearFilter(e) {
    const t = this, n = t._columnsController, s = function(o) {
      const r = n.columnCount();
      for (let a = 0; a < r; a++)
        n.columnOption(a, o, void 0);
    };
    if (t.component.beginUpdate(), arguments.length > 0)
      switch (e) {
        case "dataSource":
          t.filter(null);
          break;
        case "search":
          t.searchByText("");
          break;
        case "header":
          s("filterValues");
          break;
        case "row":
          s("filterValue");
      }
    else
      t.filter(null), t.searchByText(""), s("filterValue"), s("bufferedFilterValue"), s("filterValues");
    t.component.endUpdate();
  }
  _fireDataSourceChanged() {
    const e = this, t = function() {
      e.changed.remove(t), e.dataSourceChanged.fire();
    };
    e.changed.add(t);
  }
  _getDataSourceAdapter() {
  }
  _createDataSourceAdapterCore(e, t) {
    const s = this._getDataSourceAdapter().create(this.component);
    return s.init(e, t), s;
  }
  isLocalStore() {
    return (arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : this.store()) instanceof _d;
  }
  isCustomStore(e) {
    return e = e || this.store(), e instanceof dh;
  }
  _createDataSourceAdapter(e) {
    let t = this.option("remoteOperations");
    const n = e.store(), s = {
      filtering: !0,
      sorting: !0,
      paging: !0,
      grouping: !0,
      summary: !0
    };
    return X(t) && t.groupPaging && (t = x({}, s, t)), t === "auto" && (t = this.isLocalStore(n) || this.isCustomStore(n) ? {} : {
      filtering: !0,
      sorting: !0,
      paging: !0
    }), t === !0 && (t = s), this._createDataSourceAdapterCore(e, t);
  }
  setDataSource(e) {
    const t = this, n = t._dataSource;
    !e && n && (n.cancelAll(), n.changed.remove(t._dataChangedHandler), n.loadingChanged.remove(t._loadingChangedHandler), n.loadError.remove(t._loadErrorHandler), n.customizeStoreLoadOptions.remove(t._customizeStoreLoadOptionsHandler), n.changing.remove(t._changingHandler), n.pushed.remove(t._dataPushedHandler), n.dispose(t._isSharedDataSource)), e && (e = t._createDataSourceAdapter(e)), t._dataSource = e, e && (t._fireDataSourceChanged(), t._isLoading = !e.isLoaded(), t._needApplyFilter = !0, t._isAllDataTypesDefined = t._columnsController.isAllDataTypesDefined(), e.changed.add(t._dataChangedHandler), e.loadingChanged.add(t._loadingChangedHandler), e.loadError.add(t._loadErrorHandler), e.customizeStoreLoadOptions.add(t._customizeStoreLoadOptionsHandler), e.changing.add(t._changingHandler), e.pushed.add(t._dataPushedHandler));
  }
  items(e) {
    return this._items;
  }
  isEmpty() {
    return !this.items().length;
  }
  pageCount() {
    return this._dataSource ? this._dataSource.pageCount() : 1;
  }
  dataSource() {
    return this._dataSource;
  }
  store() {
    const e = this._dataSource;
    return e && e.store();
  }
  loadAll(e) {
    let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !1;
    const n = this, s = new w(), o = n._dataSource;
    if (o)
      if (e) {
        const r = {
          data: e,
          isCustomLoading: !0,
          storeLoadOptions: {
            isLoadingAll: !0
          },
          loadOptions: {
            filter: t ? null : n.getCombinedFilter(),
            group: o.group(),
            sort: o.sort()
          }
        };
        o._handleDataLoaded(r), W(r.data).done((a) => {
          var l;
          a = n._beforeProcessItems(a), s.resolve(n._processItems(a, {
            changeType: "loadingAll"
          }), (l = r.extra) === null || l === void 0 ? void 0 : l.summary);
        }).fail(s.reject);
      } else if (o.isLoading())
        s.reject();
      else {
        const r = x({}, o.loadOptions(), {
          isLoadingAll: !0,
          requireTotalCount: !1
        });
        o.load(r).done((a, l) => {
          a = n._beforeProcessItems(a), a = n._processItems(a, {
            changeType: "loadingAll"
          }), s.resolve(a, l && l.summary);
        }).fail(s.reject);
      }
    else
      s.resolve([]);
    return s;
  }
  getKeyByRowIndex(e, t) {
    const n = this.items(t)[e];
    if (n)
      return n.key;
  }
  getRowIndexByKey(e, t) {
    return F.getIndexByKey(e, this.items(t));
  }
  keyOf(e) {
    const t = this.store();
    if (t)
      return t.keyOf(e);
  }
  byKey(e) {
    const t = this.store(), n = this.getRowIndexByKey(e);
    let s;
    if (t)
      return n >= 0 && (s = new w().resolve(this.items()[n].data)), s || t.byKey(e);
  }
  key() {
    const e = this.store();
    if (e)
      return e.key();
  }
  getRowIndexOffset(e) {
    return 0;
  }
  getDataByKeys(e) {
    const t = this, n = new w(), s = [], o = [];
    return y(e, (r, a) => {
      s.push(t.byKey(a).done((l) => {
        o[r] = l;
      }));
    }), W.apply(p, s).always(() => {
      n.resolve(o);
    }), n;
  }
  pageIndex(e) {
    return bb(this, "pageIndex", e);
  }
  pageSize(e) {
    return bb(this, "pageSize", e);
  }
  beginCustomLoading(e) {
    this._isCustomLoading = !0, this._loadingText = e || "", this._fireLoadingChanged();
  }
  endCustomLoading() {
    this._isCustomLoading = !1, this._loadingText = void 0, this._fireLoadingChanged();
  }
  refresh(e) {
    e === !0 ? e = {
      reload: !0,
      changesOnly: !0
    } : e || (e = {
      lookup: !0,
      selection: !0,
      reload: !0
    });
    const t = this, n = t.getDataSource(), {
      changesOnly: s
    } = e, o = new w(), r = function() {
      t._repaintChangesOnly = !!s;
    };
    return W(!e.lookup || t._columnsController.refresh()).always(() => {
      e.load || e.reload ? (n && n.on("customizeLoadResult", r), W(t.reload(e.reload, s)).always(() => {
        n && n.off("customizeLoadResult", r), t._repaintChangesOnly = void 0;
      }).done(o.resolve).fail(o.reject)) : (t.updateItems({
        repaintChangesOnly: e.changesOnly
      }), o.resolve());
    }), o.promise();
  }
  getVisibleRows() {
    return this.items();
  }
  _disposeDataSource() {
    this._dataSource && this._dataSource._eventsStrategy && this._dataSource._eventsStrategy.off("loadingChanged", this.readyWatcher), this.setDataSource(null);
  }
  dispose() {
    this._disposeDataSource(), super.dispose();
  }
  repaintRows(e, t) {
    e = Array.isArray(e) ? e : [e], (e.length > 1 || f(e[0])) && this.updateItems({
      changeType: "update",
      rowIndices: e,
      isFullUpdate: !t
    });
  }
  skipProcessingPagingChange(e) {
    return this._skipProcessingPagingChange && (e === "paging.pageIndex" || e === "paging.pageSize");
  }
  getUserState() {
    return {
      searchText: this.option("searchPanel.text"),
      pageIndex: this.pageIndex(),
      pageSize: this.pageSize()
    };
  }
  getCachedStoreData() {
    return this._dataSource && this._dataSource.getCachedStoreData();
  }
  isLastPageLoaded() {
    const e = this.pageIndex(), t = this.pageCount();
    return e === t - 1;
  }
  load() {
    var e;
    return (e = this._dataSource) === null || e === void 0 ? void 0 : e.load();
  }
  reload(e, t) {
    var n;
    return (n = this._dataSource) === null || n === void 0 ? void 0 : n.reload(e, t);
  }
  push() {
    for (var e, t = arguments.length, n = new Array(t), s = 0; s < t; s++)
      n[s] = arguments[s];
    return (e = this._dataSource) === null || e === void 0 ? void 0 : e.push(...n);
  }
  itemsCount() {
    var e;
    return this._dataSource ? (e = this._dataSource) === null || e === void 0 ? void 0 : e.itemsCount() : 0;
  }
  totalItemsCount() {
    var e;
    return this._dataSource ? (e = this._dataSource) === null || e === void 0 ? void 0 : e.totalItemsCount() : 0;
  }
  hasKnownLastPage() {
    var e;
    return this._dataSource ? (e = this._dataSource) === null || e === void 0 ? void 0 : e.hasKnownLastPage() : !0;
  }
  isLoaded() {
    var e;
    return this._dataSource ? (e = this._dataSource) === null || e === void 0 ? void 0 : e.isLoaded() : !0;
  }
  totalCount() {
    var e;
    return this._dataSource ? (e = this._dataSource) === null || e === void 0 ? void 0 : e.totalCount() : 0;
  }
  hasLoadOperation() {
    var e;
    const t = ((e = this._dataSource) === null || e === void 0 ? void 0 : e.operationTypes()) ?? {};
    return Object.keys(t).some((n) => t[n]);
  }
};
const vq = {
  defaultOptions: () => ({
    loadingTimeout: 0,
    dataSource: null,
    cacheEnabled: !0,
    repaintChangesOnly: !1,
    highlightChanges: !1,
    onDataErrorOccurred: null,
    remoteOperations: "auto",
    paging: {
      enabled: !0,
      pageSize: void 0,
      pageIndex: void 0
    }
  }),
  controllers: {
    data: yO
  }
}, Fu = function(i, e) {
  if (i && (i = i.slice(0), e))
    for (let t = 0; t < i.length; t++)
      i[t] = x({
        key: i[t].key
      }, i[t]), i[t].items = Fu(i[t].items, e - 1);
  return i;
}, wb = function(i, e, t) {
  let n = {
    reload: !0,
    fullReload: !0
  };
  return e && (n = {
    sorting: !F.equalSortParameters(i.sort, e.sort),
    grouping: !F.equalSortParameters(i.group, e.group, !0),
    groupExpanding: !F.equalSortParameters(i.group, e.group) || e.groupExpand,
    filtering: !F.equalFilterParameters(i.filter, e.filter, i.langParams),
    pageIndex: i.pageIndex !== e.pageIndex,
    skip: i.skip !== e.skip,
    take: i.take !== e.take,
    pageSize: i.pageSize !== e.pageSize,
    fullReload: t,
    reload: !1,
    paging: !1
  }, n.reload = t || n.sorting || n.grouping || n.filtering, n.paging = n.pageIndex || n.pageSize || n.take), n;
}, xq = function(i, e) {
  f(e) ? Wf.executeAsync(i, e) : i();
}, Aa = function() {
  return {
    items: {}
  };
}, Sb = function(i, e) {
  const t = F.normalizeSortingInfo(i.group || i.storeLoadOptions.group || i.loadOptions.group).length, n = [];
  if (bO(n, i, t))
    return n;
  e && bq(n, i, t);
}, bO = function(i, e, t, n) {
  var s;
  const {
    storeLoadOptions: o
  } = e, r = e.take ?? o.take ?? 0, a = (s = e.cachedData) === null || s === void 0 ? void 0 : s.items;
  if (r && a) {
    const l = e.skip ?? o.skip ?? 0;
    for (let d = 0; d < r; d += 1) {
      const u = n ? r - 1 - d : d, c = u + l, h = a[c];
      if (h === void 0 && c in a)
        return !0;
      const g = yq(e, h, t, u, r);
      if (g)
        i.push(g);
      else
        return !1;
    }
    return !0;
  }
  return !1;
}, yq = function(i, e, t, n, s) {
  if (t && e) {
    const o = n === 0 && i.skips || [], r = n === s - 1 && i.takes || [];
    return wO(e, t, o, r);
  }
  return e;
}, wO = function(i, e, t, n) {
  if (e && i) {
    const s = I({}, i), o = t[0] || 0, r = n[0], {
      items: a
    } = i;
    if (a) {
      if (r === void 0 && !a[o])
        return;
      s.items = [], t.length && (s.isContinuation = !0), r && (s.isContinuationOnNextPage = i.count > r);
      for (let l = 0; r === void 0 ? a[l + o] : l < r; l += 1) {
        const d = a[l + o], u = l + 1 === r, c = wO(d, e - 1, l === 0 ? t.slice(1) : [], u ? n.slice(1) : []);
        if (c !== void 0)
          s.items.push(c);
        else
          return;
      }
    }
    return s;
  }
  return i;
}, bq = function(i, e, t) {
  const n = i.length, {
    storeLoadOptions: s
  } = e;
  if (s.skip !== void 0 && s.take && !t) {
    const o = [];
    bO(o, e, t, !0);
    const r = o.length;
    (n || r) && (e.skip = e.skip ?? s.skip, e.take = e.take ?? s.take), n && (s.skip += n, s.take -= n, e.cachedDataPartBegin = i), r && (s.take -= r, e.cachedDataPartEnd = o.reverse());
  }
}, wq = function(i, e, t) {
  const {
    storeLoadOptions: n
  } = i, s = i.skip ?? n.skip ?? 0, o = i.take ?? n.take ?? 0;
  for (let r = 0; r < o; r += 1) {
    const a = r + s, l = i.cachedData.items, d = r === 0 && i.skips || [];
    l[a] = SO(l[a], e[r], t, d);
  }
}, SO = function(i, e, t, n) {
  if (t && e) {
    const s = I({}, e);
    delete s.isContinuation, delete s.isContinuationOnNextPage;
    const o = n[0] || 0;
    return e.items && (s.items = i?.items || {}, e.items.forEach((r, a) => {
      const l = a + o, d = a === 0 ? n.slice(1) : [];
      s.items[l] = SO(s.items[l], r, t - 1, d);
    })), s;
  }
  return e;
};
class Sq extends Ue.Controller {
  init(e, t) {
    const n = this;
    n._dataSource = e, n._remoteOperations = t || {}, n._isLastPage = !e.isLastPage(), n._hasLastPage = !1, n._currentTotalCount = 0, n._cachedData = Aa(), n._lastOperationTypes = {}, n._eventsStrategy = e._eventsStrategy, n._totalCountCorrection = 0, n._isLoadingAll = !1, n.changed = Ie(), n.loadingChanged = Ie(), n.loadError = Ie(), n.customizeStoreLoadOptions = Ie(), n.changing = Ie(), n.pushed = Ie(), n._dataChangedHandler = n._handleDataChanged.bind(n), n._customizeStoreLoadOptionsHandler = n._handleCustomizeStoreLoadOptions.bind(n), n._dataLoadedHandler = n._handleDataLoaded.bind(n), n._loadingChangedHandler = n._handleLoadingChanged.bind(n), n._loadErrorHandler = n._handleLoadError.bind(n), n._pushHandler = n._handlePush.bind(n), n._changingHandler = n._handleChanging.bind(n), e.on("changed", n._dataChangedHandler), e.on("customizeStoreLoadOptions", n._customizeStoreLoadOptionsHandler), e.on("customizeLoadResult", n._dataLoadedHandler), e.on("loadingChanged", n._loadingChangedHandler), e.on("loadError", n._loadErrorHandler), e.on("changing", n._changingHandler), e.store().on("beforePush", n._pushHandler), y(e, (s, o) => {
      !n[s] && B(o) && (n[s] = function() {
        return this._dataSource[s].apply(this._dataSource, arguments);
      });
    });
  }
  dispose(e) {
    const t = this._dataSource, n = t.store();
    t.off("changed", this._dataChangedHandler), t.off("customizeStoreLoadOptions", this._customizeStoreLoadOptionsHandler), t.off("customizeLoadResult", this._dataLoadedHandler), t.off("loadingChanged", this._loadingChangedHandler), t.off("loadError", this._loadErrorHandler), t.off("changing", this._changingHandler), n && n.off("beforePush", this._pushHandler), e || t.dispose();
  }
  remoteOperations() {
    return this._remoteOperations;
  }
  refresh(e, t) {
    const n = this, s = n._dataSource;
    t.reload && (n.resetCurrentTotalCount(), n._isLastPage = !s.paginate(), n._hasLastPage = n._isLastPage);
  }
  resetCurrentTotalCount() {
    this._currentTotalCount = 0, this._totalCountCorrection = 0;
  }
  resetCache() {
    this._cachedStoreData = void 0, this._cachedPagingData = void 0;
  }
  resetPagesCache(e) {
    this._cachedData = Aa();
  }
  _needClearStoreDataCache() {
    const e = this.remoteOperations(), t = wb(this._lastLoadOptions || {}, {});
    return !Object.keys(e).every((s) => !t[s] || !e[s]);
  }
  push(e, t) {
    const n = this.store();
    this._needClearStoreDataCache() && (this._cachedStoreData = void 0), this._cachedPagingData = void 0, this.resetPagesCache(!0), this._cachedStoreData && Ho({
      keyInfo: n,
      data: this._cachedStoreData,
      changes: e
    }), t || this._applyBatch(e), this.pushed.fire(e);
  }
  getDataIndexGetter() {
    if (!this._dataIndexGetter) {
      let e, t;
      const n = this.store();
      this._dataIndexGetter = (s) => {
        const o = t && t !== this._cachedStoreData;
        if (!e || o) {
          t = this._cachedStoreData || [], e = {};
          for (let r = 0; r < t.length; r++)
            e[xn(n.keyOf(t[r]))] = r;
        }
        return e[xn(n.keyOf(s))];
      };
    }
    return this._dataIndexGetter;
  }
  _getKeyInfo() {
    return this.store();
  }
  _needToCopyDataObject() {
    return !0;
  }
  _applyBatch(e, t) {
    const n = this._getKeyInfo(), s = this._dataSource, o = F.normalizeSortingInfo(this.group()).length, r = this.option("editing.refreshMode") === "reshape", a = this.option("scrolling.mode") === "virtual";
    e = e.filter((c) => !s.paginate() || c.type !== "insert" || c.index !== void 0);
    const l = () => o ? this.itemsCount() : this.items().length, d = l();
    Ho({
      keyInfo: n,
      data: this._items,
      changes: e,
      groupCount: o,
      useInsertIndex: !0,
      skipCopying: !this._needToCopyDataObject()
    }), Ho({
      keyInfo: n,
      data: s.items(),
      changes: e,
      groupCount: o,
      useInsertIndex: !0,
      skipCopying: !this._needToCopyDataObject()
    }), (this._currentTotalCount > 0 || (t || !r) && a) && (this._totalCountCorrection += l() - d), e.splice(0, e.length);
  }
  _handlePush(e) {
    let {
      changes: t
    } = e;
    this.push(t, !0);
  }
  _handleChanging(e) {
    this.changing.fire(e), this._applyBatch(e.changes, !0);
  }
  _needCleanCacheByOperation(e, t) {
    const n = ["filtering", "sorting", "paging"], s = n.indexOf(e);
    return (s >= 0 ? n.slice(s) : [e]).some((r) => t[r]);
  }
  _customizeRemoteOperations(e, t) {
    let n = this._cachedStoreData, s = this._cachedPagingData, o = this._cachedData;
    (e.storeLoadOptions.filter && !e.remoteOperations.filtering || e.storeLoadOptions.sort && !e.remoteOperations.sorting) && (e.remoteOperations = {
      filtering: e.remoteOperations.filtering,
      summary: e.remoteOperations.summary
    }), t.fullReload ? (n = void 0, s = void 0, o = Aa()) : (t.reload ? (s = void 0, o = Aa()) : t.groupExpanding && (o = Aa()), y(t, (r, a) => {
      a && this._needCleanCacheByOperation(r, e.remoteOperations) && (n = void 0, s = void 0);
    })), s && (e.remoteOperations.paging = !1), e.cachedStoreData = n, e.cachedPagingData = s, e.cachedData = o, e.isCustomLoading || (this._cachedStoreData = n, this._cachedPagingData = s, this._cachedData = o);
  }
  _handleCustomizeStoreLoadOptions(e) {
    var t;
    this._handleDataLoading(e), ((t = e.data) === null || t === void 0 ? void 0 : t.length) !== 0 && (e.data = Sb(e, !0) || e.cachedStoreData);
  }
  _handleDataLoading(e) {
    const t = this._dataSource, n = this._lastLoadOptions;
    this.customizeStoreLoadOptions.fire(e), e.delay = this.option("loadingTimeout"), e.originalStoreLoadOptions = e.storeLoadOptions, e.remoteOperations = x({}, this.remoteOperations());
    const s = !this.isLoaded() && !this._isRefreshing;
    this.option("integrationOptions.renderedOnServer") && !this.isLoaded() && (e.delay = void 0);
    const o = x({
      pageIndex: this.pageIndex(),
      pageSize: this.pageSize()
    }, e.storeLoadOptions), r = wb(o, n, s);
    if (this._customizeRemoteOperations(e, r), !e.isCustomLoading) {
      const a = this._isRefreshing;
      e.pageIndex = t.pageIndex(), e.lastLoadOptions = o, e.operationTypes = r, this._loadingOperationTypes = r, this._isRefreshing = !0, W(a || this._isRefreshed || this.refresh(e, r)).done(() => {
        this._lastOperationId === e.operationId && (this._isRefreshed = !0, this.load().always(() => {
          this._isRefreshed = !1;
        }));
      }).fail(() => {
        t.cancel(e.operationId);
      }).always(() => {
        this._isRefreshing = !1;
      }), t.cancel(this._lastOperationId), this._lastOperationId = e.operationId, this._isRefreshing && t.cancel(this._lastOperationId);
    }
    this._handleDataLoadingCore(e);
  }
  _handleDataLoadingCore(e) {
    const {
      remoteOperations: t
    } = e;
    e.loadOptions = {};
    const n = e.cachedData.extra, s = {
      filter: !t.filtering,
      sort: !t.sorting,
      group: !t.grouping,
      summary: !t.summary,
      skip: !t.paging,
      take: !t.paging,
      requireTotalCount: n && "totalCount" in n || !t.paging,
      langParams: !t.filtering || !t.sorting
    };
    y(e.storeLoadOptions, (o, r) => {
      s[o] && (e.loadOptions[o] = r, delete e.storeLoadOptions[o]);
    }), n && (e.extra = n);
  }
  _handleDataLoaded(e) {
    const {
      loadOptions: t
    } = e, n = e.remoteOperations && !e.remoteOperations.paging, {
      cachedData: s
    } = e, {
      storeLoadOptions: o
    } = e, r = this.option("cacheEnabled") !== !1 && o, a = r && !e.isCustomLoading && s && (!n || o.group), l = r && n, d = l && !e.isCustomLoading;
    if (!t) {
      this._dataSource.cancel(e.operationId);
      return;
    }
    n && (e.skip = t.skip, e.take = t.take, delete t.skip, delete t.take), t.group && (t.group = e.group || t.group);
    const u = F.normalizeSortingInfo(e.group || o.group || t.group).length;
    if (e.cachedDataPartBegin && (e.data = e.cachedDataPartBegin.concat(e.data)), e.cachedDataPartEnd && (e.data = e.data.concat(e.cachedDataPartEnd)), !a || !Sb(e)) {
      var c;
      l && e.cachedPagingData ? e.data = Fu(e.cachedPagingData, u) : (d && (this._cachedStoreData ? e.mergeStoreLoadData && (e.data = this._cachedStoreData = this._cachedStoreData.concat(e.data)) : this._cachedStoreData = Fu(e.data, F.normalizeSortingInfo(o.group).length)), new _d(e.data).load(t).done((h) => {
        e.data = h, d && (this._cachedPagingData = Fu(e.data, u));
      }).fail((h) => {
        e.data = new w().reject(h);
      })), t.requireTotalCount && n && (e.extra = pe(e.extra) ? e.extra : {}, e.extra.totalCount = e.data.length), e.extra && e.extra.totalCount >= 0 && (o.requireTotalCount === !1 || t.requireTotalCount === !1) && (e.extra.totalCount = -1), !t.data && (o.requireTotalCount || (((c = e.extra) === null || c === void 0 ? void 0 : c.totalCount) ?? -1) >= 0) && (this._totalCountCorrection = 0), this._handleDataLoadedCore(e), a && (s.extra = s.extra || x({}, e.extra), W(e.data).done((h) => {
        wq(e, h, u);
      }));
    }
    W(e.data).done(() => {
      e.lastLoadOptions && (this._lastLoadOptions = e.lastLoadOptions, Object.keys(e.operationTypes).forEach((h) => {
        this._lastOperationTypes[h] = this._lastOperationTypes[h] || e.operationTypes[h];
      }));
    }), e.storeLoadOptions = e.originalStoreLoadOptions;
  }
  _handleDataLoadedCore(e) {
    e.remoteOperations && !e.remoteOperations.paging && Array.isArray(e.data) && (e.skip !== void 0 && (e.data = e.data.slice(e.skip)), e.take !== void 0 && (e.data = e.data.slice(0, e.take)));
  }
  _handleLoadingChanged(e) {
    this.loadingChanged.fire(e);
  }
  _handleLoadError(e) {
    this.loadError.fire(e), this.changed.fire({
      changeType: "loadError",
      error: e
    });
  }
  _loadPageSize() {
    return this.pageSize();
  }
  _handleDataChanged(e) {
    let t;
    const n = this._dataSource;
    let s = !1;
    const o = !e || f(e.changeType), r = this.itemsCount();
    o && (this._isLastPage = !r || !this._loadPageSize() || r < this._loadPageSize(), this._isLastPage && (this._hasLastPage = !0)), n.totalCount() >= 0 ? n.pageIndex() >= this.pageCount() && (n.pageIndex(this.pageCount() - 1), this.pageIndex(n.pageIndex()), this.resetPagesCache(), n.load(), s = !0) : o && (t = n.pageIndex() * this.pageSize() + r, t > this._currentTotalCount && (this._currentTotalCount = t, (n.pageIndex() === 0 || !this.option("scrolling.legacyMode")) && (this._totalCountCorrection = 0)), r === 0 && n.pageIndex() >= this.pageCount() && (n.pageIndex(this.pageCount() - 1), this.option("scrolling.mode") !== "infinite" && (n.load(), s = !0))), s || (this._operationTypes = this._lastOperationTypes, this._lastOperationTypes = {}, this.component._optionCache = {}, this.changed.fire(e), this.component._optionCache = void 0);
  }
  _scheduleCustomLoadCallbacks(e) {
    const t = this;
    t._isCustomLoading = !0, e.always(() => {
      t._isCustomLoading = !1;
    });
  }
  loadingOperationTypes() {
    return this._loadingOperationTypes;
  }
  operationTypes() {
    return this._operationTypes;
  }
  lastLoadOptions() {
    return this._lastLoadOptions || {};
  }
  isLastPage() {
    return this._isLastPage;
  }
  _dataSourceTotalCount() {
    return this._dataSource.totalCount();
  }
  _changeRowExpandCore(e) {
  }
  changeRowExpand(e) {
  }
  totalCount() {
    return parseInt((this._currentTotalCount || this._dataSourceTotalCount()) + this._totalCountCorrection);
  }
  totalCountCorrection() {
    return this._totalCountCorrection;
  }
  items() {
  }
  itemsCount() {
    return this._dataSource.items().length;
  }
  totalItemsCount() {
    return this.totalCount();
  }
  pageSize() {
    const e = this._dataSource;
    return !arguments.length && !e.paginate() ? 0 : e.pageSize.apply(e, arguments);
  }
  pageCount() {
    const e = this.totalItemsCount() - this._totalCountCorrection, t = this.pageSize();
    return t && e > 0 ? Math.max(1, Math.ceil(e / t)) : 1;
  }
  hasKnownLastPage() {
    return this._hasLastPage || this._dataSource.totalCount() >= 0;
  }
  loadFromStore(e, t) {
    const n = this._dataSource, s = new w();
    if (n)
      return t = t || n.store(), t.load(e).done((o, r) => {
        o && !Array.isArray(o) && Array.isArray(o.data) && (r = o, o = o.data), s.resolve(o, r);
      }).fail(s.reject), s;
  }
  isCustomLoading() {
    return !!this._isCustomLoading;
  }
  load(e) {
    const t = this, n = t._dataSource, s = new w();
    if (e) {
      const o = n.store(), r = n.loadOptions(), a = {
        storeLoadOptions: x({}, e, {
          langParams: r?.langParams
        }),
        isCustomLoading: !0
      };
      return y(o._customLoadOptions() || [], (l, d) => {
        d in a.storeLoadOptions || (a.storeLoadOptions[d] = r[d]);
      }), this._isLoadingAll = e.isLoadingAll, t._scheduleCustomLoadCallbacks(s), n._scheduleLoadCallbacks(s), t._handleCustomizeStoreLoadOptions(a), xq(() => {
        if (!n.store())
          return s.reject("canceled");
        W(a.data || t.loadFromStore(a.storeLoadOptions)).done((l, d) => {
          a.data = l, a.extra = d || {}, t._handleDataLoaded(a), e.requireTotalCount && a.extra.totalCount === void 0 && (a.extra.totalCount = o.totalCount(a.storeLoadOptions)), W(a.data, a.extra.totalCount).done((u, c) => {
            a.extra.totalCount = c, s.resolve(u, a.extra);
          }).fail(s.reject);
        }).fail(s.reject);
      }, t.option("loadingTimeout")), s.fail(function() {
        t._eventsStrategy.fireEvent("loadError", arguments);
      }).always(() => {
        this._isLoadingAll = !1;
      }).promise();
    }
    return n.load();
  }
  reload(e) {
    return e ? this._dataSource.reload() : this._dataSource.load();
  }
  getCachedStoreData() {
    return this._cachedStoreData;
  }
  isLoaded() {
  }
  pageIndex(e) {
  }
}
let Op = Sq;
const gh = {
  extend(i) {
    Op = i(Op);
  },
  create: (i) => new Op(i)
};
class Eq extends yO {
  _getDataSourceAdapter() {
    return gh;
  }
  _getSpecificDataSourceOption() {
    const e = this.option("dataSource");
    return e && !Array.isArray(e) && this.option("keyExpr") && _e.log("W1011"), super._getSpecificDataSourceOption();
  }
}
J.registerModule("data", {
  defaultOptions: vq.defaultOptions,
  controllers: {
    data: Eq
  }
});
const EO = (i) => class extends i {
  _applyColumnState(e) {
    const t = this;
    let n, s;
    const o = t.option("sorting.mode"), {
      rootElement: r
    } = e, {
      column: a
    } = e, l = t._getIndicatorContainer(r);
    if (e.name === "sort") {
      r.find(".dx-sort").remove(), !l.children().length && l.remove();
      const d = o !== "none" && a.allowSorting, u = t.getController && !!t.getController("columns").columnOption("sortIndex:1");
      return !f(a.groupIndex) && (d || f(a.sortOrder)) && (n = a.sortOrder === "asc" ? "ascending" : "descending", s = super._applyColumnState(e).toggleClass("dx-sort-up", a.sortOrder === "asc").toggleClass("dx-sort-down", a.sortOrder === "desc"), u && t.option("sorting.showSortIndexes") && a.sortIndex >= 0 && (p("<span>").addClass("dx-sort-index-icon").text(a.sortIndex + 1).appendTo(s), s.addClass("dx-sort-index")), d && e.rootElement.addClass(t.addWidgetPrefix("action"))), this._setAriaSortAttribute(a, n, r, u), s;
    }
    return super._applyColumnState(e);
  }
  _setAriaSortAttribute(e, t, n, s) {
    if (n.removeAttr("aria-roledescription"), e.isGrouped) {
      let o = this.localize("dxDataGrid-ariaNotSortedColumn");
      f(e.sortOrder) && (o = e.sortOrder === "asc" ? this.localize("dxDataGrid-ariaSortedAscendingColumn") : this.localize("dxDataGrid-ariaSortedDescendingColumn")), this.setAria("roledescription", o, n);
    } else if (!f(e.sortOrder))
      this.setAria("sort", "none", n);
    else if (this.setAria("sort", t, n), s && e.sortIndex >= 0) {
      const o = S.format("dxDataGrid-ariaColumnHeader"), r = S.format("dxDataGrid-ariaSortIndex", e.sortIndex + 1), a = `${o}, ${r}`;
      this.setAria("roledescription", a, n);
    }
  }
  _getIndicatorClassName(e) {
    return e === "sort" ? "dx-sort" : e === "sortIndex" ? "dx-sort-index-icon" : super._getIndicatorClassName(e);
  }
  _renderIndicator(e) {
    const {
      column: t
    } = e, n = e.container, s = e.indicator;
    if (e.name === "sort") {
      const o = this.option("rtlEnabled");
      if (f(t.sortOrder) || s && s.addClass("dx-sort-none"), n.children().length && (!o && e.columnAlignment === "left" || o && e.columnAlignment === "right")) {
        n.prepend(s);
        return;
      }
    }
    super._renderIndicator(e);
  }
  _updateIndicator(e, t, n) {
    if (!(n === "sort" && f(t.groupIndex)))
      return super._updateIndicator.apply(this, arguments);
  }
  _getIndicatorElements(e, t) {
    const n = super._getIndicatorElements(e);
    return t ? n : n && n.not(".dx-sort-none");
  }
}, Iq = (i) => class extends EO(i) {
  optionChanged(e) {
    const t = this;
    e.name === "sorting" ? (t._invalidate(), e.handled = !0) : super.optionChanged(e);
  }
  _createRow(e) {
    const t = super._createRow(e);
    return e.rowType === "header" && _.on(t, R(Te, "dxDataGridColumnHeadersView"), "td", this.createAction((n) => {
      this._processHeaderAction(n.event, t);
    })), t;
  }
  _processHeaderAction(e, t) {
    if (p(e.currentTarget).parent().get(0) !== t.get(0))
      return;
    const n = this;
    let s = null;
    const o = p(e.currentTarget), r = o.parent().index();
    let a = -1;
    [].slice.call(n.getCellElements(r)).some((g, m) => {
      if (g === o.get(0))
        return a = m, !0;
    });
    const d = n._columnsController.getVisibleColumns(r)[a], u = n.getController("editing"), c = n.option("editing.mode");
    u && u.isEditing() && (c === "batch" || c === "cell") || !n._isSortableElement(p(e.target)) || d && !f(d.groupIndex) && !d.command && (e.shiftKey ? s = "shift" : bt(e) && (s = "ctrl"), setTimeout(() => {
      n._columnsController.changeSortOrder(d.index, s);
    }));
  }
  _renderCellContent(e, t) {
    const n = this, {
      column: s
    } = t;
    !s.command && t.rowType === "header" && n._applyColumnState({
      name: "sort",
      rootElement: e,
      column: s,
      showColumnLines: n.option("showColumnLines")
    }), super._renderCellContent.apply(this, arguments);
  }
  _columnOptionChanged(e) {
    const {
      changeTypes: t
    } = e;
    if (t.length === 1 && t.sorting) {
      this._updateIndicators("sort");
      return;
    }
    super._columnOptionChanged(e);
  }
}, Dq = (i) => class extends EO(i) {
  optionChanged(e) {
    const t = this;
    e.name === "sorting" ? (t._invalidate(), e.handled = !0) : super.optionChanged(e);
  }
  _createGroupPanelItem(e, t) {
    const n = this, s = super._createGroupPanelItem(...arguments);
    return _.on(s, R(Te, "dxDataGridHeaderPanel"), n.createAction(() => {
      n._processGroupItemAction(t.index);
    })), n._applyColumnState({
      name: "sort",
      rootElement: s,
      column: {
        alignment: n.option("rtlEnabled") ? "right" : "left",
        allowSorting: t.allowSorting,
        sortOrder: t.sortOrder === "desc" ? "desc" : "asc",
        isGrouped: !0
      },
      showColumnLines: !0
    }), s;
  }
  _processGroupItemAction(e) {
    setTimeout(() => this.getController("columns").changeSortOrder(e));
  }
}, Tq = {
  defaultOptions: () => ({
    sorting: {
      mode: "single",
      ascendingText: S.format("dxDataGrid-sortingAscendingText"),
      descendingText: S.format("dxDataGrid-sortingDescendingText"),
      clearText: S.format("dxDataGrid-sortingClearText"),
      showSortIndexes: !0
    }
  }),
  extenders: {
    views: {
      columnHeadersView: Iq,
      headerPanel: Dq
    }
  }
};
J.registerModule("sorting", Tq);
const xc = "vertical", IO = "horizontal", Ap = "both", DO = "dx-scrollable-content";
function TO(i, e) {
  const t = {
    left: 0,
    top: 0
  };
  let n = e;
  for (; (s = n) !== null && s !== void 0 && s.offsetParent && !n.classList.contains(i); ) {
    var s;
    const o = n.offsetParent, r = n.getBoundingClientRect(), a = o.getBoundingClientRect();
    t.left += r.left - a.left, t.top += r.top - a.top, n = n.offsetParent;
  }
  return t;
}
function OO(i, e, t, n, s) {
  let o = arguments.length > 5 && arguments[5] !== void 0 ? arguments[5] : DO;
  const r = I({
    top: 0,
    left: 0,
    right: 0,
    bottom: 0
  }, s), a = e === xc, l = a ? "top" : "left", d = a ? "bottom" : "right", u = a ? "height" : "width", c = t[`offset${ea(u)}`], h = t[`client${ea(u)}`], g = t.getBoundingClientRect()[u], m = i.getBoundingClientRect()[u];
  let C = 1;
  Math.abs(g - c) > 1 && (C = g / c);
  const v = TO(o, i)[l] / C, E = n[l], T = E - v + r[l], V = E - v - m / C + h - r[d];
  return T <= 0 && V >= 0 ? E : E - (Math.abs(T) > Math.abs(V) ? V : T);
}
const AO = function() {
  return [{
    device: () => !tn.nativeScrolling,
    options: {
      useNative: !1
    }
  }, {
    device: (i) => !z.isSimulator() && z.real().deviceType === "desktop" && i.platform === "generic",
    options: {
      bounceEnabled: !1,
      scrollByThumb: !0,
      scrollByContent: tn.touch,
      showScrollbar: "onHover"
    }
  }];
}, Pm = "dxScrollbar", Oq = "dx-scrollbar-hoverable", Eb = "horizontal", Li = {
  onScroll: "onScroll",
  onHover: "onHover",
  always: "always",
  never: "never"
};
let Nr = null;
class RO extends Rt {
  _getDefaultOptions() {
    return I({}, super._getDefaultOptions(), {
      direction: null,
      visible: !1,
      activeStateEnabled: !1,
      visibilityMode: Li.onScroll,
      containerSize: 0,
      contentSize: 0,
      expandable: !0,
      scaleRatio: 1
    });
  }
  _init() {
    super._init(), this._isHovered = !1;
  }
  _initMarkup() {
    this._renderThumb(), super._initMarkup();
  }
  _render() {
    super._render(), this._renderDirection(), this._update(), this._attachPointerDownHandler(), this.option("hoverStateEnabled", this._isHoverMode());
    const {
      hoverStateEnabled: e
    } = this.option();
    this.$element().toggleClass(Oq, e);
  }
  _renderThumb() {
    this._$thumb = p("<div>").addClass("dx-scrollable-scroll"), p("<div>").addClass("dx-scrollable-scroll-content").appendTo(this._$thumb), this.$element().addClass("dx-scrollable-scrollbar").append(this._$thumb);
  }
  isThumb(e) {
    return !!this.$element().find(e).length;
  }
  _isHoverMode() {
    const {
      visibilityMode: e,
      expandable: t
    } = this.option();
    return (e === Li.onHover || e === Li.always) && t;
  }
  _renderDirection() {
    const {
      direction: e
    } = this.option();
    this.$element().addClass(`dx-scrollbar-${e}`), this._dimension = e === Eb ? "width" : "height", this._prop = e === Eb ? "left" : "top";
  }
  _attachPointerDownHandler() {
    _.on(this._$thumb, R(ye.down, Pm), this.feedbackOn.bind(this));
  }
  feedbackOn(e) {
    e?.preventDefault(), this.$element().addClass("dx-scrollable-scrollbar-active"), Nr = this;
  }
  feedbackOff() {
    this.$element().removeClass("dx-scrollable-scrollbar-active"), Nr = null;
  }
  cursorEnter() {
    this._isHovered = !0, this._needScrollbar() && this.option("visible", !0);
  }
  cursorLeave() {
    this._isHovered = !1, this.option("visible", !1);
  }
  _renderDimensions() {
    this._$thumb.css({
      width: this.option("width"),
      height: this.option("height")
    });
  }
  _toggleVisibility(e) {
    const {
      visibilityMode: t
    } = this.option();
    t === Li.onScroll && this._$thumb.css("opacity"), e = this._adjustVisibility(e), this.option().visible = e, this._$thumb.toggleClass("dx-state-invisible", !e);
  }
  _adjustVisibility(e) {
    if (this._baseContainerToContentRatio && !this._needScrollbar())
      return !1;
    const {
      visibilityMode: t
    } = this.option();
    switch (t) {
      case Li.onScroll:
        break;
      case Li.onHover:
        e = e || !!this._isHovered;
        break;
      case Li.never:
        e = !1;
        break;
      case Li.always:
        e = !0;
    }
    return e;
  }
  moveTo(e) {
    if (this._isHidden())
      return;
    pe(e) && (e = e[this._prop] || 0);
    const t = {};
    t[this._prop] = this._calculateScrollBarPosition(e), Ot(this._$thumb, t);
  }
  _calculateScrollBarPosition(e) {
    return -e * this._thumbRatio;
  }
  _update() {
    const e = Math.round(this.option("containerSize")), t = Math.round(this.option("contentSize"));
    let n = Math.round(this.option("baseContainerSize")), s = Math.round(this.option("baseContentSize"));
    isNaN(n) && (n = e, s = t);
    const {
      scaleRatio: o
    } = this.option();
    this._baseContainerToContentRatio = s ? n / s : n, this._realContainerToContentRatio = t ? e / t : e;
    const r = Math.round(Math.max(Math.round(e * this._realContainerToContentRatio), 15));
    this._thumbRatio = (e - r) / (o * (t - e)), this.option(this._dimension, r / o), this.$element().css("display", this._needScrollbar() ? "" : "none");
  }
  _isHidden() {
    const {
      visibilityMode: e
    } = this.option();
    return e === Li.never;
  }
  _needScrollbar() {
    return !this._isHidden() && this._baseContainerToContentRatio < 1;
  }
  containerToContentRatio() {
    return this._realContainerToContentRatio;
  }
  _normalizeSize(e) {
    return pe(e) ? e[this._dimension] || 0 : e;
  }
  _clean() {
    super._clean(), this === Nr && (Nr = null), _.off(this._$thumb, `.${Pm}`);
  }
  _optionChanged(e) {
    if (!this._isHidden())
      switch (e.name) {
        case "containerSize":
        case "contentSize":
          this.option()[e.name] = this._normalizeSize(e.value), this._update();
          break;
        case "baseContentSize":
        case "baseContainerSize":
        case "scaleRatio":
          this._update();
          break;
        case "visibilityMode":
        case "direction":
          this._invalidate();
          break;
        default:
          super._optionChanged.apply(this, arguments);
      }
  }
  update() {
    Gr(() => {
      this._adjustVisibility() && this.option("visible", !0);
    })();
  }
}
Bi.add(() => {
  _.subscribeGlobal(O.getDocument(), R(ye.up, Pm), () => {
    Nr && Nr.feedbackOff();
  });
});
const Ib = "dxNativeScrollable", Aq = "dx-scrollable-scrollbar-simulated", Rq = "dx-scrollable-scrollbars-hidden", Ra = "vertical", Kd = "horizontal";
let q_ = class extends se.inherit({}) {
  ctor(e) {
    this._init(e);
  }
  _init(e) {
    this._component = e, this._$element = e.$element(), this._$container = p(e.container()), this._$content = e.$content();
    const {
      direction: t,
      useSimulatedScrollbar: n
    } = e.option();
    this._direction = t, this._useSimulatedScrollbar = n, this.option = e.option.bind(e), this._createActionByOption = e._createActionByOption.bind(e), this._isLocked = e._isLocked.bind(e), this._isDirection = e._isDirection.bind(e), this._allowedDirection = e._allowedDirection.bind(e), this._getMaxOffset = e._getMaxOffset.bind(e), this._isRtlNativeStrategy = e._isRtlNativeStrategy.bind(e);
  }
  render() {
    const t = z.real().platform;
    this._$element.addClass("dx-scrollable-native").addClass(`dx-scrollable-native-${t}`).toggleClass(Rq, !this._isScrollbarVisible()), this._isScrollbarVisible() && this._useSimulatedScrollbar && this._renderScrollbars();
  }
  updateRtlPosition(e) {
    e && this.option("rtlEnabled") && this._isScrollbarVisible() && this._useSimulatedScrollbar && this._moveScrollbars();
  }
  _renderScrollbars() {
    this._scrollbars = {}, this._hideScrollbarTimeout = 0, this._$element.addClass(Aq), this._renderScrollbar(Ra), this._renderScrollbar(Kd);
  }
  _renderScrollbar(e) {
    this._isDirection(e) && (this._scrollbars[e] = new RO(p("<div>").appendTo(this._$element), {
      direction: e,
      expandable: this._component.option("scrollByThumb")
    }));
  }
  handleInit(e) {
  }
  handleStart() {
  }
  handleMove(e) {
    if (this._isLocked()) {
      e.cancel = !0;
      return;
    }
    this._allowedDirection() && (e.originalEvent.isScrollingEvent = !0);
  }
  handleEnd() {
  }
  handleCancel() {
  }
  handleStop() {
  }
  _eachScrollbar(e) {
    e = e.bind(this), y(this._scrollbars || {}, (t, n) => {
      e(n, t);
    });
  }
  createActions() {
    this._scrollAction = this._createActionByOption("onScroll"), this._updateAction = this._createActionByOption("onUpdated");
  }
  _createActionArgs() {
    const {
      left: e,
      top: t
    } = this.location();
    return {
      event: this._eventForUserAction,
      scrollOffset: this._getScrollOffset(),
      reachedLeft: this._isRtlNativeStrategy() ? this._isReachedRight(-e) : this._isReachedLeft(e),
      reachedRight: this._isRtlNativeStrategy() ? this._isReachedLeft(-Math.abs(e)) : this._isReachedRight(e),
      reachedTop: this._isDirection(Ra) ? Math.round(t) >= 0 : void 0,
      reachedBottom: this._isDirection(Ra) ? Math.round(Math.abs(t) - this._getMaxOffset().top) >= 0 : void 0
    };
  }
  _getScrollOffset() {
    const {
      top: e,
      left: t
    } = this.location();
    return {
      top: -e,
      left: this._normalizeOffsetLeft(-t)
    };
  }
  _normalizeOffsetLeft(e) {
    return this._isRtlNativeStrategy() ? this._getMaxOffset().left + e : e;
  }
  _isReachedLeft(e) {
    return this._isDirection(Kd) ? Math.round(e) >= 0 : void 0;
  }
  _isReachedRight(e) {
    return this._isDirection(Kd) ? Math.round(Math.abs(e) - this._getMaxOffset().left) >= 0 : void 0;
  }
  _isScrollbarVisible() {
    const {
      showScrollbar: e
    } = this.option();
    return e !== "never" && e !== !1;
  }
  handleScroll(e) {
    var t;
    this._eventForUserAction = e, this._moveScrollbars(), (t = this._scrollAction) === null || t === void 0 || t.call(this, this._createActionArgs());
  }
  _moveScrollbars() {
    const {
      top: e,
      left: t
    } = this._getScrollOffset();
    this._eachScrollbar((n) => {
      n.moveTo({
        top: -e,
        left: -t
      }), n.option("visible", !0);
    }), this._hideScrollbars();
  }
  _hideScrollbars() {
    clearTimeout(this._hideScrollbarTimeout), this._hideScrollbarTimeout = setTimeout(() => {
      this._eachScrollbar((e) => {
        e.option("visible", !1);
      });
    }, 500);
  }
  location() {
    return {
      left: -this._$container.scrollLeft(),
      top: -this._$container.scrollTop()
    };
  }
  disabledChanged() {
  }
  update() {
    this._update(), this._updateAction(this._createActionArgs());
  }
  _update() {
    this._updateDimensions(), this._updateScrollbars();
  }
  _updateDimensions() {
    this._containerSize = {
      height: le(this._$container),
      width: ne(this._$container)
    }, this._componentContentSize = {
      height: le(this._component.$content()),
      width: ne(this._component.$content())
    }, this._contentSize = {
      height: le(this._$content),
      width: ne(this._$content)
    };
  }
  _updateScrollbars() {
    this._eachScrollbar(function(e, t) {
      const n = t === Ra ? "height" : "width";
      e.option({
        containerSize: this._containerSize[n],
        contentSize: this._componentContentSize[n]
      }), e.update();
    });
  }
  _allowedDirections() {
    return {
      vertical: this._isDirection(Ra) && this._contentSize.height > this._containerSize.height,
      horizontal: this._isDirection(Kd) && this._contentSize.width > this._containerSize.width
    };
  }
  dispose() {
    const {
      className: e
    } = this._$element.get(0), t = new RegExp("dx-scrollable-native\\S*", "g");
    t.test(e) && this._$element.removeClass(e.match(t).join(" ")), _.off(this._$element, `.${Ib}`), _.off(this._$container, `.${Ib}`), this._removeScrollbars(), clearTimeout(this._hideScrollbarTimeout);
  }
  _removeScrollbars() {
    this._eachScrollbar((e) => {
      e.$element().remove();
    });
  }
  scrollBy(e) {
    const t = this.location();
    this._$container.scrollTop(Math.round(-t.top - e.top)), this._$container.scrollLeft(Math.round(-t.left - e.left));
  }
  validate(e) {
    const {
      disabled: t
    } = this.option();
    return t || ln(e) && this._isScrolledInMaxDirection(e) ? !1 : !!this._allowedDirection();
  }
  _isScrolledInMaxDirection(e) {
    const t = this._$container.get(0);
    let n;
    return e.delta > 0 ? n = e.shiftKey ? !t.scrollLeft : !t.scrollTop : e.shiftKey ? n = t.scrollLeft >= this._getMaxOffset().left : n = t.scrollTop >= this._getMaxOffset().top, n;
  }
  getDirection() {
    return this._allowedDirection();
  }
};
class FO extends se.inherit({}) {
  ctor(e) {
    this._finished = !0, this._stopped = !1, this._proxiedStepCore = this._stepCore.bind(this);
  }
  start() {
    this._stopped = !1, this._finished = !1, this._stepCore();
  }
  stop() {
    this._stopped = !0, Xi(this._stepAnimationFrame);
  }
  _stepCore() {
    if (this._isStopped()) {
      this._stop();
      return;
    }
    if (this._isFinished()) {
      this._finished = !0, this._complete();
      return;
    }
    this._step(), this._stepAnimationFrame = ac(this._proxiedStepCore);
  }
  _step() {
    se.abstract();
  }
  _isFinished() {
  }
  _stop() {
  }
  _complete() {
  }
  _isStopped() {
    return this._stopped;
  }
  inProgress() {
    return !(this._stopped || this._finished);
  }
}
const kO = "dxSimulatedScrollable", Fq = "dxScrollableStrategy", Gd = `${kO}Cursor`, Rp = `${kO}Keyboard`, kq = "dx-scrollable-scrollbars-alwaysvisible", _i = "vertical", Ut = "horizontal", Vq = Math.round(1e3 / 60), Pq = 400 / Vq, Mq = (1 - 0.92 ** Pq) / (1 - 0.92), Hi = {
  PAGE_UP: "pageUp",
  PAGE_DOWN: "pageDown",
  END: "end",
  HOME: "home",
  LEFT: "leftArrow",
  UP: "upArrow",
  RIGHT: "rightArrow",
  DOWN: "downArrow",
  TAB: "tab"
};
class VO extends FO {
  constructor() {
    super(...arguments), this.VELOCITY_LIMIT = 1;
  }
  ctor(e) {
    super.ctor(), this.scroller = e;
  }
  _isFinished() {
    return Math.abs(this.scroller._velocity) <= this.VELOCITY_LIMIT;
  }
  _step() {
    this.scroller._scrollStep(this.scroller._velocity), this.scroller._velocity *= this._acceleration();
  }
  _acceleration() {
    return this.scroller._inBounds() ? 0.92 : 0.5;
  }
  _complete() {
    this.scroller._scrollComplete();
  }
}
class Bq extends VO {
  constructor() {
    super(...arguments), this.VELOCITY_LIMIT = 0.2;
  }
  _isFinished() {
    return this.scroller._crossBoundOnNextStep() || super._isFinished();
  }
  _acceleration() {
    return 0.92;
  }
  _complete() {
    this.scroller._move(this.scroller._bounceLocation), super._complete();
  }
}
class PO extends se.inherit({}) {
  ctor(e) {
    this._initOptions(e), this._initAnimators(), this._initScrollbar();
  }
  _initOptions(e) {
    this._location = 0, this._topReached = !1, this._bottomReached = !1, this._axis = e.direction === Ut ? "x" : "y", this._prop = e.direction === Ut ? "left" : "top", this._dimension = e.direction === Ut ? "width" : "height", this._scrollProp = e.direction === Ut ? "scrollLeft" : "scrollTop", y(e, (t, n) => {
      this[`_${t}`] = n;
    });
  }
  _initAnimators() {
    this._inertiaAnimator = new VO(this), this._bounceAnimator = new Bq(this);
  }
  _initScrollbar() {
    this._scrollbar = new RO(p("<div>").appendTo(this._$container), {
      direction: this._direction,
      visible: this._scrollByThumb,
      visibilityMode: this._visibilityModeNormalize(this._scrollbarVisible),
      expandable: this._scrollByThumb
    }), this._$scrollbar = this._scrollbar.$element();
  }
  _visibilityModeNormalize(e) {
    return e === !0 ? "onScroll" : e === !1 ? "never" : e;
  }
  _scrollStep(e) {
    const t = this._location;
    this._location += e, this._suppressBounce(), this._move(), !(Math.abs(t - this._location) < 1) && _.triggerHandler(this._$container, {
      type: "scroll"
    });
  }
  _suppressBounce() {
    this._bounceEnabled || this._inBounds(this._location) || (this._velocity = 0, this._location = this._boundLocation());
  }
  _boundLocation(e) {
    return e = e !== void 0 ? e : this._location, Math.max(Math.min(e, this._maxOffset), this._minOffset);
  }
  _move(e) {
    this._location = e !== void 0 ? e * this._getScaleRatio() : this._location, this._moveContent(), this._moveScrollbar();
  }
  _moveContent() {
    const e = this._location;
    this._$container[this._scrollProp](-e / this._getScaleRatio()), this._moveContentByTranslator(e);
  }
  _getScaleRatio() {
    if (ae() && !this._scaleRatio) {
      const e = this._$element.get(0), t = this._getRealDimension(e, this._dimension), n = this._getBaseDimension(e, this._dimension);
      this._scaleRatio = Math.round(t / n * 100) / 100;
    }
    return this._scaleRatio || 1;
  }
  _getRealDimension(e, t) {
    return Math.round(Ge(e)[t]);
  }
  _getBaseDimension(e, t) {
    const n = `offset${ea(t)}`;
    return e[n];
  }
  _moveContentByTranslator(e) {
    let t;
    const n = -this._maxScrollPropValue;
    if (e > 0 && (t = e), e <= n && (t = e - n), this._translateOffset === t)
      return;
    const s = {};
    if (s[this._prop] = t, this._translateOffset = t, !t) {
      id(this._$content);
      return;
    }
    Ot(this._$content, s);
  }
  _moveScrollbar() {
    this._scrollbar.moveTo(this._location);
  }
  _scrollComplete() {
    this._inBounds() && (this._hideScrollbar(), this._completeDeferred && this._completeDeferred.resolve()), this._scrollToBounds();
  }
  _scrollToBounds() {
    var e;
    this._inBounds() || ((e = this._bounceAction) === null || e === void 0 || e.call(this), this._setupBounce(), this._bounceAnimator.start());
  }
  _setupBounce() {
    const t = (this._bounceLocation = this._boundLocation()) - this._location;
    this._velocity = t / Mq;
  }
  _inBounds(e) {
    return e = e !== void 0 ? e : this._location, this._boundLocation(e) === e;
  }
  _crossBoundOnNextStep() {
    const e = this._location, t = e + this._velocity;
    return e < this._minOffset && t >= this._minOffset || e > this._maxOffset && t <= this._maxOffset;
  }
  _initHandler(e) {
    this._stopScrolling(), this._prepareThumbScrolling(e);
  }
  _stopScrolling() {
    Gr(() => {
      this._hideScrollbar(), this._inertiaAnimator.stop(), this._bounceAnimator.stop();
    })();
  }
  _prepareThumbScrolling(e) {
    if (ln(e.originalEvent))
      return;
    const t = p(e.originalEvent.target), n = this._isScrollbar(t);
    n && this._moveToMouseLocation(e), this._thumbScrolling = n || this._isThumb(t), this._crossThumbScrolling = !this._thumbScrolling && this._isAnyThumbScrolling(t), this._thumbScrolling && this._scrollbar.feedbackOn();
  }
  _isThumbScrollingHandler(e) {
    return this._isThumb(e);
  }
  _moveToMouseLocation(e) {
    const t = e[`page${this._axis.toUpperCase()}`] - this._$element.offset()[this._prop], n = this._location + t / this._containerToContentRatio() - le(this._$container) / 2;
    this._scrollStep(-Math.round(n));
  }
  _startHandler() {
    this._showScrollbar();
  }
  _moveHandler(e) {
    this._crossThumbScrolling || (this._thumbScrolling && (e[this._axis] = -Math.round(e[this._axis] / this._containerToContentRatio())), this._scrollBy(e));
  }
  _scrollBy(e) {
    e = e[this._axis], this._inBounds() || (e *= 0.5), this._scrollStep(e);
  }
  _scrollByHandler(e) {
    !e.x && !e.y || (this._scrollBy(e), this._scrollComplete());
  }
  _containerToContentRatio() {
    return this._scrollbar.containerToContentRatio();
  }
  _endHandler(e) {
    return this._completeDeferred = w(), this._velocity = e[this._axis], this._inertiaHandler(), this._resetThumbScrolling(), this._completeDeferred.promise();
  }
  _inertiaHandler() {
    this._suppressInertia(), this._inertiaAnimator.start();
  }
  _suppressInertia() {
    (!this._inertiaEnabled || this._thumbScrolling) && (this._velocity = 0);
  }
  _resetThumbScrolling() {
    this._thumbScrolling = !1, this._crossThumbScrolling = !1;
  }
  _stopHandler() {
    this._thumbScrolling && this._scrollComplete(), this._resetThumbScrolling(), this._scrollToBounds();
  }
  _disposeHandler() {
    this._stopScrolling(), this._$scrollbar.remove();
  }
  _updateHandler() {
    this._update(), this._moveToBounds();
  }
  _update() {
    return this._stopScrolling(), qt(() => {
      this._resetScaleRatio(), this._updateLocation(), this._updateBounds(), this._updateScrollbar(), ft(() => {
        this._moveScrollbar(), this._scrollbar.update();
      });
    });
  }
  _resetScaleRatio() {
    this._scaleRatio = null;
  }
  _updateLocation() {
    this._location = (Nn(this._$content)[this._prop] - this._$container[this._scrollProp]()) * this._getScaleRatio();
  }
  _updateBounds() {
    this._maxOffset = this._getMaxOffset(), this._minOffset = this._getMinOffset();
  }
  _getMaxOffset() {
    return 0;
  }
  _getMinOffset() {
    return this._maxScrollPropValue = Math.max(this._contentSize() - this._containerSize(), 0), -this._maxScrollPropValue;
  }
  _updateScrollbar() {
    $g(() => {
      const e = this._containerSize(), t = this._contentSize(), n = this._getBaseDimension(this._$container.get(0), this._dimension), s = this._getBaseDimension(this._$content.get(0), this._dimension);
      ft(() => {
        this._scrollbar.option({
          containerSize: e,
          contentSize: t,
          baseContainerSize: n,
          baseContentSize: s,
          scaleRatio: this._getScaleRatio()
        });
      });
    })();
  }
  _moveToBounds() {
    Gr($g(Gr(() => {
      const e = this._boundLocation(), t = e !== this._location;
      if (this._location = e, this._move(), t) {
        var n;
        (n = this._scrollAction) === null || n === void 0 || n.call(this);
      }
    })))();
  }
  _createActionsHandler(e) {
    this._scrollAction = e.scroll, this._bounceAction = e.bounce;
  }
  _showScrollbar() {
    this._scrollbar.option("visible", !0);
  }
  _hideScrollbar() {
    this._scrollbar.option("visible", !1);
  }
  _containerSize() {
    return this._getRealDimension(this._$container.get(0), this._dimension);
  }
  _contentSize() {
    const e = this._$content.css(`overflow${this._axis.toUpperCase()}`) === "hidden";
    let t = this._getRealDimension(this._$content.get(0), this._dimension);
    if (!e) {
      const n = this._$content[0][`scroll${ea(this._dimension)}`] * this._getScaleRatio();
      t = Math.max(n, t);
    }
    return t;
  }
  _validateEvent(e) {
    const t = p(e.originalEvent.target);
    return this._isThumb(t) || this._isScrollbar(t);
  }
  _isThumb(e) {
    return this._scrollByThumb && this._scrollbar.isThumb(e);
  }
  _isScrollbar(e) {
    return this._scrollByThumb && e?.is(this._$scrollbar);
  }
  _reachedMin() {
    return Math.round(this._location - this._minOffset) <= 0;
  }
  _reachedMax() {
    return Math.round(this._location - this._maxOffset) >= 0;
  }
  _cursorEnterHandler() {
    this._resetScaleRatio(), this._updateScrollbar(), this._scrollbar.cursorEnter();
  }
  _cursorLeaveHandler() {
    this._scrollbar.cursorLeave();
  }
  dispose() {
  }
}
let Zn, Cr;
class MO extends se.inherit({}) {
  ctor(e) {
    this._init(e);
  }
  _init(e) {
    this._component = e, this._$element = e.$element(), this._$container = p(e.container()), this._$wrapper = e._$wrapper, this._$content = e.$content(), this.option = e.option.bind(e), this._createActionByOption = e._createActionByOption.bind(e), this._isLocked = e._isLocked.bind(e), this._isDirection = e._isDirection.bind(e), this._allowedDirection = e._allowedDirection.bind(e), this._getMaxOffset = e._getMaxOffset.bind(e);
  }
  render() {
    this._$element.addClass("dx-scrollable-simulated"), this._createScrollers(), this.option("useKeyboard") && this._$container.prop("tabIndex", 0), this._attachKeyboardHandler(), this._attachCursorHandlers();
  }
  _createScrollers() {
    this._scrollers = {}, this._isDirection(Ut) && this._createScroller(Ut), this._isDirection(_i) && this._createScroller(_i), this._$element.toggleClass(kq, this.option("showScrollbar") === "always");
  }
  _createScroller(e) {
    this._scrollers[e] = new PO(this._scrollerOptions(e));
  }
  _scrollerOptions(e) {
    return {
      direction: e,
      $content: this._$content,
      $container: this._$container,
      $wrapper: this._$wrapper,
      $element: this._$element,
      scrollByThumb: this.option("scrollByThumb"),
      scrollbarVisible: this.option("showScrollbar"),
      bounceEnabled: this.option("bounceEnabled"),
      inertiaEnabled: this.option("inertiaEnabled"),
      isAnyThumbScrolling: this._isAnyThumbScrolling.bind(this)
    };
  }
  _applyScaleRatio(e) {
    for (const t in this._scrollers) {
      const n = this._getPropByDirection(t);
      if (f(e[n])) {
        const s = this._scrollers[t];
        e[n] *= s._getScaleRatio();
      }
    }
    return e;
  }
  _isAnyThumbScrolling(e) {
    let t = !1;
    return this._eventHandler("isThumbScrolling", e).done((n, s) => {
      t = n || s;
    }), t;
  }
  handleInit(e) {
    this._suppressDirections(e), this._eventForUserAction = e, this._eventHandler("init", e);
  }
  _suppressDirections(e) {
    if (ln(e.originalEvent)) {
      this._prepareDirections(!0);
      return;
    }
    this._prepareDirections(), this._eachScroller(function(t, n) {
      const s = p(e.originalEvent.target), o = t._validateEvent(e) || this.option("scrollByContent") && this._isContent(s);
      this._validDirections[n] = o;
    });
  }
  _isContent(e) {
    return !!e.closest(this._$element).length;
  }
  _prepareDirections(e) {
    e = e || !1, this._validDirections = {}, this._validDirections[Ut] = e, this._validDirections[_i] = e;
  }
  _eachScroller(e) {
    e = e.bind(this), y(this._scrollers, (t, n) => {
      e(n, t);
    });
  }
  handleStart(e) {
    this._eventForUserAction = e, this._eventHandler("start").done(this._startAction);
  }
  _saveActive() {
    Cr = this;
  }
  _resetActive() {
    Cr === this && (Cr = null);
  }
  handleMove(e) {
    var t;
    if (this._isLocked()) {
      e.cancel = !0, this._resetActive();
      return;
    }
    this._saveActive(), (t = e.preventDefault) === null || t === void 0 || t.call(e), this._adjustDistance(e, e.delta), this._eventForUserAction = e, this._eventHandler("move", e.delta);
  }
  _adjustDistance(e, t) {
    t.x *= this._validDirections[Ut], t.y *= this._validDirections[_i];
    const n = this._tryGetDevicePixelRatio();
    n && ln(e.originalEvent) && (t.x = Math.round(t.x / n * 100) / 100, t.y = Math.round(t.y / n * 100) / 100);
  }
  _tryGetDevicePixelRatio() {
    if (ae())
      return fe().devicePixelRatio;
  }
  handleEnd(e) {
    var t;
    return this._resetActive(), this._refreshCursorState((t = e.originalEvent) === null || t === void 0 ? void 0 : t.target), this._adjustDistance(e, e.velocity), this._eventForUserAction = e, this._eventHandler("end", e.velocity).done(this._endAction);
  }
  handleCancel(e) {
    return this._resetActive(), this._eventForUserAction = e, this._eventHandler("end", {
      x: 0,
      y: 0
    });
  }
  handleStop() {
    this._resetActive(), this._eventHandler("stop");
  }
  handleScroll() {
    var e;
    this._updateRtlConfig(), (e = this._scrollAction) === null || e === void 0 || e.call(this);
  }
  _attachKeyboardHandler() {
    _.off(this._$element, `.${Rp}`), !this.option("disabled") && this.option("useKeyboard") && _.on(this._$element, R("keydown", Rp), this._keyDownHandler.bind(this));
  }
  _keyDownHandler(e) {
    if (clearTimeout(this._updateHandlerTimeout), this._updateHandlerTimeout = setTimeout(() => {
      Ye(e) === Hi.TAB && this._eachScroller((n) => {
        n._updateHandler();
      });
    }), !this._$container.is(O.getActiveElement(this._$container.get(0))))
      return;
    let t = !0;
    switch (Ye(e)) {
      case Hi.DOWN:
        this._scrollByLine({
          y: 1
        });
        break;
      case Hi.UP:
        this._scrollByLine({
          y: -1
        });
        break;
      case Hi.RIGHT:
        this._scrollByLine({
          x: 1
        });
        break;
      case Hi.LEFT:
        this._scrollByLine({
          x: -1
        });
        break;
      case Hi.PAGE_DOWN:
        this._scrollByPage(1);
        break;
      case Hi.PAGE_UP:
        this._scrollByPage(-1);
        break;
      case Hi.HOME:
        this._scrollToHome();
        break;
      case Hi.END:
        this._scrollToEnd();
        break;
      default:
        t = !1;
    }
    t && (e.stopPropagation(), e.preventDefault());
  }
  _scrollByLine(e) {
    const t = this._tryGetDevicePixelRatio();
    let n = 40;
    t && (n = Math.abs(n / t * 100) / 100), this.scrollBy({
      top: (e.y || 0) * -n,
      left: (e.x || 0) * -n
    });
  }
  _scrollByPage(e) {
    const t = this._wheelProp(), n = this._dimensionByProp(t), s = {}, o = n === "width" ? ne : le;
    s[t] = e * -o(this._$container), this.scrollBy(s);
  }
  _dimensionByProp(e) {
    return e === "left" ? "width" : "height";
  }
  _getPropByDirection(e) {
    return e === Ut ? "left" : "top";
  }
  _scrollToHome() {
    const e = this._wheelProp(), t = {};
    t[e] = 0, this._component.scrollTo(t);
  }
  _scrollToEnd() {
    const e = this._wheelProp(), t = this._dimensionByProp(e), n = {}, s = t === "width" ? ne : le;
    n[e] = s(this._$content) - s(this._$container), this._component.scrollTo(n);
  }
  createActions() {
    this._startAction = this._createActionHandler("onStart"), this._endAction = this._createActionHandler("onEnd"), this._updateAction = this._createActionHandler("onUpdated"), this._createScrollerActions();
  }
  _createScrollerActions() {
    this._scrollAction = this._createActionHandler("onScroll"), this._bounceAction = this._createActionHandler("onBounce"), this._eventHandler("createActions", {
      scroll: this._scrollAction,
      bounce: this._bounceAction
    });
  }
  _createActionHandler(e) {
    const t = this._createActionByOption(e);
    return () => {
      t(x(this._createActionArgs(), arguments));
    };
  }
  _createActionArgs() {
    const {
      horizontal: e,
      vertical: t
    } = this._scrollers, n = this._getScrollOffset();
    return this._scrollOffset = {
      top: t && n.top,
      left: e && n.left
    }, {
      event: this._eventForUserAction,
      scrollOffset: this._scrollOffset,
      reachedLeft: e?._reachedMax(),
      reachedRight: e?._reachedMin(),
      reachedTop: t?._reachedMax(),
      reachedBottom: t?._reachedMin()
    };
  }
  _getScrollOffset() {
    return {
      top: -this.location().top,
      left: -this.location().left
    };
  }
  _eventHandler(e, t) {
    const n = [].slice.call(arguments).slice(1), s = mt(this._scrollers, (o) => o[`_${e}Handler`].apply(o, n));
    return W.apply(p, s).promise();
  }
  location() {
    const e = Nn(this._$content);
    return e.top -= this._$container.scrollTop(), e.left -= this._$container.scrollLeft(), e;
  }
  disabledChanged() {
    this._attachCursorHandlers();
  }
  _attachCursorHandlers() {
    _.off(this._$element, `.${Gd}`), !this.option("disabled") && this._isHoverMode() && (_.on(this._$element, R("mouseenter", Gd), this._cursorEnterHandler.bind(this)), _.on(this._$element, R("mouseleave", Gd), this._cursorLeaveHandler.bind(this)));
  }
  _isHoverMode() {
    return this.option("showScrollbar") === "onHover";
  }
  _cursorEnterHandler(e) {
    e = e || {}, e.originalEvent = e.originalEvent || {}, !(Cr || e.originalEvent._hoverHandled) && (Zn && Zn._cursorLeaveHandler(), Zn = this, this._eventHandler("cursorEnter"), e.originalEvent._hoverHandled = !0);
  }
  _cursorLeaveHandler(e) {
    Zn !== this || Cr === Zn || (this._eventHandler("cursorLeave"), Zn = null, this._refreshCursorState(e?.relatedTarget));
  }
  _refreshCursorState(e) {
    if (!this._isHoverMode() && (!e || Cr))
      return;
    const n = p(e).closest(".dx-scrollable-simulated:not(.dx-state-disabled)"), s = n.length && n.data(Fq);
    Zn && Zn !== s && Zn._cursorLeaveHandler(), s && s._cursorEnterHandler();
  }
  update() {
    const e = this._eventHandler("update").done(this._updateAction);
    return W(e, qt(() => {
      const t = this._allowedDirections();
      return ft(() => {
        let n = t.vertical ? "pan-x" : "";
        n = t.horizontal ? "pan-y" : n, n = t.vertical && t.horizontal ? "none" : n, this._$container.css("touchAction", n);
      }), W().promise();
    }));
  }
  _allowedDirections() {
    const e = this.option("bounceEnabled"), t = this._scrollers[_i], n = this._scrollers[Ut];
    return {
      vertical: t && (t._minOffset < 0 || e),
      horizontal: n && (n._minOffset < 0 || e)
    };
  }
  _updateBounds() {
    var e;
    (e = this._scrollers[Ut]) === null || e === void 0 || e._updateBounds();
  }
  _isHorizontalAndRtlEnabled() {
    return this.option("rtlEnabled") && this.option("direction") !== _i;
  }
  updateRtlPosition(e) {
    if (e && (this._rtlConfig = {
      scrollRight: 0,
      clientWidth: this._$container.get(0).clientWidth,
      windowPixelRatio: this._getWindowDevicePixelRatio()
    }), this._updateBounds(), this._isHorizontalAndRtlEnabled()) {
      let t = this._getMaxOffset().left - this._rtlConfig.scrollRight;
      t <= 0 && (t = 0, this._rtlConfig.scrollRight = this._getMaxOffset().left), this._getScrollOffset().left !== t && (this._rtlConfig.skipUpdating = !0, this._component.scrollTo({
        left: t
      }), this._rtlConfig.skipUpdating = !1);
    }
  }
  _updateRtlConfig() {
    if (this._isHorizontalAndRtlEnabled() && !this._rtlConfig.skipUpdating) {
      const {
        clientWidth: e,
        scrollLeft: t
      } = this._$container.get(0), n = this._getWindowDevicePixelRatio();
      this._rtlConfig.windowPixelRatio === n && this._rtlConfig.clientWidth === e && (this._rtlConfig.scrollRight = this._getMaxOffset().left - t), this._rtlConfig.clientWidth = e, this._rtlConfig.windowPixelRatio = n;
    }
  }
  _getWindowDevicePixelRatio() {
    return ae() ? fe().devicePixelRatio : 1;
  }
  scrollBy(e) {
    var t, n;
    const s = this._scrollers[_i], o = this._scrollers[Ut];
    s && (e.top = s._boundLocation(e.top + s._location) - s._location), o && (e.left = o._boundLocation(e.left + o._location) - o._location), this._prepareDirections(!0), (t = this._startAction) === null || t === void 0 || t.call(this), this._eventHandler("scrollBy", {
      x: e.left,
      y: e.top
    }), (n = this._endAction) === null || n === void 0 || n.call(this), this._updateRtlConfig();
  }
  validate(e) {
    return ln(e) && bt(e) || this.option("disabled") ? !1 : this.option("bounceEnabled") ? !0 : ln(e) ? this._validateWheel(e) : this._validateMove(e);
  }
  _validateWheel(e) {
    const t = this._scrollers[this._wheelDirection(e)], n = t._reachedMin(), s = t._reachedMax(), o = !n || !s, r = !n && !s, a = n && e.delta > 0, l = s && e.delta < 0;
    let d = o && (r || a || l);
    return d = d || this._validateWheelTimer !== void 0, d && (clearTimeout(this._validateWheelTimer), this._validateWheelTimer = setTimeout(() => {
      this._validateWheelTimer = void 0;
    }, 500)), d;
  }
  _validateMove(e) {
    return !this.option("scrollByContent") && !p(e.target).closest(".dx-scrollable-scrollbar").length ? !1 : this._allowedDirection();
  }
  getDirection(e) {
    return ln(e) ? this._wheelDirection(e) : this._allowedDirection();
  }
  _wheelProp() {
    return this._wheelDirection() === Ut ? "left" : "top";
  }
  _wheelDirection(e) {
    switch (this.option("direction")) {
      case Ut:
        return Ut;
      case _i:
        return _i;
      default:
        return e != null && e.shiftKey ? Ut : _i;
    }
  }
  dispose() {
    this._resetActive(), Zn === this && (Zn = null), this._eventHandler("dispose"), this._detachEventHandlers(), this._$element.removeClass("dx-scrollable-simulated"), this._eventForUserAction = null, clearTimeout(this._validateWheelTimer), clearTimeout(this._updateHandlerTimeout);
  }
  _detachEventHandlers() {
    _.off(this._$element, `.${Gd}`), _.off(this._$container, `.${Rp}`);
  }
}
const xi = "dxScrollable", $q = "dxScrollableStrategy", Ci = "vertical", Wi = "horizontal", Fp = "both";
class Qt extends ui {
  _getDefaultOptions() {
    return I({}, super._getDefaultOptions(), {
      disabled: !1,
      onScroll: null,
      direction: Ci,
      showScrollbar: "onScroll",
      useNative: !0,
      bounceEnabled: !0,
      scrollByContent: !0,
      scrollByThumb: !1,
      onUpdated: null,
      onStart: null,
      onEnd: null,
      onBounce: null,
      useSimulatedScrollbar: !1,
      useKeyboard: !0,
      inertiaEnabled: !0,
      updateManually: !1,
      _onVisibilityChanged: M
    });
  }
  _defaultOptionsRules() {
    return super._defaultOptionsRules().concat(AO(), [{
      device: () => tn.nativeScrolling && z.real().platform === "android" && !ze.mozilla,
      options: {
        useSimulatedScrollbar: !0
      }
    }]);
  }
  _initOptions(e) {
    super._initOptions(e), "useSimulatedScrollbar" in e || this._setUseSimulatedScrollbar();
  }
  _setUseSimulatedScrollbar() {
    this.initialOption("useSimulatedScrollbar") || this.option("useSimulatedScrollbar", !this.option("useNative"));
  }
  _init() {
    super._init(), this._initScrollableMarkup(), this._locked = !1;
  }
  _visibilityChanged(e) {
    if (e) {
      this.update(), this._updateRtlPosition(), this._savedScrollOffset && this.scrollTo(this._savedScrollOffset), delete this._savedScrollOffset;
      const {
        _onVisibilityChanged: t
      } = this.option();
      t?.(this);
    } else
      this._savedScrollOffset = this.scrollOffset();
  }
  _initScrollableMarkup() {
    const e = this.$element().addClass("dx-scrollable"), t = p("<div>").addClass("dx-scrollable-container"), n = p("<div>").addClass("dx-scrollable-wrapper"), s = p("<div>").addClass("dx-scrollable-content");
    this._$container = t, this._$wrapper = n, this._$content = s, s.append(e.contents()).appendTo(t), t.appendTo(n), n.appendTo(e);
  }
  _dimensionChanged() {
    this.update(), this._updateRtlPosition();
  }
  _initMarkup() {
    super._initMarkup(), this._renderDirection();
  }
  _render() {
    this._renderStrategy(), this._attachEventHandlers(), this._renderDisabledState(), this._createActions(), this.update(), super._render(), this._updateRtlPosition(!0);
  }
  _updateRtlPosition(e) {
    this._strategy.updateRtlPosition(e);
  }
  _getMaxOffset() {
    const {
      scrollWidth: e,
      clientWidth: t,
      scrollHeight: n,
      clientHeight: s
    } = p(this.container()).get(0);
    return {
      left: e - t,
      top: n - s
    };
  }
  _attachEventHandlers() {
    const e = this._strategy, t = {
      getDirection: e.getDirection.bind(e),
      validate: this._validate.bind(this),
      isNative: this.option("useNative"),
      scrollTarget: this._$container
    };
    _.off(this._$wrapper, `.${xi}`), _.on(this._$wrapper, R(mr.init, xi), t, this._initHandler.bind(this)), _.on(this._$wrapper, R(mr.start, xi), e.handleStart.bind(e)), _.on(this._$wrapper, R(mr.move, xi), e.handleMove.bind(e)), _.on(this._$wrapper, R(mr.end, xi), e.handleEnd.bind(e)), _.on(this._$wrapper, R(mr.cancel, xi), e.handleCancel.bind(e)), _.on(this._$wrapper, R(mr.stop, xi), e.handleStop.bind(e)), _.off(this._$container, `.${xi}`), _.on(this._$container, R("scroll", xi), e.handleScroll.bind(e));
  }
  _validate(e) {
    return this._isLocked() ? !1 : (this._updateIfNeed(), this._moveIsAllowed(e));
  }
  _moveIsAllowed(e) {
    return this._strategy.validate(e);
  }
  handleMove(e) {
    this._strategy.handleMove(e);
  }
  _prepareDirections(e) {
    this._strategy._prepareDirections(e);
  }
  _initHandler() {
    const e = this._strategy;
    e.handleInit.apply(e, arguments);
  }
  _renderDisabledState() {
    const {
      disabled: e
    } = this.option();
    this.$element().toggleClass("dx-scrollable-disabled", e), this.option("disabled") ? this._lock() : this._unlock();
  }
  _renderDirection() {
    const {
      direction: e
    } = this.option();
    this.$element().removeClass(`dx-scrollable-${Wi}`).removeClass(`dx-scrollable-${Ci}`).removeClass(`dx-scrollable-${Fp}`).addClass(`dx-scrollable-${e}`);
  }
  _renderStrategy() {
    this._createStrategy(), this._strategy.render(), this.$element().data($q, this._strategy);
  }
  _createStrategy() {
    this._strategy = this.option("useNative") ? new q_(this) : new MO(this);
  }
  _createActions() {
    var e;
    (e = this._strategy) === null || e === void 0 || e.createActions();
  }
  _clean() {
    var e;
    (e = this._strategy) === null || e === void 0 || e.dispose();
  }
  _optionChanged(e) {
    var t;
    switch (e.name) {
      case "onStart":
      case "onEnd":
      case "onUpdated":
      case "onScroll":
      case "onBounce":
        this._createActions();
        break;
      case "direction":
        this._resetInactiveDirection(), this._invalidate();
        break;
      case "useNative":
        this._setUseSimulatedScrollbar(), this._invalidate();
        break;
      case "inertiaEnabled":
      case "scrollByThumb":
      case "bounceEnabled":
      case "useKeyboard":
      case "showScrollbar":
      case "useSimulatedScrollbar":
        this._invalidate();
        break;
      case "disabled":
        this._renderDisabledState(), (t = this._strategy) === null || t === void 0 || t.disabledChanged();
        break;
      case "updateManually":
      case "scrollByContent":
      case "_onVisibilityChanged":
        break;
      case "width":
        super._optionChanged(e), this._updateRtlPosition();
        break;
      default:
        super._optionChanged(e);
    }
  }
  _resetInactiveDirection() {
    const e = this._getInactiveProp();
    if (!e || !ae())
      return;
    const t = this.scrollOffset();
    t[e] = 0, this.scrollTo(t);
  }
  _getInactiveProp() {
    const {
      direction: e
    } = this.option();
    if (e === Ci)
      return "left";
    if (e === Wi)
      return "top";
  }
  _location() {
    return this._strategy.location();
  }
  _normalizeLocation(e) {
    if (pe(e)) {
      const n = Qe(e.left, e.x), s = Qe(e.top, e.y);
      return {
        left: f(n) ? -n : void 0,
        top: f(s) ? -s : void 0
      };
    }
    const {
      direction: t
    } = this.option();
    return {
      left: t !== Ci ? -e : void 0,
      top: t !== Wi ? -e : void 0
    };
  }
  _isLocked() {
    return this._locked;
  }
  _lock() {
    this._locked = !0;
  }
  _unlock() {
    this.option("disabled") || (this._locked = !1);
  }
  _isDirection(e) {
    const {
      direction: t
    } = this.option();
    return e === Ci ? t !== Wi : e === Wi ? t !== Ci : t === e;
  }
  _updateAllowedDirection() {
    const e = this._strategy._allowedDirections();
    this._isDirection(Fp) && e.vertical && e.horizontal ? this._allowedDirectionValue = Fp : this._isDirection(Wi) && e.horizontal ? this._allowedDirectionValue = Wi : this._isDirection(Ci) && e.vertical ? this._allowedDirectionValue = Ci : this._allowedDirectionValue = null;
  }
  _allowedDirection() {
    return this._allowedDirectionValue;
  }
  $content() {
    return this._$content;
  }
  content() {
    return ee(this._$content);
  }
  container() {
    return ee(this._$container);
  }
  scrollOffset() {
    return this._strategy._getScrollOffset();
  }
  _isRtlNativeStrategy() {
    const {
      useNative: e,
      rtlEnabled: t
    } = this.option();
    return e && t;
  }
  scrollTop() {
    return this.scrollOffset().top;
  }
  scrollLeft() {
    return this.scrollOffset().left;
  }
  clientHeight() {
    return le(this._$container);
  }
  scrollHeight() {
    return he(this.$content());
  }
  clientWidth() {
    return ne(this._$container);
  }
  scrollWidth() {
    return Ee(this.$content());
  }
  update() {
    if (this._strategy)
      return W(this._strategy.update()).done(() => {
        this._updateAllowedDirection();
      });
  }
  scrollBy(e) {
    e = this._normalizeLocation(e), !(!e.top && !e.left) && (this._updateIfNeed(), this._strategy.scrollBy(e));
  }
  scrollTo(e) {
    if (!ae())
      return;
    e = this._normalizeLocation(e), this._updateIfNeed();
    let t = this._location();
    const {
      useNative: n
    } = this.option();
    if (!n) {
      const o = this._strategy;
      e = o._applyScaleRatio(e), t = o._applyScaleRatio(t);
    }
    this._isRtlNativeStrategy() && (t.left -= this._getMaxOffset().left);
    const s = this._normalizeLocation({
      left: t.left - Qe(e.left, t.left),
      top: t.top - Qe(e.top, t.top)
    });
    !s.top && !s.left || this._strategy.scrollBy(s);
  }
  scrollToElement(e, t) {
    const n = p(e), s = this.$content().find(e).length, o = n.parents(".dx-scrollable").length - n.parents(".dx-scrollable-content").length === 0;
    if (!s || !o)
      return;
    const r = {
      top: 0,
      left: 0
    }, {
      direction: a
    } = this.option();
    a !== Ci && (r.left = this.getScrollElementPosition(n, Wi, t)), a !== Wi && (r.top = this.getScrollElementPosition(n, Ci, t)), this.scrollTo(r);
  }
  getScrollElementPosition(e, t, n) {
    const s = this.scrollOffset();
    return OO(e.get(0), t, p(this.container()).get(0), s, n);
  }
  _updateIfNeed() {
    this.option("updateManually") || this.update();
  }
  _useTemplates() {
    return !1;
  }
  isRenovated() {
    return !!Qt.IS_RENOVATED_WIDGET;
  }
}
xe(xi, Qt);
const Ud = "dx-freespace-row", Db = "dx-last-row-border";
function Tb(i) {
  return i ? Math.round(i.scrollWidth() - i.clientWidth()) : 0;
}
function Mm(i) {
  let {
    rowType: e,
    column: t
  } = i;
  return e === "group" && f(t.groupIndex) && !t.showWhenGrouped && !t.command;
}
function Ob(i) {
  let {
    element: e,
    watch: t,
    getter: n,
    callBack: s
  } = i;
  if (t) {
    const o = t(n, s);
    _.on(e, On, o);
  }
}
const Nq = function(i, e) {
  const t = yu(e.text) && e.rowType === "data", {
    text: n
  } = e, s = i.get(0);
  t ? F.setEmptyText(i) : e.column.encodeHtml ? s.textContent = n : s.innerHTML = n;
}, Lq = function(i) {
  const e = i.getScrollable();
  return e ? Math.ceil(parseFloat(p(e.content()).css("paddingBottom"))) : 0;
};
class Hq extends Cd {
  init() {
    super.init(), this._editingController = this.getController("editing"), this._resizingController = this.getController("resizing"), this._columnsResizerController = this.getController("columnsResizer"), this._focusController = this.getController("focus"), this._keyboardNavigationController = this.getController("keyboardNavigation"), this._validatingController = this.getController("validating"), this._errorHandlingController = this.getController("errorHandling"), this._columnHeadersView = this.getView("columnHeadersView"), this._rowHeight = 0, this._scrollTop = 0, this._scrollLeft = -1, this._scrollRight = 0, this._hasHeight = void 0, this._contentChanges = [], this._dataController.loadingChanged.add((e, t) => {
      this.setLoading(e, t);
    }), this._dataController.dataSourceChanged.add(() => {
      this._scrollLeft >= 0 && !this._dataController.isLoading() && this._handleScroll({
        component: this.getScrollable(),
        forceUpdateScrollPosition: !0,
        scrollOffset: {
          top: this._scrollTop,
          left: this._scrollLeft
        }
      });
    });
  }
  _getDefaultTemplate(e) {
    return e.command === "empty" ? function(t) {
      t.html("&nbsp;");
    } : Nq;
  }
  renderFocusState(e) {
  }
  _getDefaultGroupTemplate(e) {
    const t = this.option("summary.texts");
    return function(n, s) {
      const {
        data: o
      } = s;
      let r = `${s.column.caption}: ${s.text}`;
      const a = n.get(0);
      s.summaryItems && s.summaryItems.length && (r += ` ${F.getGroupRowSummaryText(s.summaryItems, t)}`), o && (s.groupContinuedMessage && s.groupContinuesMessage ? r += ` (${s.groupContinuedMessage}. ${s.groupContinuesMessage})` : s.groupContinuesMessage ? r += ` (${s.groupContinuesMessage})` : s.groupContinuedMessage && (r += ` (${s.groupContinuedMessage})`)), e.encodeHtml ? a.textContent = r : a.innerHTML = r;
    };
  }
  _update(e) {
  }
  _updateCell(e, t) {
    Mm(t) && (e.is(`.${this.addWidgetPrefix(Je.groupRowContainer)}`) ? e.parent() : e).addClass("dx-group-cell"), super._updateCell.apply(this, arguments);
  }
  _getCellTemplate(e) {
    const t = this, {
      column: n
    } = e;
    let s;
    return Mm(e) ? s = n.groupCellTemplate || {
      allowRenderToDetachedContainer: !0,
      render: t._getDefaultGroupTemplate(n)
    } : (e.rowType === "data" || n.command) && n.cellTemplate ? s = n.cellTemplate : s = {
      allowRenderToDetachedContainer: !0,
      render: t._getDefaultTemplate(n)
    }, s;
  }
  _createRow(e, t) {
    const n = super._createRow.apply(this, arguments);
    if (e) {
      const s = e.rowType === "group", o = e.rowType === "data";
      o && n.addClass("dx-data-row"), o && this.option("showRowLines") && n.addClass("dx-row-lines"), this.option("showColumnLines") && n.addClass("dx-column-lines"), e.visible === !1 && n.hide(), s && (n.addClass("dx-group-row"), this.setAriaExpandedAttribute(n, e));
    }
    return n;
  }
  _rowPrepared(e, t, n) {
    t.rowType === "data" && (this.option("rowAlternationEnabled") && (this._isAltRow(n) && e.addClass("dx-row-alt"), Ob({
      element: e.get(0),
      watch: t.watch,
      getter: () => this._isAltRow(n),
      callBack: (s) => {
        e.toggleClass("dx-row-alt", s);
      }
    })), this._setAriaRowIndex(t, e), Ob({
      element: e.get(0),
      watch: t.watch,
      getter: () => t.rowIndex,
      callBack: () => this._setAriaRowIndex(t, e)
    })), super._rowPrepared.apply(this, arguments);
  }
  _setAriaRowIndex(e, t) {
    if (!t.is("tr"))
      return;
    const {
      component: n
    } = this, s = n.option("scrolling.mode") === "standard" && !F.isVirtualRowRendering(n);
    let o = e.rowIndex + 1;
    s ? o = n.pageIndex() * n.pageSize() + o : o += this._dataController.getRowIndexOffset(), this.setAria("rowindex", o, t);
  }
  setAriaExpandedAttribute(e, t) {
    const n = t.isExpanded ? this.localize("dxDataGrid-ariaExpandedRow") : this.localize("dxDataGrid-ariaCollapsedRow");
    this.setAria("roledescription", n, e);
  }
  _afterRowPrepared(e) {
    const t = e.args[0], n = this._dataController, s = n.getVisibleRows()[t.rowIndex], o = this.option("integrationOptions.watchMethod");
    if (!t.data || t.rowType !== "data" || t.isNewRow || !this.option("twoWayBindingEnabled") || !o || !s)
      return;
    const r = o(() => n.generateDataValues(t.data, t.columns), () => {
      n.repaintRows([s.rowIndex], this.option("repaintChangesOnly"));
    }, {
      deep: !0,
      skipImmediate: !0
    });
    _.on(t.rowElement, On, r);
  }
  _renderScrollable(e) {
    const t = this, n = t.element();
    if (n.children().length || n.append("<div>"), (e || !t._loadPanel) && t._renderLoadPanel(n, n.parent(), t._dataController.isLocalStore()), (e || !t.getScrollable()) && t._dataController.isLoaded()) {
      const s = t.getColumns();
      let o = !0;
      for (let r = 0; r < s.length; r++)
        if (!s[r].width && !s[r].minWidth) {
          o = !1;
          break;
        }
      (t.option("columnAutoWidth") || t._hasHeight || o || t._columnsController._isColumnFixing()) && t._renderScrollableCore(n);
    }
  }
  _handleScroll(e) {
    const t = this.option("rtlEnabled"), n = e.component.option("useNative");
    this._scrollTop = e.scrollOffset.top, this._scrollLeft = e.scrollOffset.left;
    let s = e.scrollOffset.left;
    t && (this._scrollRight = Tb(e.component) - this._scrollLeft, n && (s = -this._scrollRight), this.isScrollbarVisible(!0) || (this._scrollLeft = -1)), this.scrollChanged.fire(I({}, e.scrollOffset, {
      left: s
    }), this.name);
  }
  _renderScrollableCore(e) {
    const t = this._createScrollableOptions(), n = this._handleScroll.bind(this);
    t.onScroll = n, this._scrollable = this._createComponent(e, Qt, t), this._scrollableContainer = this._scrollable && p(this._scrollable.container());
  }
  _renderLoadPanel() {
    for (var e = arguments.length, t = new Array(e), n = 0; n < e; n++)
      t[n] = arguments[n];
    return F.renderLoadPanel.apply(this, arguments);
  }
  _renderContent(e, t, n) {
    return e.empty().append(t), this._findContentElement();
  }
  _updateContent(e, t, n) {
    return this._contentChanges.push({
      newTableElement: e,
      change: t,
      isFixedTableRendering: n
    }), this.waitAsyncTemplates().done(() => {
      const s = this._contentChanges;
      this._contentChanges = [], s.forEach((o) => {
        let {
          newTableElement: r,
          change: a,
          isFixedTableRendering: l
        } = o;
        const d = this.getTableElement(l), u = this._findContentElement(l), c = a?.changeType, h = [], g = this.option("highlightChanges"), m = this.addWidgetPrefix("row-inserted-animation");
        c === "update" ? (y(a.rowIndices, (C, v) => {
          var E;
          const T = this._getRowElements(r).eq(C), V = (E = a.changeTypes) === null || E === void 0 ? void 0 : E[C], $ = a.items && a.items[C];
          h.push(() => {
            const G = this._getRowElements(d), H = G.eq(v);
            switch (V) {
              case "update":
                if ($) {
                  var ce;
                  const re = (ce = a.columnIndices) === null || ce === void 0 ? void 0 : ce[C];
                  f($.visible) && $.visible !== H.is(":visible") ? H.toggle($.visible) : re ? this._updateCells(H, T, re, $) : H.replaceWith(T);
                }
                break;
              case "insert":
                if (G.length)
                  H.length ? T.insertBefore(H) : T.insertAfter(G.last());
                else if (d) {
                  const re = T.is("tbody") ? d : d.children("tbody");
                  T.prependTo(re);
                }
                g && a.isLiveUpdate && T.addClass(m);
                break;
              case "remove":
                H.remove();
            }
          });
        }), y(h, function() {
          this();
        }), r.remove()) : (this.setTableElement(r, l), u.addClass(this.addWidgetPrefix("content")), this._setGridRole(u), this._renderContent(u, r, l));
      });
    }).fail(() => {
      this._contentChanges = [];
    });
  }
  _getGridRoleName() {
    return "grid";
  }
  _setGridRole(e) {
    var t;
    const n = !((t = this._dataController) !== null && t !== void 0 && t.isEmpty()), s = this._getGridRoleName();
    e != null && e.length && n && this.setAria("role", s, e);
  }
  _createEmptyRow(e, t, n) {
    const s = this;
    let o;
    const r = s._createRow(), a = t ? this.getFixedColumns() : this.getColumns();
    r.addClass(e).toggleClass("dx-column-lines", s.option("showColumnLines"));
    for (let l = 0; l < a.length; l++)
      o = s._createCell({
        column: a[l],
        rowType: "freeSpace",
        columnIndex: l,
        columns: a
      }), $e(n) && o.css("height", n), r.append(o);
    return s.setAria("role", "presentation", r), r;
  }
  getFixedColumns() {
    throw new Error("Method not implemented.");
  }
  _appendEmptyRow(e, t, n) {
    const s = this._getBodies(e), o = !s.length || t.is("tbody"), r = o ? e : s;
    if (n === "top") {
      if (r.first().prepend(t), o) {
        const a = r.children("colgroup");
        r.prepend(a);
      }
    } else
      r.last().append(t);
  }
  _renderFreeSpaceRow(e, t) {
    let n = this._createEmptyRow(Ud);
    n = this._wrapRowIfNeed(e, n, t?.changeType === "refresh"), this._appendEmptyRow(e, n);
  }
  _checkRowKeys(e) {
    const t = this, n = t._getRows(e), s = t._dataController.store() && t._dataController.store().key();
    s && n.some((o) => {
      if (o.rowType === "data" && o.key === void 0)
        return t._dataController.fireError("E1046", s), !0;
    });
  }
  _needUpdateRowHeight(e) {
    return e > 0 && !this._rowHeight;
  }
  _getRowsHeight(e) {
    return e = e || this._tableElement, e.children("tbody").children().not(".dx-virtual-row").not(`.${Ud}`).toArray().reduce((n, s) => n + Ge(s).height, 0);
  }
  _updateRowHeight() {
    const e = this, t = e.getTableElement(), n = e._dataController.items().length;
    if (t && e._needUpdateRowHeight(n)) {
      const s = e._getRowsHeight(t);
      e._rowHeight = s / n;
    }
  }
  _findContentElement(e) {
    let t = this.element();
    const n = this.getScrollable();
    if (t)
      return n && (t = p(n.content())), t.children().first();
  }
  _getRowElements(e) {
    const t = super._getRowElements(e);
    return t && t.not(`.${Ud}`);
  }
  _getFreeSpaceRowElements(e) {
    const t = e || this.getTableElements();
    return t && t.children("tbody").children(`.${Ud}`);
  }
  _getNoDataText() {
    return this.option("noDataText");
  }
  _rowClick(e) {
    const t = this._dataController.items()[e.rowIndex] || {};
    this.executeAction("onRowClick", x({
      evaluate(n) {
        return Be(n)(t.data);
      }
    }, e, t));
  }
  _rowDblClick(e) {
    const t = this._dataController.items()[e.rowIndex] || {};
    this.executeAction("onRowDblClick", x({}, e, t));
  }
  _getColumnsCountBeforeGroups(e) {
    for (let t = 0; t < e.length; t++)
      if (e[t].type === "groupExpand")
        return t;
    return 0;
  }
  _getGroupCellOptions(e) {
    const t = this._getColumnsCountBeforeGroups(e.columns), n = (e.row.groupIndex || 0) + t;
    return {
      columnIndex: n,
      colspan: e.columns.length - n - 1
    };
  }
  _needWrapRow() {
    return super._needWrapRow.apply(this, arguments) || !!this.option("dataRowTemplate");
  }
  _renderCells(e, t) {
    t.row.rowType === "group" ? this._renderGroupedCells(e, t) : t.row.values && super._renderCells(e, t);
  }
  _renderGroupedCells(e, t) {
    const {
      row: n
    } = t;
    let s;
    const {
      columns: o
    } = t, {
      rowIndex: r
    } = n;
    let a;
    const l = this._getGroupCellOptions(t);
    for (let c = 0; c <= l.columnIndex; c++)
      c === l.columnIndex && o[c].allowCollapsing && t.scrollingMode !== "infinite" ? (a = !!n.isExpanded, s = o[c]) : (a = null, s = {
        command: "expand",
        cssClass: o[c].cssClass,
        fixed: o[c].fixed
      }), this._needRenderCell(c, t.columnIndices) && this._renderCell(e, {
        value: a,
        row: n,
        rowIndex: r,
        column: s,
        columnIndex: c,
        columnIndices: t.columnIndices,
        change: t.change
      });
    const d = ro(this.option("rtlEnabled")), u = x({}, o[l.columnIndex], {
      command: null,
      type: null,
      cssClass: null,
      width: null,
      showWhenGrouped: !1,
      alignment: d
    });
    l.colspan > 1 && (u.colspan = l.colspan), this._needRenderCell(l.columnIndex + 1, t.columnIndices) && this._renderCell(e, {
      value: n.values[n.groupIndex],
      row: n,
      rowIndex: r,
      column: u,
      columnIndex: l.columnIndex + 1,
      columnIndices: t.columnIndices,
      change: t.change
    });
  }
  _renderRows(e, t) {
    const n = this, s = n.option("scrolling.mode");
    super._renderRows(e, x({
      scrollingMode: s
    }, t)), n._checkRowKeys(t.change), n._renderFreeSpaceRow(e, t.change), n._hasHeight || n.updateFreeSpaceRowHeight(e);
  }
  _renderDataRowByTemplate(e, t, n) {
    const {
      row: s
    } = t, o = x({
      columns: t.columns
    }, s), r = this._createRow(s, "tbody");
    r.appendTo(e), this.renderTemplate(r, n, o, !0, t.change), this._rowPrepared(r, o, t.row);
  }
  _renderRow(e, t) {
    const {
      row: n
    } = t, {
      rowTemplate: s
    } = this.option(), o = this.option("dataRowTemplate");
    n.rowType === "data" && o ? this._renderDataRowByTemplate(e, t, o) : (n.rowType === "data" || n.rowType === "group") && !f(n.groupIndex) && s ? this.renderTemplate(e, s, x({
      columns: t.columns
    }, n), !0) : super._renderRow(e, t);
  }
  _renderTable(e) {
    const t = this, n = super._renderTable(e), s = function() {
      const o = t.getScrollable();
      o && t.element().closest(fe().document).length && (t.resizeCompleted.remove(s), o._visibilityChanged(!0));
    };
    return f(t.getTableElement()) ? t._renderScrollable() : (t.setTableElement(n), t._renderScrollable(!0), t.resizeCompleted.add(s)), n;
  }
  _createTable() {
    const e = super._createTable.apply(this, arguments);
    return (this.option().rowTemplate || this.option().dataRowTemplate) && e.appendTo(this.component.$element()), e;
  }
  _renderCore(e) {
    const t = this.element();
    t.addClass(this.addWidgetPrefix("rowsview")).toggleClass(this.addWidgetPrefix("nowrap"), !this.option("wordWrapEnabled")), t.toggleClass("dx-empty", this._dataController.isEmpty()), this.setAria("role", "presentation", t);
    const n = this._renderTable({
      change: e
    }), s = this._updateContent(n, e);
    return super._renderCore(e), this._lastColumnWidths = null, s;
  }
  _getRows(e) {
    return e && e.items || this._dataController.items();
  }
  _getCellOptions(e) {
    const t = this, {
      column: n
    } = e, {
      row: s
    } = e, {
      data: o
    } = s, r = s && s.summaryCells, {
      value: a
    } = e, l = F.getDisplayValue(n, a, o, s.rowType), d = super._getCellOptions(e);
    if (d.value = a, d.oldValue = e.oldValue, d.displayValue = l, d.row = s, d.key = s.key, d.data = o, d.rowType = s.rowType, d.values = s.values, d.text = n.command ? "" : F.formatValue(l, n), d.rowIndex = s.rowIndex, d.summaryItems = r && r[e.columnIndex], d.resized = n.resizedCallbacks, f(n.groupIndex) && !n.command) {
      const u = t.option("grouping.texts"), c = t.option("scrolling.mode");
      c !== "virtual" && c !== "infinite" && (d.groupContinuesMessage = o && o.isContinuationOnNextPage && u && u.groupContinuesMessage, d.groupContinuedMessage = o && o.isContinuation && u && u.groupContinuedMessage);
    }
    return d;
  }
  _toggleDraggableSourceColumnClass(e, t, n, s) {
    const o = this._columnsController, r = o.getColumns(), a = r && r[n], l = a && a.isBand && a.index;
    y(e, (d, u) => {
      if (!p(u).hasClass("dx-group-row"))
        for (let c = 0; c < t.length && !(($e(l) && o.isParentBandColumn(t[c].index, l) || t[c].index === n) && (e.eq(d).children().eq(c).toggleClass(this.addWidgetPrefix(gc.draggableColumn), s), !$e(l))); c++)
          ;
    });
  }
  _getDevicePixelRatio() {
    return fe().devicePixelRatio;
  }
  renderNoDataText() {
    return F.renderNoDataText.apply(this, arguments);
  }
  getCellOptions(e, t) {
    const n = this._dataController.items()[e];
    let s, o;
    return n && (te(t) ? o = this._columnsController.columnOption(t) : o = this._columnsController.getVisibleColumns()[t], o && (s = this._getCellOptions({
      value: o.calculateCellValue(n.data),
      rowIndex: n.rowIndex,
      row: n,
      column: o
    }))), s;
  }
  getRow(e) {
    if (e >= 0) {
      const t = this._getRowElements();
      if (t.length > e)
        return p(t[e]);
    }
  }
  updateFreeSpaceRowHeight(e) {
    const t = this._dataController, n = t.items(!0).length, s = this._findContentElement(), o = this._getFreeSpaceRowElements(e);
    if (o && s && t.totalCount() >= 0) {
      let r = !1;
      if (n > 0)
        if (this._hasHeight)
          o.hide(), qt(() => {
            const a = this.getScrollbarWidth(!0), l = le(this.element()) - a, d = he(s), u = l - d > 0, c = this._getRowsHeight(s.children().first()), h = e || this.getTableElements(), g = Math.ceil(parseFloat(h.css("borderTopWidth"))), m = this._getHeightCorrection(), C = l - c - g - m;
            u && ft(() => {
              o.css("height", C), r = !0, o.show();
            }), ft(() => this._updateLastRowBorder(r));
          });
        else {
          const a = t.pageSize() - n, l = this.option("scrolling.mode");
          a > 0 && t.pageCount() > 1 && l !== "virtual" && l !== "infinite" && (Xh(o, a * this._rowHeight), r = !0), !r && e ? Xh(o, 0) : o.toggle(r), this._updateLastRowBorder(r);
        }
      else
        o.css("height", 0), o.show(), this._updateLastRowBorder(!0);
    }
  }
  _getHeightCorrection() {
    const e = ze.webkit && this._getDevicePixelRatio() >= 2, t = ze.chrome && ze.version >= 91, n = ze.mozilla && ze.version >= 70 && !this.option("showRowLines");
    return e || n || t ? 1 : 0;
  }
  _columnOptionChanged(e) {
    const {
      optionNames: t
    } = e;
    e.changeTypes.grouping || (t.width || t.visibleWidth) && (super._columnOptionChanged(e), this._fireColumnResizedCallbacks());
  }
  getScrollable() {
    return this._scrollable;
  }
  _handleDataChanged(e) {
    const t = this;
    switch (e.changeType) {
      case "refresh":
      case "prepend":
      case "append":
      case "update":
        t.render(null, e);
        break;
      default:
        t._update(e);
    }
  }
  publicMethods() {
    return ["isScrollbarVisible", "getTopVisibleRowData", "getScrollbarWidth", "getCellElement", "getRowElement", "getScrollable"];
  }
  contentWidth() {
    return ne(this.element()) - this.getScrollbarWidth();
  }
  getScrollbarWidth(e) {
    const t = this._scrollableContainer && this._scrollableContainer.get(0);
    let n = 0;
    return t && (e ? (n = t.clientHeight ? t.offsetHeight - t.clientHeight : 0, n += Lq(this)) : n = t.clientWidth ? t.offsetWidth - t.clientWidth : 0), n > 0 ? n : 0;
  }
  _fireColumnResizedCallbacks() {
    const e = this._lastColumnWidths || [], t = [], n = this.getColumns();
    for (let s = 0; s < n.length; s++)
      t[s] = n[s].visibleWidth, n[s].resizedCallbacks && !f(n[s].groupIndex) && e[s] !== t[s] && n[s].resizedCallbacks.fire(t[s]);
    this._lastColumnWidths = t;
  }
  _updateLastRowBorder(e) {
    this.option("showBorders") && !e ? this.element().addClass(Db) : this.element().removeClass(Db);
  }
  _updateScrollable() {
    const e = Qt.getInstance(this.element());
    e && (e.update(), (e.option("useNative") || !(e != null && e.isRenovated())) && this._updateHorizontalScrollPosition());
  }
  _updateHorizontalScrollPosition() {
    const e = this.getScrollable(), t = e && e.scrollOffset().left;
    if (this.option("rtlEnabled")) {
      const s = Tb(e);
      s - t !== this._scrollRight && (this._scrollLeft = s - this._scrollRight);
    }
    this._scrollLeft >= 0 && t !== this._scrollLeft && e.scrollTo({
      x: this._scrollLeft
    });
  }
  _resizeCore() {
    const e = this;
    e._fireColumnResizedCallbacks(), e._updateRowHeight(), ft(() => {
      e._renderScrollable(), e.renderNoDataText(), e.updateFreeSpaceRowHeight(), qt(() => {
        e._updateScrollable();
      });
    });
  }
  scrollTo(e) {
    const t = this.element(), n = t && Qt.getInstance(t);
    n && n.scrollTo(e);
  }
  height(e) {
    const t = this, n = this.element();
    if (arguments.length === 0)
      return n ? he(n, !0) : 0;
    f(e) && n && (t.hasHeight(e !== "auto"), Xh(n, e));
  }
  hasHeight(e) {
    if (arguments.length === 0)
      return !!this._hasHeight;
    this._hasHeight = e;
  }
  setLoading(e, t) {
    const n = this;
    let s = n._loadPanel;
    const o = n._dataController, r = n.option("loadPanel") || {}, a = o.isLoaded() ? r.animation : null, l = n.element();
    if (ae() && (!s && t !== void 0 && o.isLocalStore() && r.enabled === "auto" && l && (n._renderLoadPanel(l, l.parent()), s = n._loadPanel), s)) {
      const d = {
        message: t || r.text,
        animation: a,
        visible: e
      };
      e && (d.position = F.calculateLoadPanelPosition(l)), clearTimeout(n._hideLoadingTimeoutID), s.option("visible") && !e ? n._hideLoadingTimeoutID = setTimeout(() => {
        s.option(d);
      }, 200) : s.option(d);
    }
  }
  toggleDraggableColumnClass(e, t) {
    const n = this._getRowElements().not(".dx-group-row") || [];
    this._toggleDraggableSourceColumnClass(n, this.getColumns(), e, t);
  }
  _getCellElementsCore(e) {
    const t = super._getCellElementsCore.apply(this, arguments);
    if (t) {
      const n = t.filter(".dx-group-cell").index();
      if (n >= 0 && t.length > n + 1)
        return t.slice(0, n + 1);
    }
    return t;
  }
  _getBoundaryVisibleItemIndex(e, t) {
    const n = this;
    let s = 0, o = 0, r = 0, a = n._scrollTop;
    const l = n._findContentElement(), d = l && l.offset().top, u = this._dataController.items(), c = n.getTableElement();
    if (u.length && c) {
      const h = n._getRowElements(c).filter(":visible");
      if (!e) {
        const g = he(this._hasHeight ? this.element() : fe());
        a += g;
      }
      for (s = 0; s < u.length; s++) {
        o = r;
        const g = p(h).eq(s);
        if (g.length && (r = g.offset(), r = (e ? r.top : r.top + he(g)) - d, r > a)) {
          s && (t || 2 * a < Math.round(r + o)) && s--;
          break;
        }
      }
      s && s === u.length && s--;
    }
    return s;
  }
  getTopVisibleItemIndex(e) {
    return this._getBoundaryVisibleItemIndex(!0, e);
  }
  getBottomVisibleItemIndex(e) {
    return this._getBoundaryVisibleItemIndex(!1, e);
  }
  getTopVisibleRowData() {
    const e = this.getTopVisibleItemIndex(), t = this._dataController.items();
    if (t[e])
      return t[e].data;
  }
  _scrollToElement(e, t) {
    const n = this.getScrollable();
    n && n.scrollToElement(e, t);
  }
  optionChanged(e) {
    const t = this;
    switch (super.optionChanged(e), e.name) {
      case "wordWrapEnabled":
      case "showColumnLines":
      case "showRowLines":
      case "rowAlternationEnabled":
      case "rowTemplate":
      case "dataRowTemplate":
      case "twoWayBindingEnabled":
        t._invalidate(!0, !0), e.handled = !0;
        break;
      case "scrolling":
        t._rowHeight = null, t._tableElement = null, e.handled = !0;
        break;
      case "rtlEnabled":
        t._rowHeight = null, t._tableElement = null;
        break;
      case "loadPanel":
        t._tableElement = null, t._invalidate(!0, e.fullName !== "loadPanel.enabled"), e.handled = !0;
        break;
      case "noDataText":
        t.renderNoDataText(), e.handled = !0;
    }
  }
  setAriaOwns(e, t, n) {
    const s = this._findContentElement(), o = this.getTableElement();
    o != null && o.length && this.setAria("owns", `${e ?? ""} ${o.attr("id") ?? ""} ${t ?? ""}`.trim(), s);
  }
  dispose() {
    super.dispose(), clearTimeout(this._hideLoadingTimeoutID), this._scrollable && this._scrollable.dispose();
  }
  setScrollerSpacing(e, t) {
  }
  getFixedContentElement() {
    var e;
    const t = this.addWidgetPrefix("content-fixed");
    return (e = this.element()) === null || e === void 0 ? void 0 : e.children(`.${t}`);
  }
  _restoreErrorRow(e) {
  }
  isElementInside(e) {
    return e.closest(`.${this.addWidgetPrefix("rowsview")}`).is(this.element());
  }
}
const BO = {
  defaultOptions: () => ({
    hoverStateEnabled: !1,
    scrolling: {
      useNative: "auto"
    },
    loadPanel: {
      enabled: "auto",
      text: S.format("Loading"),
      width: 200,
      height: 90,
      showIndicator: !0,
      indicatorSrc: "",
      showPane: !0
    },
    dataRowTemplate: null,
    columnAutoWidth: !1,
    noDataText: S.format("dxDataGrid-noDataText"),
    wordWrapEnabled: !1,
    showColumnLines: !0,
    showRowLines: !1,
    rowAlternationEnabled: !1,
    activeStateEnabled: !1,
    twoWayBindingEnabled: !0
  }),
  views: {
    rowsView: Hq
  }
};
BO.views.rowsView;
J.registerModule("rows", BO);
const {
  abs: Ab
} = Math, Wq = sh.inherit({
  start(i) {
    this._startEventData = st(i), this._startTimer(i);
  },
  _startTimer(i) {
    const e = "timeout" in this ? this.timeout : 750;
    this._holdTimer = setTimeout(() => {
      this._requestAccept(i), this._fireEvent("dxhold", i, {
        target: i.target
      }), this._forgetAccept();
    }, e);
  },
  move(i) {
    this._touchWasMoved(i) && this._cancel(i);
  },
  _touchWasMoved(i) {
    const e = So(this._startEventData, st(i));
    return Ab(e.x) > 5 || Ab(e.y) > 5;
  },
  end() {
    this._stopTimer();
  },
  _stopTimer() {
    clearTimeout(this._holdTimer);
  },
  cancel() {
    this._stopTimer();
  },
  dispose() {
    this._stopTimer();
  }
});
ha({
  emitter: Wq,
  bubble: !0,
  events: ["dxhold"]
});
const Zs = {
  name: "dxhold"
}, zq = R("contextmenu", "dxContexMenu"), Kq = R(Zs.name, "dxContexMenu"), Gq = se.inherit({
  setup(i) {
    const e = p(i);
    _.on(e, zq, this._contextMenuHandler.bind(this)), (tn.touch || z.isSimulator()) && _.on(e, Kq, this._holdHandler.bind(this));
  },
  _holdHandler(i) {
    jo(i) && !z.isSimulator() || this._fireContextMenu(i);
  },
  _contextMenuHandler(i) {
    this._fireContextMenu(i);
  },
  _fireContextMenu: (i) => oo({
    type: "dxcontextmenu",
    originalEvent: i
  }),
  teardown(i) {
    _.off(i, ".dxContexMenu");
  }
});
Yn("dxcontextmenu", new Gq());
const $O = "dxcontextmenu", Uq = (i, e, t) => {
  const n = (() => {
    let s;
    return (o) => {
      s !== o && (t(o, s), s = o);
    };
  })();
  return {
    dispose: i(e, n),
    force() {
      n(e());
    }
  };
};
class ga extends se.inherit({}) {
  ctor(e, t, n) {
    this._$element = e, this._options = t, this._rawData = n, nI(e, this, this._dispose), this._render();
  }
  _render() {
    const e = p("<div>").addClass("dx-item-content-placeholder");
    this._$element.append(e), this._watchers = [], this._renderWatchers();
  }
  _renderWatchers() {
    this._startWatcher("disabled", this._renderDisabled.bind(this)), this._startWatcher("visible", this._renderVisible.bind(this));
  }
  _startWatcher(e, t) {
    const n = this._rawData, s = this._options.fieldGetter(e), o = Uq(this._options.watchMethod(), () => s(n), (r, a) => {
      this._dirty = !0, t(r, a);
    });
    this._watchers.push(o);
  }
  setDataField() {
    return this._dirty = !1, y(this._watchers, (e, t) => {
      t.force();
    }), this._dirty;
  }
  _renderDisabled(e, t) {
    this._$element.toggleClass("dx-state-disabled", !!e), this._$element.attr("aria-disabled", !!e), this._updateOwnerFocus(e);
  }
  _updateOwnerFocus(e) {
    const t = this._options.owner;
    t && e && t._resetItemFocus(this._$element);
  }
  _renderVisible(e, t) {
    this._$element.toggleClass("dx-state-invisible", e !== void 0 && !e);
  }
  _dispose() {
    y(this._watchers, (e, t) => {
      t.dispose();
    });
  }
  static getInstance(e) {
    return iI(e, this);
  }
}
class jq extends se.inherit({}) {
  constructor(e) {
    super(), this._collectionWidget = e;
  }
  getIndexByItemData(e) {
    return se.abstract();
  }
  getItemDataByIndex(e) {
    se.abstract();
  }
  getKeysByItems(e) {
    se.abstract();
  }
  getItemsByKeys(e, t) {
    se.abstract();
  }
  itemsGetter() {
    se.abstract();
  }
  getKeyByIndex(e) {
    const t = this._denormalizeItemIndex(e);
    return this.getKeysByItems([this.getItemDataByIndex(t)])[0];
  }
  _equalKeys(e, t) {
    return this._collectionWidget._isKeySpecified() ? He(e, t) : e === t;
  }
  beginCache() {
    this._cache = {};
  }
  endCache() {
    this._cache = null;
  }
  getIndexByKey(e) {
    return se.abstract();
  }
  getNormalizedIndex(e) {
    return this._isNormalizedItemIndex(e) ? e : this._isItemIndex(e) ? this._normalizeItemIndex(e) : this._isNode(e) ? this._getNormalizedItemIndex(e) : this._normalizeItemIndex(this.getIndexByItemData(e));
  }
  getIndex(e) {
    return this._isNormalizedItemIndex(e) ? this._denormalizeItemIndex(e) : this._isItemIndex(e) ? e : this._isNode(e) ? this._denormalizeItemIndex(this._getNormalizedItemIndex(e)) : this.getIndexByItemData(e);
  }
  getItemElement(e) {
    if (this._isNormalizedItemIndex(e))
      return this._getItemByNormalizedIndex(e);
    if (this._isItemIndex(e))
      return this._getItemByNormalizedIndex(this._normalizeItemIndex(e));
    if (this._isNode(e))
      return p(e);
    const t = this._normalizeItemIndex(this.getIndexByItemData(e));
    return this._getItemByNormalizedIndex(t);
  }
  _isNode(e) {
    return O.isNode(e && zn(e) ? e.get(0) : e);
  }
  deleteItemAtIndex(e) {
    se.abstract();
  }
  itemPlacementFunc(e, t) {
    return this._itemsFromSameParent(e, t) && e < t ? "after" : "before";
  }
  moveItemAtIndexToIndex(e, t) {
    se.abstract();
  }
  _isNormalizedItemIndex(e) {
    return typeof e == "number" && Math.round(e) === e;
  }
  _isItemIndex(e) {
    return se.abstract();
  }
  _getNormalizedItemIndex(e) {
    return se.abstract();
  }
  _normalizeItemIndex(e) {
    return se.abstract();
  }
  _denormalizeItemIndex(e) {
    return se.abstract();
  }
  _getItemByNormalizedIndex(e) {
    return se.abstract();
  }
  _itemsFromSameParent(e, t) {
    return se.abstract();
  }
}
class Y_ extends jq {
  _getPlainItems() {
    return this._collectionWidget.option("items") || [];
  }
  getIndexByItemData(e) {
    const t = this._collectionWidget.keyOf.bind(this._collectionWidget);
    return t ? this.getIndexByKey(t(e)) : this._getPlainItems().indexOf(e);
  }
  getItemDataByIndex(e) {
    return this._getPlainItems()[e];
  }
  deleteItemAtIndex(e) {
    this._getPlainItems().splice(e, 1);
  }
  itemsGetter() {
    return this._getPlainItems();
  }
  getKeysByItems(e) {
    const t = this._collectionWidget.keyOf.bind(this._collectionWidget);
    let n = e;
    if (t) {
      n = [];
      for (let s = 0; s < e.length; s++)
        n.push(t(e[s]));
    }
    return n;
  }
  getIndexByKey(e) {
    const t = this._cache, n = t && t.keys || this.getKeysByItems(this._getPlainItems());
    if (t && !t.keys && (t.keys = n), typeof e == "object") {
      for (let s = 0, {
        length: o
      } = n; s < o; s++)
        if (this._equalKeys(e, n[s]))
          return s;
    } else
      return n.indexOf(e);
    return -1;
  }
  getItemsByKeys(e, t) {
    return (t || e).slice();
  }
  moveItemAtIndexToIndex(e, t) {
    const n = this._getPlainItems(), s = n[e];
    n.splice(e, 1), n.splice(t, 0, s);
  }
  _isItemIndex(e) {
    return typeof e == "number" && Math.round(e) === e;
  }
  _getNormalizedItemIndex(e) {
    return this._collectionWidget._itemElements().index(e);
  }
  _normalizeItemIndex(e) {
    return e;
  }
  _denormalizeItemIndex(e) {
    return e;
  }
  _getItemByNormalizedIndex(e) {
    return e > -1 ? this._collectionWidget._itemElements().eq(e) : null;
  }
  _itemsFromSameParent(e, t) {
    return !0;
  }
}
class qq extends Y_ {
  _getPlainItems() {
    return mt(this._collectionWidget.option("items"), function e(t) {
      return t.items ? [t].concat(mt(t.items, e)) : t;
    });
  }
  _stringifyItem(e) {
    return JSON.stringify(e, (t, n) => t === "template" ? this._getTemplateString(n) : n);
  }
  _getTemplateString(e) {
    let t;
    return typeof e == "object" ? t = p(e).text() : t = e.toString(), t;
  }
}
const Yq = function(i, e, t, n, s) {
  let o;
  const r = ((a, l, d) => l(() => a, d))(i, e, (a) => {
    if (o && o(), Kr(a)) {
      s(a);
      return;
    }
    o = function(l, d, u, c, h) {
      const g = {}, m = u.slice(), C = u.map((v) => {
        const E = c[v];
        return d(E ? () => E(l) : () => l[v], (T) => {
          if (g[v] = T, m.length) {
            const V = m.indexOf(v);
            V >= 0 && m.splice(V, 1);
          }
          m.length || h(g);
        });
      });
      return function() {
        C.forEach((v) => v());
      };
    }(a, e, t, n, s);
  });
  return function() {
    o && o(), r && r();
  };
};
class rr extends sr {
  constructor(e, t, n, s) {
    super(), this._render = e, this._fields = t, this._fieldsMap = s || {}, this._watchMethod = n;
  }
  _renderCore(e) {
    const t = p(e.container), n = Yq(e.model, this._watchMethod, this._fields, this._fieldsMap, (s) => {
      t.empty(), this._render(t, s, e.model);
    });
    return _.on(t, On, n), t.contents();
  }
}
const Rb = "_dataSourceChangedHandler", Fb = "_getSpecificDataSourceOption", kb = "_normalizeDataSource", NO = {
  postCtor() {
    this.on("disposing", () => {
      this._disposeDataSource();
    });
  },
  _refreshDataSource() {
    this._initDataSource(), this._loadDataSource();
  },
  _initDataSource() {
    let i = Fb in this ? this[Fb]() : this.option("dataSource"), e, t;
    this._disposeDataSource(), i && (i instanceof In ? (this._isSharedDataSource = !0, this._dataSource = i) : (e = "_dataSourceOptions" in this ? this._dataSourceOptions() : {}, t = this._dataSourceType ? this._dataSourceType() : In, i = lo(i, {
      fromUrlLoadMode: "_dataSourceFromUrlLoadMode" in this && this._dataSourceFromUrlLoadMode()
    }), this._dataSource = new t(x(!0, {}, e, i))), kb in this && (this._dataSource = this[kb](this._dataSource)), this._addDataSourceHandlers(), this._initDataController());
  },
  _initDataController() {
    var i;
    const e = (i = this.option) === null || i === void 0 ? void 0 : i.call(this, "_dataController"), t = this._dataSource;
    e ? this._dataController = e : this._dataController = new xO(t);
  },
  _addDataSourceHandlers() {
    Rb in this && this._addDataSourceChangeHandler(), "_dataSourceLoadErrorHandler" in this && this._addDataSourceLoadErrorHandler(), "_dataSourceLoadingChangedHandler" in this && this._addDataSourceLoadingChangedHandler(), this._addReadyWatcher();
  },
  _addReadyWatcher() {
    this.readyWatcher = function(i) {
      this._ready && this._ready(!i);
    }.bind(this), this._dataSource.on("loadingChanged", this.readyWatcher);
  },
  _addDataSourceChangeHandler() {
    const i = this._dataSource;
    this._proxiedDataSourceChangedHandler = function(e) {
      this[Rb](i.items(), e);
    }.bind(this), i.on("changed", this._proxiedDataSourceChangedHandler);
  },
  _addDataSourceLoadErrorHandler() {
    this._proxiedDataSourceLoadErrorHandler = this._dataSourceLoadErrorHandler.bind(this), this._dataSource.on("loadError", this._proxiedDataSourceLoadErrorHandler);
  },
  _addDataSourceLoadingChangedHandler() {
    this._proxiedDataSourceLoadingChangedHandler = this._dataSourceLoadingChangedHandler.bind(this), this._dataSource.on("loadingChanged", this._proxiedDataSourceLoadingChangedHandler);
  },
  _loadDataSource() {
    const i = this._dataSource;
    i && (i.isLoaded() ? this._proxiedDataSourceChangedHandler && this._proxiedDataSourceChangedHandler() : i.load());
  },
  _loadSingle(i, e) {
    return i = i === "this" ? this._dataSource.key() || "this" : i, this._dataSource.loadSingle(i, e);
  },
  _isLastPage() {
    return !this._dataSource || this._dataSource.isLastPage() || !this._dataSource._pageSize;
  },
  _isDataSourceLoading() {
    return this._dataSource && this._dataSource.isLoading();
  },
  _disposeDataSource() {
    this._dataSource && (this._isSharedDataSource ? (delete this._isSharedDataSource, this._proxiedDataSourceChangedHandler && this._dataSource.off("changed", this._proxiedDataSourceChangedHandler), this._proxiedDataSourceLoadErrorHandler && this._dataSource.off("loadError", this._proxiedDataSourceLoadErrorHandler), this._proxiedDataSourceLoadingChangedHandler && this._dataSource.off("loadingChanged", this._proxiedDataSourceLoadingChangedHandler), this._dataSource._eventsStrategy && this._dataSource._eventsStrategy.off("loadingChanged", this.readyWatcher)) : this._dataSource.dispose(), delete this._dataSource, delete this._proxiedDataSourceChangedHandler, delete this._proxiedDataSourceLoadErrorHandler, delete this._proxiedDataSourceLoadingChangedHandler);
  },
  getDataSource() {
    return this._dataSource || null;
  }
}, jd = "dx-item", Xq = "dx-empty-collection", Zq = /^([^.]+\[\d+\]\.)+([\w.]+)$/;
let X_ = class extends Rt {
  _supportedKeys() {
    const e = (t, n) => {
      bt(n) || (n.preventDefault(), n.stopPropagation(), this._moveFocus(t, n));
    };
    return I({}, super._supportedKeys(), {
      space: (t) => {
        t.preventDefault(), this._enterKeyHandler(t);
      },
      enter: this._enterKeyHandler,
      leftArrow: e.bind(this, "left"),
      rightArrow: e.bind(this, "right"),
      upArrow: e.bind(this, "up"),
      downArrow: e.bind(this, "down"),
      pageUp: e.bind(this, "up"),
      pageDown: e.bind(this, "down"),
      home: e.bind(this, "first"),
      end: e.bind(this, "last")
    });
  }
  _getHandlerExtendedParams(e, t) {
    return x({}, e, {
      target: t.get(0),
      currentTarget: t.get(0)
    });
  }
  _enterKeyHandler(e) {
    const {
      focusedElement: t
    } = this.option(), n = p(t);
    if (!n.length)
      return;
    const s = this._getItemData(n);
    s != null && s.onClick && this._itemEventHandlerByHandler(n, s.onClick, {
      event: e
    }), this._itemClickHandler(this._getHandlerExtendedParams(e, n));
  }
  _getDefaultOptions() {
    return I({}, super._getDefaultOptions(), {
      selectOnFocus: !1,
      loopItemFocus: !0,
      items: [],
      itemTemplate: "item",
      onItemRendered: null,
      onItemClick: null,
      onItemHold: null,
      itemHoldTimeout: 750,
      onItemContextMenu: null,
      onFocusedItemChanged: null,
      noDataText: S.format("dxCollectionWidget-noDataText"),
      encodeNoDataText: !1,
      dataSource: null,
      _dataController: null,
      _itemAttributes: {},
      itemTemplateProperty: "template",
      focusedElement: null,
      displayExpr: void 0,
      disabledExpr: (e) => e ? e.disabled : void 0,
      visibleExpr: (e) => e ? e.visible : void 0
    });
  }
  _init() {
    this._compileDisplayGetter(), this._initDataController(), super._init(), this._activeStateUnit = `.${jd}`, this._cleanRenderedItems(), this._refreshDataSource();
  }
  _compileDisplayGetter() {
    const {
      displayExpr: e
    } = this.option();
    this._displayGetter = e ? Be(e) : void 0;
  }
  _initTemplates() {
    this._initItemsFromMarkup(), this._initDefaultItemTemplate(), super._initTemplates();
  }
  _getAnonymousTemplateName() {
    return "item";
  }
  _initDefaultItemTemplate() {
    const e = this._getFieldsMap();
    this._templateManager.addDefaultTemplates({
      item: new rr((t, n) => {
        pe(n) ? this._prepareDefaultItemTemplate(n, t) : (e && B(e.text) && (n = e.text(n)), t.text(String(Qe(n, ""))));
      }, this._getBindableFields(), this.option("integrationOptions.watchMethod"), e)
    });
  }
  _getBindableFields() {
    return ["text", "html"];
  }
  _getFieldsMap() {
    if (this._displayGetter)
      return {
        text: this._displayGetter
      };
  }
  _prepareDefaultItemTemplate(e, t) {
    const {
      text: n,
      html: s
    } = e;
    f(n) && t.text(n), f(s) && t.html(s);
  }
  _initItemsFromMarkup() {
    const e = pT(this.$element(), "dxItem");
    if (!e.length || this.option("items").length)
      return;
    const t = e.map((n) => {
      let {
        element: s,
        options: o
      } = n;
      return /\S/.test(s.innerHTML) && !o.template ? o.template = this._prepareItemTemplate(s) : p(s).remove(), o;
    });
    this.option("items", t);
  }
  _prepareItemTemplate(e) {
    const t = `tmpl-${new Xe()}`, n = p(e).detach().clone().removeAttr("data-options").addClass("dx-template-wrapper");
    return this._saveTemplate(t, n), t;
  }
  _dataSourceOptions() {
    return {
      paginate: !1
    };
  }
  _cleanRenderedItems() {
    this._renderedItemsCount = 0;
  }
  _focusTarget() {
    return this.$element();
  }
  _focusInHandler(e) {
    if (super._focusInHandler(e), !this._isFocusTarget(e.target))
      return;
    const t = p(this.option("focusedElement"));
    if (t.length)
      this._shouldSkipSelectOnFocus = !0, this._setFocusedItem(t), this._shouldSkipSelectOnFocus = !1;
    else {
      const n = this._getActiveItem();
      n.length && this.option("focusedElement", ee(n));
    }
  }
  _focusOutHandler(e) {
    super._focusOutHandler(e);
    const {
      focusedElement: t
    } = this.option(), n = p(t);
    this._updateFocusedItemState(n, !1);
  }
  _findActiveTarget(e) {
    return e.find(this._activeStateUnit);
  }
  _getActiveItem(e) {
    const {
      focusedElement: t
    } = this.option(), n = p(t);
    return n.length ? n : this._determineFocusedElement(e);
  }
  _determineFocusedElement(e) {
    let t = this._getFocusedElementIndex();
    const n = this._getActiveElement(), s = n.length - 1;
    return t < 0 && (t = e ? s : 0), n.eq(t);
  }
  _getFocusedElementIndex() {
    return 0;
  }
  _moveFocus(e, t) {
    const n = this._getAvailableItems();
    let s = p();
    switch (e) {
      case "pageup":
      case "up":
        s = this._prevItem(n);
        break;
      case "pagedown":
      case "down":
        s = this._nextItem(n);
        break;
      case "right":
        s = this.option("rtlEnabled") ? this._prevItem(n) : this._nextItem(n);
        break;
      case "left":
        s = this.option("rtlEnabled") ? this._nextItem(n) : this._prevItem(n);
        break;
      case "first":
        s = n.first();
        break;
      case "last":
        s = n.last();
        break;
      default:
        return !1;
    }
    s.length !== 0 && this.option("focusedElement", ee(s));
  }
  _getVisibleItems(e) {
    return (e ?? this._itemElements()).filter(":visible");
  }
  _getAvailableItems(e) {
    return this._getVisibleItems(e);
  }
  _prevItem(e) {
    const t = this._getActiveItem(), n = e.index(t), s = e.last();
    let o = p(e[n - 1]);
    const r = this.option("loopItemFocus");
    return o.length === 0 && r && (o = s), o;
  }
  _nextItem(e) {
    const t = this._getActiveItem(!0), n = e.index(t), s = e.first();
    let o = p(e[n + 1]);
    const r = this.option("loopItemFocus");
    return o.length === 0 && r && (o = s), o;
  }
  _selectFocusedItem(e) {
    this.selectItem(e);
  }
  _updateFocusedItemState(e, t, n) {
    const s = p(e);
    s.length && (this._refreshActiveDescendant(), this._refreshItemId(s, n), this._toggleFocusClass(t, s)), this._updateParentActiveDescendant();
  }
  _getElementClassToSkipRefreshId() {
    return "";
  }
  _shouldSkipRefreshId(e) {
    const t = this._getElementClassToSkipRefreshId();
    return p(e).hasClass(t);
  }
  _refreshActiveDescendant(e) {
    const {
      focusedElement: t
    } = this.option();
    if (f(t)) {
      const s = this._shouldSkipRefreshId(t) ? p(t).attr("id") : this.getFocusedItemId();
      this.setAria("activedescendant", s, e);
      return;
    }
    this.setAria("activedescendant", null, e);
  }
  _refreshItemId(e, t) {
    const {
      focusedElement: n
    } = this.option();
    this._shouldSkipRefreshId(e) || (!t && n ? this.setAria("id", this.getFocusedItemId(), e) : this.setAria("id", null, e));
  }
  _isDisabled(e) {
    return e && p(e).attr("aria-disabled") === "true";
  }
  _setFocusedItem(e) {
    if (!e || !e.length)
      return;
    this._updateFocusedItemState(e, !0), this.onFocusedItemChanged(this.getFocusedItemId());
    const {
      selectOnFocus: t
    } = this.option(), n = this._isDisabled(e);
    t && !n && !this._shouldSkipSelectOnFocus && this._selectFocusedItem(e);
  }
  _findItemElementByItem(e) {
    let t = p();
    const n = this._itemDataKey();
    return this.itemElements().each((s, o) => {
      const r = p(o);
      return r.data(n) === e ? (t = r, !1) : !0;
    }), t;
  }
  _getIndexByItem(e) {
    const {
      items: t
    } = this.option();
    return t.indexOf(e);
  }
  _itemOptionChanged(e, t, n, s) {
    const o = this._findItemElementByItem(e);
    if (!o.length)
      return;
    this.constructor.ItemClass.getInstance(o).setDataField(t, n) || this._refreshItem(o, e), t === "disabled" && n && this._resetItemFocus(o);
  }
  _resetItemFocus(e) {
    e.is(this.option("focusedElement")) && this._resetFocusedElement();
  }
  _resetFocusedElement() {
    this.option("focusedElement", null);
  }
  _refreshItem(e, t) {
    const n = this._getItemData(e), s = e.data(this._itemIndexKey());
    this._renderItem(this._renderedItemsCount + s, n, null, e);
  }
  _updateParentActiveDescendant() {
  }
  _optionChanged(e) {
    const {
      name: t,
      value: n,
      previousValue: s,
      fullName: o
    } = e;
    if (t === "items") {
      const r = o.match(Zq);
      if (r != null && r.length) {
        const a = r[r.length - 1], l = o.replace(`.${a}`, ""), d = this.option(l);
        this._itemOptionChanged(d, a, n, s);
        return;
      }
    }
    switch (t) {
      case "items":
      case "_itemAttributes":
      case "itemTemplateProperty":
      case "useItemTextAsTitle":
        this._cleanRenderedItems(), this._invalidate();
        break;
      case "dataSource":
        this._refreshDataSource(), this._renderEmptyMessage();
        break;
      case "noDataText":
      case "encodeNoDataText":
        this._renderEmptyMessage();
        break;
      case "itemTemplate":
      case "visibleExpr":
      case "disabledExpr":
        this._invalidate();
        break;
      case "onItemRendered":
        this._createItemRenderAction();
        break;
      case "onItemClick":
      case "selectOnFocus":
      case "loopItemFocus":
        break;
      case "onItemHold":
      case "itemHoldTimeout":
        this._attachHoldEvent();
        break;
      case "onItemContextMenu":
        this._attachContextMenuEvent();
        break;
      case "onFocusedItemChanged":
        this.onFocusedItemChanged = this._createActionByOption("onFocusedItemChanged");
        break;
      case "focusedElement":
        this._updateFocusedItemState(s, !1, !0), this._setFocusedItem(p(n));
        break;
      case "displayExpr":
        this._compileDisplayGetter(), this._initDefaultItemTemplate(), this._invalidate();
        break;
      default:
        super._optionChanged(e);
    }
  }
  _invalidate() {
    this._resetFocusedElement(), super._invalidate();
  }
  _loadNextPage() {
    return this._expectNextPageLoading(), this._dataController.loadNextPage();
  }
  _expectNextPageLoading() {
    this._startIndexForAppendedItems = 0;
  }
  _expectLastItemLoading() {
    this._startIndexForAppendedItems = -1;
  }
  _forgetNextPageLoading() {
    this._startIndexForAppendedItems = null;
  }
  _dataSourceChangedHandler(e, t) {
    const n = this.option("items");
    this._initialized && n && this._shouldAppendItems() ? (this._renderedItemsCount = n.length, (!this._isLastPage() || this._startIndexForAppendedItems !== -1) && (this.option().items = n.concat(e.slice(this._startIndexForAppendedItems))), this._forgetNextPageLoading(), this._refreshContent()) : this.option("items", e.slice());
  }
  _refreshContent() {
    this._prepareContent(), this._renderContent();
  }
  _dataSourceLoadErrorHandler() {
    this._forgetNextPageLoading(), this.option("items", this.option("items"));
  }
  _shouldAppendItems() {
    return this._startIndexForAppendedItems != null && this._allowDynamicItemsAppend();
  }
  _allowDynamicItemsAppend() {
    return !1;
  }
  _clean() {
    this._cleanFocusState(), this._cleanItemContainer(), this._inkRipple && delete this._inkRipple, this._resetActiveState();
  }
  _cleanItemContainer() {
    p(this._itemContainer()).empty();
  }
  _dispose() {
    super._dispose(), clearTimeout(this._itemFocusTimeout);
  }
  _refresh() {
    this._cleanRenderedItems(), super._refresh();
  }
  _itemContainer(e, t) {
    return this.$element();
  }
  _itemClass() {
    return jd;
  }
  _itemContentClass() {
    return `${this._itemClass()}-content`;
  }
  _itemResponseWaitClass() {
    return "dx-item-response-wait";
  }
  _itemSelector() {
    return `.${this._itemClass()}`;
  }
  _itemDataKey() {
    return "dxItemData";
  }
  _itemIndexKey() {
    return "dxItemIndex";
  }
  _itemElements() {
    return this._itemContainer().find(this._itemSelector());
  }
  _initMarkup() {
    super._initMarkup(), this.onFocusedItemChanged = this._createActionByOption("onFocusedItemChanged"), this.$element().addClass("dx-collection"), this._prepareContent();
  }
  _prepareContent() {
    Gr(() => {
      this._renderContentImpl();
    })();
  }
  _renderContent() {
    this._fireContentReadyAction();
  }
  _render() {
    super._render(), this._attachClickEvent(), this._attachHoldEvent(), this._attachContextMenuEvent();
  }
  _getPointerEvent() {
    return ye.down;
  }
  _attachClickEvent() {
    const e = this._itemSelector(), t = this._getPointerEvent(), n = R(Te, this.NAME), s = R(t, this.NAME), o = new vn((r) => {
      const {
        event: a
      } = r;
      this._itemPointerDownHandler(a);
    });
    _.off(this._itemContainer(), n, e), _.off(this._itemContainer(), s, e), _.on(this._itemContainer(), n, e, (r) => this._itemClickHandler(r)), _.on(this._itemContainer(), s, e, (r) => {
      o.execute({
        element: p(r.target),
        event: r
      });
    });
  }
  _itemClickHandler(e, t, n) {
    this._itemDXEventHandler(e, "onItemClick", t, n);
  }
  _itemPointerDownHandler(e) {
    this.option("focusStateEnabled") && (this._itemFocusHandler = () => {
      if (clearTimeout(this._itemFocusTimeout), this._itemFocusHandler = void 0, e.isDefaultPrevented())
        return;
      const t = p(e.target), n = t.closest(this._itemElements()), s = this._closestFocusable(t);
      n.length && this._isFocusTarget(s?.get(0)) && (this._shouldSkipSelectOnFocus = !0, this.option("focusedElement", ee(n)), this._shouldSkipSelectOnFocus = !1);
    }, this._itemFocusTimeout = setTimeout(this._forcePointerDownFocus.bind(this)));
  }
  _closestFocusable(e) {
    if (e.is(em))
      return e;
    let t = e.parent();
    for (; t.length && !O.isDocument(t.get(0)) && !O.isDocumentFragment(t.get(0)); ) {
      if (t.is(em))
        return t;
      t = t.parent();
    }
  }
  _forcePointerDownFocus() {
    this._itemFocusHandler && this._itemFocusHandler();
  }
  _updateFocusState(e, t) {
    super._updateFocusState(e, t), this._forcePointerDownFocus();
  }
  _attachHoldEvent() {
    const e = this._itemContainer(), t = this._itemSelector(), n = R(Zs.name, this.NAME);
    _.off(e, n, t), _.on(e, n, t, {
      timeout: this._getHoldTimeout()
    }, this._itemHoldHandler.bind(this));
  }
  _getHoldTimeout() {
    const {
      itemHoldTimeout: e
    } = this.option();
    return e;
  }
  _shouldFireHoldEvent() {
    return this.hasActionSubscription("onItemHold");
  }
  _itemHoldHandler(e) {
    this._shouldFireHoldEvent() ? this._itemDXEventHandler(e, "onItemHold") : e.cancel = !0;
  }
  _attachContextMenuEvent() {
    const e = this._itemContainer(), t = this._itemSelector(), n = R($O, this.NAME);
    _.off(e, n, t), _.on(e, n, t, this._itemContextMenuHandler.bind(this));
  }
  _shouldFireContextMenuEvent() {
    return this.hasActionSubscription("onItemContextMenu");
  }
  _itemContextMenuHandler(e) {
    this._shouldFireContextMenuEvent() ? this._itemDXEventHandler(e, "onItemContextMenu") : e.cancel = !0;
  }
  _renderContentImpl() {
    const {
      items: e
    } = this.option(), t = e ?? [];
    this._renderedItemsCount ? this._renderItems(t.slice(this._renderedItemsCount)) : this._renderItems(t);
  }
  _renderItems(e) {
    e.length && y(e, (t, n) => {
      this._renderItem(this._renderedItemsCount + t, n);
    }), this._renderEmptyMessage();
  }
  _getItemsContainer() {
    return this._itemContainer();
  }
  _setAttributes(e) {
    const t = I({}, this.option("_itemAttributes")), {
      class: n
    } = t;
    if (n) {
      const s = e.get(0).className;
      t.class = [s, n].join(" ");
    }
    e.attr(t);
  }
  _renderItem(e, t, n, s) {
    const o = e?.item ?? e, r = n ?? this._getItemsContainer(), a = this._renderItemFrame(o, t, r, s);
    this._setElementData(a, t, o), this._setAttributes(a), this._attachItemClickEvent(t, a);
    const l = this._getItemContent(a), {
      itemTemplate: d
    } = this.option(), u = this._renderItemContent({
      index: o,
      itemData: t,
      container: ee(l),
      contentClass: this._itemContentClass(),
      defaultTemplateName: d
    });
    return W(u).done((c) => {
      this._postprocessRenderItem({
        itemElement: a,
        itemContent: c,
        itemData: t,
        itemIndex: o
      }), this._executeItemRenderAction(e, t, ee(a));
    }), a;
  }
  _getItemContent(e) {
    const t = e.find(".dx-item-content-placeholder");
    return t.removeClass("dx-item-content-placeholder"), t;
  }
  _attachItemClickEvent(e, t) {
    !e || !e.onClick || _.on(t, Te, (n) => {
      this._itemEventHandlerByHandler(t, e.onClick, {
        event: n
      });
    });
  }
  _renderItemContent(e) {
    const t = this._getItemTemplateName(e), n = this._getTemplate(t);
    this._addItemContentClasses(e);
    const s = p(this._createItemByTemplate(n, e));
    return s.hasClass("dx-template-wrapper") ? this._renderItemContentByNode(e, s) : e.container;
  }
  _renderItemContentByNode(e, t) {
    return p(e.container).replaceWith(t), e.container = ee(t), this._addItemContentClasses(e), t;
  }
  _addItemContentClasses(e) {
    const t = [jd + "-content", e.contentClass];
    p(e.container).addClass(t.join(" "));
  }
  _appendItemToContainer(e, t, n) {
    t.appendTo(e);
  }
  _renderItemFrame(e, t, n, s) {
    const o = p("<div>");
    if (new this.constructor.ItemClass(o, this._itemOptions(), t || {}), s != null && s.length ? s.replaceWith(o) : this._appendItemToContainer.call(this, n, o, e), this.option("useItemTextAsTitle")) {
      const r = this._displayGetter ? this._displayGetter(t) : t;
      o.attr("title", r);
    }
    return o;
  }
  _itemOptions() {
    return {
      watchMethod: () => this.option("integrationOptions.watchMethod"),
      owner: this,
      fieldGetter: (e) => {
        const t = this.option(`${e}Expr`);
        return Be(t);
      }
    };
  }
  _postprocessRenderItem(e) {
  }
  _executeItemRenderAction(e, t, n) {
    this._getItemRenderAction()({
      itemElement: n,
      itemIndex: e,
      itemData: t
    });
  }
  _setElementData(e, t, n) {
    e.addClass([jd, this._itemClass()].join(" ")).data(this._itemDataKey(), t).data(this._itemIndexKey(), n);
  }
  _createItemRenderAction() {
    return this._itemRenderAction = this._createActionByOption("onItemRendered", {
      element: this.element(),
      excludeValidators: ["disabled", "readOnly"],
      category: "rendering"
    }), this._itemRenderAction;
  }
  _getItemRenderAction() {
    return this._itemRenderAction ?? this._createItemRenderAction();
  }
  _getItemTemplateName(e) {
    const t = e.itemData, n = e.templateProperty || this.option("itemTemplateProperty");
    return t && t[n] || e.defaultTemplateName;
  }
  _createItemByTemplate(e, t) {
    const {
      itemData: n,
      container: s,
      index: o
    } = t;
    return e.render({
      model: n,
      container: s,
      index: o,
      onRendered: this._onItemTemplateRendered(e, t)
    });
  }
  _onItemTemplateRendered(e, t) {
    return () => {
    };
  }
  _emptyMessageContainer() {
    return this._itemContainer();
  }
  _renderEmptyMessage(e) {
    const t = e ?? this.option("items"), n = this.option("noDataText"), s = !n || t && t.length || this._dataController.isLoading();
    s && this._$noData && (this._$noData.remove(), this._$noData = null, this.setAria("label", void 0)), s || (this._$noData = this._$noData ?? p("<div>").addClass("dx-empty-message"), this._$noData.appendTo(this._emptyMessageContainer()), this.option("encodeNoDataText") ? this._$noData.text(n) : this._$noData.html(n)), this.$element().toggleClass(Xq, !s);
  }
  _itemDXEventHandler(e, t, n, s) {
    this._itemEventHandler(e.target, t, x(n, {
      event: e
    }), s);
  }
  _itemEventHandler(e, t, n, s) {
    const o = this._createActionByOption(t, x({
      validatingTargetName: "itemElement"
    }, s));
    return this._itemEventHandlerImpl(e, o, n);
  }
  _itemEventHandlerByHandler(e, t, n, s) {
    const o = this._createAction(t, x({
      validatingTargetName: "itemElement"
    }, s));
    return this._itemEventHandlerImpl(e, o, n);
  }
  _itemEventHandlerImpl(e, t, n) {
    const s = this._closestItemElement(p(e)), o = x({}, n);
    return t(x(n, this._extendActionArgs(s), o));
  }
  _extendActionArgs(e) {
    return {
      itemElement: ee(e),
      itemIndex: this._itemElements().index(e),
      itemData: this._getItemData(e)
    };
  }
  _closestItemElement(e) {
    return p(e).closest(this._itemSelector());
  }
  _getItemData(e) {
    return p(e).data(this._itemDataKey());
  }
  _getSummaryItemsSize(e, t, n) {
    let s = 0;
    return t && y(t, (o, r) => {
      e === "width" ? s += Ee(r, n ?? !1) : e === "height" && (s += he(r, n ?? !1));
    }), s;
  }
  getFocusedItemId() {
    return this._focusedItemId || (this._focusedItemId = `dx-${new Xe()}`), this._focusedItemId;
  }
  itemElements() {
    return this._itemElements();
  }
  itemsContainer() {
    return this._itemContainer();
  }
};
X_.include(NO);
X_.ItemClass = ga;
class LO {
  constructor(e) {
    this._lastSelectAllPageDeferred = w().reject(), this.options = e, this._setOption("disabledItemKeys", []), this._clearItemKeys();
  }
  _clearItemKeys() {
    this._setOption("addedItemKeys", []), this._setOption("removedItemKeys", []), this._setOption("removedItems", []), this._setOption("addedItems", []);
  }
  validate() {
  }
  _setOption(e, t) {
    this.options[e] = t;
  }
  onSelectionChanging() {
    const {
      selectedItems: e,
      selectedItemKeys: t,
      addedItemKeys: n,
      removedItemKeys: s,
      addedItems: o,
      removedItems: r,
      onSelectionChanging: a = M
    } = this.options, l = {
      selectedItems: e,
      selectedItemKeys: t,
      addedItemKeys: n,
      removedItemKeys: s,
      addedItems: o,
      removedItems: r,
      cancel: !1
    };
    return a(l), l.cancel;
  }
  _callCallbackIfNotCanceled(e, t) {
    const n = this.onSelectionChanging();
    no(n) ? n.then((s) => {
      s ? t() : e();
    }).catch(() => {
      e();
    }) : n ? t() : e();
  }
  onSelectionChanged() {
    const {
      selectedItems: e,
      selectedItemKeys: t,
      addedItemKeys: n,
      removedItemKeys: s,
      addedItems: o,
      removedItems: r,
      onSelectionChanged: a = M
    } = this.options;
    this._clearItemKeys(), a({
      selectedItems: e,
      selectedItemKeys: t,
      addedItemKeys: n,
      removedItemKeys: s,
      addedItems: o,
      removedItems: r
    });
  }
  equalKeys(e, t) {
    return this.options.equalByReference && X(e) && X(t) ? e === t : He(e, t);
  }
  getSelectableItems(e) {
    return e.filter((t) => !(t != null && t.disabled));
  }
  _clearSelection(e, t, n, s) {
    return e = e || [], e = Array.isArray(e) ? e : [e], this.validate(), this.selectedItemKeys(e, t, n, s);
  }
  _removeTemplateProperty(e) {
    return Array.isArray(e) ? e.map((t) => this._removeTemplateProperty(t)) : (X(e) && delete e.template, e);
  }
  _loadFilteredData(e, t, n, s) {
    const o = encodeURI(JSON.stringify(this._removeTemplateProperty(e))).length, r = this.options.maxFilterLengthInRequest && o > this.options.maxFilterLengthInRequest, a = w(), l = {
      filter: r ? void 0 : e,
      select: r ? this.options.dataFields() : n || this.options.dataFields()
    };
    return e && e.length === 0 ? a.resolve([]) : this.options.load(l).done((d) => {
      let u = pe(d) ? d.data : d;
      t && !s ? u = u.filter(t) : r && (u = un(u).filter(e).toArray()), a.resolve(u);
    }).fail(a.reject.bind(a)), a;
  }
  updateSelectedItemKeyHash(e) {
    for (let t = 0; t < e.length; t++) {
      const n = xn(e[t]);
      X(n) || (this.options.keyHashIndices[n] = this.options.keyHashIndices[n] || [], this.options.keyHashIndices[n].push(t));
    }
  }
  _isAnyItemSelected(e) {
    for (let t = 0; t < e.length; t++)
      if (this.options.isItemSelected(e[t]))
        return;
    return !1;
  }
  _getFullSelectAllState() {
    const e = this.options.plainItems(), t = this.options.filter();
    let n = this.options.ignoreDisabledItems ? this.options.selectedItems : this.options.selectedItems.filter((r) => !(r != null && r.disabled));
    t && (n = un(n).filter(t).toArray());
    const s = n.length, o = e.length - this.getSelectableItems(e).length;
    if (!s)
      return this._isAnyItemSelected(e);
    if (s >= this.options.totalCount() - o)
      return !0;
  }
  _getVisibleSelectAllState() {
    const e = this.getSelectableItems(this.options.plainItems());
    let t = !1, n = !1;
    for (let s = 0; s < e.length; s++) {
      const o = e[s], r = this.options.getItemData(o), a = this.options.keyOf(r);
      this.options.isSelectableItem(o) && (this.isItemKeySelected(a) ? t = !0 : n = !0);
    }
    return t ? n ? void 0 : !0 : !1;
  }
  isItemKeySelected(e) {
    throw new Error("isItemKeySelected method should be overriden");
  }
  addSelectedItem(e, t) {
    throw new Error("addSelectedItem method should be overriden");
  }
  removeSelectedItem(e) {
    throw new Error("removeSelectedItem method should be overriden");
  }
  _selectAllPlainItems(e) {
    const t = this.getSelectableItems(this.options.plainItems());
    for (let n = 0; n < t.length; n++) {
      const s = t[n];
      if (this.options.isSelectableItem(s)) {
        const o = this.options.getItemData(s), r = this.options.keyOf(o), a = this.isItemKeySelected(r);
        !a && !e && this.addSelectedItem(r, o), a && e && this.removeSelectedItem(r);
      }
    }
  }
}
class Qq extends LO {
  getSelectedItems() {
    return this._loadFilteredData(this.options.selectionFilter);
  }
  getSelectedItemKeys() {
    const e = w(), t = this, n = this.options.key(), s = te(n) ? [n] : n;
    return this._loadFilteredData(this.options.selectionFilter, null, s).done((o) => {
      const r = o.map((a) => t.options.keyOf(a));
      e.resolve(r);
    }).fail(e.reject), e.promise();
  }
  selectedItemKeys(e, t, n, s) {
    if (s) {
      const o = this.options.filter();
      !o || JSON.stringify(o) === JSON.stringify(this.options.selectionFilter) && n ? this._setOption("selectionFilter", n ? [] : null) : this._addSelectionFilter(n, o, s);
    } else {
      t || this._setOption("selectionFilter", []);
      for (let o = 0; o < e.length; o++)
        n ? this.removeSelectedItem(e[o]) : this.addSelectedItem(e[o], s, !t);
    }
    return this.onSelectionChanged(), w().resolve();
  }
  setSelectedItems(e) {
    this._setOption("selectionFilter", null);
    for (let t = 0; t < e.length; t++)
      this.addSelectedItem(e[t]);
  }
  isItemDataSelected(e) {
    return this.isItemKeySelected(e);
  }
  isItemKeySelected(e) {
    const {
      selectionFilter: t,
      sensitivity: n
    } = this.options;
    return t ? !!un([e], {
      langParams: {
        collatorOptions: {
          sensitivity: n
        }
      }
    }).filter(t).toArray().length : !0;
  }
  _getKeyExpr() {
    const e = this.options.key();
    return Array.isArray(e) && e.length === 1 ? e[0] : e;
  }
  _normalizeKey(e) {
    const t = this.options.key();
    return Array.isArray(t) && t.length === 1 ? e[t[0]] : e;
  }
  _getFilterByKey(e) {
    const t = this._getKeyExpr();
    let n = [t, "=", this._normalizeKey(e)];
    if (Array.isArray(t)) {
      n = [];
      for (let s = 0; s < t.length; s++)
        n.push([t[s], "=", e[t[s]]]), s !== t.length - 1 && n.push("and");
    }
    return n;
  }
  addSelectedItem(e, t, n) {
    const s = this._getFilterByKey(e);
    this._addSelectionFilter(!1, s, t, n);
  }
  removeSelectedItem(e) {
    const t = this._getFilterByKey(e);
    this._addSelectionFilter(!0, t);
  }
  validate() {
    const {
      key: e
    } = this.options;
    if (e && e() === void 0)
      throw _e.Error("E1042", "Deferred selection");
  }
  _findSubFilter(e, t) {
    if (!e)
      return -1;
    const n = JSON.stringify(t);
    for (let s = 0; s < e.length; s++) {
      const o = e[s];
      if (o && JSON.stringify(o) === n)
        return s;
    }
    return -1;
  }
  _isLastSubFilter(e, t) {
    return e && t ? this._findSubFilter(e, t) === e.length - 1 || this._findSubFilter([e], t) === 0 : !1;
  }
  _addFilterOperator(e, t) {
    return e.length > 1 && te(e[1]) && e[1] !== t && (e = [e]), e.length && e.push(t), e;
  }
  _denormalizeFilter(e) {
    return e && te(e[0]) && (e = [e]), e;
  }
  _isOnlyNegativeFiltersLeft(e) {
    return e.every((t, n) => n % 2 === 0 ? Array.isArray(t) && t[0] === "!" : t === "and");
  }
  _addSelectionFilter(e, t, n, s) {
    var o;
    const r = this, a = e ? ["!", t] : t, l = e ? "and" : "or";
    let d = !0, u = r.options.selectionFilter || [];
    if (u = r._denormalizeFilter(u), (o = u) !== null && o !== void 0 && o.length && !s) {
      const c = r._removeSameFilter(u, t, e, n), h = r._removeSameFilter(u, t, !e);
      e && (c !== -1 || h !== -1) && this._isOnlyNegativeFiltersLeft(u) && (u = []);
      const m = this._isKeyFilter(t) && this._hasKeyFiltersOnlyStartingFromIndex(u, h);
      d = t.length && !m;
    }
    d && (u = r._addFilterOperator(u, l), u.push(a)), u = r._normalizeFilter(u), r._setOption("selectionFilter", !e && !u.length ? null : u);
  }
  _normalizeFilter(e) {
    return e && e.length === 1 && (e = e[0]), e;
  }
  _removeFilterByIndex(e, t, n) {
    const s = e[1];
    t > 0 ? e.splice(t - 1, 2) : e.splice(t, 2), n && s === "and" && e.splice(0, e.length);
  }
  _isSimpleKeyFilter(e, t) {
    return e.length === 3 && e[0] === t && e[1] === "=";
  }
  _isKeyFilter(e) {
    if (e.length === 2 && e[0] === "!")
      return this._isKeyFilter(e[1]);
    const t = this._getKeyExpr();
    if (Array.isArray(t)) {
      if (e.length !== 2 * t.length - 1)
        return !1;
      for (let n = 0; n < t.length; n++)
        if (n > 0 && e[2 * n - 1] !== "and" || !this._isSimpleKeyFilter(e[2 * n], t[n]))
          return !1;
      return !0;
    }
    return this._isSimpleKeyFilter(e, t);
  }
  _hasKeyFiltersOnlyStartingFromIndex(e, t) {
    if (t >= 0) {
      for (let n = t; n < e.length; n++)
        if (typeof e[n] != "string" && !this._isKeyFilter(e[n]))
          return !1;
      return !0;
    }
    return !1;
  }
  _removeSameFilter(e, t, n, s) {
    if (t = n ? ["!", t] : t, JSON.stringify(t) === JSON.stringify(e))
      return e.splice(0, e.length), 0;
    const o = this._findSubFilter(e, t);
    if (o >= 0)
      return this._removeFilterByIndex(e, o, s), o;
    for (let r = 0; r < e.length; r++)
      if (Array.isArray(e[r]) && e[r].length > 2) {
        const a = this._removeSameFilter(e[r], t, !1, s);
        if (a >= 0)
          return e[r].length ? e[r].length === 1 && (e[r] = e[r][0]) : this._removeFilterByIndex(e, r, s), a;
      }
    return -1;
  }
  getSelectAllState() {
    const e = this.options.filter();
    let {
      selectionFilter: t
    } = this.options;
    if (!t)
      return !0;
    if (!t.length)
      return !1;
    if (!(!e || !e.length)) {
      if (t = this._denormalizeFilter(t), this._isLastSubFilter(t, e))
        return !0;
      if (this._isLastSubFilter(t, ["!", e]))
        return !1;
    }
  }
  loadSelectedItemsWithFilter() {
    const e = this.options.filter(), {
      selectionFilter: t
    } = this.options, n = e ? [e, "and", t] : t;
    return this._loadFilteredData(n);
  }
  _onePageSelectAll(e) {
    return this._selectAllPlainItems(e), this.onSelectionChanged(), w().resolve();
  }
}
const Vb = function(i, e) {
  this.getLocalFilter = function(a, l, d, u) {
    return l = l === void 0 ? He : l, o.bind(this, l, a, d, u);
  }, this.getExpr = function(a) {
    if (!a)
      return;
    let l;
    return i.forEach(function(d, u) {
      l = l || [];
      let c;
      u > 0 && l.push(e ? "and" : "or"), te(a) || B(a) ? c = r(a, d) : c = function(h, g) {
        const m = [];
        for (let C = 0, {
          length: v
        } = h; C < v; C++) {
          const E = h[C], T = Be(E), V = g && T(g), $ = r(E, V);
          if (!$)
            break;
          C > 0 && m.push(e ? "or" : "and"), m.push($);
        }
        return m;
      }(a, d), l.push(c);
    }), l && l.length === 1 && (l = l[0]), l;
  }, this.getCombinedFilter = function(a, l) {
    let d = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : !1;
    const u = this.getExpr(a);
    let c = u;
    return (d || e) && l && (u ? (c = [], c.push(u), c.push(l)) : c = l), c;
  };
  let t;
  const n = function(a, l) {
    if (!t) {
      t = {};
      const d = s(i, a, l);
      for (let u = 0; u < d.length; u++)
        t[xn(d[u])] = !0;
    }
    return t;
  }, s = function(a, l, d) {
    return Array.isArray(d) ? a.map((u) => l(u)) : a;
  };
  function o(a, l, d, u, c) {
    const h = l(c);
    let g, m;
    if (!d && (g = xn(h), !X(g)))
      return n(l, u)[g] ? !e : !!e;
    for (m = 0; m < i.length; m++)
      if (a(i[m], h))
        return !e;
    return !!e;
  }
  function r(a, l) {
    if (l !== void 0)
      return [a, e ? "<>" : "=", l];
  }
};
class Jq extends LO {
  constructor(e) {
    super(e), this._lastSelectAllPageDeferred = w().reject(), this._initSelectedItemKeyHash();
  }
  _initSelectedItemKeyHash() {
    this._setOption("keyHashIndices", this.options.equalByReference ? null : {});
  }
  getSelectedItemKeys() {
    return this.options.selectedItemKeys.slice(0);
  }
  getSelectedItems() {
    return this.options.selectedItems.slice(0);
  }
  _preserveSelectionUpdate(e, t) {
    const {
      keyOf: n
    } = this.options;
    let s, o, r;
    if (!n)
      return;
    const a = t && e.length > 1 && !this.options.equalByReference;
    for (a && (s = {}), r = 0; r < e.length; r++) {
      const l = e[r], d = n(l);
      t ? (o = this.removeSelectedItem(d, s, l?.disabled), s && o >= 0 && (s[o] = !0)) : this.addSelectedItem(d, l);
    }
    a && this._batchRemoveSelectedItems(s);
  }
  _batchRemoveSelectedItems(e) {
    const t = this.options.selectedItemKeys.slice(0), n = this.options.selectedItems.slice(0);
    this.options.selectedItemKeys.length = 0, this.options.selectedItems.length = 0;
    for (let s = 0; s < t.length; s++)
      e[s] || (this.options.selectedItemKeys.push(t[s]), this.options.selectedItems.push(n[s]));
    this._initSelectedItemKeyHash(), this.updateSelectedItemKeyHash(this.options.selectedItemKeys);
  }
  _loadSelectedItemsCore(e, t, n, s) {
    let o = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : !1, r = w();
    const a = this.options.key();
    if (!e.length && !n)
      return r.resolve([]), r;
    if (n && t && !s)
      return r.resolve(this.getSelectedItems()), r;
    const l = new Vb(e, n), d = l.getCombinedFilter(a, s, o);
    let u = [];
    if (t) {
      const {
        selectedItems: g
      } = this.options;
      u = d && e.length !== g.length ? un(g).filter(d).toArray() : g.slice(0);
    }
    let c = u.length ? u : this.options.plainItems(!0).filter(this.options.isSelectableItem).map(this.options.getItemData);
    const h = l.getLocalFilter(this.options.keyOf, this.equalKeys.bind(this), this.options.equalByReference, a);
    return c = c.filter(h), u.length || !n && c.length === e.length ? r.resolve(c) : r = this._loadFilteredData(d, h, null, n), r;
  }
  _replaceSelectionUpdate(e) {
    const t = [], {
      keyOf: n
    } = this.options;
    if (n) {
      for (let s = 0; s < e.length; s++) {
        const o = e[s], r = n(o);
        t.push(r);
      }
      this.setSelectedItems(t, e);
    }
  }
  _warnOnIncorrectKeys(e) {
    const {
      allowNullValue: t
    } = this.options;
    for (let n = 0; n < e.length; n++) {
      const s = e[n];
      (!t || s !== null) && !this.isItemKeySelected(s) && _e.log("W1002", s);
    }
  }
  _isMultiSelectEnabled() {
    const {
      mode: e
    } = this.options;
    return e === "all" || e === "multiple";
  }
  _requestInProgress() {
    var e;
    return ((e = this._lastLoadDeferred) === null || e === void 0 ? void 0 : e.state()) === "pending";
  }
  _concatRequestsItems(e, t, n, s) {
    let o;
    const r = t ? e : [];
    return s ? o = s : o = Ey(e, this.options.selectedItemKeys), {
      addedItems: n.added.concat(o),
      removedItems: n.removed.concat(r),
      keys: e
    };
  }
  _collectLastRequestData(e, t, n, s) {
    const o = t && n, r = {
      added: [],
      removed: []
    }, a = this._isMultiSelectEnabled();
    let l = a ? this._lastRequestData : {};
    return a && (this._shouldMergeWithLastRequest && (o ? (this._lastLoadDeferred.reject(), l = {}) : fq(e, this.options.selectedItemKeys) || (r.added = l.addedItems, r.removed = l.removedItems, t || this._lastLoadDeferred.reject())), l = this._concatRequestsItems(e, t, r, this._shouldMergeWithLastRequest ? void 0 : s)), l;
  }
  _updateKeysByLastRequestData(e, t, n) {
    let s = e;
    if (this._isMultiSelectEnabled() && this._shouldMergeWithLastRequest && !t && !n) {
      var o, r;
      s = Ey(e.concat((o = this._lastRequestData) === null || o === void 0 ? void 0 : o.addedItems), (r = this._lastRequestData) === null || r === void 0 ? void 0 : r.removedItems), s = q4(s);
    }
    return s;
  }
  _loadSelectedItems(e, t, n, s) {
    let o = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : !1;
    const r = this, a = w(), l = r.options.filter();
    return this._shouldMergeWithLastRequest = this._requestInProgress(), this._lastRequestData = this._collectLastRequestData(e, t, n, s), W(r._lastLoadDeferred).always(() => {
      const d = r._updateKeysByLastRequestData(e, t, n);
      r._shouldMergeWithLastRequest = !1, r._loadSelectedItemsCore(d, t, n, l, o).done(a.resolve).fail(a.reject);
    }), r._lastLoadDeferred = a, a;
  }
  selectedItemKeys(e, t, n, s, o) {
    let r = arguments.length > 5 && arguments[5] !== void 0 ? arguments[5] : !1;
    if (this._isCancelingInProgress)
      return w().reject();
    const a = this._loadSelectedItems(e, n, s, o, r), l = w();
    return a.done((d) => {
      this._storeSelectionState(), t ? this._preserveSelectionUpdate(d, n) : this._replaceSelectionUpdate(d), this._isCancelingInProgress = !0, this._callCallbackIfNotCanceled(() => {
        this._isCancelingInProgress = !1, this.onSelectionChanged(), l.resolve(d);
      }, () => {
        this._isCancelingInProgress = !1, this._restoreSelectionState(), l.reject();
      });
    }), l;
  }
  addSelectedItem(e, t) {
    if (f(t) && !this.options.ignoreDisabledItems && t.disabled) {
      this.options.disabledItemKeys.indexOf(e) === -1 && this.options.disabledItemKeys.push(e);
      return;
    }
    const n = this._getKeyHash(e);
    this._indexOfSelectedItemKey(n) === -1 && (!X(n) && this.options.keyHashIndices && (this.options.keyHashIndices[n] = [this.options.selectedItemKeys.length]), this.options.selectedItemKeys.push(e), this.options.addedItemKeys.push(e), this.options.addedItems.push(t), this.options.selectedItems.push(t));
  }
  _getSelectedIndexByKey(e, t) {
    const {
      selectedItemKeys: n
    } = this.options;
    for (let s = 0; s < n.length; s++)
      if ((!t || !t[s]) && this.equalKeys(n[s], e))
        return s;
    return -1;
  }
  _getSelectedIndexByHash(e, t) {
    let n = this.options.keyHashIndices[e];
    return n && n.length > 1 && t && (n = n.filter((s) => !t[s])), n && n[0] >= 0 ? n[0] : -1;
  }
  _indexOfSelectedItemKey(e, t) {
    let n;
    return this.options.equalByReference ? n = this.options.selectedItemKeys.indexOf(e) : X(e) ? n = this._getSelectedIndexByKey(e, t) : n = this._getSelectedIndexByHash(e, t), n;
  }
  _shiftSelectedKeyIndices(e) {
    for (let t = e; t < this.options.selectedItemKeys.length; t++) {
      const n = this.options.selectedItemKeys[t], s = xn(n), o = this.options.keyHashIndices[s];
      if (o)
        for (let r = 0; r < o.length; r++)
          o[r] > e && o[r]--;
    }
  }
  removeSelectedItem(e, t, n) {
    if (!this.options.ignoreDisabledItems && n)
      return;
    const s = this._getKeyHash(e), o = !!t, r = this._indexOfSelectedItemKey(s, t);
    if (r < 0 || (this.options.removedItemKeys.push(e), this.options.removedItems.push(this.options.selectedItems[r]), o) || (this.options.selectedItemKeys.splice(r, 1), this.options.selectedItems.splice(r, 1), X(s) || !this.options.keyHashIndices))
      return r;
    const a = this.options.keyHashIndices[s];
    return a && (a.shift(), a.length || delete this.options.keyHashIndices[s], this._shiftSelectedKeyIndices(r)), r;
  }
  _updateAddedItemKeys(e, t) {
    for (let n = 0; n < e.length; n++)
      this.isItemKeySelected(e[n]) || (this.options.addedItemKeys.push(e[n]), this.options.addedItems.push(t[n]));
  }
  _updateRemovedItemKeys(e, t, n) {
    for (let s = 0; s < t.length; s++)
      this.isItemKeySelected(t[s]) || (this.options.removedItemKeys.push(t[s]), this.options.removedItems.push(n[s]));
  }
  _isItemSelectionInProgress(e, t) {
    return t && this._lastRequestData && this._requestInProgress() ? (this._lastRequestData.addedItems ?? []).includes(e) : !1;
  }
  _getKeyHash(e) {
    return this.options.equalByReference ? e : xn(e);
  }
  setSelectedItems(e, t) {
    this._updateAddedItemKeys(e, t);
    const n = this.options.selectedItemKeys, s = this.options.selectedItems;
    this.options.equalByReference || (this._initSelectedItemKeyHash(), this.updateSelectedItemKeyHash(e)), this._setOption("selectedItemKeys", e), this._setOption("selectedItems", t), this._updateRemovedItemKeys(e, n, s);
  }
  isItemDataSelected(e) {
    let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    const n = this.options.keyOf(e);
    return this.isItemKeySelected(n, t);
  }
  isItemKeySelected(e) {
    let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, n = this._isItemSelectionInProgress(e, t.checkPending);
    if (!n) {
      const s = this._getKeyHash(e);
      n = this._indexOfSelectedItemKey(s) !== -1;
    }
    return n;
  }
  getSelectAllState(e) {
    return e ? this._getVisibleSelectAllState() : this._getFullSelectAllState();
  }
  loadSelectedItemsWithFilter() {
    const e = this.options.key(), t = this.getSelectedItemKeys(), n = this.options.filter();
    if (!t.length)
      return w().resolve([]);
    const o = new Vb(t).getCombinedFilter(e, n, !0);
    return this._loadFilteredData(o);
  }
  _storeSelectionState() {
    const {
      selectedItems: e,
      selectedItemKeys: t,
      keyHashIndices: n
    } = this.options;
    this._storedSelectionState = {
      keyHashIndices: JSON.stringify(n),
      selectedItems: [...e],
      selectedItemKeys: [...t]
    };
  }
  _restoreSelectionState() {
    this._clearItemKeys();
    const {
      selectedItemKeys: e,
      selectedItems: t,
      keyHashIndices: n
    } = this._storedSelectionState;
    this._setOption("selectedItemKeys", e), this._setOption("selectedItems", t), this._setOption("keyHashIndices", JSON.parse(n));
  }
  _onePageSelectAll(e) {
    return this._lastSelectAllPageDeferred.state() === "pending" ? w().reject() : (this._storeSelectionState(), this._selectAllPlainItems(e), this._lastSelectAllPageDeferred = w(), this._callCallbackIfNotCanceled(() => {
      this.onSelectionChanged(), this._lastSelectAllPageDeferred.resolve();
    }, () => {
      this._restoreSelectionState(), this._lastSelectAllPageDeferred.reject();
    }), this._lastSelectAllPageDeferred);
  }
}
class HO {
  constructor(e) {
    this.options = x(this._getDefaultOptions(), e, {
      selectedItemKeys: e.selectedKeys || []
    }), this._selectionStrategy = this.options.deferred ? new Qq(this.options) : new Jq(this.options), this._focusedItemIndex = -1, this.options.equalByReference || this._selectionStrategy.updateSelectedItemKeyHash(this.options.selectedItemKeys);
  }
  _getDefaultOptions() {
    return {
      allowNullValue: !1,
      deferred: !1,
      equalByReference: !1,
      mode: "multiple",
      selectedItems: [],
      selectionFilter: [],
      maxFilterLengthInRequest: 0,
      onSelectionChanged: M,
      key: M,
      keyOf: (e) => e,
      load: () => w().resolve([]),
      totalCount: () => -1,
      isSelectableItem: () => !0,
      isItemSelected: () => !1,
      getItemData: (e) => e,
      dataFields: M,
      filter: M
    };
  }
  validate() {
    this._selectionStrategy.validate();
  }
  getSelectedItemKeys() {
    return this._selectionStrategy.getSelectedItemKeys();
  }
  getSelectedItems() {
    return this._selectionStrategy.getSelectedItems();
  }
  selectionFilter(e) {
    if (e === void 0)
      return this.options.selectionFilter;
    const t = this.options.selectionFilter !== e && JSON.stringify(this.options.selectionFilter) !== JSON.stringify(e);
    this.options.selectionFilter = e, t && this.onSelectionChanged();
  }
  setSelection(e, t) {
    return this.selectedItemKeys(e, !1, !1, !1, t);
  }
  select(e) {
    return this.selectedItemKeys(e, !0);
  }
  deselect(e) {
    return this.selectedItemKeys(e, !0, !0);
  }
  selectedItemKeys(e, t, n, s, o) {
    return e = e ?? [], e = Array.isArray(e) ? e : [e], this.validate(), this._selectionStrategy.selectedItemKeys(e, t, n, s, o);
  }
  clearSelection() {
    return this.selectedItemKeys([]);
  }
  _addSelectedItem(e, t) {
    this._selectionStrategy.addSelectedItem(t, e);
  }
  _removeSelectedItem(e) {
    this._selectionStrategy.removeSelectedItem(e);
  }
  _setSelectedItems(e, t) {
    this._selectionStrategy.setSelectedItems(e, t);
  }
  onSelectionChanged() {
    this._selectionStrategy.onSelectionChanged();
  }
  changeItemSelection(e, t, n) {
    var s, o;
    let r;
    const a = this.options.plainItems(), l = a[e];
    let d;
    const {
      isVirtualPaging: u
    } = this.options, c = (s = (o = this.options).allowLoadByRange) === null || s === void 0 ? void 0 : s.call(o), {
      alwaysSelectByShift: h
    } = this.options;
    let g, m = !1, C = !1;
    const v = ($) => $ >= 0 && !a.filter((G) => G.loadIndex === $).length;
    if (u && f(l) && (c && (g = l.loadIndex - e, e = l.loadIndex), m = v(this._focusedItemIndex), f(this._shiftFocusedItemIndex) && (C = v(this._shiftFocusedItemIndex))), !this.isSelectable() || !this.isDataItem(l))
      return !1;
    const E = this.options.getItemData(l), T = this.options.keyOf(E);
    t = t || {};
    let V = t.shift;
    if (h === !1 && V && (V = c !== !1 || !m && !C), V && this.options.mode === "multiple" && this._focusedItemIndex >= 0)
      c && (m || C) ? (r = e !== this._shiftFocusedItemIndex || this._focusedItemIndex !== this._shiftFocusedItemIndex, r && (d = this.changeItemSelectionWhenShiftKeyInVirtualPaging(e))) : r = this.changeItemSelectionWhenShiftKeyPressed(e, a, g);
    else if (t.control) {
      if (this._resetItemSelectionWhenShiftKeyPressed(), !n) {
        const $ = this._selectionStrategy.isItemDataSelected(E);
        this.options.mode === "single" && this.clearSelectedItems(), $ ? this._removeSelectedItem(T) : this._addSelectedItem(E, T);
      }
      r = !0;
    } else {
      this._resetItemSelectionWhenShiftKeyPressed();
      const $ = this._selectionStrategy.equalKeys(this.options.selectedItemKeys[0], T);
      (this.options.selectedItemKeys.length !== 1 || !$) && (this._setSelectedItems([T], [E]), r = !0);
    }
    if (r)
      return W(d).done(() => {
        this._focusedItemIndex = e, !n && this.onSelectionChanged();
      }), !0;
  }
  isDataItem(e) {
    return this.options.isSelectableItem(e);
  }
  isSelectable() {
    return this.options.mode === "single" || this.options.mode === "multiple";
  }
  isItemDataSelected(e) {
    return this._selectionStrategy.isItemDataSelected(e, {
      checkPending: !0
    });
  }
  isItemSelected(e, t) {
    return this._selectionStrategy.isItemKeySelected(e, t);
  }
  _resetItemSelectionWhenShiftKeyPressed() {
    delete this._shiftFocusedItemIndex;
  }
  _resetFocusedItemIndex() {
    this._focusedItemIndex = -1;
  }
  changeItemSelectionWhenShiftKeyInVirtualPaging(e) {
    const t = this.options.getLoadOptions(e, this._focusedItemIndex, this._shiftFocusedItemIndex), n = w(), s = t.skip;
    return this.options.load(t).done((o) => {
      this.changeItemSelectionWhenShiftKeyPressed(e, o, s), n.resolve();
    }), n.promise();
  }
  changeItemSelectionWhenShiftKeyPressed(e, t, n) {
    let s = !1, o;
    const r = f(n);
    let a = r ? this._focusedItemIndex - n : this._focusedItemIndex;
    const {
      keyOf: l
    } = this.options, d = t[a], u = this.options.getItemData(d), c = l(u), h = d && this.isItemDataSelected(u);
    f(this._shiftFocusedItemIndex) || (this._shiftFocusedItemIndex = this._focusedItemIndex);
    let g, m, C, v;
    if (this._shiftFocusedItemIndex !== this._focusedItemIndex)
      for (o = this._focusedItemIndex < this._shiftFocusedItemIndex ? 1 : -1, C = r ? this._focusedItemIndex - n : this._focusedItemIndex, v = r ? this._shiftFocusedItemIndex - n : this._shiftFocusedItemIndex, a = C; a !== v; a += o)
        (r || this.isDataItem(t[a])) && (m = l(this.options.getItemData(t[a])), this._removeSelectedItem(m), s = !0);
    if (e !== this._shiftFocusedItemIndex)
      for (o = e < this._shiftFocusedItemIndex ? 1 : -1, C = r ? e - n : e, v = r ? this._shiftFocusedItemIndex - n : this._shiftFocusedItemIndex, a = C; a !== v; a += o)
        (r || this.isDataItem(t[a])) && (g = this.options.getItemData(t[a]), m = l(g), this._addSelectedItem(g, m), s = !0);
    return (r || this.isDataItem(d)) && !h && (this._addSelectedItem(u, c), s = !0), s;
  }
  clearSelectedItems() {
    this._setSelectedItems([], []);
  }
  selectAll(e) {
    return this._resetFocusedItemIndex(), e ? this._selectionStrategy._onePageSelectAll(!1) : this.selectedItemKeys([], !0, !1, !0);
  }
  deselectAll(e) {
    return this._resetFocusedItemIndex(), e ? this._selectionStrategy._onePageSelectAll(!0) : this.selectedItemKeys([], !0, !0, !0);
  }
  getSelectAllState(e) {
    return this._selectionStrategy.getSelectAllState(e);
  }
  loadSelectedItemsWithFilter() {
    return this._selectionStrategy.loadSelectedItemsWithFilter();
  }
}
const Lr = -1, Qn = (i) => i !== Lr;
class vd extends X_ {
  _setOptionsByReference() {
    super._setOptionsByReference(), x(this._optionsByReference, {
      selectedItem: !0
    });
  }
  _getDefaultOptions() {
    return I({}, super._getDefaultOptions(), {
      selectionMode: "none",
      selectionRequired: !1,
      selectByClick: !0,
      selectedItems: [],
      selectedItemKeys: [],
      maxFilterLengthInRequest: 1500,
      keyExpr: null,
      selectedIndex: Lr,
      focusOnSelectedItem: !0,
      selectedItem: null,
      onSelectionChanging: null,
      onSelectionChanged: null,
      onItemReordered: null,
      onItemDeleting: null,
      onItemDeleted: null
    });
  }
  ctor(e, t) {
    this._userOptions = t || {}, super.ctor(e, t);
  }
  _init() {
    this._initEditStrategy(), super._init(), this._initKeyGetter(), this._initActions(), this._initSelectionModule();
  }
  _initKeyGetter() {
    this._keyGetter = Be(this.option("keyExpr"));
  }
  _selectedItemClass() {
    return "dx-item-selected";
  }
  _getActionsList() {
    return ["onSelectionChanging", "onSelectionChanged"];
  }
  _initActions() {
    this._actions = {}, this._getActionsList().forEach((t) => {
      this._actions[t] = this._createActionByOption(t, {
        excludeValidators: ["disabled", "readOnly"]
      }) ?? M;
    });
  }
  _getKeysByItems(e) {
    return this._editStrategy.getKeysByItems(e);
  }
  _getItemsByKeys(e, t) {
    return this._editStrategy.getItemsByKeys(e, t);
  }
  _getKeyByIndex(e) {
    return this._editStrategy.getKeyByIndex(e);
  }
  _getIndexByKey(e) {
    return this._editStrategy.getIndexByKey(e);
  }
  _getIndexByItemData(e) {
    return this._editStrategy.getIndexByItemData(e);
  }
  _isKeySpecified() {
    return !!this._dataController.key();
  }
  _getCombinedFilter() {
    return this._dataController.filter();
  }
  key() {
    const {
      keyExpr: e
    } = this.option();
    return e || this._dataController.key();
  }
  keyOf(e) {
    let t = e;
    return this.option("keyExpr") ? t = this._keyGetter(e) : this._dataController.store() && (t = this._dataController.keyOf(e)), t;
  }
  _nullValueSelectionSupported() {
    return !1;
  }
  _initSelectionModule() {
    const e = this, {
      itemsGetter: t
    } = this._editStrategy;
    this._selection = new HO({
      allowNullValue: this._nullValueSelectionSupported(),
      mode: this.option("selectionMode"),
      maxFilterLengthInRequest: this.option("maxFilterLengthInRequest"),
      equalByReference: !this._isKeySpecified(),
      onSelectionChanging: (n) => {
        var s, o;
        const r = n.addedItemKeys.length || n.removedItemKeys.length;
        if (!this._rendered || !r)
          return;
        const a = {
          removedItems: n.removedItems,
          addedItems: n.addedItems,
          cancel: !1
        };
        (s = (o = this._actions).onSelectionChanging) === null || s === void 0 || s.call(o, a), n.cancel = a.cancel;
      },
      onSelectionChanged: (n) => {
        (n.addedItemKeys.length || n.removedItemKeys.length) && (this.option("selectedItems", this._getItemsByKeys(n.selectedItemKeys, n.selectedItems)), this._updateSelectedItems(n));
      },
      filter: this._getCombinedFilter.bind(this),
      totalCount: () => {
        const {
          items: n
        } = this.option(), s = this._dataController.totalCount();
        return s >= 0 ? s : this._getItemsCount(n);
      },
      key: this.key.bind(this),
      keyOf: this.keyOf.bind(this),
      load(n) {
        var s;
        const o = e._dataController;
        return n.customQueryParams = (s = o.loadOptions()) === null || s === void 0 ? void 0 : s.customQueryParams, n.userData = o.userData(), o.store() ? o.loadFromStore(n).done((r) => {
          if (e._disposed)
            return;
          const a = zT(r).data;
          o.applyMapFunction(a);
        }) : w().resolve(this.plainItems());
      },
      dataFields: () => this._dataController.select(),
      plainItems: t.bind(this._editStrategy)
    });
  }
  _getItemsCount(e) {
    return e.reduce((t, n) => t + (n.items ? this._getItemsCount(n.items) : 1), 0);
  }
  _initEditStrategy() {
    this._editStrategy = new Y_(this);
  }
  _getSelectedItemIndices(e) {
    const t = [];
    return e = e || this._selection.getSelectedItemKeys(), this._editStrategy.beginCache(), y(e, (n, s) => {
      const o = this._getIndexByKey(s);
      Qn(o) && t.push(o);
    }), this._editStrategy.endCache(), t;
  }
  _initMarkup() {
    this._rendering = !0, this._dataController.isLoading() || this._syncSelectionOptions().done(() => this._normalizeSelectedItems()), super._initMarkup();
  }
  _render() {
    super._render(), this._rendering = !1;
  }
  _fireContentReadyAction() {
    this._rendering = !1, this._rendered = !0, super._fireContentReadyAction();
  }
  _syncSelectionOptions(e) {
    e = e ?? this._chooseSelectOption();
    let t, n, s, o;
    switch (e) {
      case "selectedIndex":
        t = this._editStrategy.getItemDataByIndex(this.option("selectedIndex")), f(t) ? (this._setOptionWithoutOptionChange("selectedItems", [t]), this._setOptionWithoutOptionChange("selectedItem", t), this._setOptionWithoutOptionChange("selectedItemKeys", this._editStrategy.getKeysByItems([t]))) : (this._setOptionWithoutOptionChange("selectedItems", []), this._setOptionWithoutOptionChange("selectedItemKeys", []), this._setOptionWithoutOptionChange("selectedItem", null));
        break;
      case "selectedItems":
        if (o = this.option("selectedItems") || [], n = o.length ? this._editStrategy.getIndexByItemData(o[0]) : Lr, this.option("selectionRequired") && !Qn(n))
          return this._syncSelectionOptions("selectedIndex");
        this._setOptionWithoutOptionChange("selectedItem", o[0]), this._setOptionWithoutOptionChange("selectedIndex", n), this._setOptionWithoutOptionChange("selectedItemKeys", this._editStrategy.getKeysByItems(o));
        break;
      case "selectedItem":
        if (t = this.option("selectedItem"), n = this._editStrategy.getIndexByItemData(t), this.option("selectionRequired") && !Qn(n))
          return this._syncSelectionOptions("selectedIndex");
        f(t) ? (this._setOptionWithoutOptionChange("selectedItems", [t]), this._setOptionWithoutOptionChange("selectedIndex", n), this._setOptionWithoutOptionChange("selectedItemKeys", this._editStrategy.getKeysByItems([t]))) : (this._setOptionWithoutOptionChange("selectedItems", []), this._setOptionWithoutOptionChange("selectedItemKeys", []), this._setOptionWithoutOptionChange("selectedIndex", Lr));
        break;
      case "selectedItemKeys":
        if (s = this.option("selectedItemKeys"), this.option("selectionRequired")) {
          const r = this._getIndexByKey(s[0]);
          if (!Qn(r))
            return this._syncSelectionOptions("selectedIndex");
        }
        return this._selection.setSelection(s);
    }
    return w().resolve().promise();
  }
  _chooseSelectOption() {
    let e = "selectedIndex";
    const t = (n) => {
      const s = this.option(n);
      return f(s) && s.length || n in this._userOptions;
    };
    return t("selectedItems") ? e = "selectedItems" : t("selectedItem") ? e = "selectedItem" : t("selectedItemKeys") && (e = "selectedItemKeys"), e;
  }
  _compareKeys(e, t) {
    if (e.length !== t.length)
      return !1;
    for (let n = 0; n < t.length; n++)
      if (e[n] !== t[n])
        return !1;
    return !0;
  }
  _normalizeSelectedItems() {
    const {
      selectionMode: e,
      selectedItems: t,
      items: n
    } = this.option();
    if (e === "none")
      this._setOptionWithoutOptionChange("selectedItems", []), this._syncSelectionOptions("selectedItems");
    else if (e === "single") {
      const s = t ?? [];
      if (s.length > 1 || !s.length && this.option("selectionRequired") && n && n.length) {
        const o = this._selection.getSelectedItems();
        let r = s[0] === void 0 ? o[0] : s[0];
        return r === void 0 && (r = this._editStrategy.itemsGetter()[0]), this.option("grouped") && r && r.items && (r.items = [r.items[0]]), this._selection.setSelection(this._getKeysByItems([r])), this._setOptionWithoutOptionChange("selectedItems", [r]), this._syncSelectionOptions("selectedItems");
      }
      this._selection.setSelection(this._getKeysByItems(s));
    } else {
      const s = this._getKeysByItems(this.option("selectedItems")), o = this._selection.getSelectedItemKeys();
      this._compareKeys(o, s) || this._selection.setSelection(s);
    }
    return w().resolve().promise();
  }
  _itemClickHandler(e, t, n) {
    let s = w().resolve();
    this._createAction((o) => {
      s = this._itemSelectHandler(o.event) ?? s;
    }, {
      validatingTargetName: "itemElement"
    })({
      itemElement: p(e.currentTarget),
      event: e
    }), s.always(() => {
      super._itemClickHandler(e, t, n);
    });
  }
  _itemSelectHandler(e, t) {
    if (!t && !this.option("selectByClick"))
      return;
    const n = e.currentTarget;
    if (this.isItemSelected(n))
      this.unselectItem(e.currentTarget);
    else {
      const s = this.selectItem(e.currentTarget);
      return s?.promise();
    }
  }
  _selectedItemElement(e) {
    return this._itemElements().eq(e);
  }
  _postprocessRenderItem(e) {
    const {
      selectionMode: t
    } = this.option();
    if (t !== "none") {
      const n = p(e.itemElement), s = this._editStrategy.getNormalizedIndex(n), o = this._isItemSelected(s);
      this._processSelectableItem(n, o);
    }
  }
  _processSelectableItem(e, t) {
    e.toggleClass(this._selectedItemClass(), t), this._setAriaSelectionAttribute(e, String(t));
  }
  _updateSelectedItems(e) {
    const {
      addedItemKeys: t,
      removedItemKeys: n
    } = e;
    if (this._rendered && (t.length || n.length)) {
      if (!this._rendering) {
        const s = [], o = [];
        this._editStrategy.beginCache();
        for (let r = 0; r < t.length; r += 1) {
          const a = this._getIndexByKey(t[r]);
          s.push(a), this._addSelection(a);
        }
        for (let r = 0; r < n.length; r += 1) {
          const a = this._getIndexByKey(n[r]);
          o.push(a), this._removeSelection(a);
        }
        this._editStrategy.endCache(), this._updateSelection(s, o);
      }
      this._actions.onSelectionChanged({
        addedItems: e.addedItems,
        removedItems: e.removedItems
      });
    }
  }
  _updateSelection(e, t) {
  }
  _setAriaSelectionAttribute(e, t) {
    this.setAria("selected", t, e);
  }
  _getFocusedElementIndex() {
    const {
      focusOnSelectedItem: e
    } = this.option();
    return e ? this._getFlatIndex() : super._getFocusedElementIndex();
  }
  _getFlatIndex() {
    const {
      selectedIndex: e = Lr
    } = this.option();
    return e;
  }
  _removeSelection(e) {
    const t = this._editStrategy.getItemElement(e);
    Qn(e) && (this._processSelectableItem(t, !1), _.triggerHandler(t, "stateChanged", !1));
  }
  _addSelection(e) {
    const t = this._editStrategy.getItemElement(e);
    Qn(e) && (this._processSelectableItem(t, !0), _.triggerHandler(t, "stateChanged", !0));
  }
  _isItemSelected(e) {
    const t = this._getKeyByIndex(e);
    return this._selection.isItemSelected(t, {
      checkPending: !0
    });
  }
  _optionChanged(e) {
    switch (e.name) {
      case "selectionMode":
        this._invalidate();
        break;
      case "dataSource":
        (!e.value || Array.isArray(e.value) && !e.value.length) && this.option("selectedItemKeys", []), super._optionChanged(e);
        break;
      case "selectedIndex":
      case "selectedItem":
      case "selectedItems":
      case "selectedItemKeys":
        this._syncSelectionOptions(e.name).done(() => this._normalizeSelectedItems());
        break;
      case "keyExpr":
        this._initKeyGetter();
        break;
      case "selectionRequired":
        this._normalizeSelectedItems();
        break;
      case "onSelectionChanging":
      case "onSelectionChanged":
        this._initActions();
        break;
      case "selectByClick":
      case "onItemDeleting":
      case "onItemDeleted":
      case "onItemReordered":
      case "maxFilterLengthInRequest":
      case "focusOnSelectedItem":
        break;
      default:
        super._optionChanged(e);
    }
  }
  _clearSelectedItems() {
    this._setOptionWithoutOptionChange("selectedItems", []), this._syncSelectionOptions("selectedItems");
  }
  _waitDeletingPrepare(e) {
    if (e.data("dxItemDeleting"))
      return w().resolve().promise();
    e.data("dxItemDeleting", !0);
    const t = w(), n = {
      cancel: !1
    }, s = this._itemEventHandler(e, "onItemDeleting", n, {
      excludeValidators: ["disabled", "readOnly"]
    });
    return W(s).always(function(o) {
      const r = !s, a = !r && s.state() === "resolved", l = !!arguments.length, d = r || a && !l || a && o;
      W(It(n.cancel)).always(() => {
        e.data("dxItemDeleting", !1);
      }).done((u) => {
        d && !u ? t.resolve() : t.reject();
      }).fail(t.reject);
    }), t.promise();
  }
  _deleteItemFromDS(e) {
    const t = this._dataController, n = w(), s = this.option("disabled"), o = t.store();
    if (!o)
      return w().resolve().promise();
    if (!o.remove)
      throw _e.Error("E1011");
    return this.option("disabled", !0), o.remove(t.keyOf(this._getItemData(e))).done((r) => {
      r !== void 0 ? n.resolve() : n.reject();
    }).fail(() => {
      n.reject();
    }), n.always(() => {
      this.option("disabled", s);
    }), n;
  }
  _tryRefreshLastPage() {
    const e = w();
    return this._isLastPage() || this.option("grouped") ? e.resolve() : this._refreshLastPage().done(() => {
      e.resolve();
    }), e.promise();
  }
  _refreshLastPage() {
    return this._expectLastItemLoading(), this._dataController.load();
  }
  _updateSelectionAfterDelete(e) {
    const t = this._getKeyByIndex(e);
    this._selection.deselect([t]);
  }
  _updateIndicesAfterIndex(e) {
    const t = this._itemElements();
    for (let n = e + 1; n < t.length; n += 1)
      p(t[n]).data(this._itemIndexKey(), n - 1);
  }
  _simulateOptionChange(e) {
    var t;
    const n = this.option(e);
    n instanceof In || (t = this._optionChangedAction) === null || t === void 0 || t.call(this, {
      name: e,
      fullName: e,
      value: n
    });
  }
  isItemSelected(e) {
    return this._isItemSelected(this._editStrategy.getNormalizedIndex(e));
  }
  selectItem(e) {
    const {
      selectionMode: t
    } = this.option();
    if (t === "none")
      return w().resolve();
    const n = this._editStrategy.getNormalizedIndex(e);
    if (!Qn(n))
      return w().resolve();
    const s = this._getKeyByIndex(n);
    if (this._selection.isItemSelected(s))
      return w().resolve();
    if (t === "single")
      return this._selection.setSelection([s]);
    const {
      selectedItemKeys: o
    } = this.option();
    return this._selection.setSelection([...o ?? [], s], [s]);
  }
  unselectItem(e) {
    const t = this._editStrategy.getNormalizedIndex(e);
    if (!Qn(t))
      return;
    const n = this._selection.getSelectedItemKeys();
    if (this.option("selectionRequired") && n.length <= 1)
      return;
    const s = this._getKeyByIndex(t);
    this._selection.isItemSelected(s, {
      checkPending: !0
    }) && this._selection.deselect([s]);
  }
  _deleteItemElementByIndex(e) {
    this._updateSelectionAfterDelete(e), this._updateIndicesAfterIndex(e), this._editStrategy.deleteItemAtIndex(e);
  }
  _afterItemElementDeleted(e, t) {
    const n = this._dataController.getDataSource() ? "dataSource" : "items";
    this._simulateOptionChange(n), this._itemEventHandler(e, "onItemDeleted", t, {
      beforeExecute() {
        e.remove();
      },
      excludeValidators: ["disabled", "readOnly"]
    }), this._renderEmptyMessage();
  }
  deleteItem(e) {
    const t = w(), n = this._editStrategy.getItemElement(e), s = this._editStrategy.getNormalizedIndex(e), o = this._itemResponseWaitClass();
    return Qn(s) ? this._waitDeletingPrepare(n).done(() => {
      n.addClass(o);
      const r = this._extendActionArgs(n);
      this._deleteItemFromDS(n).done(() => {
        this._deleteItemElementByIndex(s), this._afterItemElementDeleted(n, r), this._tryRefreshLastPage().done(() => {
          t.resolveWith(this);
        });
      }).fail(() => {
        n.removeClass(o), t.rejectWith(this);
      });
    }).fail(() => {
      t.rejectWith(this);
    }) : t.rejectWith(this), t.promise();
  }
  reorderItem(e, t) {
    const n = w(), s = this._editStrategy, o = s.getItemElement(e), r = s.getItemElement(t), a = s.getNormalizedIndex(e), l = s.getNormalizedIndex(t), d = this._dataController.getDataSource() ? "dataSource" : "items";
    return Qn(a) && Qn(l) && a !== l ? n.resolveWith(this) : n.rejectWith(this), n.promise().done(() => {
      r[s.itemPlacementFunc(a, l)](o), s.moveItemAtIndexToIndex(a, l), this._updateIndicesAfterIndex(a), this.option("selectedItems", this._getItemsByKeys(this._selection.getSelectedItemKeys(), this._selection.getSelectedItems())), d === "items" && this._simulateOptionChange(d), this._itemEventHandler(o, "onItemReordered", {
        fromIndex: s.getIndex(a),
        toIndex: s.getIndex(l)
      }, {
        excludeValidators: ["disabled", "readOnly"]
      });
    });
  }
}
class Z_ extends vd {
  _initMarkup() {
    this._asyncTemplateItemsMap = {}, super._initMarkup();
  }
  _render() {
    super._render(), this._planPostRenderActions();
  }
  _renderItemContent(e) {
    const t = w(), n = w(), s = `dx${new Xe()}`;
    this._asyncTemplateItemsMap[s] = n;
    const o = super._renderItemContent(I({}, e, {
      uniqueKey: s
    }));
    return n.done(() => {
      t.resolve(o);
    }), t.promise();
  }
  _onItemTemplateRendered(e, t) {
    return () => {
      const {
        uniqueKey: n
      } = t;
      if (n) {
        var s;
        (s = this._asyncTemplateItemsMap[n]) === null || s === void 0 || s.resolve();
      }
    };
  }
  _postProcessRenderItems() {
  }
  _planPostRenderActions() {
    for (var e = arguments.length, t = new Array(e), n = 0; n < e; n++)
      t[n] = arguments[n];
    const s = w(), o = Object.values(this._asyncTemplateItemsMap);
    return W.apply(this, o).done(() => {
      this._postProcessRenderItems(...t), s.resolve().done(() => {
        this._asyncTemplateItemsMap = {};
      });
    }), s.promise();
  }
  _clean() {
    super._clean(), Object.values(this._asyncTemplateItemsMap).forEach((t) => {
      t.reject();
    }), this._asyncTemplateItemsMap = {};
  }
}
const Pb = $t.getWindow(), e3 = {
  observe: M,
  unobserve: M,
  disconnect: M
};
class t3 {
  constructor() {
    if (!$t.hasWindow() || !Pb.ResizeObserver)
      return e3;
    this._callbacksMap = /* @__PURE__ */ new Map(), this._observer = new Pb.ResizeObserver((e) => {
      e.forEach((t) => {
        var n;
        (n = this._callbacksMap.get(t.target)) === null || n === void 0 || n(t);
      });
    });
  }
  observe(e, t) {
    this._callbacksMap.set(e, t), this._observer.observe(e);
  }
  unobserve(e) {
    this._callbacksMap.delete(e), this._observer.unobserve(e);
  }
  disconnect() {
    this._callbacksMap.clear(), this._observer.disconnect();
  }
}
const zo = new t3(), qd = "dx-invalid-message", n3 = "dx-invalid-message-auto", i3 = "dx-invalid-message-always", s3 = "dx-invalid-message-content";
let Q_ = class extends Tn {
  _getDefaultOptions() {
    return I({}, super._getDefaultOptions(), {
      integrationOptions: {},
      templatesRenderAsynchronously: !1,
      shading: !1,
      width: "auto",
      height: "auto",
      hideOnOutsideClick: !1,
      animation: null,
      visible: !0,
      propagateOutsideClick: !0,
      _checkParentVisibility: !1,
      rtlEnabled: !1,
      contentTemplate: this._renderInnerHtml,
      maxWidth: "100%",
      container: this.$element(),
      mode: "auto",
      preventScrollEvents: !1,
      positionSide: "top",
      offset: {
        h: 0,
        v: 0
      }
    });
  }
  _init() {
    super._init(), this.updateMaxWidth(), this._updatePosition();
  }
  _initMarkup() {
    super._initMarkup(), this._ensureMessageNotEmpty(), this._updatePositionByTarget(), this._toggleModeClass(), this._updateContentId();
  }
  _updatePositionByTarget() {
    const {
      target: e
    } = this.option();
    this.option("position.of", e);
  }
  _ensureMessageNotEmpty() {
    this._textMarkup = this._getTextMarkup();
    const e = this.option("visible") && this._textMarkup;
    this._toggleVisibilityClasses(e);
  }
  _toggleVisibilityClasses(e) {
    e ? (this.$element().addClass(qd), this.$wrapper().addClass(qd)) : (this.$element().removeClass(qd), this.$wrapper().removeClass(qd));
  }
  _updateContentId() {
    const {
      container: e,
      contentId: t
    } = this.option(), n = t ?? p(e).attr("aria-describedby");
    this.$content().addClass(s3).attr("id", n);
  }
  _renderInnerHtml(e) {
    const t = e && p(e);
    t?.html(this._textMarkup);
  }
  _getTextMarkup() {
    const e = this.option("validationErrors") ?? [];
    let t = "";
    return e.forEach((n) => {
      t += (t ? "<br />" : "") + lE(n?.message ?? "");
    }), t;
  }
  _toggleModeClass() {
    const {
      mode: e
    } = this.option();
    this.$wrapper().toggleClass(n3, e === "auto").toggleClass(i3, e === "always");
  }
  updateMaxWidth() {
    const e = this.option("target"), t = Ee(e);
    let n = "100%";
    t && (n = Math.max(t, 100)), this.option({
      maxWidth: n
    });
  }
  _getPositionsArray(e, t) {
    switch (e) {
      case "top":
        return [`${t} bottom`, `${t} top`];
      case "left":
        return ["right", "left"];
      case "right":
        return ["left", "right"];
      default:
        return [`${t} top`, `${t} bottom`];
    }
  }
  _updatePosition() {
    const {
      positionSide: e,
      rtlEnabled: t,
      offset: n,
      boundary: s
    } = this.option(), o = ro(t), r = this._getPositionsArray(e, o), a = I({}, n);
    this.$element().addClass(`dx-invalid-message-${e}`), t && e !== "left" && e !== "right" && (a.h = -a.h), e === "top" && (a.v = -a.v), e === "left" && (a.h = -a.h), this.option("position", {
      offset: a,
      boundary: s,
      my: r[0],
      at: r[1],
      collision: "none flip"
    });
  }
  _optionChanged(e) {
    const {
      name: t,
      value: n,
      previousValue: s
    } = e;
    switch (t) {
      case "target":
        this._updatePositionByTarget(), this.updateMaxWidth(), super._optionChanged(e);
        break;
      case "boundary":
        this.option("position.boundary", n);
        break;
      case "mode":
        this._toggleModeClass();
        break;
      case "rtlEnabled":
      case "offset":
      case "positionSide":
        this.$element().removeClass(`dx-invalid-message-${s}`), this._updatePosition();
        break;
      case "container":
        this._updateContentId(), super._optionChanged(e);
        break;
      case "contentId":
        this._updateContentId();
        break;
      case "validationErrors":
        this._ensureMessageNotEmpty(), this._renderInnerHtml(this.$content());
        break;
      default:
        super._optionChanged(e);
    }
  }
};
xe("dxValidationMessage", Q_);
const Mb = "dx-invalid-message-auto", o3 = "dx-show-invalid-badge", Bb = "dx-validation-target", r3 = ["outlined", "filled", "underlined"], $b = {
  validationMessageMode: "mode",
  validationMessagePosition: "positionSide",
  validationMessageOffset: "offset",
  validationBoundary: "boundary"
};
let ci = class extends Rt {
  ctor(e, t) {
    this.showValidationMessageTimeout = void 0, this.validationRequest = Ie(), super.ctor(e, t);
  }
  _createElement(e) {
    super._createElement(e);
    const t = this.$element();
    t && tt(t[0], Bb, this);
  }
  _initOptions(e) {
    super._initOptions(e), this.option(Ve.initValidationOptions(e));
  }
  _init() {
    this._initialValue = this.option("value"), super._init();
    const {
      validationTooltipOptions: e
    } = this.option();
    this._options.cache("validationTooltipOptions", e), this.$element().addClass(o3);
  }
  _getDefaultOptions() {
    return I({}, super._getDefaultOptions(), {
      value: null,
      name: "",
      onValueChanged: null,
      readOnly: !1,
      isValid: !0,
      validationError: null,
      validationErrors: null,
      validationStatus: "valid",
      validationMessageMode: "auto",
      validationMessagePosition: "bottom",
      validationBoundary: void 0,
      validationMessageOffset: {
        h: 0,
        v: 0
      },
      validationTooltipOptions: {},
      _showValidationMessage: !0,
      isDirty: !1
    });
  }
  _attachKeyboardEvents() {
    this.option("readOnly") || super._attachKeyboardEvents();
  }
  _setOptionsByReference() {
    super._setOptionsByReference(), x(this._optionsByReference, {
      validationError: !0
    });
  }
  _createValueChangeAction() {
    this._valueChangeAction = this._createActionByOption("onValueChanged", {
      excludeValidators: ["disabled", "readOnly"]
    });
  }
  _suppressValueChangeAction() {
    this._valueChangeActionSuppressed = !0;
  }
  _resumeValueChangeAction() {
    this._valueChangeActionSuppressed = !1;
  }
  _initMarkup() {
    this._toggleReadOnlyState();
    const {
      name: e,
      _onMarkupRendered: t
    } = this.option();
    this._setSubmitElementName(e), super._initMarkup(), this._renderValidationState(), t?.();
  }
  _raiseValueChangeAction(e, t) {
    this._valueChangeAction || this._createValueChangeAction(), this._valueChangeAction(this._valueChangeArgs(e, t));
  }
  _valueChangeArgs(e, t) {
    return {
      value: e,
      previousValue: t,
      event: this._valueChangeEventInstance
    };
  }
  _saveValueChangeEvent(e) {
    this._valueChangeEventInstance = e;
  }
  _focusInHandler(e) {
    const {
      validationMessageMode: t
    } = this.option(), n = t === "auto";
    if (this._canValueBeChangedByClick() && n) {
      var s;
      const o = (s = this._validationMessage) === null || s === void 0 ? void 0 : s.$wrapper();
      o?.removeClass(Mb), clearTimeout(this.showValidationMessageTimeout), this.showValidationMessageTimeout = setTimeout(() => o?.addClass(Mb), 150);
    }
    super._focusInHandler(e);
  }
  _canValueBeChangedByClick() {
    return !1;
  }
  _getStylingModePrefix() {
    return "dx-editor-";
  }
  _renderStylingMode() {
    const {
      stylingMode: e
    } = this.option(), t = this._getStylingModePrefix(), n = r3.map((o) => t + o);
    n.forEach((o) => this.$element().removeClass(o));
    let s = t + String(e);
    if (!n.includes(s)) {
      const o = "stylingMode", r = this._getDefaultOptions()[o], a = this._convertRulesToOptions(this._defaultOptionsRules())[o];
      s = t + (a ?? r);
    }
    this.$element().addClass(s);
  }
  _getValidationErrors() {
    let {
      validationErrors: e
    } = this.option();
    const {
      validationError: t
    } = this.option();
    return !e && t && (e = [t]), e;
  }
  _disposeValidationMessage() {
    this._$validationMessage && (this._$validationMessage.remove(), this.setAria("describedby", null), this._$validationMessage = void 0, this._validationMessage = void 0);
  }
  _toggleValidationClasses(e) {
    this.$element().toggleClass("dx-invalid", e), this.setAria("invalid", e || void 0);
  }
  _renderValidationState() {
    const {
      validationStatus: e,
      _showValidationMessage: t
    } = this.option(), n = this.option("isValid") && e !== "invalid", s = this._getValidationErrors(), o = this.$element();
    if (this._toggleValidationClasses(!n), !(!ae() || !t) && (this._disposeValidationMessage(), !n && s)) {
      const {
        validationMessageMode: r,
        validationMessageOffset: a,
        validationBoundary: l,
        rtlEnabled: d
      } = this.option();
      this._$validationMessage = p("<div>").appendTo(o);
      const u = `dx-${new Xe()}`;
      this.setAria("describedby", u), this._validationMessage = new Q_(this._$validationMessage, x({
        validationErrors: s,
        rtlEnabled: d,
        target: this._getValidationMessageTarget(),
        visualContainer: o,
        mode: r,
        positionSide: this._getValidationMessagePosition(),
        offset: a,
        boundary: l,
        contentId: u
      }, this._options.cache("validationTooltipOptions"))), this._bindInnerWidgetOptions(this._validationMessage, "validationTooltipOptions");
    }
  }
  _getValidationMessagePosition() {
    const {
      validationMessagePosition: e
    } = this.option();
    return e;
  }
  _getValidationMessageTarget() {
    return this.$element();
  }
  _toggleReadOnlyState() {
    const {
      readOnly: e
    } = this.option();
    this._toggleBackspaceHandler(e), this.$element().toggleClass("dx-state-readonly", !!e), this._setAriaReadonly(e);
  }
  _setAriaReadonly(e) {
    this.setAria("readonly", e || void 0);
  }
  _toggleBackspaceHandler(e) {
    const t = this._keyboardEventBindingTarget(), n = R("keydown", "editorReadOnly");
    _.off(t, n), e && _.on(t, n, (s) => {
      Ye(s) === "backspace" && s.preventDefault();
    });
  }
  _dispose() {
    const e = this.$element()[0];
    tt(e, Bb, null), clearTimeout(this.showValidationMessageTimeout), this._disposeValidationMessage(), super._dispose();
  }
  _setSubmitElementName(e) {
    const t = this._getSubmitElement();
    t && (e && e.length > 0 ? t.attr("name", e) : t.removeAttr("name"));
  }
  _getSubmitElement() {
    return null;
  }
  _setValidationMessageOption(e) {
    var t;
    let {
      name: n,
      value: s
    } = e;
    const o = $b[String(n)] ? $b[String(n)] : n;
    (t = this._validationMessage) === null || t === void 0 || t.option(o, s);
  }
  _hasActiveElement() {
    return !1;
  }
  _optionChanged(e) {
    var t;
    const {
      name: n,
      value: s,
      previousValue: o
    } = e;
    switch (n) {
      case "onValueChanged":
        this._createValueChangeAction();
        break;
      case "readOnly":
        this._toggleReadOnlyState(), this._refreshFocusState();
        break;
      case "value":
        s != o && (this.option("isDirty", this._initialValue !== s), this.validationRequest.fire({
          value: s,
          editor: this
        })), this._valueChangeActionSuppressed || (this._raiseValueChangeAction(s, o), this._saveValueChangeEvent(void 0));
        break;
      case "width":
        super._optionChanged(e), (t = this._validationMessage) === null || t === void 0 || t.updateMaxWidth();
        break;
      case "name":
        this._setSubmitElementName(s);
        break;
      case "isValid":
      case "validationError":
      case "validationErrors":
      case "validationStatus":
        this.option(Ve.synchronizeValidationOptions(e, this.option())), this._renderValidationState();
        break;
      case "validationBoundary":
      case "validationMessageMode":
      case "validationMessagePosition":
      case "validationMessageOffset":
        this._setValidationMessageOption(e);
        break;
      case "rtlEnabled":
        this._setValidationMessageOption(e), super._optionChanged(e);
        break;
      case "validationTooltipOptions":
        this._innerWidgetOptionChanged(this._validationMessage, e);
        break;
      case "_showValidationMessage":
      case "isDirty":
        break;
      default:
        super._optionChanged(e);
    }
  }
  _resetToInitialValue() {
    this.option("value", this._initialValue);
  }
  blur() {
    this._hasActiveElement() && li.resetActiveElement();
  }
  clear() {
    const e = this._getDefaultOptions();
    this.option("value", e.value);
  }
  reset() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : void 0;
    arguments.length && (this._initialValue = e), this._resetToInitialValue(), this.option("isDirty", !1), this.option("isValid", !0);
  }
};
ci.isEditor = (i) => i instanceof ci;
class mh {
  constructor(e, t, n) {
    this.instance = null, this.$container = null, this.$placeMarker = null, this.editor = t, this.name = e, this.options = n || {};
  }
  _addPlaceMarker(e) {
    this.$placeMarker = p("<div>").appendTo(e);
  }
  _addToContainer(e) {
    const {
      $placeMarker: t,
      $container: n
    } = this;
    t ? t.replaceWith(e) : e.appendTo(n);
  }
  _attachEvents(e, t) {
    throw "Not implemented";
  }
  _create() {
    throw "Not implemented";
  }
  _isRendered() {
    return !!this.instance;
  }
  _isVisible() {
    const {
      editor: e,
      options: t
    } = this;
    return t.visible || !e.option("readOnly");
  }
  _isDisabled() {
    throw "Not implemented";
  }
  _shouldRender() {
    return this._isVisible() && !this._isRendered();
  }
  dispose() {
    const {
      instance: e,
      $placeMarker: t
    } = this;
    e && (e.dispose ? e.dispose() : e.remove(), this.instance = null), t && t.remove();
  }
  render() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : this.$container;
    if (this.$container = e, this._isVisible()) {
      const {
        instance: t,
        $element: n
      } = this._create();
      this.instance = t, this._attachEvents(t, n);
    } else
      this._addPlaceMarker(e);
  }
  update() {
    return this._shouldRender() && this.render(), !!this.instance;
  }
}
const a3 = ye.down;
class l3 extends mh {
  _create() {
    const e = p("<span>").addClass("dx-clear-button-area").append(p("<span>").addClass("dx-icon").addClass("dx-icon-clear"));
    return this._addToContainer(e), this.update(!0), {
      instance: e,
      $element: e
    };
  }
  _isVisible() {
    const {
      editor: e
    } = this;
    return e._isClearButtonVisible();
  }
  _attachEvents(e, t) {
    const {
      editor: n
    } = this, s = n.NAME;
    _.on(t, R(a3, s), (o) => {
      o.preventDefault(), o.pointerType !== "mouse" && n._clearValueHandler(o);
    }), _.on(t, R(Te, s), (o) => n._clearValueHandler(o));
  }
  _legacyRender(e, t) {
    e.toggleClass("dx-show-clear-button", t);
  }
  update() {
    (arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : !1) || super.update();
    const {
      editor: t,
      instance: n
    } = this, s = t.$element(), o = this._isVisible();
    n && n.toggleClass("dx-state-invisible", !o), this._legacyRender(s, o);
  }
}
class d3 {
  constructor(e) {
    this.NAME = "dxLabel", this._props = e, this._id = `dx-texteditor-label-${new Xe()}`, this._render(), this._toggleMarkupVisibility();
  }
  _isVisible() {
    return !!this._props.text && this._props.mode !== "hidden";
  }
  _render() {
    this._$before = p("<div>").addClass("dx-label-before"), this._$labelSpan = p("<span>"), this._$label = p("<div>").addClass("dx-label").append(this._$labelSpan), this._$after = p("<div>").addClass("dx-label-after"), this._$root = p("<div>").addClass("dx-texteditor-label").attr("id", this._id).append(this._$before).append(this._$label).append(this._$after), this._updateMark(), this._updateText(), this._updateBeforeWidth(), this._updateMaxWidth();
  }
  _toggleMarkupVisibility() {
    const e = this._isVisible();
    this._updateEditorBeforeButtonsClass(e), this._updateEditorLabelClass(e), e ? this._$root.appendTo(this._props.$editor) : this._$root.detach(), this._attachEvents();
  }
  _attachEvents() {
    const e = R(Te, this.NAME), t = R(rd, this.NAME), n = R(n4, this.NAME);
    _.off(this._$labelSpan, e), _.off(this._$labelSpan, t), _.off(this._$labelSpan, n), this._isVisible() && this._isOutsideMode() && (_.on(this._$labelSpan, e, (s) => {
      fe().getSelection().toString() === "" && (this._props.onClickHandler(), s.preventDefault());
    }), _.on(this._$labelSpan, t, (s) => {
      this._props.onHoverHandler(s);
    }), _.on(this._$labelSpan, n, (s) => {
      this._props.onActiveHandler(s);
    }));
  }
  _updateEditorLabelClass(e) {
    if (this._props.$editor.removeClass("dx-texteditor-with-floating-label").removeClass("dx-texteditor-label-outside").removeClass("dx-texteditor-with-label"), e) {
      const t = this._props.mode === "floating" ? "dx-texteditor-with-floating-label" : "dx-texteditor-with-label";
      this._props.$editor.addClass(t), this._isOutsideMode() && this._props.$editor.addClass("dx-texteditor-label-outside");
    }
  }
  _isOutsideMode() {
    return this._props.mode === "outside";
  }
  _updateEditorBeforeButtonsClass() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : this._isVisible();
    if (this._props.$editor.removeClass("dx-texteditor-with-before-buttons"), e) {
      const t = this._props.containsButtonsBefore ? "dx-texteditor-with-before-buttons" : "";
      this._props.$editor.addClass(t);
    }
  }
  _updateMark() {
    this._$labelSpan.attr("data-mark", this._props.mark);
  }
  _updateText() {
    this._$labelSpan.text(this._props.text);
  }
  _updateBeforeWidth() {
    if (this._isVisible()) {
      const e = this._props.beforeWidth ?? this._props.getBeforeWidth();
      this._$before.css({
        width: e
      }), this._updateLabelTransform();
    }
  }
  _updateLabelTransform() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 0;
    if (this._$labelSpan.css("transform", ""), this._isVisible() && this._isOutsideMode()) {
      const n = (this._props.rtlEnabled ? 1 : -1) * (ne(this._$before) + e);
      this._$labelSpan.css("transform", `translateX(${n}px)`);
    }
  }
  _updateMaxWidth() {
    if (this._isVisible() && !this._isOutsideMode()) {
      const e = this._props.containerWidth ?? this._props.getContainerWidth();
      this._$label.css({
        maxWidth: e
      });
    }
  }
  $element() {
    return this._$root;
  }
  isVisible() {
    return this._isVisible();
  }
  getId() {
    if (this._isVisible())
      return this._id;
  }
  updateMode(e) {
    this._props.mode = e, this._toggleMarkupVisibility(), this._updateBeforeWidth(), this._updateMaxWidth();
  }
  updateText(e) {
    this._props.text = e, this._updateText(), this._toggleMarkupVisibility(), this._updateBeforeWidth(), this._updateMaxWidth();
  }
  updateMark(e) {
    this._props.mark = e, this._updateMark();
  }
  updateContainsButtonsBefore(e) {
    this._props.containsButtonsBefore = e, this._updateEditorBeforeButtonsClass();
  }
  updateBeforeWidth(e) {
    this._props.beforeWidth = e, this._updateBeforeWidth();
  }
  updateMaxWidth(e) {
    this._props.containerWidth = e, this._updateMaxWidth();
  }
}
class u3 extends mh {
  _attachEvents(e, t) {
    const {
      editor: n
    } = this;
    _.on(t, rd, () => {
      n.$element().addClass("dx-custom-button-hovered");
    }), _.on(t, ad, () => {
      n.$element().removeClass("dx-custom-button-hovered");
    }), _.on(t, Te, (s) => {
      s.stopPropagation();
    });
  }
  _create() {
    const {
      editor: e
    } = this, t = p("<div>");
    this._addToContainer(t);
    const n = e._createComponent(t, wt, I({}, this.options, {
      ignoreParentReadOnly: !0,
      disabled: this._isDisabled(),
      integrationOptions: this._prepareIntegrationOptions(e)
    }));
    return {
      $element: t,
      instance: n
    };
  }
  _prepareIntegrationOptions(e) {
    return I({}, e.option("integrationOptions"), {
      skipTemplates: ["content"]
    });
  }
  update() {
    const e = super.update();
    return this.instance && this.instance.option("disabled", this._isDisabled()), e;
  }
  _isVisible() {
    const {
      visible: e
    } = this.editor.option();
    return !!e;
  }
  _isDisabled() {
    if (this.options.disabled !== void 0)
      return this.instance ? this.instance.option("disabled") : this.options.disabled;
    const {
      readOnly: t
    } = this.editor.option();
    return t;
  }
}
function c3(i) {
  (() => {
    if (!i || typeof i != "object" || Array.isArray(i))
      throw _e.Error("E1053");
  })(), (() => {
    if (!("name" in i))
      throw _e.Error("E1054");
  })(), (() => {
    const {
      name: e
    } = i;
    if (typeof e != "string")
      throw _e.Error("E1055");
  })(), (() => {
    const {
      location: e
    } = i;
    "location" in i && e !== "after" && e !== "before" && (i.location = "after");
  })();
}
function Nb(i, e) {
  if (i.includes(e))
    throw _e.Error("E1055", e);
  i.push(e);
}
function h3(i, e) {
  return !!e.find((t) => t.name === i);
}
class p3 {
  constructor(e, t) {
    this.buttons = [], this.defaultButtonsInfo = t, this.editor = e;
  }
  _compileButtonInfo(e) {
    const t = [];
    return e.map((n) => {
      const s = typeof n == "string";
      if (s || c3(n), s || h3(n.name, this.defaultButtonsInfo)) {
        const a = this.defaultButtonsInfo.find((l) => {
          let {
            name: d
          } = l;
          return d === n || d === n.name;
        });
        if (!a)
          throw _e.Error("E1056", this.editor.NAME, n);
        return Nb(t, n), a;
      }
      const {
        name: r
      } = n;
      return Nb(t, r), I({}, n, {
        Ctor: u3
      });
    });
  }
  _createButton(e) {
    const {
      Ctor: t,
      options: n,
      name: s
    } = e, o = new t(s, this.editor, n);
    return this.buttons.push(o), o;
  }
  _renderButtons(e, t, n) {
    let s = null;
    return (e ? this._compileButtonInfo(e) : this.defaultButtonsInfo).forEach((r) => {
      const {
        location: a = "after"
      } = r;
      a === n && this._createButton(r).render((() => (s = s ?? p("<div>").addClass("dx-texteditor-buttons-container"), n === "before" ? t.prepend(s) : t.append(s), s))());
    }), s;
  }
  clean() {
    this.buttons.forEach((e) => e.dispose()), this.buttons = [];
  }
  getButton(e) {
    const t = this.buttons.find((n) => {
      let {
        name: s
      } = n;
      return s === e;
    });
    return t?.instance;
  }
  renderAfterButtons(e, t) {
    return this._renderButtons(e, t, "after");
  }
  renderBeforeButtons(e, t) {
    return this._renderButtons(e, t, "before");
  }
  updateButtons(e) {
    this.buttons.forEach((t) => {
      (!e || e.includes(t.name)) && t.update();
    });
  }
}
const g3 = "dx-texteditor", m3 = "dx-texteditor-input", Yd = ["KeyDown", "KeyPress", "KeyUp", "Change", "Cut", "Copy", "Paste", "Input"], f3 = ["tab", "enter", "shift", "control", "alt", "escape", "pageUp", "pageDown", "end", "home", "leftArrow", "upArrow", "rightArrow", "downArrow"];
let _3 = d3;
function Lb(i) {
  if (f(i) && !Array.isArray(i))
    throw _e.Error("E1053");
}
class C3 extends ci {
  ctor(e, t) {
    t && Lb(t.buttons), this._buttonCollection = new p3(this, this._getDefaultButtons()), this._$beforeButtonsContainer = null, this._$afterButtonsContainer = null, this._labelContainerElement = null, super.ctor(e, t);
  }
  _getDefaultOptions() {
    return I({}, super._getDefaultOptions(), {
      buttons: void 0,
      value: "",
      spellcheck: !1,
      showClearButton: !1,
      valueChangeEvent: "change",
      placeholder: "",
      inputAttr: {},
      onFocusIn: null,
      onFocusOut: null,
      onKeyDown: null,
      onKeyUp: null,
      onChange: null,
      onInput: null,
      onCut: null,
      onCopy: null,
      onPaste: null,
      onEnterKey: null,
      mode: "text",
      hoverStateEnabled: !0,
      focusStateEnabled: !0,
      text: void 0,
      displayValueFormatter: (e) => f(e) && e !== !1 ? e : "",
      stylingMode: Pe().editorStylingMode || "outlined",
      showValidationMark: !0,
      label: "",
      labelMode: "static",
      labelMark: ""
    });
  }
  _defaultOptionsRules() {
    return super._defaultOptionsRules().concat([{
      device() {
        const e = pn();
        return Zt(e);
      },
      options: {
        labelMode: "floating",
        stylingMode: Pe().editorStylingMode || "filled"
      }
    }, {
      device() {
        const e = pn();
        return nn(e);
      },
      options: {
        labelMode: "outside"
      }
    }]);
  }
  _getDefaultButtons() {
    return [{
      name: "clear",
      Ctor: l3
    }];
  }
  _isClearButtonVisible() {
    return this.option("showClearButton") && !this.option("readOnly");
  }
  _input() {
    return this.$element().find(".dx-texteditor-input").first();
  }
  _isFocused() {
    return qs(this._input()) || super._isFocused();
  }
  _inputWrapper() {
    return this.$element();
  }
  _buttonsContainer() {
    return this._inputWrapper().find(".dx-texteditor-buttons-container").eq(0);
  }
  _isControlKey(e) {
    return f3.includes(e);
  }
  _renderStylingMode() {
    super._renderStylingMode();
    const {
      stylingMode: e
    } = this.option();
    this._updateButtonsStyling(e);
  }
  _initMarkup() {
    this.$element().addClass("dx-texteditor"), this._renderInput(), this._renderButtonContainers(), this._renderStylingMode(), this._renderInputType(), this._renderPlaceholder(), this._renderProps(), super._initMarkup(), this._renderValue(), this._renderLabel();
  }
  _render() {
    super._render(), this._refreshValueChangeEvent(), this._refreshEvents(), this._renderEnterKeyAction(), this._renderEmptinessEvent();
  }
  _renderInput() {
    this._$textEditorContainer = p("<div>").addClass("dx-texteditor-container").appendTo(this.$element()), this._$textEditorInputContainer = p("<div>").addClass("dx-texteditor-input-container").appendTo(this._$textEditorContainer), this._$textEditorInputContainer.append(this._createInput());
  }
  _getInputContainer() {
    return this._$textEditorInputContainer;
  }
  _renderPendingIndicator() {
    this.$element().addClass("dx-validation-pending");
    const e = this._getInputContainer(), t = p("<div>").addClass("dx-pending-indicator").appendTo(e);
    this._pendingIndicator = this._createComponent(t, Dn);
  }
  _disposePendingIndicator() {
    this._pendingIndicator && (this._pendingIndicator.dispose(), this._pendingIndicator.$element().remove(), this._pendingIndicator = null, this.$element().removeClass("dx-validation-pending"));
  }
  _renderValidationState() {
    super._renderValidationState(), this.option("validationStatus") === "pending" ? (this._pendingIndicator || this._renderPendingIndicator(), this._showValidMark = !1) : (this.option("validationStatus") === "invalid" && (this._showValidMark = !1), !this._showValidMark && this.option("showValidationMark") === !0 && (this._showValidMark = this.option("validationStatus") === "valid" && !!this._pendingIndicator), this._disposePendingIndicator()), this._toggleValidMark();
  }
  _getButtonsContainer() {
    return this._$textEditorContainer;
  }
  _renderButtonContainers() {
    const {
      buttons: e
    } = this.option(), t = this._getButtonsContainer();
    this._$beforeButtonsContainer = this._buttonCollection.renderBeforeButtons(e, t), this._$afterButtonsContainer = this._buttonCollection.renderAfterButtons(e, t);
  }
  _cleanButtonContainers() {
    var e, t;
    (e = this._$beforeButtonsContainer) === null || e === void 0 || e.remove(), (t = this._$afterButtonsContainer) === null || t === void 0 || t.remove(), this._buttonCollection.clean();
  }
  _clean() {
    this._buttonCollection.clean(), this._disposePendingIndicator(), this._unobserveLabelContainerResize(), this._$beforeButtonsContainer = null, this._$afterButtonsContainer = null, this._$textEditorContainer = null, super._clean();
  }
  _createInput() {
    const e = p("<input>");
    return this._applyInputAttributes(e, this.option("inputAttr")), e;
  }
  _setSubmitElementName(e) {
    const {
      inputAttr: t
    } = this.option();
    super._setSubmitElementName(e || t?.name || "");
  }
  _applyInputAttributes(e) {
    let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    const n = x(this._getDefaultAttributes(), t);
    e.attr(n).addClass("dx-texteditor-input"), this._setInputMinHeight(e);
  }
  _setInputMinHeight(e) {
    e.css("minHeight", this.option("height") ? "0" : "");
  }
  _getPlaceholderAttr() {
    const {
      ios: e,
      mac: t
    } = z.real(), {
      placeholder: n
    } = this.option();
    return n || (e || t ? " " : null);
  }
  _getDefaultAttributes() {
    return {
      autocomplete: "off",
      placeholder: this._getPlaceholderAttr()
    };
  }
  _updateButtons(e) {
    this._buttonCollection.updateButtons(e);
  }
  _updateButtonsStyling(e) {
    y(this.option("buttons"), (t, n) => {
      let {
        options: s,
        name: o
      } = n;
      if (s && !s.stylingMode && this.option("visible")) {
        const r = this.getButton(o);
        r != null && r.option && r.option("stylingMode", e === "underlined" ? "text" : "contained");
      }
    });
  }
  _renderValue() {
    return this._renderInputValue().promise();
  }
  _renderInputValue(e) {
    e = e ?? this.option("value");
    const {
      text: t,
      displayValue: n,
      displayValueFormatter: s
    } = this.option();
    let o = t;
    return n !== void 0 && e !== null ? o = s?.(n) : f(o) || (o = s?.(e)), this.option("text", o), this._input().val() !== (f(o) ? o : "") ? this._renderDisplayText(o) : this._toggleEmptinessEventHandler(), w().resolve();
  }
  _renderDisplayText(e) {
    this._input().val(e), this._toggleEmptinessEventHandler();
  }
  _isValueValid() {
    if (this._input().length) {
      const {
        validity: e
      } = this._input().get(0);
      if (e)
        return e.valid;
    }
    return !0;
  }
  _toggleEmptiness(e) {
    this.$element().toggleClass("dx-texteditor-empty", e), this._togglePlaceholder(e);
  }
  _togglePlaceholder(e) {
    this.$element().find(".dx-placeholder").eq(0).toggleClass("dx-state-invisible", !e);
  }
  _renderProps() {
    this._toggleReadOnlyState(), this._toggleSpellcheckState(), this._toggleTabIndex();
  }
  _toggleDisabledState(e) {
    super._toggleDisabledState(e), this._input().prop("disabled", e);
  }
  _toggleTabIndex() {
    const e = this._input(), t = this.option("disabled"), n = this.option("focusStateEnabled");
    t || !n ? e.attr("tabIndex", -1) : e.removeAttr("tabIndex");
  }
  _toggleReadOnlyState() {
    this._input().prop("readOnly", this._readOnlyPropValue()), super._toggleReadOnlyState();
  }
  _readOnlyPropValue() {
    const {
      readOnly: e
    } = this.option();
    return !!e;
  }
  _toggleSpellcheckState() {
    const {
      spellcheck: e
    } = this.option();
    this._input().prop("spellcheck", e);
  }
  _unobserveLabelContainerResize() {
    this._labelContainerElement && (zo.unobserve(this._labelContainerElement), this._labelContainerElement = null);
  }
  _getLabelContainer() {
    return this._input();
  }
  _getLabelContainerWidth() {
    return ne(this._getLabelContainer());
  }
  _getLabelBeforeWidth() {
    return (this._$beforeButtonsContainer && ne(this._$beforeButtonsContainer)) ?? 0;
  }
  _updateLabelWidth() {
    this._label.updateBeforeWidth(this._getLabelBeforeWidth()), this._label.updateMaxWidth(this._getLabelContainerWidth());
  }
  _getFieldElement() {
    return this._getLabelContainer();
  }
  _setFieldAria(e) {
    var t;
    const n = this.option("inputAttr"), s = n?.["aria-label"], o = (t = this._label) === null || t === void 0 ? void 0 : t.getId(), r = s ? void 0 : o;
    if (r || e) {
      const a = {
        labelledby: r,
        label: s
      };
      this.setAria(a, this._getFieldElement());
    }
  }
  _renderLabel() {
    this._unobserveLabelContainerResize(), this._labelContainerElement = p(this._getLabelContainer()).get(0);
    const {
      label: e,
      labelMode: t,
      labelMark: n,
      rtlEnabled: s
    } = this.option(), o = {
      onClickHandler: () => {
        this.focus();
      },
      onHoverHandler: (r) => {
        r.stopPropagation();
      },
      onActiveHandler: (r) => {
        r.stopPropagation();
      },
      $editor: this.$element(),
      text: e,
      mark: n,
      mode: t,
      rtlEnabled: s,
      containsButtonsBefore: !!this._$beforeButtonsContainer,
      getContainerWidth: () => this._getLabelContainerWidth(),
      getBeforeWidth: () => this._getLabelBeforeWidth()
    };
    this._label = new _3(o), this._setFieldAria(), this._labelContainerElement && zo.observe(this._labelContainerElement, this._updateLabelWidth.bind(this));
  }
  _renderPlaceholder() {
    this._renderPlaceholderMarkup(), this._attachPlaceholderEvents();
  }
  _renderPlaceholderMarkup() {
    this._$placeholder && (this._$placeholder.remove(), this._$placeholder = null);
    const e = this._input(), t = this.option("placeholder"), n = {
      id: t ? `dx-${new Xe()}` : void 0,
      "data-dx_placeholder": t
    }, s = this._$placeholder = p("<div>").attr(n);
    s.insertAfter(e), s.addClass("dx-placeholder");
  }
  _attachPlaceholderEvents() {
    const e = R(ye.up, this.NAME);
    _.on(this._$placeholder, e, () => {
      _.trigger(this._input(), "focus");
    }), this._toggleEmptinessEventHandler();
  }
  _placeholder() {
    return this._$placeholder ?? p();
  }
  _clearValueHandler(e) {
    const t = this._input();
    e.stopPropagation(), this._saveValueChangeEvent(e), this._clearValue(), this._isFocused() || _.trigger(t, "focus"), _.trigger(t, "input");
  }
  _clearValue() {
    this.clear();
  }
  _renderEvents() {
    const e = this._input();
    y(Yd, (t, n) => {
      if (this.hasActionSubscription(`on${n}`)) {
        const s = this._createActionByOption(`on${n}`, {
          excludeValidators: ["readOnly"]
        });
        _.on(e, R(n.toLowerCase(), this.NAME), (o) => {
          this._disposed || s({
            event: o
          });
        });
      }
    });
  }
  _refreshEvents() {
    const e = this._input();
    y(Yd, (t, n) => {
      _.off(e, R(n.toLowerCase(), this.NAME));
    }), this._renderEvents();
  }
  _keyPressHandler(e) {
    this.option("text", this._input().val());
  }
  _keyDownHandler(e) {
    const t = this._input(), n = e.ctrlKey && Ye(e) === "enter", {
      value: s
    } = this.option(), o = t.val() !== s;
    n && o && _.trigger(t, "change");
  }
  _getValueChangeEventOptionName() {
    return "valueChangeEvent";
  }
  _renderValueChangeEvent() {
    const e = R(this._renderValueEventName(), `${this.NAME}TextChange`), t = R(this.option(this._getValueChangeEventOptionName()), `${this.NAME}ValueChange`), n = R("keydown", `${this.NAME}TextChange`), s = this._input();
    _.on(s, e, this._keyPressHandler.bind(this)), _.on(s, t, this._valueChangeEventHandler.bind(this)), _.on(s, n, this._keyDownHandler.bind(this));
  }
  _cleanValueChangeEvent() {
    const e = `.${this.NAME}ValueChange`, t = `.${this.NAME}TextChange`;
    _.off(this._input(), e), _.off(this._input(), t);
  }
  _refreshValueChangeEvent() {
    this._cleanValueChangeEvent(), this._renderValueChangeEvent();
  }
  _renderValueEventName() {
    return "input change keypress";
  }
  _focusTarget() {
    return this._input();
  }
  _focusEventTarget() {
    return this.element();
  }
  _isInput(e) {
    return e === this._input().get(0);
  }
  _preventNestedFocusEvent(e) {
    if (e.isDefaultPrevented())
      return !0;
    let t = this._isNestedTarget(e.relatedTarget);
    return e.type === "focusin" ? t = t && this._isNestedTarget(e.target) && !this._isInput(e.target) : t || this._toggleFocusClass(!1, this.$element()), t && e.preventDefault(), t;
  }
  _isNestedTarget(e) {
    return !!this.$element().find(e).length;
  }
  _focusClassTarget(e) {
    return this.$element();
  }
  _focusInHandler(e) {
    this._preventNestedFocusEvent(e), super._focusInHandler(e);
  }
  _focusOutHandler(e) {
    this._preventNestedFocusEvent(e), super._focusOutHandler(e);
  }
  _toggleFocusClass(e, t) {
    super._toggleFocusClass(e, this._focusClassTarget(t));
  }
  _hasFocusClass(e) {
    return super._hasFocusClass(p(e || this.$element()));
  }
  _renderEmptinessEvent() {
    const e = this._input();
    _.on(e, "input blur", this._toggleEmptinessEventHandler.bind(this));
  }
  _toggleEmptinessEventHandler() {
    const e = this._input().val(), t = (e === "" || e === null) && this._isValueValid();
    this._toggleEmptiness(t);
  }
  _valueChangeEventHandler(e, t) {
    this.option("readOnly") || (this._saveValueChangeEvent(e), this.option("value", arguments.length > 1 ? t : this._input().val()), this._saveValueChangeEvent(void 0));
  }
  _renderEnterKeyAction() {
    this._enterKeyAction = this._createActionByOption("onEnterKey", {
      excludeValidators: ["readOnly"]
    }), _.off(this._input(), "keyup.onEnterKey.dxTextEditor"), _.on(this._input(), "keyup.onEnterKey.dxTextEditor", this._enterKeyHandlerUp.bind(this));
  }
  _enterKeyHandlerUp(e) {
    if (!this._disposed && Ye(e) === "enter") {
      var t;
      (t = this._enterKeyAction) === null || t === void 0 || t.call(this, {
        event: e
      });
    }
  }
  _updateValue() {
    this._options.silent("text", null), this._renderValue();
  }
  _dispose() {
    this._enterKeyAction = void 0, super._dispose();
  }
  _getSubmitElement() {
    return this._input();
  }
  _hasActiveElement() {
    return this._input().is(O.getActiveElement(this._input()[0]));
  }
  _optionChanged(e) {
    const {
      name: t,
      fullName: n,
      value: s
    } = e, o = t.replace("on", "");
    if (Yd.includes(o)) {
      this._refreshEvents();
      return;
    }
    switch (t) {
      case "valueChangeEvent":
        this._refreshValueChangeEvent(), this._refreshFocusEvent(), this._refreshEvents();
        break;
      case "onValueChanged":
        this._createValueChangeAction();
        break;
      case "focusStateEnabled":
        super._optionChanged(e), this._toggleTabIndex();
        break;
      case "spellcheck":
        this._toggleSpellcheckState();
        break;
      case "mode":
        this._renderInputType();
        break;
      case "onEnterKey":
        this._renderEnterKeyAction();
        break;
      case "placeholder":
        this._renderPlaceholder(), this._setFieldAria(!0), this._input().attr({
          placeholder: this._getPlaceholderAttr()
        });
        break;
      case "label":
        this._label.updateText(s), this._setFieldAria(!0);
        break;
      case "labelMark":
        this._label.updateMark(s);
        break;
      case "labelMode":
        this._label.updateMode(s), this._setFieldAria();
        break;
      case "width":
        super._optionChanged(e), this._label.updateMaxWidth(this._getLabelContainerWidth());
        break;
      case "readOnly":
      case "disabled":
        this._updateButtons(), super._optionChanged(e);
        break;
      case "showClearButton":
        this._updateButtons(["clear"]);
        break;
      case "text":
      case "showValidationMark":
        break;
      case "value":
        this._updateValue(), super._optionChanged(e);
        break;
      case "inputAttr":
        this._applyInputAttributes(this._input(), this.option(t));
        break;
      case "stylingMode":
        this._renderStylingMode(), this._updateLabelWidth();
        break;
      case "buttons": {
        n === t && Lb(s), this._cleanButtonContainers(), this._renderButtonContainers();
        const {
          stylingMode: r
        } = this.option();
        this._updateButtonsStyling(r), this._updateLabelWidth(), this._label.updateContainsButtonsBefore(!!this._$beforeButtonsContainer);
        break;
      }
      case "visible":
        if (super._optionChanged(e), s && this.option("buttons")) {
          this._cleanButtonContainers(), this._renderButtonContainers();
          const {
            stylingMode: r
          } = this.option();
          this._updateButtonsStyling(r);
        }
        break;
      case "displayValueFormatter":
        this._invalidate();
        break;
      default:
        super._optionChanged(e);
    }
  }
  _renderInputType() {
    this._setInputType(this.option("mode"));
  }
  _setInputType(e) {
    const t = this._input();
    e === "search" && (e = "text");
    try {
      t.prop("type", e);
    } catch {
      t.prop("type", "text");
    }
  }
  getButton(e) {
    return this._buttonCollection.getButton(e);
  }
  focus() {
    _.trigger(this._input(), "focus");
  }
  clear() {
    this._showValidMark && (this._showValidMark = !1, this._renderValidationState());
    const e = this._getDefaultOptions();
    this.option("value") === e.value ? (this._options.silent("text", ""), this._renderValue()) : this.option("value", e.value);
  }
  _resetInputText() {
    this._options.silent("text", this._initialValue), this._renderValue();
  }
  _isValueEqualToInitial() {
    const {
      value: e
    } = this.option(), t = this._initialValue;
    return e === t;
  }
  _resetToInitialValue() {
    this._isValueEqualToInitial() ? this._resetInputText() : super._resetToInitialValue(), this._disposePendingIndicator(), this._showValidMark = !1, this._toggleValidMark();
  }
  _toggleValidMark() {
    this.$element().toggleClass("dx-valid", !!this._showValidMark);
  }
  reset() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : void 0;
    arguments.length ? super.reset(e) : super.reset();
  }
  on(e, t) {
    const n = super.on(e, t), s = e.charAt(0).toUpperCase() + e.substr(1);
    return Yd.includes(s) && this._refreshEvents(), n;
  }
}
class WO {
  constructor(e) {
    this._value = " ", x(this, e);
  }
  next(e) {
    if (!arguments.length)
      return this._next;
    this._next = e;
  }
  _prepareHandlingArgs(e, t) {
    t = t || {};
    const n = Object.prototype.hasOwnProperty.call(e, "value") ? "value" : "text";
    return e[n] = t.str ?? e[n], e.start = t.start ?? e.start, e.length = t.length ?? e.length, e.index += 1, e;
  }
  first(e) {
    return e = e || 0, this.next().first(e + 1);
  }
  isAccepted(e) {
    return !1;
  }
  adjustedCaret(e, t, n) {
    return t ? this._adjustedForward(e, 0, n) : this._adjustedBackward(e, 0, n);
  }
  _adjustedForward(e, t, n) {
  }
  _adjustedBackward(e, t, n) {
  }
  isValid(e) {
  }
  reset() {
  }
  clear(e) {
  }
  text() {
  }
  value() {
  }
  rawValue() {
  }
  handle(e) {
  }
}
class v3 extends WO {
  next() {
  }
  handle() {
    return 0;
  }
  text() {
    return "";
  }
  value() {
    return "";
  }
  first() {
    return 0;
  }
  rawValue() {
    return "";
  }
  adjustedCaret() {
    return 0;
  }
  isValid() {
    return !0;
  }
}
class zO extends WO {
  text() {
    return (this._value !== " " ? this._value : this.maskChar) + this.next().text();
  }
  value() {
    return this._value + this.next().value();
  }
  rawValue() {
    return this._value + this.next().rawValue();
  }
  handle(e) {
    const t = Object.prototype.hasOwnProperty.call(e, "value") ? e.value : e.text;
    if (!t || !t.length || !e.length)
      return 0;
    if (e.start)
      return this.next().handle(this._prepareHandlingArgs(e, {
        start: e.start - 1
      }));
    const n = t[0], s = t.substring(1);
    return this._tryAcceptChar(n, e), this._accepted() ? this.next().handle(this._prepareHandlingArgs(e, {
      str: s,
      length: e.length - 1
    })) + 1 : this.handle(this._prepareHandlingArgs(e, {
      str: s,
      length: e.length - 1
    }));
  }
  clear(e) {
    this._tryAcceptChar(" ", e), this.next().clear(this._prepareHandlingArgs(e));
  }
  reset() {
    this._accepted(!1), this.next().reset();
  }
  _tryAcceptChar(e, t) {
    if (this._accepted(!1), !this._isAllowed(e, t))
      return;
    const n = e === " " ? this.maskChar : e;
    t.fullText = t.fullText.substring(0, t.index) + n + t.fullText.substring(t.index + 1), this._accepted(!0), this._value = e;
  }
  _accepted(e) {
    if (!arguments.length)
      return !!this._isAccepted;
    this._isAccepted = !!e;
  }
  first(e) {
    return this._value === " " ? e || 0 : super.first(e);
  }
  _isAllowed(e, t) {
    return e === " " ? !0 : this._isValid(e, t);
  }
  _isValid(e, t) {
    const {
      allowedChars: n
    } = this;
    return n instanceof RegExp ? n.test(e) : B(n) ? n(e, t.index, t.fullText) : Array.isArray(n) ? n.includes(e) : n === e;
  }
  isAccepted(e) {
    return e === 0 ? this._accepted() : this.next().isAccepted(e - 1);
  }
  _adjustedForward(e, t, n) {
    return t >= e ? t : this.next()._adjustedForward(e, t + 1, n) || t + 1;
  }
  _adjustedBackward(e, t) {
    return t >= e - 1 ? e : this.next()._adjustedBackward(e, t + 1) || t + 1;
  }
  isValid(e) {
    return this._isValid(this._value, e) && this.next().isValid(this._prepareHandlingArgs(e));
  }
}
class Hb extends zO {
  value() {
    return this.next().value();
  }
  handle(e) {
    const t = Object.prototype.hasOwnProperty.call(e, "value"), n = t ? e.value : e.text;
    if (!n.length || !e.length)
      return 0;
    if (e.start || t)
      return this.next().handle(this._prepareHandlingArgs(e, {
        start: e.start && e.start - 1
      }));
    const s = n[0], o = n.substring(1);
    this._tryAcceptChar(s);
    const r = this._isAllowed(s) ? this._prepareHandlingArgs(e, {
      str: o,
      length: e.length - 1
    }) : e;
    return this.next().handle(r) + 1;
  }
  clear(e) {
    this._accepted(!1), this.next().clear(this._prepareHandlingArgs(e));
  }
  _tryAcceptChar(e) {
    this._accepted(this._isValid(e));
  }
  _isValid(e) {
    return e === this.maskChar;
  }
  first(e) {
    return e = e || 0, this.next().first(e + 1);
  }
  _adjustedForward(e, t, n) {
    return t >= e && n === this.maskChar ? t : e === t + 1 && this._accepted() ? e : this.next()._adjustedForward(e, t + 1, n);
  }
  _adjustedBackward(e, t) {
    return t >= e - 1 ? 0 : this.next()._adjustedBackward(e, t + 1);
  }
  isValid(e) {
    return this.next().isValid(this._prepareHandlingArgs(e));
  }
}
const x3 = "blur beforedeactivate", y3 = ["deleteContentBackward", "deleteSoftLineBackward", "deleteContent", "deleteHardLineBackward"], b3 = ["historyUndo", "historyRedo"], w3 = ["focusIn", "focusOut", "input", "paste", "cut", "drop", "beforeInput"];
function S3(i) {
  return " ".repeat(i);
}
class E3 {
  constructor(e) {
    this.editor = e;
  }
  _editorOption() {
    return this.editor.option(...arguments);
  }
  _editorInput() {
    return this.editor._input();
  }
  _editorCaret(e) {
    if (!e)
      return this.editor._caret();
    this.editor._caret(e);
  }
  _attachChangeEventHandler() {
    if (!this._editorOption("valueChangeEvent").split(" ").includes("change"))
      return;
    const e = this._editorInput(), t = R(x3, "dxMask");
    _.on(e, t, (n) => {
      this.editor._changeHandler(n);
    });
  }
  _beforeInputHandler() {
    this._previousText = this._editorOption("text"), this._prevCaret = this._editorCaret();
  }
  _inputHandler(e) {
    const {
      originalEvent: t
    } = e;
    if (!t)
      return;
    const {
      inputType: n
    } = t;
    if (b3.includes(n))
      this._handleHistoryInputEvent();
    else if (y3.includes(n))
      this._handleBackwardDeleteInputEvent();
    else {
      const s = this._editorCaret();
      if (!s.end)
        return;
      this._clearSelectedText(), this._autoFillHandler(t), this._editorCaret(s), this._handleInsertTextInputEvent(t.data);
    }
    this._editorOption("text") === this._previousText && e.stopImmediatePropagation();
  }
  _handleHistoryInputEvent() {
    const e = this._editorCaret();
    this._updateEditorMask({
      start: e.start,
      length: e.end - e.start,
      text: ""
    }), this._editorCaret(this._prevCaret);
  }
  _handleBackwardDeleteInputEvent() {
    this._clearSelectedText(!0);
    const e = this._editorCaret();
    this.editor.setForwardDirection(), this.editor._adjustCaret(), this._editorCaret().start !== e.start && (this.editor.setBackwardDirection(), this.editor._adjustCaret());
  }
  _clearSelectedText(e) {
    const n = this._prevCaret && this._prevCaret.end - this._prevCaret.start || Number(e), s = this._editorCaret();
    this._isAutoFill() || (this.editor.setBackwardDirection(), this._updateEditorMask({
      start: s.start,
      length: n,
      text: S3(n)
    }));
  }
  _handleInsertTextInputEvent(e) {
    var t;
    const n = e ?? "";
    this.editor.setForwardDirection(), this._updateEditorMask({
      start: ((t = this._prevCaret) === null || t === void 0 ? void 0 : t.start) ?? 0,
      length: n.length || 1,
      text: n
    }) || this._editorCaret(this._prevCaret);
  }
  _updateEditorMask(e) {
    const t = e.text.length, n = this.editor._handleChain(e);
    if (this.editor._displayMask(), this.editor.isForwardDirection()) {
      const {
        start: s,
        end: o
      } = this._editorCaret(), r = n - t;
      n > 1 && t === 1 && this._editorCaret({
        start: s + r,
        end: o + r
      }), this.editor._adjustCaret();
    }
    return !!n;
  }
  _focusInHandler() {
    if (this.editor._showMaskPlaceholder(), this.editor.setForwardDirection(), !this.editor._isValueEmpty() && this._editorOption("isValid"))
      this.editor._adjustCaret();
    else {
      const e = this.editor._maskRulesChain.first();
      this._caretTimeout = setTimeout(() => {
        this._editorCaret({
          start: e,
          end: e
        });
      }, 0);
    }
  }
  _focusOutHandler(e) {
    this.editor._changeHandler(e), this._editorOption("showMaskMode") === "onFocus" && this.editor._isValueEmpty() && (this._editorOption("text", ""), this.editor._renderDisplayText(""));
  }
  _delHandler(e) {
    const {
      editor: t
    } = this;
    t._maskKeyHandler(e, () => {
      t._hasSelection() || t._handleKey(" ");
    });
  }
  _cutHandler(e) {
    const t = this._editorCaret(), n = this._editorInput().val().substring(t.start, t.end);
    this.editor._maskKeyHandler(e, () => cc(e, n));
  }
  _dropHandler() {
    this._clearDragTimer(), this._dragTimer = setTimeout(() => {
      const e = this.editor._convertToValue(this._editorInput().val());
      this._editorOption("value", e);
    });
  }
  _pasteHandler(e) {
    const {
      editor: t
    } = this;
    if (this._editorOption("disabled"))
      return;
    const n = this._editorCaret();
    t._maskKeyHandler(e, () => {
      const s = cc(e), o = t._maskRulesChain.text().substring(n.end), r = t._handleChain({
        text: s,
        start: n.start,
        length: s.length
      }), a = n.start + r;
      t._handleChain({
        text: o,
        start: a,
        length: o.length
      }), t._caret({
        start: a,
        end: a
      });
    });
  }
  _autoFillHandler(e) {
    const {
      editor: t
    } = this, n = this._editorInput().val();
    this._inputHandlerTimer = setTimeout(() => {
      this._isAutoFill() && (t._maskKeyHandler(e, () => {
        t._handleChain({
          text: n,
          start: 0,
          length: n.length
        });
      }), t._validateMask());
    });
  }
  _isAutoFill() {
    const e = this._editorInput();
    if (ze.webkit) {
      const t = e.get(0);
      return t?.matches(":-webkit-autofill") ?? !1;
    }
    return !1;
  }
  _clearDragTimer() {
    clearTimeout(this._dragTimer);
  }
  _clearTimers() {
    this._clearDragTimer(), clearTimeout(this._caretTimeout), clearTimeout(this._inputHandlerTimer);
  }
  getHandler(e) {
    return (t) => {
      var n;
      (n = this[`_${e}Handler`]) === null || n === void 0 || n.call(this, t);
    };
  }
  attachEvents() {
    const e = this._editorInput();
    w3.forEach((t) => {
      const n = R(t.toLowerCase(), "dxMask");
      _.on(e, n, this.getHandler(t));
    }), this._attachChangeEventHandler();
  }
  detachEvents() {
    this._clearTimers(), _.off(this._editorInput(), ".dxMask");
  }
  clean() {
    this._clearTimers();
  }
}
const {
  ios: I3,
  mac: D3
} = z.real(), T3 = I3 || D3, O3 = (i) => {
  let e;
  try {
    e = {
      start: i.selectionStart,
      end: i.selectionEnd
    };
  } catch {
    e = {
      start: 0,
      end: 0
    };
  }
  return e;
}, A3 = (i, e) => {
  const t = O.getBody();
  if (!(!t.contains(i) && !t.contains(i.getRootNode().host)))
    try {
      i.selectionStart = e.start, i.selectionEnd = e.end;
    } catch {
    }
}, R3 = function(i, e) {
  let t = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : !1;
  if (i = p(i).get(0), !f(e))
    return O3(i);
  !t && T3 && O.getActiveElement(i) !== i || A3(i, e);
}, Wb = R3, F3 = {
  0: /[0-9]/,
  9: /[0-9\s]/,
  "#": /[-+0-9\s]/,
  L: (i) => Xd(i),
  l: (i) => Xd(i) || Kb(i),
  C: /\S/,
  c: /./,
  A: (i) => Xd(i) || zb(i),
  a: (i) => Xd(i) || zb(i) || Kb(i)
};
function zb(i) {
  return /[0-9]/.test(i);
}
function Xd(i) {
  const e = i.charCodeAt();
  return e > 64 && e < 91 || e > 96 && e < 123 || e > 127;
}
function Kb(i) {
  return i === " ";
}
class J_ extends C3 {
  _getDefaultOptions() {
    return I({}, super._getDefaultOptions(), {
      mask: "",
      maskChar: "_",
      maskRules: {},
      maskInvalidMessage: S.format("validation-mask"),
      useMaskedValue: !1,
      showMaskMode: "always"
    });
  }
  _supportedKeys() {
    const e = this, t = {
      del: e._maskStrategy.getHandler("del"),
      enter: e._changeHandler
    }, n = super._supportedKeys();
    return y(t, (s, o) => {
      const r = n[s];
      n[s] = function(a) {
        e.option("mask") && o.call(e, a), r && r(a);
      };
    }), n;
  }
  _getSubmitElement() {
    return this.option("mask") ? this._$hiddenElement : super._getSubmitElement();
  }
  _init() {
    super._init(), this._initMaskStrategy();
  }
  _initMaskStrategy() {
    this._maskStrategy = new E3(this);
  }
  _initMarkup() {
    this._renderHiddenElement(), super._initMarkup();
  }
  _attachMouseWheelEventHandlers() {
    if (!(this._onMouseWheel !== M))
      return;
    const t = this._input(), n = R(sd, this.NAME), s = this._createAction((o) => {
      const {
        event: r
      } = o;
      qs(t) && !bt(r) && (this._onMouseWheel(r), r.preventDefault(), r.stopPropagation());
    });
    _.off(t, n), _.on(t, n, (o) => {
      s({
        event: o
      });
    });
  }
  _onMouseWheel(e) {
  }
  _useMaskBehavior() {
    return !!this.option("mask");
  }
  _attachDropEventHandler() {
    if (!this._useMaskBehavior())
      return;
    const t = R("drop", this.NAME), n = this._input();
    _.off(n, t), _.on(n, t, (s) => s.preventDefault());
  }
  _render() {
    this._attachMouseWheelEventHandlers(), this._renderMask(), super._render(), this._attachDropEventHandler();
  }
  _renderHiddenElement() {
    this.option("mask") && (this._$hiddenElement = p("<input>").attr("type", "hidden").appendTo(this._inputWrapper()));
  }
  _removeHiddenElement() {
    this._$hiddenElement && this._$hiddenElement.remove();
  }
  _renderMask() {
    this.$element().removeClass("dx-texteditor-masked"), this._maskRulesChain = null, this._maskStrategy.detachEvents(), this.option("mask") && (this.$element().addClass("dx-texteditor-masked"), this._maskStrategy.attachEvents(), this._parseMask(), this._renderMaskedValue());
  }
  _changeHandler(e) {
    const t = this._input(), n = t.val();
    if (n === this._changedValue)
      return;
    this._changedValue = n;
    const s = $s(e, {
      type: "change"
    });
    _.trigger(t, s);
  }
  _parseMask() {
    this._maskRules = x({}, F3, this.option("maskRules")), this._maskRulesChain = this._parseMaskRule(0);
  }
  _parseMaskRule(e) {
    const {
      mask: t
    } = this.option();
    if (e >= t.length)
      return new v3();
    const n = t[e], s = n === "\\", o = s ? new Hb({
      maskChar: t[e + 1]
    }) : this._getMaskRule(n);
    return o.next(this._parseMaskRule(e + 1 + s)), o;
  }
  _getMaskRule(e) {
    let t;
    return y(this._maskRules, (n, s) => {
      if (n === e)
        return t = {
          pattern: n,
          allowedChars: s
        }, !1;
    }), f(t) ? new zO(x({
      maskChar: this.option("maskChar") || " "
    }, t)) : new Hb({
      maskChar: e
    });
  }
  _renderMaskedValue() {
    if (!this._maskRulesChain)
      return;
    const e = this.option("value") || "";
    this._maskRulesChain.clear(this._normalizeChainArguments());
    const t = {
      length: e.length
    };
    t[this._isMaskedValueMode() ? "text" : "value"] = e, this._handleChain(t), this._displayMask();
  }
  _replaceSelectedText(e, t, n) {
    if (n === void 0)
      return e;
    const s = e.slice(0, t.start), o = e.slice(t.end);
    return s + n + o;
  }
  _isMaskedValueMode() {
    return this.option("useMaskedValue");
  }
  _displayMask(e) {
    e = e || this._caret(), this._renderValue(), this._caret(e);
  }
  _isValueEmpty() {
    return yu(this._value);
  }
  _shouldShowMask() {
    const {
      showMaskMode: e
    } = this.option();
    return e === "onFocus" ? qs(this._input()) || !this._isValueEmpty() : !0;
  }
  _showMaskPlaceholder() {
    if (this._shouldShowMask()) {
      const e = this._maskRulesChain.text();
      this.option("text", e);
      const {
        showMaskMode: t
      } = this.option();
      t === "onFocus" && this._renderDisplayText(e);
    }
  }
  _renderValue() {
    if (this._maskRulesChain && (this._showMaskPlaceholder(), this._$hiddenElement)) {
      const e = this._maskRulesChain.value(), t = yu(e) ? "" : this._getPreparedValue();
      this._$hiddenElement.val(t);
    }
    return super._renderValue();
  }
  _getPreparedValue() {
    return this._convertToValue().replace(/\s+$/, "");
  }
  _valueChangeEventHandler(e, t) {
    if (!this._maskRulesChain) {
      super._valueChangeEventHandler.apply(this, arguments);
      return;
    }
    this._saveValueChangeEvent(e), this.option("value", this._getPreparedValue());
  }
  _isControlKeyFired(e) {
    return this._isControlKey(Ye(e)) || bt(e);
  }
  _handleChain(e) {
    const t = this._maskRulesChain.handle(this._normalizeChainArguments(e));
    return this._updateMaskInfo(), t;
  }
  _normalizeChainArguments(e) {
    return e = e || {}, e.index = 0, e.fullText = this._maskRulesChain.text(), e;
  }
  _convertToValue(e) {
    return this._isMaskedValueMode() ? e = this._replaceMaskCharWithEmpty(e || this._textValue || "") : e = e || this._value || "", e;
  }
  _replaceMaskCharWithEmpty(e) {
    const {
      maskChar: t
    } = this.option();
    return e.replace(new RegExp(t, "g"), " ");
  }
  _maskKeyHandler(e, t) {
    if (this.option("readOnly"))
      return;
    this.setForwardDirection(), e.preventDefault(), this._handleSelection();
    const n = this._input().val(), s = () => {
      n !== this._input().val() && _.trigger(this._input(), "input");
    }, o = t();
    o ? o.then(s) : (this.setForwardDirection(), this._adjustCaret(), this._displayMask(), this._maskRulesChain.reset(), s());
  }
  _handleKey(e, t) {
    this._direction(t || "forward"), this._adjustCaret(e), this._handleKeyChain(e), this._moveCaret();
  }
  _handleSelection() {
    if (!this._hasSelection())
      return;
    const e = this._caret(), t = new Array(e.end - e.start + 1).join(" ");
    this._handleKeyChain(t);
  }
  _handleKeyChain(e) {
    const t = this._caret(), n = this.isForwardDirection() ? t.start : t.start - 1, s = this.isForwardDirection() ? t.end : t.end - 1, o = n === s ? 1 : s - n;
    this._handleChain({
      text: e,
      start: n,
      length: o
    });
  }
  _tryMoveCaretBackward() {
    this.setBackwardDirection();
    const e = this._caret().start;
    return this._adjustCaret(), !e || e !== this._caret().start;
  }
  _adjustCaret(e) {
    const t = this._caret().start, n = this.isForwardDirection(), s = this._maskRulesChain.adjustedCaret(t, n, e);
    this._caret({
      start: s,
      end: s
    });
  }
  _moveCaret() {
    const e = this._caret().start, t = e + (this.isForwardDirection() ? 0 : -1), n = this._maskRulesChain.isAccepted(t) ? e + (this.isForwardDirection() ? 1 : -1) : e;
    this._caret({
      start: n,
      end: n
    });
  }
  _caret(e, t) {
    const n = this._input();
    if (n.length) {
      if (!arguments.length)
        return Wb(n);
      Wb(n, e, t);
    }
  }
  _hasSelection() {
    const e = this._caret();
    return e.start !== e.end;
  }
  _direction(e) {
    if (!arguments.length)
      return this._typingDirection;
    this._typingDirection = e;
  }
  setForwardDirection() {
    this._direction("forward");
  }
  setBackwardDirection() {
    this._direction("backward");
  }
  isForwardDirection() {
    return this._direction() === "forward";
  }
  _updateMaskInfo() {
    this._textValue = this._maskRulesChain.text(), this._value = this._maskRulesChain.value();
  }
  _clean() {
    this._maskStrategy && this._maskStrategy.clean(), super._clean();
  }
  _validateMask() {
    if (!this._maskRulesChain)
      return;
    const e = yu(this.option("value")) || this._maskRulesChain.isValid(this._normalizeChainArguments());
    this.option({
      isValid: e,
      validationError: e ? null : {
        editorSpecific: !0,
        message: this.option("maskInvalidMessage")
      }
    });
  }
  _updateHiddenElement() {
    this._removeHiddenElement(), this.option("mask") && (this._input().removeAttr("name"), this._renderHiddenElement());
    const {
      name: e
    } = this.option();
    this._setSubmitElementName(e);
  }
  _updateMaskOption() {
    this._updateHiddenElement(), this._renderMask(), this._validateMask(), this._refreshValueChangeEvent();
  }
  _processEmptyMask(e) {
    if (e)
      return;
    const t = this.option("value");
    this.option({
      text: t,
      isValid: !0,
      validationError: null
    }), this.validationRequest.fire({
      value: t,
      editor: this
    }), this._renderValue();
  }
  _optionChanged(e) {
    switch (e.name) {
      case "mask":
        this._updateMaskOption(), this._processEmptyMask(e.value);
        break;
      case "maskChar":
      case "maskRules":
      case "useMaskedValue":
        this._updateMaskOption();
        break;
      case "value":
        this._renderMaskedValue(), this._validateMask(), super._optionChanged(e), this._changedValue = this._input().val();
        break;
      case "maskInvalidMessage":
        break;
      case "showMaskMode":
        this.option("text", ""), this._renderValue();
        break;
      default:
        super._optionChanged(e);
    }
  }
  clear() {
    const {
      value: e
    } = this._getDefaultOptions();
    this.option("value") === e && this._renderMaskedValue(), super.clear();
  }
}
const k3 = fe(), V3 = ["backspace", "tab", "enter", "pageUp", "pageDown", "end", "home", "leftArrow", "rightArrow", "downArrow", "upArrow", "del"];
class ma extends J_ {
  ctor(e, t) {
    t && (this._showClearButton = t.showClearButton), super.ctor(e, t);
  }
  _getDefaultOptions() {
    return I({}, super._getDefaultOptions(), {
      value: "",
      mode: "text",
      maxLength: null
    });
  }
  _initMarkup() {
    this.$element().addClass("dx-textbox"), super._initMarkup(), this.setAria("role", "textbox");
  }
  _renderInputType() {
    super._renderInputType(), this._renderSearchMode();
  }
  _useTemplates() {
    return !1;
  }
  _renderProps() {
    super._renderProps(), this._toggleMaxLengthProp();
  }
  _toggleMaxLengthProp() {
    const e = this._getMaxLength();
    e && e > 0 ? this._input().attr("maxLength", e) : this._input().removeAttr("maxLength");
  }
  _renderSearchMode() {
    const {
      mode: e
    } = this.option();
    if (e === "search") {
      if (this.$element().addClass("dx-searchbox"), this._renderSearchIcon(), this._showClearButton === void 0) {
        const {
          showClearButton: t
        } = this.option();
        this._showClearButton = t, this.option("showClearButton", !0);
      }
    } else
      this.$element().removeClass("dx-searchbox"), this._$searchIcon && this._$searchIcon.remove(), this.option("showClearButton", this._showClearButton === void 0 ? this.option("showClearButton") : this._showClearButton), delete this._showClearButton;
  }
  _renderSearchIcon() {
    const e = p("<div>").addClass("dx-icon").addClass("dx-icon-search");
    e.prependTo(this._input().parent()), this._$searchIcon = e;
  }
  _getLabelContainerWidth() {
    if (this._$searchIcon) {
      const e = this._input().parent();
      return ne(e) - this._getLabelBeforeWidth();
    }
    return super._getLabelContainerWidth();
  }
  _getLabelBeforeWidth() {
    let e = super._getLabelBeforeWidth();
    return this._$searchIcon && (e += Ee(this._$searchIcon)), e;
  }
  _optionChanged(e) {
    switch (e.name) {
      case "maxLength":
        this._toggleMaxLengthProp();
        break;
      case "mode":
        super._optionChanged(e), this._updateLabelWidth();
        break;
      case "mask":
        super._optionChanged(e), this._toggleMaxLengthProp();
        break;
      default:
        super._optionChanged(e);
    }
  }
  _onKeyDownCutOffHandler(e) {
    const t = this._getMaxLength();
    if (t && !e.ctrlKey && !this._hasSelection()) {
      const n = p(e.target), s = Ye(e);
      return this._cutOffExtraChar(n), n.val().length < t || V3.includes(s) || k3.getSelection().toString() !== "";
    }
    return !0;
  }
  _onChangeCutOffHandler(e) {
    const t = p(e.target);
    this.option("maxLength") && this._cutOffExtraChar(t);
  }
  _cutOffExtraChar(e) {
    const t = this._getMaxLength(), n = e.val();
    t && n.length > t && e.val(n.substr(0, t));
  }
  _getMaxLength() {
    const {
      mask: e,
      maxLength: t
    } = this.option();
    return !!e ? null : t;
  }
}
xe("dxTextBox", ma);
function P3(i) {
  return class {
    constructor() {
      throw new Error(`Module '${i}' not found`);
    }
    static getInstance() {
    }
  };
}
let Gb = P3("TextBox");
const Xo = {
  _getDefaultOptions() {
    return x(this.callBase(), {
      searchMode: "",
      searchExpr: null,
      searchValue: "",
      searchEnabled: !1,
      searchEditorOptions: {}
    });
  },
  _initMarkup() {
    this._renderSearch(), this.callBase();
  },
  _renderSearch() {
    const i = this.$element(), e = this.option("searchEnabled"), t = this._addWidgetPrefix("search"), n = this._addWidgetPrefix("with-search");
    if (!e) {
      i.removeClass(n), this._removeSearchBox();
      return;
    }
    const s = this._getSearchEditorOptions();
    this._searchEditor ? this._searchEditor.option(s) : (i.addClass(n), this._$searchEditorElement = p("<div>").addClass(t).prependTo(i), this._searchEditor = this._createComponent(this._$searchEditorElement, Gb, s));
  },
  _removeSearchBox() {
    this._$searchEditorElement && this._$searchEditorElement.remove(), delete this._$searchEditorElement, delete this._searchEditor;
  },
  _getSearchEditorOptions() {
    const i = this, e = i.option("searchEditorOptions"), t = S.format("Search");
    return x({
      mode: "search",
      placeholder: t,
      tabIndex: i.option("tabIndex"),
      value: i.option("searchValue"),
      valueChangeEvent: "input",
      inputAttr: {
        "aria-label": t
      },
      onValueChanged(n) {
        const s = i.option("searchTimeout");
        i._valueChangeDeferred = w(), clearTimeout(i._valueChangeTimeout), i._valueChangeDeferred.done(function() {
          this.option("searchValue", n.value);
        }.bind(i)), n.event && n.event.type === "input" && s ? i._valueChangeTimeout = setTimeout(() => {
          i._valueChangeDeferred.resolve();
        }, s) : i._valueChangeDeferred.resolve();
      }
    }, e);
  },
  _getAriaTarget() {
    return this.option("searchEnabled") ? this._itemContainer(!0) : this.callBase();
  },
  _focusTarget() {
    return this.option("searchEnabled") ? this._itemContainer(!0) : this.callBase();
  },
  _updateFocusState(i, e) {
    this.option("searchEnabled") && this._toggleFocusClass(e, this.$element()), this.callBase(i, e);
  },
  getOperationBySearchMode: (i) => i === "equals" ? "=" : i,
  _optionChanged(i) {
    switch (i.name) {
      case "searchEnabled":
      case "searchEditorOptions":
        this._invalidate();
        break;
      case "searchExpr":
      case "searchMode":
      case "searchValue":
        if (!this._dataSource) {
          _e.log("W1009");
          return;
        }
        i.name === "searchMode" ? this._dataSource.searchOperation(this.getOperationBySearchMode(i.value)) : this._dataSource[i.name](i.value), this._dataSource.load();
        break;
      case "searchTimeout":
        break;
      default:
        this.callBase(i);
    }
  },
  focus() {
    if (!this.option("focusedElement") && this.option("searchEnabled")) {
      this._searchEditor && this._searchEditor.focus();
      return;
    }
    this.callBase();
  },
  _cleanAria() {
    const i = this.$element();
    this.setAria({
      role: null,
      activedescendant: null
    }, i), i.attr("tabIndex", null);
  },
  _clean() {
    this.callBase(), this._cleanAria();
  },
  _refresh() {
    this._valueChangeDeferred && this._valueChangeDeferred.resolve(), this.callBase();
  },
  setEditorClass(i) {
    Gb = i;
  }
}, M3 = se.inherit({
  ctor() {
    this._dataStructure = [], this._itemsCount = 0, this._visibleItemsCount = 0;
  },
  _indexByKey: {},
  _convertItemsToNodes(i, e) {
    const t = this;
    y(i, (n, s) => {
      const o = f(e) ? e : t._getParentId(s), r = t._convertItemToNode(s, o);
      t._dataStructure.push(r), t._checkForDuplicateId(r.internalFields.key), t._indexByKey[r.internalFields.key] = t._dataStructure.length - 1, t._itemHasChildren(s) && t._convertItemsToNodes(t._dataAccessors.getters.items(s), r.internalFields.key);
    });
  },
  _checkForDuplicateId(i) {
    if (f(this._indexByKey[i]))
      throw _e.Error("E1040", i);
  },
  _getParentId(i) {
    return this._dataType === "plain" ? this._dataAccessors.getters.parentKey(i) : void 0;
  },
  _itemHasChildren(i) {
    if (this._dataType === "plain")
      return;
    const e = this._dataAccessors.getters.items(i);
    return e && e.length;
  },
  _getUniqueKey(i) {
    const e = this._dataAccessors.getters.key, t = e(i);
    return e && (t || t === 0) && Kr(t) ? t : this.getItemsCount();
  },
  _convertItemToNode(i, e) {
    this._itemsCount++, i.visible !== !1 && this._visibleItemsCount++;
    const t = {
      internalFields: {
        disabled: this._dataAccessors.getters.disabled(i, {
          defaultValue: !1
        }),
        expanded: this._dataAccessors.getters.expanded(i, {
          defaultValue: !1
        }),
        selected: this._dataAccessors.getters.selected(i, {
          defaultValue: !1
        }),
        key: this._getUniqueKey(i),
        parentKey: f(e) ? e : this._rootValue,
        item: this._makeObjectFromPrimitive(i),
        childrenKeys: []
      }
    };
    return x(t, i), delete t.items, t;
  },
  setChildrenKeys() {
    const i = this;
    y(this._dataStructure, (e, t) => {
      if (t.internalFields.parentKey === i._rootValue)
        return;
      const n = i.getParentNode(t);
      n && n.internalFields.childrenKeys.push(t.internalFields.key);
    });
  },
  _makeObjectFromPrimitive(i) {
    if (Kr(i)) {
      const e = i;
      i = {}, this._dataAccessors.setters.key(i, e);
    }
    return i;
  },
  _convertToPublicNode(i, e) {
    if (!i)
      return null;
    const t = {
      text: this._dataAccessors.getters.display(i),
      key: i.internalFields.key,
      selected: i.internalFields.selected,
      expanded: i.internalFields.expanded,
      disabled: i.internalFields.disabled,
      parent: e || null,
      itemData: i.internalFields.item,
      children: [],
      items: []
    };
    return t.parent && (t.parent.children.push(t), t.parent.items.push(t)), t;
  },
  convertToPublicNodes(i, e) {
    if (!i.length)
      return [];
    const t = this, n = [];
    return y(i, (s, o) => {
      o = Kr(o) ? t._getByKey(o) : o;
      const r = t._convertToPublicNode(o, e);
      r.children = t.convertToPublicNodes(o.internalFields.childrenKeys, r), n.push(r), o.internalFields.publicNode = r;
    }), n;
  },
  setDataAccessors(i) {
    this._dataAccessors = i;
  },
  _getByKey(i) {
    return this._dataStructure[this.getIndexByKey(i)] || null;
  },
  getParentNode(i) {
    return this._getByKey(i.internalFields.parentKey);
  },
  getByKey(i, e) {
    if (e == null)
      return null;
    let t = null;
    const n = this;
    return function(s, o) {
      return y(s, (r, a) => {
        if ((a.internalFields && a.internalFields.key || n._dataAccessors.getters.key(a)).toString() === o.toString())
          return t = a, !1;
      }), t;
    }(i, e);
  },
  getItemsCount() {
    return this._itemsCount;
  },
  getVisibleItemsCount() {
    return this._visibleItemsCount;
  },
  updateIndexByKey() {
    const i = this;
    this._indexByKey = {}, y(this._dataStructure, (e, t) => {
      i._checkForDuplicateId(t.internalFields.key), i._indexByKey[t.internalFields.key] = e;
    });
  },
  updateChildrenKeys() {
    this._indexByKey = {}, this.removeChildrenKeys(), this.updateIndexByKey(), this.setChildrenKeys();
  },
  removeChildrenKeys() {
    this._indexByKey = {}, y(this._dataStructure, (i, e) => {
      e.internalFields.childrenKeys = [];
    });
  },
  getIndexByKey(i) {
    return this._indexByKey[i];
  },
  createPlainStructure(i, e, t) {
    return this._itemsCount = 0, this._visibleItemsCount = 0, this._rootValue = e, this._dataType = t, this._indexByKey = {}, this._convertItemsToNodes(i), this.setChildrenKeys(), this._dataStructure;
  }
}), vr = "expanded", mo = "selected", B3 = "disabled";
Xo.setEditorClass(ma);
const $3 = se.inherit({
  ctor(i) {
    this.options = {}, x(this.options, this._defaultOptions(), i), this.options.dataConverter.setDataAccessors(this.options.dataAccessors), this._selectedNodesKeys = [], this._expandedNodesKeys = [], this._dataStructure = [], this._createInternalDataStructure(), this.getTreeNodes();
  },
  setOption(i, e) {
    this.options[i] = e, i === "recursiveSelection" && this._updateSelection();
  },
  _defaultOptions: () => ({
    dataAccessors: void 0,
    items: [],
    multipleSelection: !0,
    recursiveSelection: !1,
    recursiveExpansion: !1,
    rootValue: 0,
    searchValue: "",
    dataType: "tree",
    searchMode: "contains",
    dataConverter: new M3(),
    onNodeChanged: M,
    sort: null
  }),
  _createInternalDataStructure() {
    this._initialDataStructure = this.options.dataConverter.createPlainStructure(this.options.items, this.options.rootValue, this.options.dataType), this._dataStructure = this.options.searchValue.length ? this.search(this.options.searchValue) : this._initialDataStructure, this.options.dataConverter._dataStructure = this._dataStructure, this._updateSelection(), this._updateExpansion();
  },
  _updateSelection() {
    this.options.recursiveSelection && (this._setChildrenSelection(), this._setParentSelection()), this._selectedNodesKeys = this._updateNodesKeysArray(mo);
  },
  _updateExpansion(i) {
    this.options.recursiveExpansion && (i ? this._updateOneBranch(i) : this._setParentExpansion()), this._expandedNodesKeys = this._updateNodesKeysArray(vr);
  },
  _updateNodesKeysArray(i) {
    const e = this;
    let t = [];
    return y(e._getDataBySelectionMode(), (n, s) => {
      e._isNodeVisible(s) && s.internalFields[i] && (i === vr || e.options.multipleSelection ? t.push(s.internalFields.key) : (t.length && e.toggleSelection(t[0], !1, !0), t = [s.internalFields.key]));
    }), t;
  },
  _getDataBySelectionMode() {
    return this.options.multipleSelection ? this.getData() : this.getFullData();
  },
  _isNodeVisible: (i) => i.internalFields.item.visible !== !1,
  _getByKey(i, e) {
    return i === this._dataStructure ? this.options.dataConverter._getByKey(e) : this.options.dataConverter.getByKey(i, e);
  },
  _setChildrenSelection() {
    const i = this;
    y(this._dataStructure, (e, t) => {
      if (!t.internalFields.childrenKeys.length)
        return;
      const n = t.internalFields.selected;
      n === !0 && i._toggleChildrenSelection(t, n);
    });
  },
  _setParentSelection() {
    const i = this;
    y(this._dataStructure, (e, t) => {
      i.options.dataConverter.getParentNode(t) && t.internalFields.parentKey !== i.options.rootValue && i._iterateParents(t, (s) => {
        const o = i._calculateSelectedState(s);
        i._setFieldState(s, mo, o);
      });
    });
  },
  _setParentExpansion() {
    const i = this;
    y(this._dataStructure, (e, t) => {
      t.internalFields.expanded && i._updateOneBranch(t.internalFields.key);
    });
  },
  _updateOneBranch(i) {
    const e = this, t = this.getNodeByKey(i);
    e._iterateParents(t, (n) => {
      e._setFieldState(n, vr, !0);
    });
  },
  _iterateChildren(i, e, t, n) {
    if (!B(t))
      return;
    const s = this, o = i.internalFields.key;
    n = n || [], n.indexOf(o) === -1 && (n.push(o), y(i.internalFields.childrenKeys, (r, a) => {
      const l = s.getNodeByKey(a);
      t(l), l.internalFields.childrenKeys.length && e && s._iterateChildren(l, e, t, n);
    }));
  },
  _iterateParents(i, e, t) {
    if (i.internalFields.parentKey === this.options.rootValue || !B(e))
      return;
    t = t || [];
    const {
      key: n
    } = i.internalFields;
    if (t.indexOf(n) === -1) {
      t.push(n);
      const s = this.options.dataConverter.getParentNode(i);
      s && (e(s), s.internalFields.parentKey !== this.options.rootValue && this._iterateParents(s, e, t));
    }
  },
  _calculateSelectedState(i) {
    const e = i.internalFields.childrenKeys.length;
    let t = 0, n = 0, s = !1;
    for (let o = 0; o <= e - 1; o++) {
      const r = this.getNodeByKey(i.internalFields.childrenKeys[o]), a = r.internalFields.item.visible === !1, l = r.internalFields.selected;
      if (a) {
        n++;
        continue;
      }
      l ? t++ : l === void 0 && (t += 0.5);
    }
    return t && (s = t === e - n ? !0 : void 0), s;
  },
  _toggleChildrenSelection(i, e) {
    const t = this;
    this._iterateChildren(i, !0, (n) => {
      t._isNodeVisible(n) && t._setFieldState(n, mo, e);
    });
  },
  _setFieldState(i, e, t) {
    i.internalFields[e] !== t && (i.internalFields[e] = t, i.internalFields.publicNode && (i.internalFields.publicNode[e] = t), this.options.dataAccessors.setters[e](i.internalFields.item, t), this.options.onNodeChanged(i));
  },
  _markChildren(i) {
    const e = this;
    y(i, (t, n) => {
      const s = e.getIndexByKey(n), o = e.getNodeByKey(n);
      e._dataStructure[s] = 0, o.internalFields.childrenKeys.length && e._markChildren(o.internalFields.childrenKeys);
    });
  },
  _removeNode(i) {
    const e = this.getNodeByKey(i);
    this._dataStructure[this.getIndexByKey(i)] = 0, this._markChildren(e.internalFields.childrenKeys);
    const t = this;
    let n = 0;
    const s = x([], this._dataStructure);
    y(s, (o, r) => {
      r || (t._dataStructure.splice(o - n, 1), n++);
    });
  },
  _addNode(i) {
    const {
      dataConverter: e
    } = this.options, t = e._convertItemToNode(i, this.options.dataAccessors.getters.parentKey(i));
    this._dataStructure = this._dataStructure.concat(t), this._initialDataStructure = this._initialDataStructure.concat(t), e._dataStructure = e._dataStructure.concat(t);
  },
  _updateFields() {
    this.options.dataConverter.updateChildrenKeys(), this._updateSelection(), this._updateExpansion();
  },
  getSelectedNodesKeys() {
    return this._selectedNodesKeys;
  },
  getExpandedNodesKeys() {
    return this._expandedNodesKeys;
  },
  getData() {
    return this._dataStructure;
  },
  getFullData() {
    return this._initialDataStructure;
  },
  getNodeByItem(i) {
    let e = null;
    return y(this._dataStructure, (t, n) => {
      if (n.internalFields.item === i)
        return e = n, !1;
    }), e;
  },
  getNodesByItems(i) {
    const e = this, t = [];
    return y(i, (n, s) => {
      const o = e.getNodeByItem(s);
      o && t.push(o);
    }), t;
  },
  getNodeByKey(i, e) {
    return this._getByKey(e || this._getDataBySelectionMode(), i);
  },
  getTreeNodes() {
    return this.options.dataConverter.convertToPublicNodes(this.getRootNodes());
  },
  getItemsCount() {
    return this.options.dataConverter.getItemsCount();
  },
  getVisibleItemsCount() {
    return this.options.dataConverter.getVisibleItemsCount();
  },
  getPublicNode: (i) => i.internalFields.publicNode,
  getRootNodes() {
    return this.getChildrenNodes(this.options.rootValue);
  },
  getChildrenNodes(i) {
    return un(this._dataStructure, {
      langParams: this.options.langParams
    }).filter(["internalFields.parentKey", i]).toArray();
  },
  getIndexByKey(i) {
    return this.options.dataConverter.getIndexByKey(i);
  },
  addItem(i) {
    this._addNode(i), this._updateFields();
  },
  removeItem(i) {
    this._removeNode(i), this._updateFields();
  },
  toggleSelection(i, e, t) {
    const n = this._isSingleModeUnselect(e), s = this._getByKey(t || n ? this._initialDataStructure : this._dataStructure, i);
    this._setFieldState(s, mo, e), this.options.recursiveSelection && !t && (e ? this._setChildrenSelection() : this._toggleChildrenSelection(s, e), this._setParentSelection()), this._selectedNodesKeys = this._updateNodesKeysArray(mo);
  },
  _isSingleModeUnselect(i) {
    return !this.options.multipleSelection && !i;
  },
  toggleNodeDisabledState(i, e) {
    const t = this.getNodeByKey(i);
    this._setFieldState(t, B3, e);
  },
  toggleSelectAll(i) {
    if (!f(i))
      return;
    const e = this, t = e._selectedNodesKeys[e._selectedNodesKeys.length - 1], n = e._isSingleModeUnselect(i) ? this._initialDataStructure : this._dataStructure;
    y(n, (s, o) => {
      e._isNodeVisible(o) && e._setFieldState(o, mo, i);
    }), e._selectedNodesKeys = e._updateNodesKeysArray(mo), !i && e.options.selectionRequired && e.toggleSelection(t, !0);
  },
  isAllSelected() {
    return this.getSelectedNodesKeys().length ? this.getSelectedNodesKeys().length === this.getVisibleItemsCount() ? !0 : void 0 : !1;
  },
  toggleExpansion(i, e) {
    const t = this.getNodeByKey(i);
    this._setFieldState(t, vr, e), e && this._updateExpansion(i), this._expandedNodesKeys = this._updateNodesKeysArray(vr);
  },
  isFiltered(i) {
    return !this.options.searchValue.length || !!this._filterDataStructure(this.options.searchValue, [i]).length;
  },
  _createCriteria(i, e, t) {
    const n = [];
    return Array.isArray(i) ? (y(i, (s, o) => {
      n.push([o, t, e], "or");
    }), n.pop(), n) : [i, t, e];
  },
  _filterDataStructure(i, e) {
    const t = this.options.searchExpr || this.options.dataAccessors.getters.display, n = Xo.getOperationBySearchMode(this.options.searchMode), s = this._createCriteria(t, i, n);
    return e = e || this._initialDataStructure, un(e, {
      langParams: this.options.langParams
    }).filter(s).toArray();
  },
  search(i) {
    const e = this;
    let t = this._filterDataStructure(i);
    const {
      dataConverter: n
    } = this.options;
    return function s(o, r) {
      const {
        length: a
      } = o;
      for (; r < a; ) {
        const l = o[r];
        if (l.internalFields.parentKey === e.options.rootValue) {
          r++;
          continue;
        }
        const d = n.getParentNode(l);
        if (!d) {
          _e.log("W1007", l.internalFields.parentKey, l.internalFields.key), r++;
          continue;
        }
        if (d.internalFields.expanded || e._setFieldState(d, vr, !0), o.includes(d)) {
          r++;
          continue;
        }
        o.splice(r, 0, d), s(o, r);
      }
    }(t, 0), this.options.sort && (t = ps.queryByOptions(un(t), {
      sort: this.options.sort,
      langParams: this.options.langParams
    }).toArray()), n._indexByKey = {}, y(t, (s, o) => {
      o.internalFields.childrenKeys = [], n._indexByKey[o.internalFields.key] = s;
    }), n._dataStructure = t, n.setChildrenKeys(), n._dataStructure;
  }
});
class KO extends Z_ {
  _getDefaultOptions() {
    return I({}, super._getDefaultOptions(), {
      keyExpr: "id",
      displayExpr: "text",
      selectedExpr: "selected",
      disabledExpr: "disabled",
      itemsExpr: "items",
      hoverStateEnabled: !0,
      parentIdExpr: "parentId",
      expandedExpr: "expanded"
    });
  }
  _defaultOptionsRules() {
    return super._defaultOptionsRules().concat([{
      device: () => z.real().deviceType === "desktop" && !z.isSimulator(),
      options: {
        focusStateEnabled: !0
      }
    }]);
  }
  _init() {
    super._init(), this._initAccessors(), this._initDataAdapter(), this._initDynamicTemplates();
  }
  _initDataSource() {
    var e;
    super._initDataSource(), (e = this._dataSource) === null || e === void 0 || e.paginate(!1);
  }
  _initDataAdapter() {
    const e = this._createDataAdapterAccessors();
    this._dataAdapter = new $3(x({
      dataAccessors: {
        getters: e.getters,
        setters: e.setters
      },
      items: this.option("items")
    }, this._getDataAdapterOptions()));
  }
  _getDataAdapterOptions() {
  }
  _getItemExtraPropNames() {
  }
  _initDynamicTemplates() {
    const e = ["text", "html", "items", "icon"].concat(this._getItemExtraPropNames());
    this._templateManager.addDefaultTemplates({
      item: new rr(this._addContent.bind(this), e, this.option("integrationOptions.watchMethod"), {
        text: this._displayGetter,
        items: this._itemsGetter
      })
    });
  }
  _addContent(e, t) {
    e.html(t.html).append(this._getIconContainer(t)).append(this._getTextContainer(t));
  }
  _getLinkContainer(e, t, n) {
    const {
      linkAttr: s,
      url: o
    } = n, r = X(s) ? s : {};
    return p("<a>").addClass("dx-item-url").attr(I({}, r, {
      href: o
    })).append(e).append(t);
  }
  _getIconContainer(e) {
    if (!e.icon)
      return;
    const t = cs(e.icon);
    if (t.is("img")) {
      var n;
      const s = (n = this.NAME) !== null && n !== void 0 && n.startsWith("dxPrivateComponent") ? "" : `${this.NAME} `;
      t.attr("alt", `${s}item icon`);
    }
    return t;
  }
  _getTextContainer(e) {
    return p("<span>").text(e.text);
  }
  _initAccessors() {
    const e = this;
    y(this._getAccessors(), (t, n) => {
      e._compileAccessor(n);
    }), this._compileDisplayGetter();
  }
  _getAccessors() {
    return ["key", "selected", "items", "disabled", "parentId", "expanded"];
  }
  _getChildNodes(e) {
    const t = this, n = [];
    return y(e.internalFields.childrenKeys, (s, o) => {
      const r = t._dataAdapter.getNodeByKey(o);
      n.push(r);
    }), n;
  }
  _hasChildren(e) {
    return e && e.internalFields.childrenKeys.length;
  }
  _compileAccessor(e) {
    const t = `_${e}Getter`, n = `_${e}Setter`, s = this.option(`${e}Expr`);
    if (!s) {
      this[t] = M, this[n] = M;
      return;
    }
    if (B(s)) {
      this[n] = function(o, r) {
        o[s()] = r;
      }, this[t] = function(o) {
        return o[s()];
      };
      return;
    }
    this[t] = Be(s), this[n] = $f(s);
  }
  _createDataAdapterAccessors() {
    const e = this, t = {
      getters: {},
      setters: {}
    };
    return y(this._getAccessors(), (n, s) => {
      const o = `_${s}Getter`, r = `_${s}Setter`, a = s === "parentId" ? "parentKey" : s;
      t.getters[a] = e[o], t.setters[a] = e[r];
    }), t.getters.display = this._displayGetter ? this._displayGetter : (n) => n.text, t;
  }
  _initMarkup() {
    super._initMarkup(), this._addWidgetClass();
  }
  _addWidgetClass() {
    this._focusTarget().addClass(this._widgetClass());
  }
  _widgetClass() {
  }
  _renderItemFrame(e, t, n) {
    const s = super._renderItemFrame.apply(this, arguments);
    return s.toggleClass("dx-state-disabled", !!this._disabledGetter(t)), s;
  }
  _optionChanged(e) {
    switch (e.name) {
      case "displayExpr":
      case "keyExpr":
        this._initAccessors(), this._initDynamicTemplates(), this.repaint();
        break;
      case "itemsExpr":
      case "selectedExpr":
      case "disabledExpr":
      case "expandedExpr":
      case "parentIdExpr":
        this._initAccessors(), this._initDataAdapter(), this.repaint();
        break;
      case "items":
        this._initDataAdapter(), super._optionChanged(e);
        break;
      default:
        super._optionChanged(e);
    }
  }
}
const Wn = "dx-menu-item", N3 = `${Wn}-content`, kp = `${Wn}-selected`, Ub = `${Wn}-wrapper`, L3 = `${Wn}-expanded`, H3 = `${Wn}-has-text`, W3 = `${Wn}-has-icon`, z3 = `${Wn}-has-submenu`, GO = `${Wn}-popout`, K3 = `${GO}-container`, UO = `${Wn}-text`, G3 = {
  show: 50,
  hide: 300
}, U3 = `${UO}-with-url`;
class eC extends KO {
  _getDefaultOptions() {
    return x(super._getDefaultOptions(), {
      items: [],
      cssClass: "",
      activeStateEnabled: !0,
      showSubmenuMode: {
        name: "onHover",
        delay: {
          show: 50,
          hide: 300
        }
      },
      animation: {
        show: {
          type: "fade",
          from: 0,
          to: 1,
          duration: 100
        },
        hide: {
          type: "fade",
          from: 1,
          to: 0,
          duration: 100
        }
      },
      selectByClick: !1,
      focusOnSelectedItem: !1,
      keyExpr: null,
      _itemAttributes: {
        role: "menuitem"
      },
      useInkRipple: !1
    });
  }
  _itemDataKey() {
    return "dxMenuItemDataKey";
  }
  _itemClass() {
    return Wn;
  }
  _setAriaSelectionAttribute(e, t) {
  }
  _selectedItemClass() {
    return kp;
  }
  _widgetClass() {
    return "dx-menu-base";
  }
  _focusTarget() {
    return this._itemContainer();
  }
  _clean() {
    this.option("focusedElement", null), super._clean();
  }
  _supportedKeys() {
    return x(super._supportedKeys(), {
      space: () => {
        const e = p(this.option("focusedElement"));
        !e.length || !this._isSelectionEnabled() || this.selectItem(e[0]);
      },
      pageUp: M,
      pageDown: M
    });
  }
  _isSelectionEnabled() {
    const {
      selectionMode: e
    } = this.option();
    return e === "single";
  }
  _init() {
    super._init(), this._activeStateUnit = `.${Wn}`, this._renderSelectedItem(), this._initActions();
  }
  _getLinkContainer(e, t, n) {
    const {
      linkAttr: s,
      url: o
    } = n;
    return e?.addClass("dx-icon-with-url"), t?.addClass(U3), super._getLinkContainer(e, t, {
      linkAttr: s,
      url: o
    });
  }
  _addContent(e, t) {
    const {
      html: n,
      url: s
    } = t;
    if (s) {
      e.html(n);
      const o = this._getLinkContainer(this._getIconContainer(t), this._getTextContainer(t), t);
      e.append(o);
    } else
      super._addContent(e, t);
    e.append(this._getPopoutContainer(t)), this._addContentClasses(t, e.parent());
  }
  _getTextContainer(e) {
    const {
      text: t
    } = e;
    if (!t)
      return;
    const n = p("<span>").addClass(UO), s = pe(e) ? t : String(e);
    return n.text(s);
  }
  _getItemExtraPropNames() {
    return ["url", "linkAttr"];
  }
  _getPopoutContainer(e) {
    const {
      items: t
    } = e;
    let n;
    if (t != null && t.length) {
      const s = p("<div>").addClass(GO);
      n = p("<span>").addClass(K3).append(s);
    }
    return n;
  }
  _getDataAdapterOptions() {
    return {
      rootValue: 0,
      multipleSelection: !1,
      recursiveSelection: !1,
      recursiveExpansion: !1,
      searchValue: ""
    };
  }
  _selectByItem(e) {
    if (!e)
      return;
    const t = this._dataAdapter.getNodeByItem(e);
    this._dataAdapter.toggleSelection(t.internalFields.key, !0);
  }
  _renderSelectedItem() {
    const e = this._dataAdapter.getSelectedNodesKeys(), t = e.length && e[0], n = this.option("selectedItem");
    if (!t) {
      this._selectByItem(n);
      return;
    }
    const s = this._dataAdapter.getNodeByKey(t);
    if (s.selectable !== !1) {
      if (!n) {
        this.option("selectedItem", s.internalFields.item);
        return;
      }
      n !== s.internalFields.item && (this._dataAdapter.toggleSelection(t, !1), this._selectByItem(n));
    }
  }
  _initActions() {
  }
  _initMarkup() {
    super._initMarkup(), this.option("useInkRipple") && this._renderInkRipple();
  }
  _renderInkRipple() {
    this._inkRipple = w_();
  }
  _toggleActiveState(e, t, n) {
    if (super._toggleActiveState.apply(this, arguments), !this._inkRipple)
      return;
    const s = {
      element: e,
      event: n
    };
    t ? this._inkRipple.showWave(s) : this._inkRipple.hideWave(s);
  }
  _getShowSubmenuMode() {
    const {
      showSubmenuMode: e
    } = this.option(), t = X(e) ? e.name : e;
    return this._isDesktopDevice() ? t : "onClick";
  }
  _initSelectedItems() {
  }
  _isDesktopDevice() {
    return z.real().deviceType === "desktop";
  }
  _initEditStrategy() {
    const e = qq;
    this._editStrategy = new e(this);
  }
  _addCustomCssClass(e) {
    e.addClass(this.option("cssClass"));
  }
  _itemWrapperSelector() {
    return `.${Ub}`;
  }
  _hoverStartHandler(e) {
    const t = this._getItemElementByEventArgs(e);
    if (!(!t || this._isItemDisabled(t)) && (e.stopPropagation(), this._getShowSubmenuMode() === "onHover")) {
      const n = this._getSubmenuDelay("show");
      n === 0 ? this._showSubmenu(t) : (clearTimeout(this._showSubmenusTimeout), this._showSubmenusTimeout = setTimeout(this._showSubmenu.bind(this, t), n));
    }
  }
  _getAvailableItems(e) {
    return super._getAvailableItems(e).filter(function() {
      return p(this).css("visibility") !== "hidden";
    });
  }
  _isItemDisabled(e) {
    return this._disabledGetter(e.data(this._itemDataKey()));
  }
  _showSubmenu(e) {
    this._addExpandedClass(e);
  }
  _addExpandedClass(e) {
    p(e).addClass(L3);
  }
  _getSubmenuDelay(e) {
    const {
      delay: t
    } = this.option("showSubmenuMode");
    return f(t) ? X(t) ? t[e] : t : G3[e];
  }
  _getItemElementByEventArgs(e) {
    let t = p(e.target);
    if (t.hasClass(this._itemClass()) || t.get(0) === e.currentTarget)
      return t;
    for (; !t.hasClass(this._itemClass()); )
      if (t = t.parent(), t.hasClass("dx-submenu"))
        return null;
    return t;
  }
  _hoverEndHandler(e) {
    clearTimeout(this._showSubmenusTimeout);
  }
  _hasSubmenu(e) {
    return e?.internalFields.childrenKeys.length;
  }
  _renderContentImpl() {
    this._renderItems(this._dataAdapter.getRootNodes());
  }
  _renderItems(e, t) {
    if (!e.length)
      return;
    this.hasIcons = !1;
    const n = this._renderContainer(this.$element(), t);
    let s = -1, o = -1;
    y(e, (r, a) => {
      const l = a.visible !== !1;
      l && s < 0 && (s = r), s < r && (a.beginGroup || r === o) && (o = l ? r : r + 1), r === o && s < r && this._renderSeparator(n), this._renderItem(r, a, n);
    }), this.hasIcons || n.addClass("dx-menu-no-icons");
  }
  _renderContainer(e, t) {
    const n = p("<ul>");
    return this.setAria("role", "none", n), n.appendTo(e).addClass("dx-menu-items-container");
  }
  _createDOMElement(e) {
    const t = p("<li>");
    return this.setAria("role", "none", t), t.appendTo(e).addClass(Ub);
  }
  _renderItem(e, t, n, s) {
    var o;
    const {
      items: r = []
    } = this.option(), a = s ?? this._createDOMElement(n);
    (o = r[e + 1]) !== null && o !== void 0 && o.beginGroup && a.addClass("dx-menu-last-group-item");
    const l = super._renderItem(e, t.internalFields.item, a);
    return t.internalFields.item === this.option("selectedItem") && l.addClass(kp), l.attr("tabIndex", -1), this._hasSubmenu(t) && this.setAria("haspopup", "true", l), l;
  }
  _renderItemFrame(e, t, n) {
    const s = n.children(`.${Wn}`);
    return s.length ? s : super._renderItemFrame.apply(this, arguments);
  }
  _refreshItem(e, t) {
    const n = this._dataAdapter.getNodeByItem(t), s = e.data(this._itemIndexKey()), o = e.closest("ul"), r = e.closest("li");
    this._renderItem(s, n, o, r);
  }
  _addContentClasses(e, t) {
    const n = e.text ? !!e.text.length : !1, s = !!e.icon, o = e.items ? !!e.items.length : !1;
    t.toggleClass(H3, n), t.toggleClass(W3, s), this.hasIcons || (this.hasIcons = s), t.toggleClass(z3, o);
  }
  _getItemContent(e) {
    let t = super._getItemContent(e);
    return t.length || (t = e.children(`.${N3}`)), t;
  }
  _postprocessRenderItem(e) {
    const t = p(e.itemElement), n = this._dataAdapter.getSelectedNodesKeys();
    if (!n.length || !this._selectedGetter(e.itemData) || !this._isItemSelectable(e.itemData)) {
      this._setAriaSelectionAttribute(t, "false");
      return;
    }
    this._dataAdapter.getNodeByItem(e.itemData).internalFields.key === n[0] ? (t.addClass(this._selectedItemClass()), this._setAriaSelectionAttribute(t, "true")) : this._setAriaSelectionAttribute(t, "false");
  }
  _isItemSelectable(e) {
    return e.selectable !== !1;
  }
  _renderSeparator(e) {
    p("<li>").appendTo(e).addClass("dx-menu-separator");
  }
  _itemClickHandler(e) {
    if (e._skipHandling)
      return;
    const t = this._createAction(this._updateSubmenuVisibilityOnClick.bind(this));
    this._itemDXEventHandler(e, "onItemClick", {}, {
      beforeExecute: this._itemClick,
      afterExecute: t.bind(this)
    }), e._skipHandling = !0;
  }
  _itemClick(e) {
    const {
      event: t,
      itemData: n
    } = e.args[0], s = this._getItemElementByEventArgs(t), o = s && s.find(".dx-item-url").get(0);
    n.url && o && o.click();
  }
  _updateSubmenuVisibilityOnClick(e) {
    this._updateSelectedItemOnClick(e), this._getShowSubmenuMode() === "onClick" && this._addExpandedClass(e.args[0].itemElement);
  }
  _updateSelectedItemOnClick(e) {
    const t = e.args ? e.args[0] : e;
    if (!this._isItemSelectAllowed(t.itemData))
      return;
    const n = this._dataAdapter.getSelectedNodesKeys(), s = n.length && this._dataAdapter.getNodeByKey(n[0]);
    s && this._toggleItemSelection(s, !1), !s || s.internalFields.item !== t.itemData ? this.selectItem(t.itemData) : (this._fireSelectionChangeEvent(null, this.option("selectedItem")), this._setOptionWithoutOptionChange("selectedItem", null));
  }
  _isItemSelectAllowed(e) {
    const t = this._isSelectionEnabled() && this.option("selectByClick");
    return !this._isContainerEmpty() && t && this._isItemSelectable(e) && !this._itemsGetter(e);
  }
  _isContainerEmpty() {
    return this._itemContainer().is(":empty");
  }
  _syncSelectionOptions() {
    return CE();
  }
  _optionChanged(e) {
    switch (e.name) {
      case "showSubmenuMode":
        break;
      case "selectedItem": {
        const t = this._dataAdapter.getNodeByItem(e.value), n = this._dataAdapter.getSelectedNodesKeys()[0];
        if (t && t.internalFields.key !== n) {
          if (t.selectable === !1)
            break;
          n && this._toggleItemSelection(this._dataAdapter.getNodeByKey(n), !1), this._toggleItemSelection(t, !0), this._updateSelectedItems();
        }
        break;
      }
      case "cssClass":
      case "position":
      case "selectByClick":
      case "animation":
      case "useInkRipple":
        this._invalidate();
        break;
      default:
        super._optionChanged(e);
    }
  }
  _toggleItemSelection(e, t) {
    const n = this._getElementByItem(e.internalFields.item);
    n && p(n).toggleClass(kp), this._dataAdapter.toggleSelection(e.internalFields.key, t);
  }
  _getElementByItem(e) {
    let t;
    return y(this._itemElements(), (n, s) => p(s).data(this._itemDataKey()) !== e ? !0 : (t = s, !1)), t;
  }
  _updateSelectedItems(e, t) {
    (e || t) && this._fireSelectionChangeEvent(t, e);
  }
  _fireSelectionChangeEvent(e, t) {
    this._createActionByOption("onSelectionChanged", {
      excludeValidators: ["disabled", "readOnly"]
    })({
      addedItems: [e],
      removedItems: [t]
    });
  }
  selectItem(e) {
    const t = e.nodeType ? this._getItemData(e) : e, n = this._dataAdapter.getSelectedNodesKeys()[0], s = this.option("selectedItem"), o = this._dataAdapter.getNodeByItem(t);
    o.internalFields.key !== n && (n && this._toggleItemSelection(this._dataAdapter.getNodeByKey(n), !1), this._toggleItemSelection(o, !0), this._updateSelectedItems(s, t), this._setOptionWithoutOptionChange("selectedItem", t));
  }
  unselectItem(e) {
    const t = e.nodeType ? this._getItemData(e) : e, n = this._dataAdapter.getNodeByItem(t), s = this.option("selectedItem");
    n.internalFields.selected && (this._toggleItemSelection(n, !1), this._updateSelectedItems(s, null), this._setOptionWithoutOptionChange("selectedItem", null));
  }
}
eC.ItemClass = ga;
const j3 = "dx-menu-phone-overlay", jb = ["onShowing", "onShown", "onSubmenuCreated", "onHiding", "onHidden", "onPositioning", "onLeftFirstItem", "onLeftLastItem", "onCloseRootSubmenu", "onExpandLastSubmenu"], q3 = ["up", "down", "first", "last"], qb = fe();
class tC extends eC {
  getShowEvent(e) {
    if (X(e)) {
      if (e.name !== null)
        return e.name ?? "dxcontextmenu";
    } else
      return e;
    return null;
  }
  getShowDelay(e) {
    return X(e) && e.delay;
  }
  _getDefaultOptions() {
    return x(super._getDefaultOptions(), {
      showEvent: "dxcontextmenu",
      hideOnOutsideClick: !0,
      position: {
        at: "top left",
        my: "top left"
      },
      onShowing: null,
      onShown: null,
      onSubmenuCreated: null,
      onHiding: null,
      onHidden: null,
      onPositioning: null,
      submenuDirection: "auto",
      visible: !1,
      target: void 0,
      onLeftFirstItem: null,
      onLeftLastItem: null,
      onCloseRootSubmenu: null,
      onExpandLastSubmenu: null
    });
  }
  _defaultOptionsRules() {
    return super._defaultOptionsRules().concat([{
      device: () => !ae(),
      options: {
        animation: null
      }
    }]);
  }
  _setDeprecatedOptions() {
    super._setDeprecatedOptions(), x(this._deprecatedOptions, {
      closeOnOutsideClick: {
        since: "22.2",
        alias: "hideOnOutsideClick"
      }
    });
  }
  _initActions() {
    this._actions = {}, y(jb, (e, t) => {
      this._actions[t] = this._createActionByOption(t) || M;
    });
  }
  _setOptionsByReference() {
    super._setOptionsByReference(), x(this._optionsByReference, {
      animation: !0,
      selectedItem: !0
    });
  }
  _focusInHandler() {
  }
  _itemContainer() {
    return this._overlay ? this._overlay.$content() : p();
  }
  _eventBindingTarget() {
    return this._itemContainer();
  }
  itemsContainer() {
    return this._overlay ? this._overlay.$content() : void 0;
  }
  _supportedKeys() {
    return x(super._supportedKeys(), {
      space: () => {
        const e = p(this.option("focusedElement"));
        this.hide(), !(!e.length || !this._isSelectionEnabled()) && this.selectItem(e[0]);
      },
      escape: this.hide
    });
  }
  _getActiveItem(e) {
    const t = this._getAvailableItems(), n = t.filter(".dx-state-focused"), s = t.filter(".dx-state-hover");
    return s.closest(".dx-menu-items-container").find(".dx-menu-item").index(n) >= 0 ? n : s.length ? s : super._getActiveItem();
  }
  _moveFocus(e) {
    const t = this._getItemsByLocation(e), n = this._getActiveItem(!0), s = this.itemsContainer().find(".dx-state-hover"), r = !!(p(this.option("focusedElement")).length || s.length);
    let a;
    switch (e) {
      case "up":
        a = r ? this._prevItem(t) : n, this._setFocusedElement(a), n.is(t.first()) && this._actions.onLeftFirstItem(n);
        break;
      case "down":
        a = r ? this._nextItem(t) : n, this._setFocusedElement(a), n.is(t.last()) && this._actions.onLeftLastItem(n);
        break;
      case "right":
        a = this.option("rtlEnabled") ? this._hideSubmenuHandler() : this._expandSubmenuHandler(t, e), this._setFocusedElement(a);
        break;
      case "left":
        a = this.option("rtlEnabled") ? this._expandSubmenuHandler(t, e) : this._hideSubmenuHandler(), this._setFocusedElement(a);
        break;
      case "first":
        a = t.first(), this._setFocusedElement(a);
        break;
      case "last":
        a = t.last(), this._setFocusedElement(a);
        break;
      default:
        return super._moveFocus(e);
    }
  }
  _setFocusedElement(e) {
    e && e.length !== 0 && (this.option("focusedElement", ee(e)), this._scrollToElement(e));
  }
  _scrollToElement(e) {
    const n = e.closest(".dx-scrollable").dxScrollable("instance");
    n?.scrollToElement(e);
  }
  _getItemsByLocation(e) {
    const t = this._getActiveItem(!0);
    let n;
    return q3.includes(e) && (n = t.closest(".dx-menu-items-container").children().children()), n = this._getAvailableItems(n), n;
  }
  _getAriaTarget() {
    return this.$element();
  }
  _refreshActiveDescendant() {
    if (f(this._overlay)) {
      const e = this._overlay.$content();
      super._refreshActiveDescendant(e);
    }
  }
  _hideSubmenuHandler() {
    const e = this._getActiveItem(!0), t = e.parents(".dx-menu-item-expanded").first();
    if (t.length)
      return this._hideSubmenusOnSameLevel(t), this._hideSubmenu(e.closest(".dx-submenu")), t;
    this._actions.onCloseRootSubmenu(e);
  }
  _expandSubmenuHandler(e, t) {
    const n = this._getActiveItem(!0), s = this._getItemData(n), o = this._dataAdapter.getNodeByItem(s), r = this._hasSubmenu(o), a = n.children(".dx-submenu");
    if (r && !n.hasClass("dx-state-disabled"))
      return (!a.length || a.css("visibility") === "hidden") && this._showSubmenu(n), this._nextItem(this._getItemsByLocation(t));
    this._actions.onExpandLastSubmenu(n);
  }
  _clean() {
    this._overlay && (this._overlay.$element().remove(), this._overlay = null), this._detachShowContextMenuEvents(this._getTarget()), this._shownSubmenus = [], super._clean();
  }
  _initMarkup() {
    this.$element().addClass("dx-has-context-menu"), super._initMarkup();
  }
  _render() {
    super._render(), this._renderVisibility(this.option("visible")), this._addWidgetClass();
  }
  _isTargetOutOfComponent(e) {
    return !(p(e).closest(".dx-context-menu").length !== 0);
  }
  _focusOutHandler(e) {
    const {
      relatedTarget: t
    } = e;
    t && this._isTargetOutOfComponent(t) && this.hide(), super._focusOutHandler(e);
  }
  _renderContentImpl() {
    this._detachShowContextMenuEvents(this._getTarget()), this._attachShowContextMenuEvents();
  }
  _attachKeyboardEvents() {
    !this._keyboardListenerId && this._focusTarget().length && super._attachKeyboardEvents();
  }
  _renderContextMenuOverlay() {
    if (this._overlay)
      return;
    const e = this._getOverlayOptions();
    this._overlay = this._createComponent(p("<div>").appendTo(this._$element), Tn, e);
    const t = this._overlay.$content();
    t.addClass("dx-context-menu"), this._addCustomCssClass(t), this._addPlatformDependentClass(t), this._attachContextMenuEvent();
  }
  preventShowingDefaultContextMenuAboveOverlay() {
    const e = this._itemContainer(), t = R($O, this.NAME);
    _.off(e, t, ".dx-submenu"), _.on(e, t, ".dx-submenu", (n) => {
      n.stopPropagation(), n.preventDefault(), _.off(e, t, ".dx-submenu");
    });
  }
  _itemContextMenuHandler(e) {
    super._itemContextMenuHandler(e), e.stopPropagation();
  }
  _addPlatformDependentClass(e) {
    z.current().phone && e.addClass(j3);
  }
  _detachShowContextMenuEvents(e) {
    const t = this.getShowEvent(this.option("showEvent"));
    if (!t)
      return;
    const n = R(t, this.NAME);
    this._showContextMenuEventHandler ? _.off(O.getDocument(), n, e, this._showContextMenuEventHandler) : _.off(p(e), n);
  }
  _attachShowContextMenuEvents() {
    const e = this._getTarget(), t = this.getShowEvent(this.option("showEvent"));
    if (!t)
      return;
    const n = R(t, this.NAME);
    let s = this._createAction((r) => {
      const a = this.getShowDelay(this.option("showEvent"));
      a ? setTimeout(() => this._show(r.event), a) : this._show(r.event);
    }, {
      validatingTargetName: "target"
    });
    const o = (r) => s({
      event: r,
      target: p(r.currentTarget)
    });
    s = this._createAction(s), zn(e) || e.nodeType || lt(e) ? (this._showContextMenuEventHandler = void 0, _.on(e, n, o)) : (this._showContextMenuEventHandler = o, _.on(O.getDocument(), n, e, this._showContextMenuEventHandler));
  }
  _hoverEndHandler(e) {
    super._hoverEndHandler(e), e.stopPropagation();
  }
  _renderDimensions() {
  }
  _renderContainer(e, t) {
    const n = t || this._itemContainer();
    e = p("<div>"), e.appendTo(n).addClass("dx-submenu").css("visibility", t ? "hidden" : "visible"), e.parent().hasClass("dx-overlay-content") || this._addCustomCssClass(e);
    const s = super._renderContainer(e);
    return t ? s : this.option("width") ? s.css("minWidth", this.option("width")) : this.option("height") ? s.css("minHeight", this.option("height")) : s;
  }
  _renderSubmenuItems(e, t) {
    this._renderItems(this._getChildNodes(e), t);
    const n = t.children(".dx-submenu");
    this._actions.onSubmenuCreated({
      itemElement: ee(t),
      itemData: e.internalFields.item,
      submenuElement: ee(n)
    }), this._initScrollable(n), this.setAria({
      role: "menu"
    }, n);
  }
  _getOverlayOptions() {
    const e = this.option("position");
    return {
      focusStateEnabled: this.option("focusStateEnabled"),
      animation: this.option("animation"),
      innerOverlay: !0,
      hideOnOutsideClick: (n) => this._hideOnOutsideClickHandler(n),
      propagateOutsideClick: !0,
      hideOnParentScroll: !0,
      deferRendering: !1,
      position: {
        at: e.at,
        my: e.my,
        of: this._getTarget(),
        collision: "flipfit"
      },
      shading: !1,
      showTitle: !1,
      height: "auto",
      width: "auto",
      onShown: this._overlayShownActionHandler.bind(this),
      onHiding: this._overlayHidingActionHandler.bind(this),
      onHidden: this._overlayHiddenActionHandler.bind(this),
      visualContainer: qb
    };
  }
  _overlayShownActionHandler(e) {
    this._actions.onShown(e);
  }
  _overlayHidingActionHandler(e) {
    this._actions.onHiding(e), e.cancel || (this._hideAllShownSubmenus(), this._setOptionWithoutOptionChange("visible", !1));
  }
  _overlayHiddenActionHandler(e) {
    this._actions.onHidden(e);
  }
  _shouldHideOnOutsideClick(e) {
    const {
      closeOnOutsideClick: t,
      hideOnOutsideClick: n
    } = this.option();
    return B(n) ? n(e) : B(t) ? t(e) : n || t;
  }
  _hideOnOutsideClickHandler(e) {
    if (!this._shouldHideOnOutsideClick(e))
      return !1;
    if (O.isDocument(e.target))
      return !0;
    const t = this._getActiveItemsContainer(e.target), n = this._getItemsContainers(), s = this._searchActiveItem(e.target), o = this.$element().parents(".dx-menu-item"), r = s[0] === o[0] && s.length && o.length;
    return this._isIncludeOverlay(t, n) && s.length || r ? (this._getShowSubmenuMode() === "onClick" && this._hideAllShownChildSubmenus(s), !1) : !0;
  }
  _getActiveItemsContainer(e) {
    return p(e).closest(".dx-menu-items-container");
  }
  _getItemsContainers() {
    return this._overlay.$content().find(".dx-menu-items-container");
  }
  _searchActiveItem(e) {
    return p(e).closest(".dx-menu-item").eq(0);
  }
  _isIncludeOverlay(e, t) {
    let n = !1;
    return y(t, (s, o) => {
      e.is(o) && !n && (n = !0);
    }), n;
  }
  _hideAllShownChildSubmenus(e) {
    const t = e.find(".dx-submenu"), n = x([], this._shownSubmenus);
    t.length > 0 && y(n, (s, o) => {
      const r = this._searchActiveItem(o.context).parent();
      r.parent().is(e.parent().parent()) && !r.is(e.parent()) && this._hideSubmenu(o);
    });
  }
  _initScrollable(e) {
    this._createComponent(e, Qt, {
      useKeyboard: !1,
      _onVisibilityChanged: (t) => {
        t.scrollTo(0);
      }
    });
  }
  _setSubMenuHeight(e, t, n) {
    const s = e.find(".dx-menu-items-container"), o = he(s), r = this._getMaxHeight(t, !n), a = Math.min(o, r);
    e.css("height", n ? a : "100%");
  }
  _getMaxHeight(e) {
    let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !0;
    const n = he(qb), s = zn(e), o = O.getDocument(), r = e.length && e[0] === o;
    if (!s || r)
      return n;
    const a = e[0].getBoundingClientRect().top, l = he(e);
    return (t ? Math.max(a, n - a - l) : Math.max(a + l, n - a)) - 10;
  }
  _dimensionChanged() {
    this._shownSubmenus && this._shownSubmenus.forEach((e) => {
      const t = e.closest(".dx-menu-item");
      this._setSubMenuHeight(e, t, !0), this._scrollToElement(t);
      const n = this._getSubmenuPosition(t);
      Un.setup(e, n);
    });
  }
  _getSubmenuBorderWidth() {
    return m_(pn()) ? 1 : 0;
  }
  _showSubmenu(e) {
    const t = this._dataAdapter.getNodeByItem(this._getItemData(e));
    if (this._hideSubmenusOnSameLevel(e), !this._hasSubmenu(t))
      return;
    let n = e.children(".dx-submenu");
    const s = n.length;
    super._showSubmenu(e), s || (this._renderSubmenuItems(t, e), n = e.children(".dx-submenu")), this._planPostRenderActions(n);
  }
  _setSubmenuVisible(e) {
    if (!e)
      return;
    const t = e?.closest(".dx-menu-item");
    this._setSubMenuHeight(e, t, !0), !this._isSubmenuVisible(e) && t && this._drawSubmenu(t);
  }
  _hideSubmenusOnSameLevel(e) {
    const t = e.parent(".dx-menu-item-wrapper").siblings().find(".dx-menu-item-expanded");
    t.length && (t.removeClass("dx-menu-item-expanded"), this._hideSubmenu(t.find(".dx-submenu")));
  }
  _hideSubmenuGroup(e) {
    this._isSubmenuVisible(e) && this._hideSubmenuCore(e);
  }
  _isSubmenuVisible(e) {
    return e.css("visibility") === "visible";
  }
  _drawSubmenu(e) {
    const t = this.option("animation") ? this.option("animation").show : {}, n = e.children(".dx-submenu"), s = this._getSubmenuPosition(e);
    this._overlay && this._overlay.option("visible") && (f(this._shownSubmenus) || (this._shownSubmenus = []), this._shownSubmenus.includes(n) || this._shownSubmenus.push(n), t && Le.stop(n), Un.setup(n, s), t && (pe(t.to) && (t.to.position = s), this._animate(n, t)), n.css("visibility", "visible"));
  }
  _animate(e, t) {
    Le.animate(e, t);
  }
  _getSubmenuPosition(e) {
    const t = this.option("submenuDirection").toLowerCase(), s = {
      collision: "flip",
      of: e.parent(".dx-menu-item-wrapper"),
      offset: {
        h: 0,
        v: -1
      }
    };
    switch (t) {
      case "left":
        s.at = "left top", s.my = "right top";
        break;
      case "right":
        s.at = "right top", s.my = "left top";
        break;
      default:
        this.option("rtlEnabled") ? (s.at = "left top", s.my = "right top") : (s.at = "right top", s.my = "left top");
    }
    return s;
  }
  _updateSubmenuVisibilityOnClick(e) {
    if (!e.args.length)
      return;
    const {
      itemData: t
    } = e.args[0], n = this._dataAdapter.getNodeByItem(t);
    if (!n)
      return;
    const s = p(e.args[0].itemElement);
    let o = s.find(".dx-submenu");
    if (this._hasSubmenu(n) && !o.length && (this._renderSubmenuItems(n, s), o = s.find(".dx-submenu")), s.context === o.context && o.css("visibility") === "visible")
      return;
    this._updateSelectedItemOnClick(e);
    const a = t && t.closeMenuOnClick === !1;
    if (!(!t || t.disabled || a))
      if (o.length === 0) {
        const l = p(s.parents(".dx-submenu")[0]);
        this._hideSubmenu(l), !e.canceled && this._overlay && this._overlay.option("visible") && this.option("visible", !1);
      } else
        this._shownSubmenus && this._shownSubmenus.length > 0 && this._shownSubmenus[0].is(o) && this._hideSubmenu(o), this._showSubmenu(s);
  }
  _hideSubmenu(e) {
    const t = x([], this._shownSubmenus);
    y(t, (n, s) => {
      (e.is(s) || Xs(e[0], s[0])) && (s.parent().removeClass("dx-menu-item-expanded"), this._hideSubmenuCore(s));
    });
  }
  _hideSubmenuCore(e) {
    const t = this._shownSubmenus.indexOf(e), n = this.option("animation") ? this.option("animation").hide : null;
    t >= 0 && this._shownSubmenus.splice(t, 1), this._stopAnimate(e), n && this._animate(e, n), e.css("visibility", "hidden"), e.dxScrollable("instance").scrollTo(0), this.option("focusedElement", null);
  }
  _stopAnimate(e) {
    Le.stop(e, !0);
  }
  _hideAllShownSubmenus() {
    const e = x([], this._shownSubmenus);
    this._overlay.$content().find(".dx-menu-item-expanded").removeClass("dx-menu-item-expanded"), y(e, (n, s) => {
      this._hideSubmenu(s);
    });
  }
  _visibilityChanged(e) {
    e && this._renderContentImpl();
  }
  _optionChanged(e) {
    if (jb.includes(e.name)) {
      this._initActions();
      return;
    }
    switch (e.name) {
      case "visible":
        this._renderVisibility(e.value);
        break;
      case "showEvent":
      case "position":
      case "submenuDirection":
        this._invalidate();
        break;
      case "target":
        e.previousValue && this._detachShowContextMenuEvents(e.previousValue), this._invalidate();
        break;
      case "closeOnOutsideClick":
      case "hideOnOutsideClick":
        break;
      default:
        super._optionChanged(e);
    }
  }
  _renderVisibility(e) {
    return e ? this._show() : this._hide();
  }
  _toggleVisibility() {
  }
  _show(e) {
    const t = {
      jQEvent: e
    };
    let n = w().reject().promise();
    if (this._actions.onShowing(t), t.cancel)
      return n;
    const s = this._positionContextMenu(e);
    if (s) {
      var o;
      this._overlay || (this._renderContextMenuOverlay(), this._overlay.$content().addClass(this._widgetClass()), this._renderFocusState(), this._attachHoverEvents(), this._attachClickEvent(), this._renderItems(this._dataAdapter.getRootNodes()));
      const r = p(this._overlay.content()).children(".dx-submenu");
      this._setOptionWithoutOptionChange("visible", !0), this._overlay.option({
        height: () => this._getMaxHeight(s.of),
        maxHeight: () => {
          const a = r.find(".dx-menu-items-container"), l = this._getSubmenuBorderWidth();
          return he(a) + 2 * l;
        },
        position: s
      }), r.length && this._setSubMenuHeight(r, s.of, !1), n = this._overlay.show(), e && e.stopPropagation(), this._setAriaAttributes(), (e == null || (o = e.originalEvent) === null || o === void 0 ? void 0 : o.type) === Zs.name && this.preventShowingDefaultContextMenuAboveOverlay();
    }
    return n;
  }
  _renderItems(e, t) {
    super._renderItems(e, t);
    const n = p(this._overlay.content()).children(".dx-submenu");
    n.length && this._initScrollable(n);
  }
  _setAriaAttributes() {
    this._overlayContentId = `dx-${new Xe()}`, this.setAria("owns", this._overlayContentId), this.setAria({
      id: this._overlayContentId,
      role: "menu"
    }, this._overlay.$content());
  }
  _cleanAriaAttributes() {
    this._overlay && this.setAria("id", null, this._overlay.$content()), this.setAria("owns", void 0);
  }
  _getTarget() {
    return this.option("target") || this.option("position").of || p(O.getDocument());
  }
  _getContextMenuPosition() {
    return x({}, this.option("position"), {
      of: this._getTarget()
    });
  }
  _positionContextMenu(e) {
    let t = this._getContextMenuPosition();
    const n = this._isInitialOptionValue("position"), s = this._createActionByOption("onPositioning");
    e && e.preventDefault && n && (t.of = e);
    const o = {
      position: t,
      event: e
    };
    return s(o), o.cancel ? t = null : o.event && (o.event.cancel = !0, e.preventDefault()), t;
  }
  _refresh() {
    if (!ae())
      super._refresh();
    else if (this._overlay) {
      const e = this._overlay.option("position");
      super._refresh(), this._overlay && this._overlay.option("position", e);
    } else
      super._refresh();
  }
  _hide() {
    let e;
    return this._overlay && (e = this._overlay.hide(), this._setOptionWithoutOptionChange("visible", !1)), this._cleanAriaAttributes(), this.option("focusedElement", null), e || w().reject().promise();
  }
  toggle(e) {
    const t = this.option("visible");
    return e = e === void 0 ? !t : e, this._renderVisibility(e);
  }
  show() {
    return this.toggle(!0);
  }
  hide() {
    return this.toggle(!1);
  }
  _postProcessRenderItems(e) {
    this._setSubmenuVisible(e);
  }
}
xe("dxContextMenu", tC);
const Y3 = "dx-context-menu", X3 = {
  columnHeadersView: "header",
  rowsView: "content",
  footerView: "footer",
  headerPanel: "headerPanel"
}, Z3 = ["columnHeadersView", "rowsView", "footerView", "headerPanel"];
class Q3 extends Ue.ViewController {
  init() {
    this.createAction("onContextMenuPreparing");
  }
  getContextMenuItems(e) {
    if (!e)
      return !1;
    const t = this, n = p(e.target);
    let s, o, r, a;
    return y(Z3, function() {
      const l = t.getView(this);
      if (s = l && l.element(), s && (s.is(n) || s.find(n).length)) {
        var d;
        r = n.closest(".dx-row > td, .dx-row > tr"), o = r.parent();
        const u = l.getRowIndex(o), c = r[0] && r[0].cellIndex, h = o.data("options"), g = {
          event: e,
          targetElement: ee(n),
          target: X3[this],
          rowIndex: u,
          row: l._getRows()[u],
          columnIndex: c,
          column: h == null || (d = h.cells) === null || d === void 0 || (d = d[c]) === null || d === void 0 ? void 0 : d.column
        };
        if (g.items = l.getContextMenuItems && l.getContextMenuItems(g), t.executeAction("onContextMenuPreparing", g), t._contextMenuPrepared(g), a = g.items, a)
          return !1;
      }
    }), a;
  }
  _contextMenuPrepared(e) {
  }
}
class J3 extends Ue.View {
  init() {
    super.init(), this._contextMenuController = this.getController("contextMenu");
  }
  _renderCore() {
    const e = this.element().addClass(Y3);
    this.setAria("role", "presentation", e), this._createComponent(e, tC, {
      onPositioning: (t) => {
        const {
          event: n
        } = t, s = t.component, o = this._contextMenuController.getContextMenuItems(n);
        o ? (s.option("items", o), n.stopPropagation()) : t.cancel = !0;
      },
      onItemClick(t) {
        var n, s;
        (n = t.itemData) === null || n === void 0 || (s = n.onItemClick) === null || s === void 0 || s.call(n, t);
      },
      cssClass: this.getWidgetContainerClass(),
      target: this.component.$element()
    });
  }
}
const eY = {
  defaultOptions: () => ({
    onContextMenuPreparing: null
  }),
  controllers: {
    contextMenu: Q3
  },
  views: {
    contextMenuView: J3
  }
};
J.registerModule("contextMenu", eY);
class tY extends Ue.ViewController {
  init() {
    this._resizingController = this.getController("resizing"), this._columnsController = this.getController("columns"), this._columnHeadersView = this.getView("columnHeadersView"), this._rowsView = this.getView("rowsView");
  }
  _createErrorRow(e, t) {
    let n, s;
    const o = this._renderErrorMessage(e);
    return t ? (n = p("<tr>").attr("role", "row").addClass("dx-error-row"), s = p("<div>").addClass("dx-closebutton").addClass(this.addWidgetPrefix("action")), _.on(s, Te, this.createAction((r) => {
      var a, l;
      const d = r.event;
      let u;
      const c = p(d.currentTarget).closest(".dx-error-row").index();
      d.stopPropagation(), y(t, (h, g) => {
        u = p(g).children("tbody").children("tr").eq(c), this.removeErrorRow(u);
      }), (a = this._resizingController) === null || a === void 0 || (l = a.fireContentReadyAction) === null || l === void 0 || l.call(a);
    })), p("<td>").attr({
      colSpan: this._columnsController.getVisibleColumns().length,
      role: "gridcell"
    }).prepend(s).append(o).appendTo(n), n) : o;
  }
  _renderErrorMessage(e) {
    const t = e.url ? e.message.replace(e.url, "") : e.message || e, n = p("<div>").attr("role", "alert").attr("aria-roledescription", S.format("dxDataGrid-ariaError")).addClass("dx-error-message").text(t);
    return e.url && p("<a>").attr("href", e.url).text(e.url).appendTo(n), n;
  }
  renderErrorRow(e, t, n) {
    var s, o;
    const r = this;
    let a, l;
    if (n)
      return n.find(".dx-error-message").remove(), a = r._createErrorRow(e), n.prepend(a), a;
    const d = t >= 0 || !r._columnHeadersView.isVisible() ? r._rowsView : r._columnHeadersView, u = d.getTableElements();
    return y(u, (c, h) => {
      if (a = r._createErrorRow(e, u), l = l || a, t >= 0) {
        const g = d._getRowElements(p(h)).eq(t);
        r.removeErrorRow(g.next()), a.insertAfter(g);
      } else {
        const g = p(h).children("tbody"), m = g.children("tr");
        r._columnHeadersView.isVisible() ? (r.removeErrorRow(m.last()), p(h).append(a)) : (r.removeErrorRow(m.first()), g.first().prepend(a));
      }
    }), (s = this._resizingController) === null || s === void 0 || (o = s.fireContentReadyAction) === null || o === void 0 || o.call(s), l;
  }
  removeErrorRow(e) {
    if (!e) {
      const t = this._columnHeadersView && this._columnHeadersView.element();
      if (e = t && t.find(".dx-error-row"), !e || !e.length) {
        const n = this._rowsView.element();
        e = n && n.find(".dx-error-row");
      }
    }
    e && e.hasClass("dx-error-row") && e.remove();
  }
  optionChanged(e) {
    e.name === "errorRowEnabled" ? e.handled = !0 : super.optionChanged(e);
  }
}
const nY = (i) => class extends i {
  init() {
    super.init(), this.dataErrorOccurred.add((e, t) => {
      this.option("errorRowEnabled") && this._errorHandlingController.renderErrorRow(e, void 0, t);
    }), this.changed.add((e) => {
      if (!(e && e.changeType === "loadError") && this._editingController && !this._editingController.hasChanges()) {
        var t, n;
        (t = this._errorHandlingController) === null || t === void 0 || (n = t.removeErrorRow) === null || n === void 0 || n.call(t);
      }
    });
  }
}, iY = {
  defaultOptions: () => ({
    errorRowEnabled: !0
  }),
  controllers: {
    errorHandling: tY
  },
  extenders: {
    controllers: {
      data: nY
    }
  }
};
J.registerModule("errorHandling", iY);
const sY = {
  container: "dx-gridbase-a11y-status-container"
}, oY = (i) => {
  let {
    statusText: e
  } = i;
  return p("<div>").text(e ?? "").addClass(sY.container).attr("role", "status");
}, nC = ["columnsSeparatorView", "blockSeparatorView", "trackerView", "headerPanel", "columnHeadersView", "rowsView", "footerView", "columnChooserView", "filterPanelView", "pagerView", "draggingHeaderView", "contextMenuView", "errorView", "headerFilterView", "filterBuilderView"], rY = {
  a11yStatusContainer: "e2e-a11y-general-status-container"
}, Fa = function(i) {
  return te(i) && i.endsWith("%");
}, aY = function(i) {
  return te(i) && i.endsWith("px");
}, jO = function(i, e) {
  const t = i._rowsView.contentWidth(), n = i._getTotalWidth(e, t);
  return t - n;
}, lY = function(i, e, t, n) {
  return jO(i, n.map((s, o) => o === e ? t : s));
}, dY = function(i, e) {
  mU(i, !0), F.setSelectionRange(i, e);
};
class uY extends Ue.ViewController {
  init() {
    this._prevContentMinHeight = null, this._dataController = this.getController("data"), this._columnsController = this.getController("columns"), this._columnHeadersView = this.getView("columnHeadersView"), this._adaptiveColumnsController = this.getController("adaptiveColumns"), this._editorFactoryController = this.getController("editorFactory"), this._footerView = this.getView("footerView"), this._rowsView = this.getView("rowsView"), this._gridView = this.getView("gridView");
  }
  _initPostRenderHandlers() {
    this._refreshSizesHandler || (this._refreshSizesHandler = (e) => {
      let t = new w().resolve(null);
      const n = e?.changeType, s = e?.isDelayed, o = n && n !== "updateSelection" && n !== "updateFocusedRow" && n !== "pageIndex" && !s;
      this._dataController.changed.remove(this._refreshSizesHandler), this._checkSize() && (t = this._refreshSizes(e)), o && W(t).done(() => {
        this._setAriaLabel(), this.fireContentReadyAction();
      });
    }, this._dataController.changed.add(() => {
      this._dataController.changed.add(this._refreshSizesHandler);
    }));
  }
  _refreshSizes(e) {
    let t = new w().resolve(null);
    const n = e?.changeType, s = e?.isDelayed, o = this._dataController.items();
    if (!e || n === "refresh" || n === "prepend" || n === "append")
      s || (t = this.resize());
    else if (n === "update") {
      var r;
      if (((r = e.changeTypes) === null || r === void 0 ? void 0 : r.length) === 0)
        return t;
      (o.length > 1 || e.changeTypes[0] !== "insert") && !(o.length === 0 && e.changeTypes[0] === "remove") && !e.needUpdateDimensions ? (t = new w(), this._waitAsyncTemplates().done(() => {
        qt(() => ft(() => qt(() => {
          this._setScrollerSpacing(), this._rowsView.resize(), t.resolve();
        })));
      }).fail(t.reject)) : t = this.resize();
    }
    return t;
  }
  fireContentReadyAction() {
    this.component._fireContentReadyAction();
  }
  _getWidgetAriaLabel() {
    return "dxDataGrid-ariaDataGrid";
  }
  _setAriaLabel() {
    var e;
    const t = ((e = this._columnsController) === null || e === void 0 || (e = e._columns) === null || e === void 0 ? void 0 : e.filter((d) => {
      let {
        visible: u
      } = d;
      return !!u;
    }).length) ?? 0, n = Math.max(0, this._dataController.totalItemsCount()), s = this._getWidgetAriaLabel(), o = S.format(s, n, t), r = this.component.$element().children(".dx-gridbase-container"), a = S.format(this._expandableWidgetAriaId), l = [o];
    a && l.push(a), this.component.setAria("label", l.join(". "), r), this._gridView.setWidgetA11yStatusText(o);
  }
  _getBestFitWidths() {
    var e;
    const t = this._rowsView, n = this._columnHeadersView;
    let s = t.getColumnWidths();
    if (!((e = s) !== null && e !== void 0 && e.length)) {
      var o;
      const r = n.getTableElement();
      n.setTableElement((o = t.getTableElement()) === null || o === void 0 ? void 0 : o.children(".dx-header")), s = n.getColumnWidths(), n.setTableElement(r);
    }
    return s;
  }
  _setVisibleWidths(e, t) {
    const n = this._columnsController;
    n.beginUpdate(), y(e, (s, o) => {
      const r = n.getColumnId(o);
      n.columnOption(r, "visibleWidth", t[s]);
    }), n.endUpdate();
  }
  _toggleBestFitModeForView(e, t, n) {
    if (!e || !e.isVisible())
      return;
    const s = this._rowsView.getTableElements(), o = e.getTableElements();
    y(s, (r, a) => {
      let l;
      const d = p(a), u = o.eq(r);
      u && u.length && (n ? l = u.children("tbody").appendTo(d) : l = d.children(`.${t}`).appendTo(u), l.toggleClass(t, n), l.toggleClass(this.addWidgetPrefix("best-fit"), n));
    });
  }
  _toggleBestFitMode(e) {
    const t = this._rowsView.getTableElement(), n = this._rowsView.getTableElements().eq(1);
    t && (t.css("tableLayout", e ? "auto" : "fixed"), t.children("colgroup").css("display", e ? "none" : ""), y(n.find("tr.dx-group-row"), (s, o) => {
      p(o).css("display", e ? "none" : "");
    }), n.toggleClass(this.addWidgetPrefix("table-fixed"), !e), this._toggleBestFitModeForView(this._columnHeadersView, "dx-header", e), this._toggleBestFitModeForView(this._footerView, "dx-footer", e), this._needStretch() && (t.get(0).style.width = e ? "auto" : ""));
  }
  _toggleContentMinHeight(e) {
    const t = this._rowsView.getScrollable(), n = this._rowsView._findContentElement();
    t?.option("useNative") === !1 && (e === !0 && (this._prevContentMinHeight = n.get(0).style.minHeight), f(this._prevContentMinHeight) && n.css({
      minHeight: e ? F.getContentHeightLimit(ze) : this._prevContentMinHeight
    }));
  }
  _synchronizeColumns() {
    const e = this._columnsController, t = e.getVisibleColumns(), n = this.option("columnAutoWidth"), s = this.option("wordWrapEnabled"), o = t.some((m) => !f(m.width));
    let r = this._needBestFit(), a = !1, l, d = !1, u = [], c, h;
    !r && y(t, (m, C) => {
      if (C.width === "auto")
        return r = !0, !1;
    }), y(t, (m, C) => {
      if (C.minWidth)
        return a = !0, !1;
    }), this._setVisibleWidths(t, []);
    const g = this.component.$element();
    r && (c = O.getActiveElement(g.get(0)), h = F.getSelectionRange(c), this._toggleBestFitMode(!0), l = !0), this._toggleContentMinHeight(s), g && g.get(0) && this._maxWidth && (delete this._maxWidth, g[0].style.maxWidth = ""), qt(() => {
      r ? (u = this._getBestFitWidths(), y(t, (m, C) => {
        const v = e.getColumnId(C);
        e.columnOption(v, "bestFitWidth", u[m], !0);
      })) : a && (u = this._getBestFitWidths()), y(t, function(m) {
        const {
          width: C
        } = this;
        C !== "auto" && (f(C) ? u[m] = $e(C) || aY(C) ? parseFloat(C) : C : n || (u[m] = void 0));
      }), l && (this._toggleBestFitMode(!1), l = !1, c && c !== O.getActiveElement() && (Ge(c).bottom < 0 || dY(c, h))), d = this._correctColumnWidths(u, t), n && (function() {
        let m;
        y(t, (C, v) => {
          v.type === "groupExpand" && (m = u[C]);
        }), y(t, (C, v) => {
          v.type === "groupExpand" && m && (u[C] = m);
        });
      }(), this._needStretch() && this._processStretch(u, t)), ft(() => {
        (r || d || o) && this._setVisibleWidths(t, u), s && this._toggleContentMinHeight(!1);
      });
    });
  }
  _needBestFit() {
    return this.option("columnAutoWidth");
  }
  _needStretch() {
    return this._columnsController.getVisibleColumns().some((e) => e.width === "auto" && !e.command);
  }
  _getAverageColumnsWidth(e) {
    const t = jO(this, e), n = e.filter((s) => s === void 0).length;
    return t / n;
  }
  _correctColumnWidths(e, t) {
    const n = this;
    let s, o = !1, r = !1, a = !1;
    const l = n.component.$element(), d = n._hasWidth;
    for (s = 0; s < t.length; s++) {
      const u = s, c = t[u], h = e[u] === "adaptiveHidden";
      let g = e[u];
      const {
        minWidth: m
      } = c;
      m && (g === void 0 ? g = n._getAverageColumnsWidth(e) : Fa(g) && lY(n, u, m, e) < 0 && (g = -1));
      const C = n._getRealColumnWidth(u, e.map((v, E) => u === E ? g : v));
      m && !h && C < m && (e[u] = m, a = !0, s = -1), f(c.width) || (r = !0), Fa(c.width) && (o = !0);
    }
    if (!r && e.length) {
      const u = n._rowsView.element(), c = n._rowsView.contentWidth(), h = n._rowsView.getScrollbarWidth(), g = n._getTotalWidth(e, c);
      if (g < c) {
        const m = F.getLastResizableColumnIndex(t, e);
        if (m >= 0 && (e[m] = "auto", a = !0, d === !1 && !o)) {
          const C = F.getComponentBorderWidth(this, u);
          n._maxWidth = g + h + C, l.css("maxWidth", n._maxWidth);
        }
      }
    }
    return a;
  }
  _processStretch(e, t) {
    const n = this._rowsView.contentWidth(), s = this._getTotalWidth(e, n), o = {
      length: 0
    };
    if (!e.length)
      return;
    y(t, function(d) {
      (this.width || e[d] === "adaptiveHidden") && (o[d] = !0, o.length++);
    });
    const r = n - s, a = Math.floor(r / (e.length - o.length));
    let l = r - a * (e.length - o.length);
    if (r >= 0)
      for (let d = 0; d < e.length; d++)
        o[d] || (e[d] += a, l > 0 && (l < 1 ? (e[d] += l, l = 0) : (e[d]++, l--)));
  }
  _getRealColumnWidth(e, t, n) {
    let s = 1;
    const o = t[e];
    if (!Fa(o))
      return parseFloat(o);
    const r = t.reduce((u, c, h) => Fa(c) ? u + parseFloat(c) : u, 0), a = t.reduce((u, c) => !c || c === "adaptiveHidden" || Fa(c) ? u : u + parseFloat(c), 0);
    n = n || this._rowsView.contentWidth();
    const l = n - a, d = r * n / 100;
    return a > 0 && d + a >= n && (s = d > l ? l / d : 1), parseFloat(o) * n * s / 100;
  }
  _getTotalWidth(e, t) {
    let n = 0;
    for (let s = 0; s < e.length; s++) {
      const o = e[s];
      o && o !== "adaptiveHidden" && (n += this._getRealColumnWidth(s, e, t));
    }
    return Math.ceil(n);
  }
  _getGroupElement() {
    return this.component.$element().children().get(0);
  }
  updateSize(e) {
    const t = this, n = p(e), s = t.addWidgetPrefix("important-margin");
    if (t._hasHeight === void 0 && n && n.is(":visible") && ne(n)) {
      const o = n.children(`.${t.getWidgetContainerClass()}`);
      o.length && o.detach(), t._hasHeight = !!le(n);
      const r = ne(n);
      n.addClass(s), t._hasWidth = ne(n) === r, n.removeClass(s), o.length && o.appendTo(n);
    }
  }
  publicMethods() {
    return ["resize", "updateDimensions"];
  }
  _waitAsyncTemplates() {
    var e, t, n;
    return W((e = this._columnHeadersView) === null || e === void 0 ? void 0 : e.waitAsyncTemplates(!0), (t = this._rowsView) === null || t === void 0 ? void 0 : t.waitAsyncTemplates(!0), (n = this._footerView) === null || n === void 0 ? void 0 : n.waitAsyncTemplates(!0));
  }
  resize() {
    if (this.component._requireResize)
      return new w().resolve();
    const e = new w();
    return this._waitAsyncTemplates().done(() => {
      W(this.updateDimensions()).done(e.resolve).fail(e.reject);
    }).fail(e.reject), e.promise();
  }
  updateDimensions(e) {
    const t = this;
    if (t._initPostRenderHandlers(), !t._checkSize(e))
      return;
    const n = t._resizeDeferred, s = t._resizeDeferred = new w();
    return W(n).always(() => {
      ft(() => {
        t._dataController.isLoaded() && t._synchronizeColumns(), t._resetGroupElementHeight(), qt(() => {
          ft(() => {
            qt(() => {
              t._updateDimensionsCore();
            });
          });
        });
      }).done(s.resolve).fail(s.reject);
    }), s.promise();
  }
  _resetGroupElementHeight() {
    const e = this._getGroupElement(), t = this._rowsView.getScrollable();
    e && e.style.height && (!t || !t.scrollTop()) && (e.style.height = "");
  }
  _checkSize(e) {
    const t = this.component.$element(), n = t.is(":visible"), s = this._lastWidth !== ne(t) || this._lastHeight !== le(t) || this._devicePixelRatio !== fe().devicePixelRatio;
    return n && (!e || s);
  }
  _setScrollerSpacingCore() {
    const e = this, t = e._rowsView.getScrollbarWidth(), n = e._rowsView.getScrollbarWidth(!0);
    ft(() => {
      e._columnHeadersView && e._columnHeadersView.setScrollerSpacing(t), e._footerView && e._footerView.setScrollerSpacing(t), e._rowsView.setScrollerSpacing(t, n);
    });
  }
  _setScrollerSpacing() {
    const e = this._rowsView.getScrollable(), t = this.option("scrolling.useNative") === !0;
    !e || t ? ft(() => {
      qt(() => {
        this._setScrollerSpacingCore();
      });
    }) : this._setScrollerSpacingCore();
  }
  _setAriaOwns() {
    var e, t, n;
    const s = (e = this._columnHeadersView) === null || e === void 0 ? void 0 : e.getTableElement(), o = (t = this._footerView) === null || t === void 0 ? void 0 : t.getTableElement();
    (n = this._rowsView) === null || n === void 0 || n.setAriaOwns(s?.attr("id"), o?.attr("id"));
  }
  _updateDimensionsCore() {
    const e = this, t = e._dataController, n = e._rowsView, s = e.component.$element(), o = this._getGroupElement(), r = le(s), a = e.option("height") ?? s.get(0).style.height, l = !!a && a !== "auto", d = parseInt(s.css("maxHeight")), u = d && r >= d, c = o && o.scrollHeight === o.offsetHeight;
    e.updateSize(s), ft(() => {
      const h = e._hasHeight || !!d || l;
      if (n.hasHeight(h), this._setAriaOwns(), u && !c && p(o).css("height", d), !t.isLoaded()) {
        n.setLoading(t.isLoading());
        return;
      }
      qt(() => {
        e._updateLastSizes(s), e._setScrollerSpacing(), y(nC, (g, m) => {
          const C = e.getView(m);
          C && C.resize();
        }), this._editorFactoryController && this._editorFactoryController.resize();
      });
    });
  }
  _updateLastSizes(e) {
    this._lastWidth = ne(e), this._lastHeight = le(e), this._devicePixelRatio = fe().devicePixelRatio;
  }
  optionChanged(e) {
    switch (e.name) {
      case "width":
      case "height":
        this.component._renderDimensions(), this.resize();
      case "renderAsync":
        e.handled = !0;
        return;
      default:
        super.optionChanged(e);
    }
  }
}
class cY extends Ue.ViewController {
  _scrollChangedHandler(e, t, n) {
    for (let s = 0; s < e.length; s++)
      e[s] && e[s].name !== n && e[s].scrollTo({
        left: t.left,
        top: t.top
      });
  }
  init() {
    const e = [this.getView("columnHeadersView"), this.getView("footerView"), this.getView("rowsView")];
    for (let t = 0; t < e.length; t++) {
      const n = e[t];
      n && n.scrollChanged.add(this._scrollChangedHandler.bind(this, e));
    }
  }
}
class hY extends Ue.View {
  init() {
    this._resizingController = this.getController("resizing"), this._dataController = this.getController("data");
  }
  _endUpdateCore() {
    this.component._requireResize && (this.component._requireResize = !1, this._resizingController.resize());
  }
  getView(e) {
    return this.component._views[e];
  }
  element() {
    return this._groupElement;
  }
  optionChanged(e) {
    const t = this;
    f(t._groupElement) && e.name === "showBorders" ? (t._groupElement.toggleClass(t.addWidgetPrefix("borders"), !!e.value), e.handled = !0) : super.optionChanged(e);
  }
  _renderViews(e) {
    const t = this;
    y(nC, (n, s) => {
      const o = t.getView(s);
      o && o.render(e);
    });
  }
  _getTableRoleName() {
    return "group";
  }
  render(e) {
    const t = !this._groupElement, n = this._groupElement || p("<div>").addClass(this.getWidgetContainerClass());
    n.addClass("dx-gridbase-container"), n.toggleClass(this.addWidgetPrefix("borders"), !!this.option("showBorders")), this.setAria("role", "presentation", e), this.component.setAria("role", this._getTableRoleName(), n), this._rootElement = e || this._rootElement, t && (this._groupElement = n, ae() && this._resizingController.updateSize(e), n.appendTo(e)), this._a11yGeneralStatusElement || (this._a11yGeneralStatusElement = oY({}), this._a11yGeneralStatusElement.attr(rY.a11yStatusContainer, "true"), n.append(this._a11yGeneralStatusElement)), this._renderViews(n);
  }
  update() {
    const e = this, t = e._rootElement, n = e._groupElement;
    t && n && (this._resizingController.resize(), e._dataController.isLoaded() && e._resizingController.fireContentReadyAction());
  }
  setWidgetA11yStatusText(e) {
    var t;
    (t = this._a11yGeneralStatusElement) === null || t === void 0 || t.text(e);
  }
}
const pY = {
  defaultOptions: () => ({
    showBorders: !1,
    renderAsync: !1
  }),
  controllers: {
    resizing: uY,
    synchronizeScrolling: cY
  },
  views: {
    gridView: hY
  },
  VIEW_NAMES: nC
};
J.registerModule("gridView", pY);
const qO = "dx-toolbar", gY = "dxToolbarItemDataKey";
class YO extends Z_ {
  _getSynchronizableOptionsForCreateComponent() {
    return super._getSynchronizableOptionsForCreateComponent().filter((e) => e !== "disabled");
  }
  _initTemplates() {
    super._initTemplates();
    const e = new rr((t, n, s) => {
      if (pe(n)) {
        const {
          text: o,
          html: r,
          widget: a
        } = n;
        o && t.text(o).wrapInner("<div>"), r && t.html(r), a === "dxDropDownButton" && (n.options = n.options ?? {}, f(n.options.stylingMode) || (n.options.stylingMode = this.option("useFlatButtons") ? "text" : "contained")), a === "dxButton" && (this.option("useFlatButtons") && (n.options = n.options ?? {}, n.options.stylingMode = n.options.stylingMode ?? "text"), this.option("useDefaultButtons") && (n.options = n.options ?? {}, n.options.type = n.options.type ?? "default"));
      } else
        t.text(String(n));
      this._getTemplate("dx-polymorph-widget").render({
        container: t,
        model: s,
        parent: this
      });
    }, ["text", "html", "widget", "options"], this.option("integrationOptions.watchMethod"));
    this._templateManager.addDefaultTemplates({
      item: e,
      menuItem: e
    });
  }
  _getDefaultOptions() {
    return I({}, super._getDefaultOptions(), {
      renderAs: "topToolbar",
      grouped: !1,
      useFlatButtons: !1,
      useDefaultButtons: !1
    });
  }
  _defaultOptionsRules() {
    return super._defaultOptionsRules().concat([{
      device: () => Gn(),
      options: {
        useFlatButtons: !0
      }
    }]);
  }
  _itemContainer() {
    return this._$toolbarItemsContainer.find([".dx-toolbar-before", ".dx-toolbar-center", ".dx-toolbar-after"].join(","));
  }
  _itemClass() {
    return "dx-toolbar-item";
  }
  _itemDataKey() {
    return gY;
  }
  _dimensionChanged(e) {
    this._disposed || (this._arrangeItems(), this._applyCompactMode());
  }
  _initMarkup() {
    this._renderToolbar(), this._renderSections(), super._initMarkup();
  }
  _render() {
    super._render(), this._updateDimensionsInMaterial();
  }
  _postProcessRenderItems() {
    this._arrangeItems();
  }
  _renderToolbar() {
    this.$element().addClass(qO), this._$toolbarItemsContainer = p("<div>").addClass("dx-toolbar-items-container").appendTo(this.$element()), this.setAria("role", "toolbar");
  }
  _renderSections() {
    const e = this._$toolbarItemsContainer;
    y(["before", "center", "after"], (t, n) => {
      const s = `dx-toolbar-${n}`;
      e.find(`.${s}`).length || (this[`_$${n}Section`] = p("<div>").addClass(s).attr("role", "presentation").appendTo(e));
    });
  }
  _arrangeItems(e) {
    var t, n;
    const s = e ?? ne(this.$element());
    this._$centerSection.css({
      margin: "0 auto",
      float: "none"
    });
    const o = Ge((t = this._$beforeSection) === null || t === void 0 ? void 0 : t.get(0)), r = Ge((n = this._$afterSection) === null || n === void 0 ? void 0 : n.get(0));
    this._alignCenterSection(o, r, s);
    const a = this._$toolbarItemsContainer.find(".dx-toolbar-label").eq(0), l = a.parent();
    if (!a.length)
      return;
    const d = o.width ? o.width : a.position().left, u = l.hasClass("dx-toolbar-before") ? 0 : d, c = l.hasClass("dx-toolbar-after") ? 0 : r.width;
    let h = 0;
    l.children().not(".dx-toolbar-label").each((C, v) => {
      h += Ee(v);
    });
    const g = s - h, m = Math.max(g - u - c, 0);
    if (l.hasClass("dx-toolbar-before"))
      this._alignSection(this._$beforeSection, m);
    else {
      const C = Ee(a) - ne(a);
      a.css("maxWidth", m - C);
    }
  }
  _alignCenterSection(e, t, n) {
    var s;
    this._alignSection(this._$centerSection, n - e.width - t.width);
    const o = this.option("rtlEnabled"), r = o ? t : e, a = o ? e : t, l = Ge((s = this._$centerSection) === null || s === void 0 ? void 0 : s.get(0));
    (r.right > l.left || l.right > a.left) && this._$centerSection.css({
      marginLeft: r.width,
      marginRight: a.width,
      float: r.width > a.width ? "none" : "right"
    });
  }
  _alignSection(e, t) {
    let s = e.find(".dx-toolbar-label").toArray();
    t -= this._getCurrentLabelsPaddings(s);
    const o = this._getCurrentLabelsWidth(s), r = Math.abs(o - t);
    t < o ? (s = s.reverse(), this._alignSectionLabels(s, r, !1)) : this._alignSectionLabels(s, r, !0);
  }
  _alignSectionLabels(e, t, n) {
    const s = function(o) {
      return Ge(o).width;
    };
    for (let o = 0; o < e.length; o++) {
      const r = p(e[o]), a = Math.ceil(s(e[o]));
      let l;
      n && r.css("maxWidth", "inherit");
      const d = Math.ceil(n ? s(e[o]) : a);
      if (d < t)
        l = n ? d : 0, t -= d;
      else {
        l = n ? a + t : a - t, r.css("maxWidth", l);
        break;
      }
      r.css("maxWidth", l);
    }
  }
  _applyCompactMode() {
    const e = p(this.element());
    e.removeClass("dx-toolbar-compact"), this.option("compactMode") && this._getSummaryItemsSize("width", this._itemElements(), !0) > ne(e) && e.addClass("dx-toolbar-compact");
  }
  _getCurrentLabelsWidth(e) {
    let t = 0;
    return e.forEach((n) => {
      t += Ee(n);
    }), t;
  }
  _getCurrentLabelsPaddings(e) {
    let t = 0;
    return e.forEach((n) => {
      t += Ee(n) - ne(n);
    }), t;
  }
  _renderItem(e, t, n, s) {
    const o = t.location ?? "center", r = n ?? this[`_$${o}Section`], a = !!(t.text ?? t.html), l = super._renderItem(e, t, r, s);
    return l.toggleClass("dx-toolbar-button", !a).toggleClass("dx-toolbar-label", a).addClass(t.cssClass), l;
  }
  _renderGroupedItems() {
    y(this.option("items"), (e, t) => {
      const n = t.items, s = p("<div>").addClass("dx-toolbar-group"), o = t.location ?? "center";
      !n || !n.length || (y(n, (r, a) => {
        this._renderItem(r, a, s, null);
      }), this._$toolbarItemsContainer.find(`.dx-toolbar-${o}`).append(s));
    });
  }
  _renderItems(e) {
    this.option("grouped") && e.length && e[0].items ? this._renderGroupedItems() : super._renderItems(e);
  }
  _getToolbarItems() {
    return this.option("items") ?? [];
  }
  _renderContentImpl() {
    const e = this._getToolbarItems();
    this.$element().toggleClass("dx-toolbar-mini", e.length === 0), this._renderedItemsCount ? this._renderItems(e.slice(this._renderedItemsCount)) : this._renderItems(e), this._applyCompactMode();
  }
  _renderEmptyMessage() {
  }
  _clean() {
    this._$toolbarItemsContainer.children().empty(), this.$element().empty(), delete this._$beforeSection, delete this._$centerSection, delete this._$afterSection;
  }
  _visibilityChanged(e) {
    e && this._arrangeItems();
  }
  _isVisible() {
    return ne(this.$element()) > 0 && le(this.$element()) > 0;
  }
  _getIndexByItem(e) {
    return this._getToolbarItems().indexOf(e);
  }
  _itemOptionChanged(e, t, n, s) {
    super._itemOptionChanged(e, t, n, s), this._arrangeItems();
  }
  _optionChanged(e) {
    const {
      name: t
    } = e;
    switch (t) {
      case "width":
        super._optionChanged(e), this._dimensionChanged();
        break;
      case "renderAs":
      case "useFlatButtons":
      case "useDefaultButtons":
        this._invalidate();
        break;
      case "compactMode":
        this._applyCompactMode();
        break;
      case "grouped":
        break;
      default:
        super._optionChanged(e);
    }
  }
  _dispose() {
    super._dispose(), clearTimeout(this._waitParentAnimationTimeout);
  }
  _updateDimensionsInMaterial() {
    if (Zt()) {
      const e = () => new Promise((n) => {
        const s = () => {
          let r = !0;
          return this.$element().parents().each((a, l) => {
            if (Le.isAnimating(p(l)))
              return r = !1, !1;
          }), r && n(), r;
        }, o = () => {
          clearTimeout(this._waitParentAnimationTimeout), this._waitParentAnimationTimeout = setTimeout(() => s() || o(), 15);
        };
        o();
      }), t = () => {
        const n = this.$element().find(".dx-toolbar-label"), s = [];
        return n.each((o, r) => {
          const a = p(r).text(), l = p(r).css("fontWeight");
          s.push(Bz(a, l));
        }), Promise.all(s);
      };
      Promise.all([e(), t()]).then(() => {
        this._dimensionChanged();
      });
    }
  }
}
xe("dxToolbarBase", YO);
const mY = ["dxAutocomplete", "dxButton", "dxCheckBox", "dxDateBox", "dxMenu", "dxSelectBox", "dxTabs", "dxTextBox", "dxButtonGroup", "dxDropDownButton"], fY = function(i) {
  const e = i.data && i.data(), t = e && e.dxComponents, n = t && t[0];
  return n && e[n];
};
function yc(i, e) {
  var t;
  if (!i)
    return;
  const n = i._findItemElementByItem(e);
  if (!n.length)
    return;
  const s = i._getItemData(n), o = !!((t = s.options) !== null && t !== void 0 && t.disabled || s.disabled || i.option("disabled")), {
    widget: r
  } = s;
  if (r && mY.includes(r)) {
    const d = n.find(r.toLowerCase().replace("dx", ".dx-"));
    if (d.length) {
      var a, l;
      const u = fY(d);
      if (!u)
        return;
      let c = (a = u._focusTarget) === null || a === void 0 ? void 0 : a.call(u);
      r === "dxDropDownButton" ? c = c && c.find(".dx-buttongroup") : c = c ?? p(u.element());
      const h = (l = s.options) === null || l === void 0 ? void 0 : l.tabIndex;
      o ? c.attr("tabIndex", -1) : c.attr("tabIndex", h ?? 0);
    }
  }
}
class _Y {
  constructor(e) {
    this._toolbar = e;
  }
  _initMarkup() {
  }
  _updateMenuVisibility() {
  }
  _renderMenuItems() {
  }
  _renderItem() {
  }
  _getMenuItems() {
  }
  _getToolbarItems() {
    return this._toolbar.option("items") ?? [];
  }
  _getItemsWidth() {
    return this._toolbar._getSummaryItemsSize("width", this._toolbar._itemElements(), !0);
  }
  _arrangeItems() {
    const e = this._toolbar._$toolbarItemsContainer.find(".dx-toolbar-label").eq(0);
    if (!e.length)
      return;
    const t = ne(this._toolbar.$element()), n = Ee(e) - ne(e);
    e.css("maxWidth", t - n);
  }
  _hideOverflowItems() {
  }
  _dimensionChanged() {
  }
  _itemOptionChanged() {
  }
  _optionChanged() {
  }
}
const fh = "dxResizable", CY = R(Rl, fh), vY = R(oa, fh), xY = R(Fl, fh), yY = {
  left: "borderLeftWidth",
  top: "borderTopWidth",
  right: "borderRightWidth",
  bottom: "borderBottomWidth"
};
class XO extends ui {
  _getDefaultOptions() {
    return I({}, super._getDefaultOptions(), {
      handles: "all",
      step: "1",
      stepPrecision: "simple",
      minWidth: 30,
      maxWidth: 1 / 0,
      minHeight: 30,
      maxHeight: 1 / 0,
      onResizeStart: null,
      onResize: null,
      onResizeEnd: null,
      roundStepValue: !0,
      keepAspectRatio: !0
    });
  }
  _init() {
    super._init(), this.$element().addClass("dx-resizable");
  }
  _initMarkup() {
    super._initMarkup(), this._renderHandles();
  }
  _render() {
    super._render(), this._renderActions();
  }
  _renderActions() {
    this._resizeStartAction = this._createActionByOption("onResizeStart"), this._resizeEndAction = this._createActionByOption("onResizeEnd"), this._resizeAction = this._createActionByOption("onResize");
  }
  _renderHandles() {
    this._handles = [];
    const {
      handles: e
    } = this.option();
    if (e === "none" || !e)
      return;
    const t = e === "all" ? ["top", "bottom", "left", "right"] : e.split(" "), n = {};
    y(t, (s, o) => {
      n[o] = !0, this._renderHandle(o);
    }), n.bottom && n.right && this._renderHandle("corner-bottom-right"), n.bottom && n.left && this._renderHandle("corner-bottom-left"), n.top && n.right && this._renderHandle("corner-top-right"), n.top && n.left && this._renderHandle("corner-top-left"), this._attachEventHandlers();
  }
  _renderHandle(e) {
    const t = p("<div>").addClass("dx-resizable-handle").addClass(`dx-resizable-handle-${e}`).appendTo(this.$element());
    this._handles.push(t);
  }
  _attachEventHandlers() {
    if (this.option("disabled"))
      return;
    const e = {};
    e[CY] = this._dragStartHandler.bind(this), e[vY] = this._dragHandler.bind(this), e[xY] = this._dragEndHandler.bind(this), this._handles.forEach((t) => {
      _.on(t, e, {
        direction: "both",
        immediate: !0
      });
    });
  }
  _detachEventHandlers() {
    this._handles.forEach((e) => {
      _.off(e);
    });
  }
  _toggleEventHandlers(e) {
    e ? this._attachEventHandlers() : this._detachEventHandlers();
  }
  _getElementSize() {
    const e = this.$element();
    return e.css("boxSizing") === "border-box" ? {
      width: Ee(e),
      height: he(e)
    } : {
      width: ne(e),
      height: le(e)
    };
  }
  _dragStartHandler(e) {
    var t;
    const n = this.$element();
    if (n.is(".dx-state-disabled, .dx-state-disabled *")) {
      e.cancel = !0;
      return;
    }
    this._toggleResizingClass(!0), this._movingSides = this._getMovingSides(e), this._elementLocation = Nn(n), this._elementSize = this._getElementSize(), this._renderDragOffsets(e), (t = this._resizeStartAction) === null || t === void 0 || t.call(this, {
      event: e,
      width: this._elementSize.width,
      height: this._elementSize.height,
      handles: this._movingSides
    }), e.targetElements = null;
  }
  _toggleResizingClass(e) {
    this.$element().toggleClass("dx-resizable-resizing", e);
  }
  _renderDragOffsets(e) {
    const t = this._getArea();
    if (!t)
      return;
    const n = p(e.target).closest(".dx-resizable-handle"), s = Ee(n), o = he(n), r = n.offset(), a = t.offset, l = this._getAreaScrollOffset();
    e.maxLeftOffset = this._leftMaxOffset = r.left - a.left - l.scrollX, e.maxRightOffset = this._rightMaxOffset = a.left + t.width - r.left - s + l.scrollX, e.maxTopOffset = this._topMaxOffset = r.top - a.top - l.scrollY, e.maxBottomOffset = this._bottomMaxOffset = a.top + t.height - r.top - o + l.scrollY;
  }
  _getBorderWidth(e, t) {
    if (lt(e.get(0)))
      return 0;
    const n = e.css(yY[t]);
    return parseInt(n) || 0;
  }
  _proportionate(e, t) {
    const n = this._elementSize, s = e === "x" ? n.width / n.height : n.height / n.width;
    return t * s;
  }
  _getProportionalDelta(e) {
    let {
      x: t,
      y: n
    } = e;
    const s = this._proportionate("y", t);
    if (s >= n)
      return {
        x: t,
        y: s
      };
    const o = this._proportionate("x", n);
    return o >= t ? {
      x: o,
      y: n
    } : {
      x: 0,
      y: 0
    };
  }
  _getDirectionName(e) {
    const t = this._movingSides;
    return e === "x" ? t.left ? "left" : "right" : t.top ? "top" : "bottom";
  }
  _fitIntoArea(e, t) {
    const n = this._getDirectionName(e);
    return Math.min(t, this[`_${n}MaxOffset`] ?? 1 / 0);
  }
  _fitDeltaProportionally(e) {
    let t = I({}, e);
    const n = this._elementSize, {
      minWidth: s,
      minHeight: o,
      maxWidth: r,
      maxHeight: a
    } = this.option(), l = () => n.width + t.x, d = () => n.height + t.y, u = (g) => t[g] === this._fitIntoArea(g, t[g]), c = () => ss(l(), s, r) && u("x"), h = () => ss(d(), o, a) && u("y");
    if (!c()) {
      const g = this._fitIntoArea("x", Lt(l(), s, r) - n.width);
      t = {
        x: g,
        y: this._proportionate("y", g)
      };
    }
    if (!h()) {
      const g = this._fitIntoArea("y", Lt(d(), o, a) - n.height);
      t = {
        x: this._proportionate("x", g),
        y: g
      };
    }
    return c() && h() ? t : {
      x: 0,
      y: 0
    };
  }
  _fitDelta(e) {
    let {
      x: t,
      y: n
    } = e;
    const s = this._elementSize, {
      minWidth: o,
      minHeight: r,
      maxWidth: a,
      maxHeight: l
    } = this.option();
    return {
      x: Lt(s.width + t, o, a) - s.width,
      y: Lt(s.height + n, r, l) - s.height
    };
  }
  _getDeltaByOffset(e) {
    const t = this._movingSides, n = this._isCornerHandler(t) && this.option("keepAspectRatio");
    let s = {
      x: e.x * (t.left ? -1 : 1),
      y: e.y * (t.top ? -1 : 1)
    };
    if (n) {
      const o = this._getProportionalDelta(s);
      s = this._fitDeltaProportionally(o);
    } else {
      const o = this._fitDelta(s);
      s = this._roundByStep(o);
    }
    return s;
  }
  _updatePosition(e, t) {
    let {
      width: n,
      height: s
    } = t;
    const o = this._elementLocation, r = this._movingSides, a = this.$element(), l = this._getElementSize(), d = e.y * (r.top ? -1 : 1) - ((l.height || s) - s), u = e.x * (r.left ? -1 : 1) - ((l.width || n) - n);
    Ot(a, {
      top: o.top + (r.top ? d : 0),
      left: o.left + (r.left ? u : 0)
    });
  }
  _dragHandler(e) {
    const t = this._getOffset(e), n = this._getDeltaByOffset(t), s = this._updateDimensions(n);
    this._updatePosition(n, s), this._triggerResizeAction(e, s);
  }
  _updateDimensions(e) {
    const t = (c) => c.substring(c.length - 2) === "px", {
      stepPrecision: n
    } = this.option(), s = n === "strict", o = this._elementSize, r = o.width + e.x, a = o.height + e.y, l = this.$element().get(0).style, d = e.x || s || t(l.width), u = e.y || s || t(l.height);
    return d && this.option({
      width: r
    }), u && this.option({
      height: a
    }), {
      width: d ? r : o.width,
      height: u ? a : o.height
    };
  }
  _triggerResizeAction(e, t) {
    var n;
    let {
      width: s,
      height: o
    } = t;
    (n = this._resizeAction) === null || n === void 0 || n.call(this, {
      event: e,
      width: this.option("width") || s,
      height: this.option("height") || o,
      handles: this._movingSides
    }), Ii(this.$element());
  }
  _isCornerHandler(e) {
    return Object.values(e).reduce((t, n) => t ^ n, 0) === 0;
  }
  _getOffset(e) {
    const {
      offset: t
    } = e, n = this._movingSides;
    return !n.left && !n.right && (t.x = 0), !n.top && !n.bottom && (t.y = 0), t;
  }
  _roundByStep(e) {
    const {
      stepPrecision: t
    } = this.option();
    return t === "strict" ? this._roundStrict(e) : this._roundNotStrict(e);
  }
  _getSteps() {
    return Lf(this.option("step"), !this.option("roundStepValue"));
  }
  _roundNotStrict(e) {
    const t = this._getSteps();
    return {
      x: e.x - e.x % t.h,
      y: e.y - e.y % t.v
    };
  }
  _roundStrict(e) {
    const t = this._movingSides, n = {
      x: e.x * (t.left ? -1 : 1),
      y: e.y * (t.top ? -1 : 1)
    }, s = this._getSteps(), o = this._elementLocation, r = this._elementSize, a = t.left ? o.left : o.left + r.width, l = t.top ? o.top : o.top + r.height, d = (a + n.x) % s.h, u = (l + n.y) % s.v, c = Math.sign || ((T) => (T = +T, T === 0 || isNaN(T) ? T : T > 0 ? 1 : -1)), h = (T, V) => (1 + 0.2 * c(V)) % 1 * T, g = (T, V) => Math.abs(T) < 0.2 * V;
    let m = n.x - d, C = n.y - u;
    d > h(s.h, n.x) && (m += s.h), u > h(s.v, n.y) && (C += s.v);
    const v = (t.left || t.right) && !g(n.x, s.h) ? m : 0, E = (t.top || t.bottom) && !g(n.y, s.v) ? C : 0;
    return {
      x: v * (t.left ? -1 : 1),
      y: E * (t.top ? -1 : 1)
    };
  }
  _getMovingSides(e) {
    const t = p(e.target), n = t.hasClass("dx-resizable-handle-corner-top-left"), s = t.hasClass("dx-resizable-handle-corner-top-right"), o = t.hasClass("dx-resizable-handle-corner-bottom-left"), r = t.hasClass("dx-resizable-handle-corner-bottom-right");
    return {
      top: t.hasClass("dx-resizable-handle-top") || n || s,
      left: t.hasClass("dx-resizable-handle-left") || n || o,
      bottom: t.hasClass("dx-resizable-handle-bottom") || o || r,
      right: t.hasClass("dx-resizable-handle-right") || s || r
    };
  }
  _getArea() {
    let e = this.option("area");
    return B(e) && (e = e.call(this)), pe(e) ? this._getAreaFromObject(e) : this._getAreaFromElement(e);
  }
  _getAreaScrollOffset() {
    const e = this.option("area"), t = !B(e) && !pe(e), n = {
      scrollY: 0,
      scrollX: 0
    };
    if (t) {
      const s = p(e)[0];
      lt(s) && (n.scrollX = s.pageXOffset, n.scrollY = s.pageYOffset);
    }
    return n;
  }
  _getAreaFromObject(e) {
    const t = {
      width: e.right - e.left,
      height: e.bottom - e.top,
      offset: {
        left: e.left,
        top: e.top
      }
    };
    return this._correctAreaGeometry(t), t;
  }
  _getAreaFromElement(e) {
    const t = p(e);
    let n;
    return t.length && (n = {
      width: Kg(t),
      height: Ju(t),
      offset: x({
        top: 0,
        left: 0
      }, lt(t[0]) ? {} : t.offset())
    }, this._correctAreaGeometry(n, t)), n;
  }
  _correctAreaGeometry(e, t) {
    const n = t ? this._getBorderWidth(t, "left") : 0, s = t ? this._getBorderWidth(t, "top") : 0;
    e.offset.left += n + this._getBorderWidth(this.$element(), "left"), e.offset.top += s + this._getBorderWidth(this.$element(), "top"), e.width -= Ee(this.$element()) - Kg(this.$element()), e.height -= he(this.$element()) - Ju(this.$element());
  }
  _dragEndHandler(e) {
    var t;
    const n = this.$element();
    (t = this._resizeEndAction) === null || t === void 0 || t.call(this, {
      event: e,
      width: Ee(n),
      height: he(n),
      handles: this._movingSides
    }), this._toggleResizingClass(!1);
  }
  _renderWidth(e) {
    this.option("width", Lt(e, this.option("minWidth"), this.option("maxWidth")));
  }
  _renderHeight(e) {
    this.option("height", Lt(e, this.option("minHeight"), this.option("maxHeight")));
  }
  _optionChanged(e) {
    switch (e.name) {
      case "disabled":
        this._toggleEventHandlers(!e.value), super._optionChanged(e);
        break;
      case "handles":
        this._invalidate();
        break;
      case "minWidth":
      case "maxWidth":
        ae() && this._renderWidth(Ee(this.$element()));
        break;
      case "minHeight":
      case "maxHeight":
        ae() && this._renderHeight(he(this.$element()));
        break;
      case "onResize":
      case "onResizeStart":
      case "onResizeEnd":
        this._renderActions();
        break;
      case "area":
      case "stepPrecision":
      case "step":
      case "roundStepValue":
      case "keepAspectRatio":
        break;
      default:
        super._optionChanged(e);
    }
  }
  _clean() {
    this.$element().find(".dx-resizable-handle").remove();
  }
  _useTemplates() {
    return !1;
  }
}
xe(fh, XO);
class bY {
  constructor(e) {
    this.init(e);
  }
  init(e) {
    let {
      dragEnabled: t,
      handle: n,
      draggableElement: s,
      positionController: o
    } = e;
    this._positionController = o, this._draggableElement = s, this._handle = n, this._dragEnabled = t, this.unsubscribe(), t && this.subscribe();
  }
  moveDown(e) {
    this._moveTo(5, 0, e);
  }
  moveUp(e) {
    this._moveTo(-5, 0, e);
  }
  moveLeft(e) {
    this._moveTo(0, -5, e);
  }
  moveRight(e) {
    this._moveTo(0, 5, e);
  }
  subscribe() {
    const e = this._getEventNames();
    _.on(this._handle, e.startEventName, (t) => {
      this._dragStartHandler(t);
    }), _.on(this._handle, e.updateEventName, (t) => {
      this._dragUpdateHandler(t);
    }), _.on(this._handle, e.endEventName, (t) => {
      this._dragEndHandler(t);
    });
  }
  unsubscribe() {
    const e = this._getEventNames();
    _.off(this._handle, e.startEventName), _.off(this._handle, e.updateEventName), _.off(this._handle, e.endEventName);
  }
  _getEventNames() {
    const e = R(Rl, "overlayDrag"), t = R(oa, "overlayDrag"), n = R(Fl, "overlayDrag");
    return {
      startEventName: e,
      updateEventName: t,
      endEventName: n
    };
  }
  _dragStartHandler(e) {
    const t = this._getAllowedOffsets();
    this._prevOffset = {
      x: 0,
      y: 0
    }, e.targetElements = [], e.maxTopOffset = t.top, e.maxBottomOffset = t.bottom, e.maxLeftOffset = t.left, e.maxRightOffset = t.right;
  }
  _dragUpdateHandler(e) {
    const t = {
      top: e.offset.y - this._prevOffset.y,
      left: e.offset.x - this._prevOffset.x
    };
    this._moveByOffset(t), this._prevOffset = e.offset;
  }
  _dragEndHandler(e) {
    this._positionController.dragHandled(), this._positionController.detectVisualPositionChange(e);
  }
  _moveTo(e, t, n) {
    if (!this._dragEnabled)
      return;
    n.preventDefault(), n.stopPropagation();
    const s = this._fitOffsetIntoAllowedRange(e, t);
    this._moveByOffset(s), this._dragEndHandler(n);
  }
  _fitOffsetIntoAllowedRange(e, t) {
    const n = this._getAllowedOffsets();
    return {
      top: Lt(e, -n.top, n.bottom),
      left: Lt(t, -n.left, n.right)
    };
  }
  _getContainerDimensions() {
    const e = O.getDocument(), t = this._positionController.$dragResizeContainer.get(0);
    let n = Ee(t), s = he(t);
    return lt(t) && (s = Math.max(e.body.clientHeight, s), n = Math.max(e.body.clientWidth, n)), {
      width: n,
      height: s
    };
  }
  _getContainerPosition() {
    const e = this._positionController.$dragResizeContainer.get(0);
    return lt(e) ? {
      top: 0,
      left: 0
    } : Ug(e);
  }
  _getElementPosition() {
    return Ug(this._draggableElement);
  }
  _getInnerDelta() {
    const e = this._getContainerDimensions(), t = this._getElementDimensions();
    return {
      x: e.width - t.width,
      y: e.height - t.height
    };
  }
  _getOuterDelta() {
    const {
      width: e,
      height: t
    } = this._getElementDimensions(), {
      outsideDragFactor: n
    } = this._positionController;
    return {
      x: e * n,
      y: t * n
    };
  }
  _getFullDelta() {
    const e = this._getInnerDelta(), t = this._getOuterDelta();
    return {
      x: e.x + t.x,
      y: e.y + t.y
    };
  }
  _getElementDimensions() {
    return {
      width: this._draggableElement.offsetWidth,
      height: this._draggableElement.offsetHeight
    };
  }
  _getAllowedOffsets() {
    const e = this._getFullDelta();
    if (!(e.y >= 0 && e.x >= 0))
      return {
        top: 0,
        bottom: 0,
        left: 0,
        right: 0
      };
    const n = this._getElementPosition(), s = this._getContainerPosition(), o = this._getOuterDelta();
    return {
      top: n.top - s.top + o.y,
      bottom: -n.top + s.top + e.y,
      left: n.left - s.left + o.x,
      right: -n.left + s.left + e.x
    };
  }
  _moveByOffset(e) {
    const t = Nn(this._draggableElement), n = {
      left: t.left + e.left,
      top: t.top + e.top
    };
    Ot(this._draggableElement, n);
  }
}
const wY = {
  setOverflow: M,
  restoreOverflow: M
}, SY = () => {
  if (!$t.hasWindow())
    return wY;
  const i = $t.getWindow(), {
    documentElement: e
  } = O.getDocument(), t = O.getBody(), n = z.real().platform === "ios", s = {
    overflow: null,
    overflowX: null,
    overflowY: null,
    paddingRight: null,
    position: null,
    top: null,
    left: null
  };
  return {
    setOverflow: n ? () => {
      if (f(s.position) || t.style.position === "fixed")
        return;
      const {
        scrollY: o,
        scrollX: r
      } = i;
      s.position = t.style.position, s.top = t.style.top, s.left = t.style.left, t.style.setProperty("position", "fixed"), t.style.setProperty("top", -o + "px"), t.style.setProperty("left", -r + "px");
    } : () => {
      (() => {
        const o = i.innerWidth - e.clientWidth;
        if (s.paddingRight || o <= 0)
          return;
        const r = i.getComputedStyle(t).getPropertyValue("padding-right"), a = parseInt(r, 10);
        s.paddingRight = a, t.style.setProperty("padding-right", `${a + o}px`);
      })(), !(s.overflow || t.style.overflow === "hidden") && (s.overflow = t.style.overflow, s.overflowX = t.style.overflowX, s.overflowY = t.style.overflowY, t.style.setProperty("overflow", "hidden"));
    },
    restoreOverflow: n ? () => {
      if (!f(s.position))
        return;
      const o = -parseInt(t.style.top, 10), r = -parseInt(t.style.left, 10);
      ["position", "top", "left"].forEach((a) => {
        s[a] ? t.style.setProperty(a, s[a]) : t.style.removeProperty(a);
      }), i.scrollTo(r, o), s.position = null;
    } : () => {
      f(s.paddingRight) && (s.paddingRight ? t.style.setProperty("padding-right", `${s.paddingRight}px`) : t.style.removeProperty("padding-right"), s.paddingRight = null), ["overflow", "overflowX", "overflowY"].forEach((o) => {
        if (!f(s[o]))
          return;
        const r = o.replace(/(X)|(Y)/, (a) => `-${a.toLowerCase()}`);
        s[o] ? t.style.setProperty(r, s[o]) : t.style.removeProperty(r), s[o] = null;
      });
    }
  };
}, EY = ["fullScreen", "forceApplyBindings", "dragOutsideBoundary", "dragAndResizeArea", "outsideDragFactor"], Vp = $t.getWindow();
class IY extends QT {
  constructor(e) {
    let {
      fullScreen: t,
      forceApplyBindings: n,
      dragOutsideBoundary: s,
      dragAndResizeArea: o,
      outsideDragFactor: r
    } = e, a = hi(e, EY);
    super(a), this._props = I({}, this._props, {
      fullScreen: t,
      forceApplyBindings: n,
      dragOutsideBoundary: s,
      dragAndResizeArea: o,
      outsideDragFactor: r
    }), this._$dragResizeContainer = void 0, this._updateDragResizeContainer();
  }
  set fullScreen(e) {
    this._props.fullScreen = e, e ? this._fullScreenEnabled() : this._fullScreenDisabled();
  }
  get $dragResizeContainer() {
    return this._$dragResizeContainer;
  }
  get outsideDragFactor() {
    return this._props.dragOutsideBoundary ? 1 : this._props.outsideDragFactor;
  }
  set dragAndResizeArea(e) {
    this._props.dragAndResizeArea = e, this._updateDragResizeContainer();
  }
  set dragOutsideBoundary(e) {
    this._props.dragOutsideBoundary = e, this._updateDragResizeContainer();
  }
  set outsideDragFactor(e) {
    this._props.outsideDragFactor = e;
  }
  updateContainer(e) {
    super.updateContainer(e), this._updateDragResizeContainer();
  }
  dragHandled() {
    this.restorePositionOnNextRender(!1);
  }
  resizeHandled() {
    this.restorePositionOnNextRender(!1);
  }
  positionContent() {
    if (this._props.fullScreen)
      Ot(this._$content, {
        top: 0,
        left: 0
      }), this.detectVisualPositionChange();
    else {
      var e, t;
      (e = (t = this._props).forceApplyBindings) === null || e === void 0 || e.call(t), super.positionContent();
    }
  }
  _updateDragResizeContainer() {
    this._$dragResizeContainer = this._getDragResizeContainer();
  }
  _getDragResizeContainer() {
    return this._props.dragOutsideBoundary ? p(Vp) : this._props.dragAndResizeArea ? p(this._props.dragAndResizeArea) : KI().get(0) || this._props.container ? this._$markupContainer : p(Vp);
  }
  _getVisualContainer() {
    return this._props.fullScreen ? p(Vp) : super._getVisualContainer();
  }
  _fullScreenEnabled() {
    this.restorePositionOnNextRender(!1);
  }
  _fullScreenDisabled() {
    this.restorePositionOnNextRender(!0);
  }
}
const DY = $t.getWindow(), Yb = ["cancel", "clear", "done"], TY = ze.safari && YT(ze.version, [11]) < 0, Ss = {
  static: "",
  inherit: "dx-popup-inherit-height",
  flex: "dx-popup-flex-height"
}, OY = (i) => {
  const e = z.current(), {
    platform: t
  } = e;
  let n = "bottom", s = "before";
  if (t === "ios")
    switch (i) {
      case "cancel":
        n = "top";
        break;
      case "clear":
        n = "top", s = "after";
        break;
      case "done":
        s = "after";
    }
  else if (t === "android")
    switch (i) {
      case "cancel":
      case "done":
        s = "after";
    }
  return {
    toolbar: n,
    location: s
  };
};
class pi extends Tn {
  _supportedKeys() {
    return I({}, super._supportedKeys(), {
      upArrow: (e) => {
        var t;
        (t = this._drag) === null || t === void 0 || t.moveUp(e);
      },
      downArrow: (e) => {
        var t;
        (t = this._drag) === null || t === void 0 || t.moveDown(e);
      },
      leftArrow: (e) => {
        var t;
        (t = this._drag) === null || t === void 0 || t.moveLeft(e);
      },
      rightArrow: (e) => {
        var t;
        (t = this._drag) === null || t === void 0 || t.moveRight(e);
      }
    });
  }
  _getDefaultOptions() {
    return I({}, super._getDefaultOptions(), {
      fullScreen: !1,
      title: "",
      showTitle: !0,
      titleTemplate: "title",
      onTitleRendered: null,
      dragOutsideBoundary: !1,
      dragEnabled: !1,
      enableBodyScroll: !0,
      outsideDragFactor: 0,
      onResizeStart: null,
      onResize: null,
      onResizeEnd: null,
      resizeEnabled: !1,
      toolbarItems: [],
      showCloseButton: !1,
      bottomTemplate: "bottom",
      useDefaultToolbarButtons: !1,
      useFlatToolbarButtons: !1,
      autoResizeEnabled: !0
    });
  }
  _defaultOptionsRules() {
    return super._defaultOptionsRules().concat([{
      device: {
        platform: "ios"
      },
      options: {
        animation: this._iosAnimation
      }
    }, {
      device: {
        platform: "android"
      },
      options: {
        animation: this._androidAnimation
      }
    }, {
      device: {
        platform: "generic"
      },
      options: {
        showCloseButton: !0
      }
    }, {
      device: (e) => z.real().deviceType === "desktop" && e.platform === "generic",
      options: {
        dragEnabled: !0
      }
    }, {
      device: () => z.real().deviceType === "desktop" && !z.isSimulator(),
      options: {
        focusStateEnabled: !0
      }
    }, {
      device: () => Gn(),
      options: {
        useFlatToolbarButtons: !0
      }
    }, {
      device: () => Zt(),
      options: {
        useDefaultToolbarButtons: !0,
        showCloseButton: !1
      }
    }]);
  }
  _iosAnimation() {
    return {
      show: {
        type: "slide",
        duration: 400,
        from: {
          position: {
            my: "top",
            at: "bottom"
          }
        },
        to: {
          position: {
            my: "center",
            at: "center"
          }
        }
      },
      hide: {
        type: "slide",
        duration: 400,
        from: {
          opacity: 1,
          position: {
            my: "center",
            at: "center"
          }
        },
        to: {
          opacity: 1,
          position: {
            my: "top",
            at: "bottom"
          }
        }
      }
    };
  }
  _androidAnimation() {
    return this.option("fullScreen") ? {
      show: {
        type: "slide",
        duration: 300,
        from: {
          top: "30%",
          opacity: 0
        },
        to: {
          top: 0,
          opacity: 1
        }
      },
      hide: {
        type: "slide",
        duration: 300,
        from: {
          top: 0,
          opacity: 1
        },
        to: {
          top: "30%",
          opacity: 0
        }
      }
    } : {
      show: {
        type: "fade",
        duration: 400,
        from: 0,
        to: 1
      },
      hide: {
        type: "fade",
        duration: 400,
        from: 1,
        to: 0
      }
    };
  }
  _init() {
    const {
      _wrapperClassExternal: e
    } = this.option(), t = e ? `dx-popup-wrapper ${e}` : "dx-popup-wrapper";
    super._init(), this._createBodyOverflowManager(), this._updateResizeCallbackSkipCondition(), this.$element().addClass("dx-popup"), this.$wrapper().addClass(t), this._$popupContent = this._$content.wrapInner(p("<div>").addClass("dx-popup-content")).children().eq(0), this._toggleContentScrollClass(), this.$overlayContent().attr("role", "dialog");
  }
  _render() {
    const e = this.option("fullScreen");
    this._toggleFullScreenClass(e), super._render();
  }
  _createBodyOverflowManager() {
    this._bodyOverflowManager = SY();
  }
  _toggleFullScreenClass(e) {
    this.$overlayContent().toggleClass("dx-popup-fullscreen", e).toggleClass("dx-popup-normal", !e);
  }
  _initTemplates() {
    super._initTemplates(), this._templateManager.addDefaultTemplates({
      title: new Lo(),
      bottom: new Lo()
    });
  }
  _getActionsList() {
    return super._getActionsList().concat(["onResizeStart", "onResize", "onResizeEnd"]);
  }
  _contentResizeHandler(e) {
    this._shouldSkipContentResize(e) || this._renderGeometry({
      shouldOnlyReposition: !0
    });
  }
  _doesShowAnimationChangeDimensions() {
    const e = this.option("animation");
    return ["to", "from"].some((t) => {
      var n;
      const s = e == null || (n = e.show) === null || n === void 0 ? void 0 : n[t];
      return X(s) && ("width" in s || "height" in s);
    });
  }
  _updateResizeCallbackSkipCondition() {
    const e = this._doesShowAnimationChangeDimensions();
    this._shouldSkipContentResize = (t) => e && this._showAnimationProcessing || this._areContentDimensionsRendered(t);
  }
  _observeContentResize(e) {
    if (!this.option("useResizeObserver"))
      return;
    const t = this._$content.get(0);
    e ? zo.observe(t, (n) => {
      this._contentResizeHandler(n);
    }) : zo.unobserve(t);
  }
  _areContentDimensionsRendered(e) {
    var t, n, s;
    const o = (t = e.contentBoxSize) === null || t === void 0 ? void 0 : t[0];
    if (o) {
      var r, a;
      return parseInt(o.inlineSize, 10) === ((r = this._renderedDimensions) === null || r === void 0 ? void 0 : r.width) && parseInt(o.blockSize, 10) === ((a = this._renderedDimensions) === null || a === void 0 ? void 0 : a.height);
    }
    const {
      contentRect: l
    } = e;
    return parseInt(l.width, 10) === ((n = this._renderedDimensions) === null || n === void 0 ? void 0 : n.width) && parseInt(l.height, 10) === ((s = this._renderedDimensions) === null || s === void 0 ? void 0 : s.height);
  }
  _renderContent() {
    super._renderContent(), this._observeContentResize(!0);
  }
  _renderContentImpl() {
    this._renderTitle(), super._renderContentImpl(), this._renderResize(), this._renderBottom();
  }
  _renderTitle() {
    const e = this._getToolbarItems("top"), {
      title: t,
      showTitle: n
    } = this.option();
    if (n && t && e.unshift({
      location: z.current().ios ? "center" : "before",
      text: t
    }), n || e.length > 0) {
      this._$title && this._$title.remove();
      const s = p("<div>").addClass("dx-popup-title").insertBefore(this.$content());
      this._$title = this._renderTemplateByType("titleTemplate", e, s).addClass("dx-popup-title"), this._renderDrag(), this._executeTitleRenderAction(this._$title), this._$title.toggleClass("dx-has-close-button", this._hasCloseButton());
    } else
      this._$title && this._$title.detach();
    this._toggleAriaLabel();
  }
  _toggleAriaLabel() {
    var e;
    const {
      title: t,
      showTitle: n
    } = this.option(), o = n && !!t ? new Xe() : null;
    (e = this._$title) === null || e === void 0 || e.find(".dx-toolbar-label").eq(0).attr("id", o), this.$overlayContent().attr("aria-labelledby", o);
  }
  _renderTemplateByType(e, t, n, s) {
    const {
      rtlEnabled: o,
      useDefaultToolbarButtons: r,
      useFlatToolbarButtons: a,
      disabled: l
    } = this.option(), d = this._getTemplateByOption(e);
    if (d instanceof Lo) {
      const h = x({}, this.option("integrationOptions"), {
        skipTemplates: ["content", "title"]
      }), g = x(s, {
        items: t,
        rtlEnabled: o,
        useDefaultButtons: r,
        useFlatButtons: a,
        disabled: l,
        integrationOptions: h
      });
      this._getTemplate("dx-polymorph-widget").render({
        container: n,
        model: {
          widget: this._getToolbarName(),
          options: g
        }
      });
      const m = n.children("div");
      return n.replaceWith(m), m;
    }
    const c = p(d.render({
      container: ee(n)
    }));
    return c.hasClass("dx-template-wrapper") && (n.replaceWith(c), n = c), n;
  }
  _getToolbarName() {
    return "dxToolbarBase";
  }
  _renderVisibilityAnimate(e) {
    return super._renderVisibilityAnimate(e);
  }
  _hide() {
    return this._observeContentResize(!1), super._hide();
  }
  _executeTitleRenderAction(e) {
    this._getTitleRenderAction()({
      titleElement: ee(e)
    });
  }
  _getTitleRenderAction() {
    return this._titleRenderAction || this._createTitleRenderAction();
  }
  _createTitleRenderAction() {
    return this._titleRenderAction = this._createActionByOption("onTitleRendered", {
      element: this.element(),
      excludeValidators: ["disabled", "readOnly"]
    });
  }
  _getCloseButton() {
    return {
      toolbar: "top",
      location: "after",
      template: this._getCloseButtonRenderer()
    };
  }
  _getCloseButtonRenderer() {
    return (e, t, n) => {
      const s = p("<div>").addClass("dx-closebutton");
      this._createComponent(s, wt, {
        icon: "close",
        onClick: this._createToolbarItemAction(void 0),
        stylingMode: "text",
        integrationOptions: {}
      }), p(n).append(s);
    };
  }
  _getToolbarItems(e) {
    const t = this.option("toolbarItems"), n = [];
    this._toolbarItemClasses = [];
    const s = z.current().platform;
    let o = 0;
    return y(t, (r, a) => {
      const l = f(a.shortcut), d = l ? OY(a.shortcut) : a;
      if (l && s === "ios" && o < 2 && (d.toolbar = "top", o++), d.toolbar = a.toolbar || d.toolbar || "top", d && d.toolbar === e) {
        l && x(d, {
          location: a.location
        }, this._getToolbarItemByAlias(a));
        const u = s === "generic";
        a.shortcut === "done" && u || a.shortcut === "cancel" && !u ? n.unshift(d) : n.push(d);
      }
    }), e === "top" && this._hasCloseButton() && n.push(this._getCloseButton()), n;
  }
  _hasCloseButton() {
    const {
      showCloseButton: e,
      showTitle: t
    } = this.option();
    return e && t;
  }
  _getLocalizationKey(e) {
    return e.toLowerCase() === "done" ? "OK" : Jr(e, !0);
  }
  _getToolbarButtonStylingMode(e) {
    return nn() ? e === "done" ? "contained" : "outlined" : this.option("useFlatToolbarButtons") ? "text" : "contained";
  }
  _getToolbarButtonType(e) {
    return nn() && e === "done" || this.option("useDefaultToolbarButtons") ? "default" : "normal";
  }
  _getToolbarItemByAlias(e) {
    const t = this, n = e.shortcut;
    if (!Yb.includes(n))
      return !1;
    const s = x({
      text: S.format(this._getLocalizationKey(n)),
      onClick: this._createToolbarItemAction(e.onClick),
      integrationOptions: {},
      type: this._getToolbarButtonType(n),
      stylingMode: this._getToolbarButtonStylingMode(n)
    }, e.options || {}), o = `dx-popup-${n}`;
    return this._toolbarItemClasses.push(o), {
      template(r, a, l) {
        const d = p("<div>").addClass(o).appendTo(l);
        t._createComponent(d, wt, s);
      }
    };
  }
  _createToolbarItemAction(e) {
    return this._createAction(e, {
      afterExecute(t) {
        t.component.hide();
      }
    });
  }
  _renderBottom() {
    const e = this._getToolbarItems("bottom");
    if (e.length) {
      var t;
      (t = this._$bottom) === null || t === void 0 || t.remove();
      const s = p("<div>").addClass("dx-popup-bottom").insertAfter(this.$content());
      this._$bottom = this._renderTemplateByType("bottomTemplate", e, s, {
        compactMode: !0
      }).addClass("dx-popup-bottom"), this._toggleClasses();
    } else {
      var n;
      (n = this._$bottom) === null || n === void 0 || n.detach();
    }
  }
  _toggleDisabledState(e) {
    super._toggleDisabledState(...arguments), this.$content().toggleClass("dx-state-disabled", !!e);
  }
  _toggleClasses() {
    y(Yb, (t, n) => {
      const s = `dx-popup-${n}`;
      if (this._toolbarItemClasses.includes(s)) {
        var o;
        this.$wrapper().addClass(`${s}-visible`), (o = this._$bottom) === null || o === void 0 || o.addClass(s);
      } else {
        var r;
        this.$wrapper().removeClass(`${s}-visible`), (r = this._$bottom) === null || r === void 0 || r.removeClass(s);
      }
    });
  }
  _toggleFocusClass(e, t) {
    if (super._toggleFocusClass(e, t), e && !vj(this._zIndex)) {
      const n = JT(this._zIndexInitValue());
      Fm(this._zIndex), this._zIndex = n, this._$wrapper.css("zIndex", n), this._$content.css("zIndex", n);
    }
  }
  _toggleContentScrollClass() {
    const e = !this.option("preventScrollEvents");
    this.$content().toggleClass("dx-popup-content-scrollable", e);
  }
  _getPositionControllerConfig() {
    const {
      fullScreen: e,
      forceApplyBindings: t,
      dragOutsideBoundary: n,
      dragAndResizeArea: s,
      outsideDragFactor: o
    } = this.option();
    return I({}, super._getPositionControllerConfig(), {
      fullScreen: e,
      forceApplyBindings: t,
      dragOutsideBoundary: n,
      dragAndResizeArea: s,
      outsideDragFactor: o
    });
  }
  _initPositionController() {
    this._positionController = new IY(this._getPositionControllerConfig());
  }
  _getDragTarget() {
    return this.topToolbar();
  }
  _renderGeometry(e) {
    const {
      visible: t,
      useResizeObserver: n
    } = this.option();
    if (t && $t.hasWindow()) {
      const o = this._showAnimationProcessing && !(e != null && e.forceStopAnimation) && n;
      this._isAnimationPaused = o || void 0, this._stopAnimation(), e != null && e.shouldOnlyReposition ? this._renderPosition(!1) : this._renderGeometryImpl(e?.isDimensionChange), o && (this._animateShowing(), this._isAnimationPaused = void 0);
    }
  }
  _cacheDimensions() {
    this.option("useResizeObserver") && (this._renderedDimensions = {
      width: parseInt(ne(this._$content), 10),
      height: parseInt(le(this._$content), 10)
    });
  }
  _renderGeometryImpl() {
    (arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : !1) || this._resetContentHeight(), super._renderGeometryImpl(), this._cacheDimensions(), this._setContentHeight();
  }
  _resetContentHeight() {
    this._getOptionValue("height") === "auto" && this.$content().css({
      height: "auto",
      maxHeight: "none"
    });
  }
  _renderDrag() {
    const e = this._getDragTarget(), {
      dragEnabled: t
    } = this.option();
    if (!e)
      return;
    const n = {
      dragEnabled: t,
      handle: e.get(0),
      draggableElement: this._$content.get(0),
      positionController: this._positionController
    };
    this._drag ? this._drag.init(n) : this._drag = new bY(n), this.$overlayContent().toggleClass("dx-popup-draggable", t);
  }
  _renderResize() {
    this._resizable = this._createComponent(this._$content, XO, {
      handles: this.option("resizeEnabled") ? "all" : "none",
      onResizeEnd: (e) => {
        this._resizeEndHandler(e), this._observeContentResize(!0);
      },
      onResize: (e) => {
        this._setContentHeight(), this._actions.onResize(e);
      },
      onResizeStart: (e) => {
        this._observeContentResize(!1), this._actions.onResizeStart(e);
      },
      minHeight: 100,
      minWidth: 100,
      area: this._positionController.$dragResizeContainer,
      keepAspectRatio: !1
    });
  }
  _resizeEndHandler(e) {
    const t = this._resizable.option("width"), n = this._resizable.option("height");
    t && this._setOptionWithoutOptionChange("width", t), n && this._setOptionWithoutOptionChange("height", n), this._cacheDimensions(), this._positionController.resizeHandled(), this._positionController.detectVisualPositionChange(e.event), this._actions.onResizeEnd(e);
  }
  _setContentHeight() {
    const {
      forceApplyBindings: e
    } = this.option();
    (e || M)();
    const t = this.$overlayContent().get(0), n = this._chooseHeightStrategy(t);
    this.$content().css(this._getHeightCssStyles(n, t)), this._setHeightClasses(this.$overlayContent(), n);
  }
  _heightStrategyChangeOffset(e, t) {
    return e === Ss.flex ? -t : 0;
  }
  _chooseHeightStrategy(e) {
    const t = e.style.width === "auto" || e.style.width === "";
    let n = Ss.static;
    return this._isAutoHeight() && this.option("autoResizeEnabled") && (t || TY ? n = Ss.inherit : n = Ss.flex), n;
  }
  _getHeightCssStyles(e, t) {
    let n = {};
    const s = this._getOptionValue("maxHeight", t), o = this._getOptionValue("minHeight", t), r = this._splitPopupHeight(), a = r.header + r.footer + r.contentVerticalOffsets + r.popupVerticalOffsets + this._heightStrategyChangeOffset(e, r.popupVerticalPaddings);
    if (e === Ss.static) {
      if (!this._isAutoHeight() || s || o) {
        const d = (this.option("fullScreen") ? Math.min(Ge(t).height, $t.getWindow().innerHeight) : Ge(t).height) - a;
        n = {
          height: Math.max(0, d),
          minHeight: "auto",
          maxHeight: "auto"
        };
      }
    } else {
      const l = p(this._positionController.$visualContainer).get(0), d = c1(s, -a, l);
      n = {
        height: "auto",
        minHeight: h1(o, -a, l),
        maxHeight: d
      };
    }
    return n;
  }
  _setHeightClasses(e, t) {
    let n = "";
    for (const s in Ss)
      Ss[s] !== t && (n += ` ${Ss[s]}`);
    e.removeClass(n).addClass(t);
  }
  _isAutoHeight() {
    return this.$overlayContent().get(0).style.height === "auto";
  }
  _splitPopupHeight() {
    const e = this.topToolbar(), t = this.bottomToolbar();
    return {
      header: gx(e?.get(0)),
      footer: gx(t?.get(0)),
      contentVerticalOffsets: Yh(this.$overlayContent().get(0), !0),
      popupVerticalOffsets: Yh(this.$content().get(0), !0),
      popupVerticalPaddings: Yh(this.$content().get(0), !1)
    };
  }
  _isAllWindowCovered() {
    const {
      fullScreen: e
    } = this.option();
    return super._isAllWindowCovered() || e;
  }
  _renderDimensions() {
    this.option("fullScreen") ? this.$overlayContent().css({
      width: "100%",
      height: "100%",
      minWidth: "",
      maxWidth: "",
      minHeight: "",
      maxHeight: ""
    }) : super._renderDimensions(), $t.hasWindow() && this._renderFullscreenWidthClass();
  }
  _dimensionChanged() {
    this._renderGeometry({
      isDimensionChange: !0
    });
  }
  _clean() {
    super._clean(), this._observeContentResize(!1);
  }
  _dispose() {
    super._dispose(), this._toggleBodyScroll(!0);
  }
  _renderFullscreenWidthClass() {
    const e = Ee(this.$overlayContent()) === ne(DY);
    this.$overlayContent().toggleClass("dx-popup-fullscreen-width", e);
  }
  _toggleSafariScrolling() {
    this.option("enableBodyScroll") && super._toggleSafariScrolling();
  }
  _toggleBodyScroll(e) {
    if (!this._bodyOverflowManager)
      return;
    const {
      setOverflow: t,
      restoreOverflow: n
    } = this._bodyOverflowManager;
    e ? n() : t();
  }
  refreshPosition() {
    this._renderPosition();
  }
  _optionChanged(e) {
    var t;
    const {
      value: n,
      name: s
    } = e;
    switch (s) {
      case "disabled":
        super._optionChanged(e), this._renderTitle(), this._renderBottom();
        break;
      case "animation":
        this._updateResizeCallbackSkipCondition();
        break;
      case "enableBodyScroll":
        this.option("visible") && this._toggleBodyScroll(n);
        break;
      case "showTitle":
      case "title":
      case "titleTemplate":
        this._renderTitle(), this._renderGeometry(), Ii(this.$overlayContent());
        break;
      case "bottomTemplate":
        this._renderBottom(), this._renderGeometry(), Ii(this.$overlayContent());
        break;
      case "container":
        if (super._optionChanged(e), this.option("resizeEnabled")) {
          var o;
          (o = this._resizable) === null || o === void 0 || o.option("area", this._positionController.$dragResizeContainer);
        }
        break;
      case "width":
      case "height":
        super._optionChanged(e), (t = this._resizable) === null || t === void 0 || t.option(s, n);
        break;
      case "onTitleRendered":
        this._createTitleRenderAction();
        break;
      case "toolbarItems":
      case "useDefaultToolbarButtons":
      case "useFlatToolbarButtons": {
        const r = !e.fullName.match(/^toolbarItems((\[\d+\])(\.(options|visible).*)?)?$/);
        this._renderTitle(), this._renderBottom(), r && (this._renderGeometry(), Ii(this.$overlayContent()));
        break;
      }
      case "dragEnabled":
        this._renderDrag();
        break;
      case "dragAndResizeArea":
        this._positionController.dragAndResizeArea = n, this.option("resizeEnabled") && this._resizable.option("area", this._positionController.$dragResizeContainer), this._positionController.positionContent();
        break;
      case "dragOutsideBoundary":
        this._positionController.dragOutsideBoundary = n, this.option("resizeEnabled") && this._resizable.option("area", this._positionController.$dragResizeContainer);
        break;
      case "outsideDragFactor":
        this._positionController.outsideDragFactor = n;
        break;
      case "resizeEnabled":
        this._renderResize(), this._renderGeometry();
        break;
      case "autoResizeEnabled":
        this._renderGeometry(), Ii(this.$overlayContent());
        break;
      case "fullScreen":
        this._positionController.fullScreen = n, this._toggleFullScreenClass(n), this._toggleSafariScrolling(), this._renderGeometry(), Ii(this.$overlayContent());
        break;
      case "showCloseButton":
        this._renderTitle();
        break;
      case "preventScrollEvents":
        super._optionChanged(e), this._toggleContentScrollClass();
        break;
      default:
        super._optionChanged(e);
    }
  }
  bottomToolbar() {
    return this._$bottom;
  }
  topToolbar() {
    return this._$title;
  }
  $content() {
    return this._$popupContent;
  }
  content() {
    return ee(this.$content());
  }
  $overlayContent() {
    return this._$content;
  }
  getFocusableElements() {
    return this.$wrapper().find("[tabindex]").filter((e, t) => t.getAttribute("tabindex") >= 0);
  }
}
xe("dxPopup", pi);
const ZO = "dxswipestart", QO = "dxswipe", iC = "dxswipeend", AY = {
  defaultItemSizeFunc() {
    return ne(this.getElement());
  },
  getBounds() {
    return [this._maxLeftOffset, this._maxRightOffset];
  },
  calcOffsetRatio(i) {
    return (st(i).x - (this._savedEventData && this._savedEventData.x || 0)) / this._itemSizeFunc().call(this, i);
  },
  isFastSwipe(i) {
    const e = st(i);
    return this.FAST_SWIPE_SPEED_LIMIT * Math.abs(e.x - this._tickData.x) >= e.time - this._tickData.time;
  }
}, RY = {
  defaultItemSizeFunc() {
    return le(this.getElement());
  },
  getBounds() {
    return [this._maxTopOffset, this._maxBottomOffset];
  },
  calcOffsetRatio(i) {
    return (st(i).y - (this._savedEventData && this._savedEventData.y || 0)) / this._itemSizeFunc().call(this, i);
  },
  isFastSwipe(i) {
    const e = st(i);
    return this.FAST_SWIPE_SPEED_LIMIT * Math.abs(e.y - this._tickData.y) >= e.time - this._tickData.time;
  }
}, FY = {
  horizontal: AY,
  vertical: RY
}, kY = ud.inherit({
  TICK_INTERVAL: 300,
  FAST_SWIPE_SPEED_LIMIT: 10,
  ctor(i) {
    this.callBase(i), this.direction = "horizontal", this.elastic = !0;
  },
  _getStrategy() {
    return FY[this.direction];
  },
  _defaultItemSizeFunc() {
    return this._getStrategy().defaultItemSizeFunc.call(this);
  },
  _itemSizeFunc() {
    return this.itemSizeFunc || this._defaultItemSizeFunc;
  },
  _init(i) {
    this._tickData = st(i);
  },
  _start(i) {
    this._savedEventData = st(i), i = this._fireEvent("dxswipestart", i), i.cancel || (this._maxLeftOffset = i.maxLeftOffset, this._maxRightOffset = i.maxRightOffset, this._maxTopOffset = i.maxTopOffset, this._maxBottomOffset = i.maxBottomOffset);
  },
  _move(i) {
    const e = this._getStrategy(), t = st(i);
    let n = e.calcOffsetRatio.call(this, i);
    n = this._fitOffset(n, this.elastic), t.time - this._tickData.time > this.TICK_INTERVAL && (this._tickData = t), this._fireEvent("dxswipe", i, {
      offset: n
    }), i.cancelable !== !1 && i.preventDefault();
  },
  _end(i) {
    const e = this._getStrategy(), t = e.calcOffsetRatio.call(this, i), n = e.isFastSwipe.call(this, i);
    let s = t, o = this._calcTargetOffset(t, n);
    s = this._fitOffset(s, this.elastic), o = this._fitOffset(o, !1), this._fireEvent("dxswipeend", i, {
      offset: s,
      targetOffset: o
    });
  },
  _fitOffset(i, e) {
    const n = this._getStrategy().getBounds.call(this);
    return i < -n[0] ? e ? (-2 * n[0] + i) / 3 : -n[0] : i > n[1] ? e ? (2 * n[1] + i) / 3 : n[1] : i;
  },
  _calcTargetOffset(i, e) {
    let t;
    return e ? (t = Math.ceil(Math.abs(i)), i < 0 && (t = -t)) : t = Math.round(i), t;
  }
});
ha({
  emitter: kY,
  events: ["dxswipestart", "dxswipe", "dxswipeend"]
});
class VY extends q_ {
  _init(e) {
    super._init(e), this._$topPocket = e._$topPocket, this._$pullDown = e._$pullDown, this._$refreshingText = e._$refreshingText, this._$scrollViewContent = p(e.content()), this._$container = p(e.container()), this._initCallbacks();
  }
  _initCallbacks() {
    this.pullDownCallbacks = Ie(), this.releaseCallbacks = Ie(), this.reachBottomCallbacks = Ie();
  }
  render() {
    super.render(), this._renderPullDown(), this._releaseState();
  }
  _renderPullDown() {
    const e = p("<div>").addClass("dx-scrollview-pull-down-image"), t = p("<div>").addClass("dx-scrollview-pull-down-indicator"), n = new Dn(p("<div>")).$element(), s = this._$pullDownText = p("<div>").addClass("dx-scrollview-pull-down-text");
    this._$pullingDownText = p("<div>").text(this.option("pullingDownText")).appendTo(s), this._$pulledDownText = p("<div>").text(this.option("pulledDownText")).appendTo(s), this._$refreshingText = p("<div>").text(this.option("refreshingText")).appendTo(s), this._$pullDown.empty().append(e).append(t.append(n)).append(s);
  }
  _releaseState() {
    this._state = 0, this._refreshPullDownText();
  }
  _refreshPullDownText() {
    const e = this, t = [{
      element: this._$pullingDownText,
      visibleState: 0
    }, {
      element: this._$pulledDownText,
      visibleState: 1
    }, {
      element: this._$refreshingText,
      visibleState: 2
    }];
    y(t, (n, s) => {
      const o = e._state === s.visibleState ? "addClass" : "removeClass";
      s.element[o]("dx-scrollview-pull-down-text-visible");
    });
  }
  update() {
    super.update(), this._setTopPocketOffset();
  }
  _updateDimensions() {
    super._updateDimensions(), this._topPocketSize = this._$topPocket.get(0).clientHeight;
    const e = this._$scrollViewContent.get(0), t = this._$container.get(0);
    this._bottomBoundary = Math.max(e.clientHeight - t.clientHeight, 0);
  }
  _allowedDirections() {
    const e = super._allowedDirections();
    return e.vertical = e.vertical || this._pullDownEnabled, e;
  }
  _setTopPocketOffset() {
    this._$topPocket.css({
      top: -this._topPocketSize
    });
  }
  handleEnd() {
    super.handleEnd(), this._complete();
  }
  handleStop() {
    super.handleStop(), this._complete();
  }
  _complete() {
    this._state === 1 && (this._setPullDownOffset(this._topPocketSize), clearTimeout(this._pullDownRefreshTimeout), this._pullDownRefreshTimeout = setTimeout(() => {
      this._pullDownRefreshing();
    }, 400));
  }
  _setPullDownOffset(e) {
    Ot(this._$topPocket, {
      top: e
    }), Ot(this._$scrollViewContent, {
      top: e
    });
  }
  handleScroll(e) {
    if (super.handleScroll(e), this._state === 2)
      return;
    const t = this.location().top, n = (this._location || 0) - t;
    this._location = t, this._isPullDown() ? this._pullDownReady() : n > 0 && this._isReachBottom() ? this._reachBottom() : this._stateReleased();
  }
  _isPullDown() {
    return this._pullDownEnabled && this._location >= this._topPocketSize;
  }
  _isReachBottom() {
    return this._reachBottomEnabled && this.isBottomReached();
  }
  isBottomReached() {
    return Math.round(this._bottomBoundary + Math.floor(this._location)) <= 1;
  }
  _reachBottom() {
    this._state !== 3 && (this._state = 3, this.reachBottomCallbacks.fire());
  }
  _pullDownReady() {
    this._state !== 1 && (this._state = 1, this._$pullDown.addClass("dx-scrollview-pull-down-ready"), this._refreshPullDownText());
  }
  _stateReleased() {
    this._state !== 0 && (this._$pullDown.removeClass("dx-scrollview-pull-down-loading").removeClass("dx-scrollview-pull-down-ready"), this._releaseState());
  }
  _pullDownRefreshing() {
    this._state !== 2 && (this._state = 2, this._$pullDown.addClass("dx-scrollview-pull-down-loading").removeClass("dx-scrollview-pull-down-ready"), this._refreshPullDownText(), this.pullDownCallbacks.fire());
  }
  pullDownEnable(e) {
    e && (this._updateDimensions(), this._setTopPocketOffset()), this._pullDownEnabled = e;
  }
  reachBottomEnable(e) {
    this._reachBottomEnabled = e;
  }
  pendingRelease() {
    this._state = 1;
  }
  release() {
    const e = w();
    return this._updateDimensions(), clearTimeout(this._releaseTimeout), this._state === 3 && (this._state = 0), this._releaseTimeout = setTimeout(() => {
      this._setPullDownOffset(0), this._stateReleased(), this.releaseCallbacks.fire(), this._updateAction(), e.resolve();
    }, 400), e.promise();
  }
  dispose() {
    clearTimeout(this._pullDownRefreshTimeout), clearTimeout(this._releaseTimeout), super.dispose();
  }
}
class PY extends q_ {
  _init(e) {
    super._init(e), this._$topPocket = e._$topPocket, this._$pullDown = e._$pullDown, this._$scrollViewContent = p(e.content()), this._$container = p(e.container()), this._initCallbacks(), this._location = 0;
  }
  _initCallbacks() {
    this.pullDownCallbacks = Ie(), this.releaseCallbacks = Ie(), this.reachBottomCallbacks = Ie();
  }
  render() {
    super.render(), this._renderPullDown(), this._releaseState();
  }
  _renderPullDown() {
    const e = p("<div>").addClass("dx-scrollview-pull-down-indicator"), t = new Dn(p("<div>")).$element();
    this._$icon = p("<div>").addClass("dx-icon-pulldown"), this._$pullDown.empty().append(this._$icon).append(e.append(t));
  }
  _releaseState() {
    this._state = 0, this._releasePullDown(), this._updateDimensions();
  }
  _releasePullDown() {
    this._$pullDown.css({
      opacity: 0
    });
  }
  _updateDimensions() {
    super._updateDimensions(), this._topPocketSize = this._$topPocket.get(0).clientHeight;
    const e = this._$scrollViewContent.get(0), t = this._$container.get(0);
    this._bottomBoundary = Math.max(e.clientHeight - t.clientHeight, 0);
  }
  _allowedDirections() {
    const e = super._allowedDirections();
    return e.vertical = e.vertical || this._pullDownEnabled, e;
  }
  handleInit(e) {
    super.handleInit(e), this._state === 0 && this._location === 0 && (this._startClientY = st(e.originalEvent).y, this._state = 4);
  }
  handleMove(e) {
    super.handleMove(e), this._deltaY = st(e.originalEvent).y - this._startClientY, this._state === 4 && (this._pullDownEnabled && this._deltaY > 0 ? this._state = 5 : this._complete()), this._state === 5 && (e.preventDefault(), this._movePullDown());
  }
  _movePullDown() {
    const e = this._getPullDownHeight(), t = Math.min(3 * e, this._deltaY + this._getPullDownStartPosition()), n = 180 * t / e / 3;
    this._$pullDown.css({
      opacity: 1
    }).toggleClass("dx-scrollview-pull-down-refreshing", t < e), Ot(this._$pullDown, {
      top: t
    }), this._$icon.css({
      transform: `rotate(${n}deg)`
    });
  }
  _isPullDown() {
    return this._pullDownEnabled && this._state === 5 && this._deltaY >= this._getPullDownHeight() - this._getPullDownStartPosition();
  }
  _getPullDownHeight() {
    return Math.round(0.05 * he(this._$element));
  }
  _getPullDownStartPosition() {
    return -Math.round(1.5 * he(this._$pullDown));
  }
  handleEnd() {
    this._isPullDown() && this._pullDownRefreshing(), this._complete();
  }
  handleStop() {
    this._complete();
  }
  _complete() {
    (this._state === 4 || this._state === 5) && this._releaseState();
  }
  handleScroll(e) {
    if (super.handleScroll(e), this._state === 2)
      return;
    const t = this.location().top, n = this._location - t;
    this._location = t, n > 0 && this._isReachBottom() ? this._reachBottom() : this._stateReleased();
  }
  _isReachBottom() {
    return this._reachBottomEnabled && this.isBottomReached();
  }
  isBottomReached() {
    return Math.round(this._bottomBoundary + Math.floor(this._location)) <= 1;
  }
  _reachBottom() {
    this.reachBottomCallbacks.fire();
  }
  _stateReleased() {
    this._state !== 0 && (this._$pullDown.removeClass("dx-scrollview-pull-down-loading"), this._releaseState());
  }
  _pullDownRefreshing() {
    this._state = 2, this._pullDownRefreshHandler();
  }
  _pullDownRefreshHandler() {
    this._refreshPullDown(), this.pullDownCallbacks.fire();
  }
  _refreshPullDown() {
    this._$pullDown.addClass("dx-scrollview-pull-down-loading"), Ot(this._$pullDown, {
      top: this._getPullDownHeight()
    });
  }
  pullDownEnable(e) {
    this._$topPocket.toggle(e), this._pullDownEnabled = e;
  }
  reachBottomEnable(e) {
    this._reachBottomEnabled = e;
  }
  pendingRelease() {
    this._state = 1;
  }
  release() {
    const e = w();
    return this._updateDimensions(), clearTimeout(this._releaseTimeout), this._releaseTimeout = setTimeout(() => {
      this._stateReleased(), this.releaseCallbacks.fire(), this._updateAction(), e.resolve();
    }, 800), e.promise();
  }
  dispose() {
    clearTimeout(this._pullDownRefreshTimeout), clearTimeout(this._releaseTimeout), super.dispose();
  }
}
class MY extends PO {
  ctor() {
    this._topPocketSize = 0, this._bottomPocketSize = 0, super.ctor.apply(this, arguments), this._initCallbacks(), this._releaseState();
  }
  _releaseState() {
    this._state = 0, this._refreshPullDownText();
  }
  _refreshPullDownText() {
    const e = this, t = [{
      element: this._$pullingDownText,
      visibleState: 0
    }, {
      element: this._$pulledDownText,
      visibleState: 1
    }, {
      element: this._$refreshingText,
      visibleState: 2
    }];
    y(t, (n, s) => {
      const o = e._state === s.visibleState ? "addClass" : "removeClass";
      s.element[o]("dx-scrollview-pull-down-text-visible");
    });
  }
  _initCallbacks() {
    this.pullDownCallbacks = Ie(), this.releaseCallbacks = Ie(), this.reachBottomCallbacks = Ie();
  }
  _updateBounds() {
    if (this._direction !== "horizontal") {
      this._topPocketSize = this._$topPocket.get(0).clientHeight, this._bottomPocketSize = this._$bottomPocket.get(0).clientHeight;
      const t = this._$container.get(0), n = this._$content.get(0);
      this._bottomBoundary = Math.max(n.clientHeight - this._bottomPocketSize - t.clientHeight, 0);
    }
    super._updateBounds();
  }
  _updateScrollbar() {
    this._scrollbar.option({
      containerSize: this._containerSize(),
      contentSize: this._contentSize() - this._topPocketSize - this._bottomPocketSize,
      scaleRatio: this._getScaleRatio()
    });
  }
  _moveContent() {
    super._moveContent(), this._isPullDown() ? this._pullDownReady() : this._isReachBottom() ? this._reachBottomReady() : this._state !== 0 && this._stateReleased();
  }
  _moveScrollbar() {
    this._scrollbar.moveTo(this._topPocketSize + this._location);
  }
  _isPullDown() {
    return this._pullDownEnabled && this._location >= 0;
  }
  _isReachBottom() {
    return this._reachBottomEnabled && this.isBottomReached();
  }
  isBottomReached() {
    const e = this._$container.get(0);
    return Math.round(this._bottomBoundary - Math.ceil(e.scrollTop)) <= 1;
  }
  _scrollComplete() {
    this._inBounds() && this._state === 1 ? this._pullDownRefreshing() : this._inBounds() && this._state === 3 ? this._reachBottomLoading() : super._scrollComplete();
  }
  _reachBottomReady() {
    this._state !== 3 && (this._state = 3, this._minOffset = this._getMinOffset());
  }
  _getMaxOffset() {
    return -this._topPocketSize;
  }
  _getMinOffset() {
    return Math.min(super._getMinOffset(), -this._topPocketSize);
  }
  _reachBottomLoading() {
    this.reachBottomCallbacks.fire();
  }
  _pullDownReady() {
    this._state !== 1 && (this._state = 1, this._maxOffset = 0, this._$pullDown.addClass("dx-scrollview-pull-down-ready"), this._refreshPullDownText());
  }
  _stateReleased() {
    this._state !== 0 && (this._releaseState(), this._updateBounds(), this._$pullDown.removeClass("dx-scrollview-pull-down-loading").removeClass("dx-scrollview-pull-down-ready"), this.releaseCallbacks.fire());
  }
  _pullDownRefreshing() {
    this._state !== 2 && (this._state = 2, this._$pullDown.addClass("dx-scrollview-pull-down-loading").removeClass("dx-scrollview-pull-down-ready"), this._refreshPullDownText(), this.pullDownCallbacks.fire());
  }
  _releaseHandler() {
    var e;
    return this._state === 0 && this._moveToBounds(), this._update(), this._releaseTask && this._releaseTask.abort(), this._releaseTask = fE(this._release.bind(this)), (e = this._releaseTask) === null || e === void 0 ? void 0 : e.promise;
  }
  _release() {
    this._stateReleased(), this._scrollComplete();
  }
  _reachBottomEnablingHandler(e) {
    this._reachBottomEnabled !== e && (this._reachBottomEnabled = e, this._updateBounds());
  }
  _pullDownEnablingHandler(e) {
    this._pullDownEnabled !== e && (this._pullDownEnabled = e, this._considerTopPocketChange(), this._updateHandler());
  }
  _considerTopPocketChange() {
    this._location -= le(this._$topPocket) || -this._topPocketSize, this._maxOffset = 0, this._move();
  }
  _pendingReleaseHandler() {
    this._state = 1;
  }
  dispose() {
    this._releaseTask && this._releaseTask.abort(), super.dispose();
  }
}
class BY extends MO {
  _init(e) {
    super._init(e), this._$pullDown = e._$pullDown, this._$topPocket = e._$topPocket, this._$bottomPocket = e._$bottomPocket, this._initCallbacks();
  }
  _initCallbacks() {
    this.pullDownCallbacks = Ie(), this.releaseCallbacks = Ie(), this.reachBottomCallbacks = Ie();
  }
  render() {
    this._renderPullDown(), super.render();
  }
  _renderPullDown() {
    const e = p("<div>").addClass("dx-scrollview-pull-down-image"), t = p("<div>").addClass("dx-scrollview-pull-down-indicator"), n = new Dn(p("<div>")).$element(), s = this._$pullDownText = p("<div>").addClass("dx-scrollview-pull-down-text");
    this._$pullingDownText = p("<div>").text(this.option("pullingDownText")).appendTo(s), this._$pulledDownText = p("<div>").text(this.option("pulledDownText")).appendTo(s), this._$refreshingText = p("<div>").text(this.option("refreshingText")).appendTo(s), this._$pullDown.empty().append(e).append(t.append(n)).append(s);
  }
  pullDownEnable(e) {
    this._eventHandler("pullDownEnabling", e);
  }
  reachBottomEnable(e) {
    this._eventHandler("reachBottomEnabling", e);
  }
  _createScroller(e) {
    const t = this, n = t._scrollers[e] = new MY(t._scrollerOptions(e));
    n.pullDownCallbacks.add(() => {
      t.pullDownCallbacks.fire();
    }), n.releaseCallbacks.add(() => {
      t.releaseCallbacks.fire();
    }), n.reachBottomCallbacks.add(() => {
      t.reachBottomCallbacks.fire();
    });
  }
  _scrollerOptions(e) {
    return I({}, super._scrollerOptions(e), {
      $topPocket: this._$topPocket,
      $bottomPocket: this._$bottomPocket,
      $pullDown: this._$pullDown,
      $pullDownText: this._$pullDownText,
      $pullingDownText: this._$pullingDownText,
      $pulledDownText: this._$pulledDownText,
      $refreshingText: this._$refreshingText
    });
  }
  pendingRelease() {
    this._eventHandler("pendingRelease");
  }
  release() {
    return this._eventHandler("release").done(this._updateAction);
  }
  location() {
    const e = super.location();
    return e.top += le(this._$topPocket), e;
  }
  isBottomReached() {
    return this._scrollers.vertical.isBottomReached();
  }
  dispose() {
    y(this._scrollers, function() {
      this.dispose();
    }), super.dispose();
  }
}
const $Y = "dx-scrollview-loadpanel", NY = {
  pullDown: VY,
  swipeDown: PY,
  simulated: BY
}, JO = !ae();
class eA extends Qt {
  finishLoading() {
  }
  release() {
  }
  refresh() {
  }
  scrollOffset() {
    return {
      top: 0,
      left: 0
    };
  }
  isBottomReached() {
    return !1;
  }
  _optionChanged(e) {
    const {
      name: t
    } = e;
    if (t !== "onUpdated")
      return super._optionChanged.apply(this, arguments);
  }
}
class tA extends Qt {
  _getDefaultOptions() {
    return I({}, super._getDefaultOptions(), {
      pullingDownText: S.format("dxScrollView-pullingDownText"),
      pulledDownText: S.format("dxScrollView-pulledDownText"),
      refreshingText: S.format("dxScrollView-refreshingText"),
      reachBottomText: S.format("dxScrollView-reachBottomText"),
      onPullDown: null,
      onReachBottom: null,
      refreshStrategy: "pullDown"
    });
  }
  _defaultOptionsRules() {
    return super._defaultOptionsRules().concat([{
      device() {
        return z.real().platform === "android";
      },
      options: {
        refreshStrategy: "swipeDown"
      }
    }, {
      device: () => Gn(),
      options: {
        pullingDownText: "",
        pulledDownText: "",
        refreshingText: "",
        reachBottomText: ""
      }
    }]);
  }
  _init() {
    super._init(), this._loadingIndicatorEnabled = !0;
  }
  _initScrollableMarkup() {
    super._initScrollableMarkup(), this.$element().addClass("dx-scrollview"), this._initContent(), this._initTopPocket(), this._initBottomPocket(), this._initLoadPanel();
  }
  _initContent() {
    const e = p("<div>").addClass("dx-scrollview-content");
    this._$content.wrapInner(e);
  }
  _initTopPocket() {
    this._$topPocket = p("<div>").addClass("dx-scrollview-top-pocket"), this._$pullDown = p("<div>").addClass("dx-scrollview-pull-down"), this._$topPocket.append(this._$pullDown), this._$content.prepend(this._$topPocket);
  }
  _initBottomPocket() {
    this._$bottomPocket = p("<div>").addClass("dx-scrollview-bottom-pocket"), this._$reachBottom = p("<div>").addClass("dx-scrollview-scrollbottom");
    const e = p("<div>").addClass("dx-scrollview-scrollbottom-indicator"), t = new Dn(p("<div>")).$element();
    this._$reachBottomText = p("<div>").addClass("dx-scrollview-scrollbottom-text"), this._updateReachBottomText(), this._$reachBottom.append(e.append(t)).append(this._$reachBottomText), this._$bottomPocket.append(this._$reachBottom), this._$content.append(this._$bottomPocket);
  }
  _initLoadPanel() {
    const e = p("<div>").addClass($Y).appendTo(this.$element()), {
      refreshingText: t
    } = this.option();
    this._loadPanel = this._createComponent(e, z_, {
      shading: !1,
      delay: 400,
      message: t,
      position: {
        of: this.$element()
      }
    });
  }
  _updateReachBottomText() {
    const {
      reachBottomText: e
    } = this.option();
    this._$reachBottomText.text(e);
  }
  _createStrategy() {
    const {
      useNative: e,
      refreshStrategy: t
    } = this.option(), s = NY[e ? t : "simulated"];
    this._strategy = new s(this), this._strategy.pullDownCallbacks.add(this._pullDownHandler.bind(this)), this._strategy.releaseCallbacks.add(this._releaseHandler.bind(this)), this._strategy.reachBottomCallbacks.add(this._reachBottomHandler.bind(this));
  }
  _createActions() {
    super._createActions(), this._pullDownAction = this._createActionByOption("onPullDown"), this._reachBottomAction = this._createActionByOption("onReachBottom"), this._tryRefreshPocketState();
  }
  _tryRefreshPocketState() {
    this._pullDownEnable(this.hasActionSubscription("onPullDown")), this._reachBottomEnable(this.hasActionSubscription("onReachBottom"));
  }
  on(e) {
    const t = super.on.apply(this, arguments);
    return (e === "pullDown" || e === "reachBottom") && this._tryRefreshPocketState(), t;
  }
  _pullDownEnable(e) {
    if (arguments.length === 0)
      return this._pullDownEnabled;
    this._$pullDown && this._strategy && (this._$pullDown.toggle(e), this._strategy.pullDownEnable(e), this._pullDownEnabled = e);
  }
  _reachBottomEnable(e) {
    if (arguments.length === 0)
      return this._reachBottomEnabled;
    this._$reachBottom && this._strategy && (this._$reachBottom.toggle(e), this._strategy.reachBottomEnable(e), this._reachBottomEnabled = e);
  }
  _pullDownHandler() {
    this._loadingIndicator(!1), this._pullDownLoading();
  }
  _loadingIndicator(e) {
    if (arguments.length < 1)
      return this._loadingIndicatorEnabled;
    this._loadingIndicatorEnabled = e;
  }
  _pullDownLoading() {
    var e;
    this.startLoading(), (e = this._pullDownAction) === null || e === void 0 || e.call(this);
  }
  _reachBottomHandler() {
    this._loadingIndicator(!1), this._reachBottomLoading();
  }
  _reachBottomLoading() {
    var e;
    this.startLoading(), (e = this._reachBottomAction) === null || e === void 0 || e.call(this);
  }
  _releaseHandler() {
    this.finishLoading(), this._loadingIndicator(!0);
  }
  _optionChanged(e) {
    switch (e.name) {
      case "onPullDown":
      case "onReachBottom":
        this._createActions();
        break;
      case "pullingDownText":
      case "pulledDownText":
      case "refreshingText":
      case "refreshStrategy":
        this._invalidate();
        break;
      case "reachBottomText":
        this._updateReachBottomText();
        break;
      default:
        super._optionChanged(e);
    }
  }
  content() {
    return ee(this._$content.children().eq(1));
  }
  release(e) {
    return e !== void 0 && this.toggleLoading(!e), this._strategy.release();
  }
  toggleLoading(e) {
    this._reachBottomEnable(e);
  }
  refresh() {
    this.hasActionSubscription("onPullDown") && (this._strategy.pendingRelease(), this._pullDownLoading());
  }
  startLoading() {
    this._loadingIndicator() && this.$element().is(":visible") && this._loadPanel.show(), this._lock();
  }
  finishLoading() {
    this._loadPanel.hide(), this._unlock();
  }
  isBottomReached() {
    return this._strategy.isBottomReached();
  }
  _dispose() {
    this._strategy.dispose(), super._dispose(), this._loadPanel && this._loadPanel.$element().remove();
  }
}
xe("dxScrollView", JO ? eA : tA);
const nA = JO ? eA : tA, LY = "__dx_key__";
class sC extends Z_ {
  _getDefaultOptions() {
    return I({}, super._getDefaultOptions(), {
      repaintChangesOnly: !1
    });
  }
  _customizeStoreLoadOptions(e) {
    this._dataController.getDataSource() && !this._dataController.isLoaded() && (this._correctionIndex = 0), this._correctionIndex && e.storeLoadOptions && (e.storeLoadOptions.skip += this._correctionIndex);
  }
  reload() {
    this._correctionIndex = 0;
  }
  _init() {
    super._init(), this._refreshItemsCache(), this._correctionIndex = 0, this._subscribeLoadOptionsCustomization(!0);
  }
  _findItemElementByKey(e) {
    let t = p();
    const n = this.key();
    return this.itemElements().each((s, o) => {
      const r = p(o), a = this._getItemData(r);
      if (n ? gd(n, this.keyOf(a), e) : this._isItemEquals(a, e))
        return t = r, !1;
    }), t;
  }
  _dataSourceChangedHandler(e, t) {
    t != null && t.changes ? this._modifyByChanges(t.changes) : (super._dataSourceChangedHandler(e, t), this._refreshItemsCache());
  }
  _isItemEquals(e, t) {
    e && e.__dx_key__ && (e = e.data);
    try {
      return JSON.stringify(e) === JSON.stringify(t);
    } catch {
      return e === t;
    }
  }
  _isItemStrictEquals(e, t) {
    return this._isItemEquals(e, t);
  }
  _shouldAddNewGroup(e, t) {
    let n = !1;
    return this.option("grouped") && (e.length || (n = !0), y(e, (s, o) => {
      o.type === "insert" && (n = !0, y(t, (r, a) => {
        if (o.data.key !== void 0 && o.data.key === a.key)
          return n = !1, !1;
      }));
    })), n;
  }
  _partialRefresh() {
    if (this.option("repaintChangesOnly")) {
      const e = (n) => n && n.__dx_key__ !== void 0 ? n.__dx_key__ : this.keyOf(n), t = vO(this._itemsCache, this._editStrategy.itemsGetter(), e, this._isItemStrictEquals.bind(this));
      if (t && this._itemsCache.length && !this._shouldAddNewGroup(t, this._itemsCache))
        return this._modifyByChanges(t, !0), this._renderEmptyMessage(), !0;
      this._refreshItemsCache();
    }
    return !1;
  }
  _refreshItemsCache() {
    if (this.option("repaintChangesOnly")) {
      const e = this._editStrategy.itemsGetter();
      try {
        this._itemsCache = x(!0, [], e), this.key() || (this._itemsCache = this._itemsCache.map((t, n) => ({
          [LY]: e[n],
          data: t
        })));
      } catch {
        this._itemsCache = x([], e);
      }
    }
  }
  _dispose() {
    this._subscribeLoadOptionsCustomization(!1), super._dispose();
  }
  _updateByChange(e, t, n, s) {
    if (s)
      this._renderItem(n.index, n.data, null, this._findItemElementByKey(n.key));
    else {
      const o = t[Yo(e, t, n.key)];
      o && V_(e, t, n.key, n.data).done(() => {
        this._renderItem(t.indexOf(o), o, null, this._findItemElementByKey(n.key));
      });
    }
  }
  _insertByChange(e, t, n, s) {
    W(s || P_(e, t, n.data, n.index)).done(() => {
      this._beforeItemElementInserted(n), this._renderItem(n.index ?? t.length, n.data), this._afterItemElementInserted(), this._correctionIndex++;
    });
  }
  _updateSelectionAfterRemoveByChange(e) {
    const {
      selectedIndex: t,
      selectedItems: n
    } = this.option();
    t > e ? this.option("selectedIndex", t - 1) : t === e && n.length === 1 ? this.option("selectedItems", []) : this._normalizeSelectedItems();
  }
  _beforeItemElementInserted(e) {
    const {
      selectedIndex: t
    } = this.option();
    e.index <= t && this.option("selectedIndex", t + 1);
  }
  _afterItemElementInserted() {
    this._renderEmptyMessage();
  }
  _removeByChange(e, t, n, s) {
    const o = s ? n.index : Yo(e, t, n.key);
    if (s ? n.oldItem : t[o]) {
      const a = this._findItemElementByKey(n.key), l = this._extendActionArgs(a);
      this._waitDeletingPrepare(a).done(() => {
        s ? (this._updateIndicesAfterIndex(o - 1), this._afterItemElementDeleted(a, l), this._updateSelectionAfterRemoveByChange(o)) : (this._deleteItemElementByIndex(o), this._afterItemElementDeleted(a, l));
      }), this._correctionIndex--;
    }
  }
  _modifyByChanges(e, t) {
    const n = this._editStrategy.itemsGetter(), s = {
      key: this.key.bind(this),
      keyOf: this.keyOf.bind(this)
    }, o = this._dataController, r = o.paginate(), a = o.group();
    (r || a) && (e = e.filter((l) => l.type !== "insert" || l.index !== void 0)), e.forEach((l) => this[`_${l.type}ByChange`](s, n, l, t)), this._renderedItemsCount = n.length, this._refreshItemsCache(), this._fireContentReadyAction();
  }
  _appendItemToContainer(e, t, n) {
    const s = e.children(this._itemSelector()).get(n);
    O.insertElement(e.get(0), t.get(0), s);
  }
  _subscribeLoadOptionsCustomization(e) {
    this._dataController && (e ? (this._correctionIndex = 0, this._dataController.on("customizeStoreLoadOptions", this._customizeStoreLoadOptions.bind(this))) : this._dataController.off("customizeStoreLoadOptions", this._customizeStoreLoadOptions.bind(this)));
  }
  _optionChanged(e) {
    switch (e.name) {
      case "items": {
        this._partialRefresh(e.value) || super._optionChanged(e);
        break;
      }
      case "dataSource":
        (!this.option("repaintChangesOnly") || !e.value) && this.option("items", []), this._subscribeLoadOptionsCustomization(!1), super._optionChanged(e), this._subscribeLoadOptionsCustomization(!0);
        break;
      case "repaintChangesOnly":
        break;
      default:
        super._optionChanged(e);
    }
  }
}
function HY(i) {
  return i ? Number(i.replace("px", "")) : 0;
}
function WY(i) {
  var e, t;
  return i && ae() ? (e = (t = fe()).getComputedStyle) === null || e === void 0 ? void 0 : e.call(t, i) : null;
}
function zY(i, e) {
  const t = WY(i);
  return t ? HY(t[`margin${ea(e)}`]) : 0;
}
const KY = (i) => Array.isArray(i) && i.every((e) => {
  const t = Object.keys(e).length === 2, n = "key" in e && "items" in e;
  return t && n && Array.isArray(e.items);
}), iA = {
  _getSpecificDataSourceOption() {
    let i = this.option("dataSource"), e = !1, t = {};
    return this._getGroupedOption() && KY(i) && (t = i.reduce((n, s) => {
      const o = s.items.map((r) => (X(r) || (r = {
        text: r
      }, e = !0), "key" in r || (r.key = s.key), r));
      return n.concat(o);
    }, []), i = {
      store: {
        type: "array",
        data: t
      },
      group: {
        selector: "key",
        keepInitialKeyOrder: !0
      }
    }, e && (i.searchExpr = "text")), i;
  }
};
class GY extends ga {
  _renderWatchers() {
    super._renderWatchers(), this._startWatcher("badge", this._renderBadge.bind(this)), this._startWatcher("showChevron", this._renderShowChevron.bind(this));
  }
  _renderBadge(e) {
    if (this._$element.children(".dx-list-item-badge-container").remove(), !e)
      return;
    const t = p("<div>").addClass("dx-list-item-badge-container").append(p("<div>").addClass("dx-list-item-badge").addClass("dx-badge").text(e)), n = this._$element.children(".dx-list-item-chevron-container").first();
    n.length > 0 ? t.insertBefore(n) : t.appendTo(this._$element);
  }
  _renderShowChevron(e) {
    if (this._$element.children(".dx-list-item-chevron-container").remove(), !e)
      return;
    const t = p("<div>").addClass("dx-list-item-chevron-container"), n = p("<div>").addClass("dx-list-item-chevron");
    t.append(n).appendTo(this._$element);
  }
}
const UY = "dx-list-select-checkbox", jY = "dx-list-select-radiobutton", qY = Be("items");
class _h extends sC {
  _supportedKeys() {
    const e = this, t = function(s) {
      let o = n(s);
      const {
        focusedElement: r
      } = e.option();
      o.is(r) && (function(l, d) {
        let u = l.position().top;
        d === "prev" && (u = l.position().top - le(e.$element()) + he(l)), e.scrollTo(u);
      }(o, s), o = n(s)), e.option("focusedElement", ee(o)), e.scrollToItem(o);
    };
    function n(s) {
      const o = e.scrollTop(), r = le(e.$element()), {
        focusedElement: a
      } = e.option();
      let l = p(a), d = !0;
      if (!l.length)
        return p();
      for (; d; ) {
        const u = l[s]();
        if (!u.length)
          break;
        const c = u.position().top + he(u) / 2;
        d = c < r + o && c > o, d && (l = u);
      }
      return l;
    }
    return I({}, super._supportedKeys(), {
      leftArrow: M,
      rightArrow: M,
      pageUp() {
        return t("prev"), !1;
      },
      pageDown() {
        return t("next"), !1;
      }
    });
  }
  _getDefaultOptions() {
    return I({}, super._getDefaultOptions(), {
      hoverStateEnabled: !0,
      pullRefreshEnabled: !1,
      scrollingEnabled: !0,
      selectByClick: !0,
      showScrollbar: "onScroll",
      useNativeScrolling: !0,
      bounceEnabled: !0,
      scrollByContent: !0,
      scrollByThumb: !1,
      pullingDownText: S.format("dxList-pullingDownText"),
      pulledDownText: S.format("dxList-pulledDownText"),
      refreshingText: S.format("dxList-refreshingText"),
      pageLoadingText: S.format("dxList-pageLoadingText"),
      onScroll: null,
      onPullRefresh: null,
      onPageLoading: null,
      pageLoadMode: "scrollBottom",
      nextButtonText: S.format("dxList-nextButtonText"),
      onItemSwipe: null,
      grouped: !1,
      onGroupRendered: null,
      collapsibleGroups: !1,
      groupTemplate: "group",
      indicateLoading: !0,
      activeStateEnabled: !0,
      _itemAttributes: {
        role: "option"
      },
      useInkRipple: !1,
      wrapItemText: !1,
      _swipeEnabled: !0,
      showChevronExpr: (e) => e?.showChevron,
      badgeExpr: (e) => e?.badge,
      _onItemsRendered: () => {
      }
    });
  }
  _defaultOptionsRules() {
    const e = pn();
    return super._defaultOptionsRules().concat(AO(), [{
      device: () => !tn.nativeScrolling,
      options: {
        useNativeScrolling: !1
      }
    }, {
      device: (t) => !tn.nativeScrolling && !z.isSimulator() && z.real().deviceType === "desktop" && t.platform === "generic",
      options: {
        showScrollbar: "onHover",
        pageLoadMode: "nextButton"
      }
    }, {
      device: () => z.real().deviceType === "desktop" && !z.isSimulator(),
      options: {
        focusStateEnabled: !0
      }
    }, {
      device: () => Zt(e),
      options: {
        useInkRipple: !0
      }
    }, {
      device: () => Gn(e),
      options: {
        pullingDownText: "",
        pulledDownText: "",
        refreshingText: "",
        pageLoadingText: ""
      }
    }]);
  }
  _visibilityChanged(e) {
    e && this._updateLoadingState(!0);
  }
  _itemClass() {
    return "dx-list-item";
  }
  _itemDataKey() {
    return "dxListItemData";
  }
  _itemContainer() {
    return this._$container;
  }
  _getItemsContainer() {
    return this._$listContainer;
  }
  _cleanItemContainer() {
    super._cleanItemContainer();
    const e = this._getItemsContainer();
    p(e).empty(), e.appendTo(this._$container);
  }
  _saveSelectionChangeEvent(e) {
    this._selectionChangeEventInstance = e;
  }
  _getSelectionChangeEvent() {
    return this._selectionChangeEventInstance;
  }
  _refreshItemElements() {
    const {
      grouped: e
    } = this.option(), t = this._getItemsContainer();
    e ? this._itemElementsCache = t.children(".dx-list-group").children(".dx-list-group-body").children(this._itemSelector()) : this._itemElementsCache = t.children(this._itemSelector());
  }
  _getItemAndHeaderElements() {
    const t = `${`> .dx-list-group-body > ${this._itemSelector()}`}, > .dx-list-group-header`;
    return this._getItemsContainer().children(".dx-list-group").find(t);
  }
  _getAvailableItems(e) {
    const {
      collapsibleGroups: t
    } = this.option();
    return t ? this._getItemAndHeaderElements().filter((o, r) => p(r).hasClass("dx-list-group-header") ? !0 : !p(r).closest(".dx-list-group").hasClass("dx-list-group-collapsed")) : super._getAvailableItems(e);
  }
  _modifyByChanges() {
    super._modifyByChanges.apply(this, arguments), this._refreshItemElements(), this._updateLoadingState(!0);
  }
  reorderItem(e, t) {
    return super.reorderItem(e, t).done(function() {
      this._refreshItemElements();
    });
  }
  deleteItem(e) {
    return super.deleteItem(e).done(function() {
      this._refreshItemElements();
    });
  }
  _itemElements() {
    return this._itemElementsCache;
  }
  _itemSelectHandler(e) {
    const {
      selectionMode: t
    } = this.option();
    if (t === "single" && this.isItemSelected(e.currentTarget))
      return;
    const s = p(e.target).closest(`.${UY}`).length || p(e.target).closest(`.${jY}`).length;
    return s && this.option("focusedElement", e.currentTarget), super._itemSelectHandler(e, s);
  }
  _allowDynamicItemsAppend() {
    return !0;
  }
  _updateActiveStateUnit() {
    const {
      collapsibleGroups: e
    } = this.option(), t = [".dx-list-item", ".dx-list-select-all"];
    e && t.push(".dx-list-group-header"), this._activeStateUnit = t.join(",");
  }
  _init() {
    super._init(), this._updateActiveStateUnit(), this._dataController.resetDataSourcePageIndex(), this._$container = this.$element(), this._$listContainer = p("<div>").addClass("dx-list-items"), this._initScrollView(), this._feedbackShowTimeout = 70, this._createGroupRenderAction();
  }
  _scrollBottomMode() {
    const {
      pageLoadMode: e
    } = this.option();
    return e === "scrollBottom";
  }
  _nextButtonMode() {
    const {
      pageLoadMode: e
    } = this.option();
    return e === "nextButton";
  }
  _dataSourceOptions() {
    const e = this._scrollBottomMode(), t = this._nextButtonMode();
    return x(super._dataSourceOptions(), {
      paginate: Qe(e || t, !0)
    });
  }
  _getGroupedOption() {
    return this.option("grouped");
  }
  _getGroupContainerByIndex(e) {
    return this._getItemsContainer().find(".dx-list-group").eq(e).find(".dx-list-group-body");
  }
  _dataSourceFromUrlLoadMode() {
    return "raw";
  }
  _initScrollView() {
    const e = this.option("scrollingEnabled"), t = e && this.option("pullRefreshEnabled"), n = e && this._scrollBottomMode() && !!this._dataController.getDataSource();
    this._scrollView = this._createComponent(this.$element(), YY(), {
      height: this.option("height"),
      width: this.option("width"),
      disabled: this.option("disabled") || !e,
      onScroll: this._scrollHandler.bind(this),
      onPullDown: t ? this._pullDownHandler.bind(this) : null,
      onReachBottom: n ? this._scrollBottomHandler.bind(this) : null,
      showScrollbar: this.option("showScrollbar"),
      useNative: this.option("useNativeScrolling"),
      bounceEnabled: this.option("bounceEnabled"),
      scrollByContent: this.option("scrollByContent"),
      scrollByThumb: this.option("scrollByThumb"),
      pullingDownText: this.option("pullingDownText"),
      pulledDownText: this.option("pulledDownText"),
      refreshingText: this.option("refreshingText"),
      reachBottomText: this.option("pageLoadingText"),
      useKeyboard: !1
    }), this._$container = p(this._scrollView.content()), this._$listContainer.appendTo(this._$container), this._toggleWrapItemText(this.option("wrapItemText")), this._createScrollViewActions();
  }
  _toggleWrapItemText(e) {
    this._$listContainer.toggleClass("dx-wrap-item-text", e);
  }
  _createScrollViewActions() {
    this._scrollAction = this._createActionByOption("onScroll"), this._pullRefreshAction = this._createActionByOption("onPullRefresh"), this._pageLoadingAction = this._createActionByOption("onPageLoading");
  }
  _scrollHandler(e) {
    var t;
    (t = this._scrollAction) === null || t === void 0 || t.call(this, e);
  }
  _initTemplates() {
    this._templateManager.addDefaultTemplates({
      group: new rr((e, t) => {
        pe(t) ? t.key && e.text(t.key) : e.text(String(t));
      }, ["key"], this.option("integrationOptions.watchMethod"))
    }), super._initTemplates();
  }
  _prepareDefaultItemTemplate(e, t) {
    if (super._prepareDefaultItemTemplate(e, t), e.icon) {
      const n = cs(e.icon).addClass("dx-list-item-icon"), s = p("<div>").addClass("dx-list-item-icon-container");
      s.append(n), t.prepend(s);
    }
  }
  _getBindableFields() {
    return ["text", "html", "icon"];
  }
  _updateLoadingState(e) {
    const t = this._dataController, n = this._scrollBottomMode() && e && !t.isLoading() && !this._isLastPage();
    this._shouldContinueLoading(n) ? this._infiniteDataLoading() : (this._scrollView.release(!n && !t.isLoading()), this._toggleNextButton(this._shouldRenderNextButton() && !this._isLastPage()), this._loadIndicationSuppressed(!1));
  }
  _shouldRenderNextButton() {
    return this._nextButtonMode() && this._dataController.isLoaded();
  }
  _isDataSourceFirstLoadCompleted(e) {
    return f(e) && (this._isFirstLoadCompleted = e), this._isFirstLoadCompleted;
  }
  _dataSourceLoadingChangedHandler(e) {
    if (!this._loadIndicationSuppressed()) {
      if (e && this.option("indicateLoading"))
        this._showLoadingIndicatorTimer = setTimeout(() => {
          if (!!this._itemElements().length || this._isDataSourceFirstLoadCompleted()) {
            var o;
            (o = this._scrollView) === null || o === void 0 || o.startLoading();
          }
        });
      else {
        var t;
        clearTimeout(this._showLoadingIndicatorTimer), (t = this._scrollView) === null || t === void 0 || t.finishLoading();
      }
      e || this._isDataSourceFirstLoadCompleted(!1);
    }
  }
  _dataSourceChangedHandler() {
    if (!this._shouldAppendItems() && ae()) {
      var e;
      (e = this._scrollView) === null || e === void 0 || e.scrollTo(0);
    }
    super._dataSourceChangedHandler.apply(this, arguments), this._isDataSourceFirstLoadCompleted(!0);
  }
  _refreshContent() {
    this._prepareContent(), this._fireContentReadyAction();
  }
  _hideLoadingIfLoadIndicationOff() {
    this.option("indicateLoading") || this._dataSourceLoadingChangedHandler(!1);
  }
  _loadIndicationSuppressed(e) {
    if (!arguments.length)
      return this._isLoadIndicationSuppressed;
    this._isLoadIndicationSuppressed = e;
  }
  _scrollViewIsFull() {
    const e = this._scrollView;
    return !e || le(e.content()) > le(e.container());
  }
  _pullDownHandler(e) {
    var t;
    (t = this._pullRefreshAction) === null || t === void 0 || t.call(this, e);
    const n = this._dataController;
    n.getDataSource() && !n.isLoading() ? (this._clearSelectedItems(), n.pageIndex(0), n.reload()) : this._updateLoadingState();
  }
  _shouldContinueLoading(e) {
    var t;
    const n = le(this._scrollView.content()) - le(this._scrollView.container()) < (((t = this._scrollView.scrollOffset()) === null || t === void 0 ? void 0 : t.top) ?? 0);
    return e && (!this._scrollViewIsFull() || n);
  }
  _infiniteDataLoading() {
    this.$element().is(":visible") && (clearTimeout(this._loadNextPageTimer), this._loadNextPageTimer = setTimeout(() => {
      this._loadNextPage();
    }));
  }
  _scrollBottomHandler(e) {
    var t;
    (t = this._pageLoadingAction) === null || t === void 0 || t.call(this, e), !this._dataController.isLoading() && !this._isLastPage() ? this._loadNextPage() : this._updateLoadingState();
  }
  _renderItems(e) {
    this.option("grouped") ? (y(e, this._renderGroup.bind(this)), this._attachGroupCollapseEvent(), this._renderEmptyMessage(), Zt() && this.attachGroupHeaderInkRippleEvents()) : super._renderItems.apply(this, arguments), this._refreshItemElements(), this._updateLoadingState(!0);
  }
  _postProcessRenderItems() {
    const {
      _onItemsRendered: e
    } = this.option();
    e?.();
  }
  _attachGroupCollapseEvent() {
    const {
      collapsibleGroups: e
    } = this.option(), t = R(Te, this.NAME), n = this.$element();
    n.toggleClass("dx-list-collapsible-groups", e), _.off(n, t, ".dx-list-group-header"), e && _.on(n, t, ".dx-list-group-header", (s) => {
      this._processGroupCollapse(s);
    });
  }
  _processGroupCollapse(e) {
    this._createAction((n) => {
      const {
        focusStateEnabled: s
      } = this.option(), o = p(n.event.currentTarget).parent();
      if (this._collapseGroupHandler(o), s) {
        const r = ee(o.find(".dx-list-group-header"));
        this.option({
          focusedElement: r
        });
      }
    }, {
      validatingTargetName: "element"
    })({
      event: e
    });
  }
  _enterKeyHandler(e) {
    const {
      collapsibleGroups: t,
      focusedElement: n
    } = this.option(), s = p(n).hasClass("dx-list-group-header");
    if (t && s) {
      const o = this._getHandlerExtendedParams(e, p(n));
      this._processGroupCollapse(o);
      return;
    }
    super._enterKeyHandler(e);
  }
  _collapseGroupHandler(e, t) {
    const n = w(), s = e.children(".dx-list-group-header"), o = e.hasClass("dx-list-group-collapsed");
    if (this._updateGroupHeaderAriaExpanded(s, o), o === t)
      return n.resolve();
    const r = e.children(".dx-list-group-body"), a = he(r);
    let l = 0;
    return a === 0 && (js(r, "auto"), l = he(r)), e.toggleClass("dx-list-group-collapsed", t), Le.animate(r, {
      type: "custom",
      from: {
        height: a
      },
      to: {
        height: l
      },
      duration: 200,
      complete: function() {
        this.updateDimensions(), this._updateLoadingState(!0), n.resolve();
      }.bind(this)
    }), n.promise();
  }
  _dataSourceLoadErrorHandler() {
    this._forgetNextPageLoading(), this._initialized && (this._renderEmptyMessage(), this._updateLoadingState());
  }
  _initMarkup() {
    this._itemElementsCache = p(), this.$element().addClass("dx-list"), super._initMarkup(), this.option("useInkRipple") && this._renderInkRipple();
    const e = {
      role: "group",
      roledescription: S.format("dxList-ariaRoleDescription")
    };
    this.setAria(e, this.$element()), this.setAria({
      role: "application"
    }, this._focusTarget()), this._setListAria();
  }
  _setListAria() {
    const {
      items: e,
      allowItemDeleting: t,
      collapsibleGroups: n
    } = this.option(), s = t ? S.format("dxList-listAriaLabel-deletable") : S.format("dxList-listAriaLabel"), o = e?.length && !n, r = {
      role: o ? "listbox" : void 0,
      label: o ? s : void 0
    };
    this.setAria(r, this._$listContainer);
  }
  _focusTarget() {
    return this._itemContainer();
  }
  _renderInkRipple() {
    this._inkRipple = w_();
  }
  _toggleActiveState(e, t, n) {
    super._toggleActiveState.apply(this, arguments);
    const s = this;
    if (!this._inkRipple)
      return;
    const o = {
      element: e,
      event: n
    };
    if (t)
      if (Zt())
        this._inkRippleTimer = setTimeout(() => {
          var a;
          (a = s._inkRipple) === null || a === void 0 || a.showWave(o);
        }, 35);
      else {
        var r;
        (r = s._inkRipple) === null || r === void 0 || r.showWave(o);
      }
    else
      clearTimeout(this._inkRippleTimer), this._inkRipple.hideWave(o);
  }
  _postprocessRenderItem(e) {
    this._refreshItemElements(), super._postprocessRenderItem.apply(this, arguments), this.option("_swipeEnabled") && this._attachSwipeEvent(p(e.itemElement));
  }
  _getElementClassToSkipRefreshId() {
    return "dx-list-group-header";
  }
  _attachSwipeEvent(e) {
    const t = R(iC, this.NAME);
    _.on(e, t, this._itemSwipeEndHandler.bind(this));
  }
  _itemSwipeEndHandler(e) {
    this._itemDXEventHandler(e, "onItemSwipe", {
      direction: e.offset < 0 ? "left" : "right"
    });
  }
  _nextButtonHandler(e) {
    var t;
    (t = this._pageLoadingAction) === null || t === void 0 || t.call(this, e);
    const n = this._dataController;
    if (n.getDataSource() && !n.isLoading()) {
      var s;
      this._scrollView.toggleLoading(!0), (s = this._$nextButton) === null || s === void 0 || s.detach(), this._loadIndicationSuppressed(!0), this._loadNextPage();
    }
  }
  _setGroupAria(e, t) {
    const {
      collapsibleGroups: n
    } = this.option(), s = {
      role: n ? void 0 : "group",
      labelledby: n ? void 0 : t
    };
    this.setAria(s, e);
  }
  _updateGroupHeaderAriaExpanded(e, t) {
    this.setAria({
      expanded: t
    }, e);
  }
  _setGroupHeaderAria(e, t) {
    const {
      collapsibleGroups: n
    } = this.option(), s = {
      role: n ? "button" : void 0,
      expanded: n ? !0 : void 0,
      controls: n ? t : void 0
    };
    this.setAria(s, e);
  }
  _setGroupBodyAria(e, t) {
    const {
      collapsibleGroups: n
    } = this.option(), s = {
      role: n ? "listbox" : void 0,
      labelledby: n ? t : void 0
    };
    this.setAria(s, e);
  }
  _renderGroup(e, t) {
    const n = p("<div>").addClass("dx-list-group").appendTo(this._getItemsContainer()), s = `dx-${new Xe().toString()}`, o = p("<div>").addClass("dx-list-group-header").attr("id", s).appendTo(n), {
      groupTemplate: r
    } = this.option(), a = this._getTemplate(t.template || r, t, e, o), l = {
      index: e,
      itemData: t,
      container: ee(o)
    };
    this._createItemByTemplate(a, l), p("<div>").addClass("dx-list-group-header-indicator").prependTo(o), this._renderingGroupIndex = e;
    const d = `dx-${new Xe().toString()}`, u = p("<div>").addClass("dx-list-group-body").attr("id", d).appendTo(n);
    y(qY(t) || [], (c, h) => {
      this._renderItem({
        group: e,
        item: c
      }, h, u);
    }), this._groupRenderAction({
      groupElement: ee(n),
      groupIndex: e,
      groupData: t
    }), this._setGroupAria(n, s), this._setGroupHeaderAria(o, d), this._setGroupBodyAria(u, s);
  }
  downInkRippleHandler(e) {
    this._toggleActiveState(p(e.currentTarget), !0, e);
  }
  upInkRippleHandler(e) {
    this._toggleActiveState(p(e.currentTarget), !1);
  }
  attachGroupHeaderInkRippleEvents() {
    const e = this.$element();
    this._downInkRippleHandler = this._downInkRippleHandler || this.downInkRippleHandler.bind(this), this._upInkRippleHandler = this._upInkRippleHandler || this.upInkRippleHandler.bind(this);
    const t = [e, "dxpointerdown", ".dx-list-group-header", this._downInkRippleHandler], n = [e, "dxpointerup dxpointerout", ".dx-list-group-header", this._upInkRippleHandler];
    _.off(...t), _.on(...t), _.off(...n), _.on(...n);
  }
  _createGroupRenderAction() {
    this._groupRenderAction = this._createActionByOption("onGroupRendered");
  }
  _clean() {
    clearTimeout(this._inkRippleTimer), this._$nextButton && (this._$nextButton.remove(), this._$nextButton = null), super._clean.apply(this, arguments);
  }
  _dispose() {
    this._isDataSourceFirstLoadCompleted(!1), clearTimeout(this._holdTimer), clearTimeout(this._loadNextPageTimer), clearTimeout(this._showLoadingIndicatorTimer), super._dispose();
  }
  _toggleDisabledState(e) {
    super._toggleDisabledState(e), this._scrollView.option("disabled", e || !this.option("scrollingEnabled"));
  }
  _toggleNextButton(e) {
    const t = this._dataController, n = this._getNextButton();
    this.$element().toggleClass("dx-has-next", e), e && t.isLoaded() && n.appendTo(this._itemContainer()), e || n.detach();
  }
  _getNextButton() {
    return this._$nextButton || (this._$nextButton = this._createNextButton()), this._$nextButton;
  }
  _createNextButton() {
    const e = p("<div>").addClass("dx-list-next-button"), t = p("<div>").appendTo(e);
    return this._createComponent(t, wt, {
      text: this.option("nextButtonText"),
      onClick: this._nextButtonHandler.bind(this),
      type: Gn() ? "default" : void 0,
      integrationOptions: {}
    }), e;
  }
  _moveFocus() {
    super._moveFocus.apply(this, arguments), this.scrollToItem(this.option("focusedElement"));
  }
  _refresh() {
    if (!ae())
      super._refresh();
    else {
      const e = this._scrollView.scrollTop();
      super._refresh(), e && this._scrollView.scrollTo(e);
    }
  }
  _optionChanged(e) {
    switch (e.name) {
      case "pageLoadMode":
        this._toggleNextButton(e.value), this._initScrollView();
        break;
      case "dataSource":
        super._optionChanged(e), this._initScrollView(), this._updateLoadingState(!0), this._isDataSourceFirstLoadCompleted(!1);
        break;
      case "items":
        super._optionChanged(e), this._isDataSourceFirstLoadCompleted(!1);
        break;
      case "pullingDownText":
      case "pulledDownText":
      case "refreshingText":
      case "pageLoadingText":
      case "showScrollbar":
      case "bounceEnabled":
      case "scrollByContent":
      case "scrollByThumb":
      case "useNativeScrolling":
      case "scrollingEnabled":
      case "pullRefreshEnabled":
        this._initScrollView(), this._updateLoadingState(!0);
        break;
      case "nextButtonText":
      case "onItemSwipe":
      case "useInkRipple":
      case "grouped":
      case "groupTemplate":
      case "showChevronExpr":
      case "badgeExpr":
        this._invalidate();
        break;
      case "onScroll":
      case "onPullRefresh":
      case "onPageLoading":
        this._createScrollViewActions();
        break;
      case "collapsibleGroups":
        this._updateActiveStateUnit(), this._invalidate();
        break;
      case "wrapItemText":
        this._toggleWrapItemText(e.value);
        break;
      case "onGroupRendered":
        this._createGroupRenderAction();
        break;
      case "width":
      case "height":
        super._optionChanged(e), this._scrollView.option(e.name, e.value), this._scrollView.update();
        break;
      case "indicateLoading":
        this._hideLoadingIfLoadIndicationOff();
        break;
      case "visible":
        super._optionChanged(e), this._scrollView.update();
        break;
      case "rtlEnabled":
        this._initScrollView(), super._optionChanged(e);
        break;
      case "_swipeEnabled":
      case "_onItemsRendered":
      case "selectByClick":
        break;
      default:
        super._optionChanged(e);
    }
  }
  _extendActionArgs(e) {
    if (!this.option("grouped"))
      return super._extendActionArgs(e);
    const t = e.closest(".dx-list-group"), n = t.find(".dx-list-item");
    return x(super._extendActionArgs(e), {
      itemIndex: {
        group: t.index(),
        item: n.index(e)
      }
    });
  }
  expandGroup(e) {
    const t = w(), n = this._getItemsContainer().find(".dx-list-group").eq(e);
    return this._collapseGroupHandler(n, !1).done(() => {
      t.resolveWith(this);
    }), t.promise();
  }
  collapseGroup(e) {
    const t = w(), n = this._getItemsContainer().find(".dx-list-group").eq(e);
    return this._collapseGroupHandler(n, !0).done(() => {
      t.resolveWith(this);
    }), t;
  }
  updateDimensions() {
    const e = this, t = w();
    return e._scrollView ? e._scrollView.update().done(() => {
      !e._scrollViewIsFull() && e._updateLoadingState(!0), t.resolveWith(e);
    }) : t.resolveWith(e), t.promise();
  }
  reload() {
    super.reload(), this.scrollTo(0), this._pullDownHandler();
  }
  repaint() {
    this.scrollTo(0), super.repaint();
  }
  scrollTop() {
    return this._scrollView.scrollOffset().top;
  }
  clientHeight() {
    return this._scrollView.clientHeight();
  }
  scrollHeight() {
    return this._scrollView.scrollHeight();
  }
  scrollBy(e) {
    this._scrollView.scrollBy(e);
  }
  scrollTo(e) {
    this._scrollView.scrollTo(e);
  }
  scrollToItem(e) {
    const t = this._editStrategy.getItemElement(e), n = t?.get(0);
    this._scrollView.scrollToElement(n, {
      bottom: zY(n, "bottom")
    });
  }
  _dimensionChanged() {
    this.updateDimensions();
  }
}
_h.include(iA);
_h.ItemClass = GY;
function YY() {
  return nA;
}
class XY extends _h {
  _init() {
    super._init(), this._activeStateUnit = ".dx-toolbar-menu-action:not(.dx-toolbar-hidden-button-group)";
  }
  _initMarkup() {
    this._renderSections(), super._initMarkup(), this._setMenuRole();
  }
  _getSections() {
    return this._itemContainer().children();
  }
  _itemElements() {
    return this._getSections().children(this._itemSelector());
  }
  _renderSections() {
    const e = this._itemContainer();
    y(["before", "center", "after", "menu"], (t, n) => {
      const s = `_$${n}Section`;
      this[s] || (this[s] = p("<div>").addClass("dx-toolbar-menu-section")), this[s].appendTo(e);
    });
  }
  _renderItems() {
    super._renderItems.apply(this, arguments), this._updateSections();
  }
  _setMenuRole() {
    this.$element().find(".dx-scrollview-content").attr("role", "menu");
  }
  _updateSections() {
    const e = this.$element().find(".dx-toolbar-menu-section");
    e.removeClass("dx-toolbar-menu-last-section"), e.not(":empty").eq(-1).addClass("dx-toolbar-menu-last-section");
  }
  _renderItem(e, t, n, s) {
    const o = t.location ?? "menu", r = this[`_$${o}Section`], a = super._renderItem(e, t, r, s);
    return this._getItemTemplateName({
      itemData: t
    }) && a.addClass("dx-toolbar-menu-custom"), (o === "menu" || t.widget === "dxButton" || t.widget === "dxButtonGroup" || t.isAction) && a.addClass("dx-toolbar-menu-action"), t.widget === "dxButton" && a.addClass("dx-toolbar-hidden-button"), t.widget === "dxButtonGroup" && a.addClass("dx-toolbar-hidden-button-group"), a.addClass(t.cssClass), a;
  }
  _getItemTemplateName(e) {
    const t = super._getItemTemplateName(e), n = e.itemData;
    return n?.menuItemTemplate || t;
  }
  _dataSourceOptions() {
    return {
      paginate: !1
    };
  }
  _itemClickHandler(e, t, n) {
    p(e.target).closest(".dx-toolbar-menu-action").length && super._itemClickHandler(e, t, n);
  }
  _clean() {
    this._getSections().empty(), super._clean();
  }
}
class ZY extends Rt {
  _supportedKeys() {
    var e;
    let t = {};
    return (!this.option("opened") || !((e = this._list) !== null && e !== void 0 && e.option("focusedElement"))) && (t = this._button._supportedKeys()), x(super._supportedKeys(), t, {
      tab() {
        var n;
        (n = this._popup) === null || n === void 0 || n.hide();
      }
    });
  }
  _getDefaultOptions() {
    return I({}, super._getDefaultOptions(), {
      items: [],
      onItemClick: null,
      dataSource: null,
      itemTemplate: "item",
      onButtonClick: null,
      activeStateEnabled: !0,
      hoverStateEnabled: !0,
      opened: !1,
      onItemRendered: null,
      closeOnClick: !0,
      useInkRipple: !1,
      container: void 0,
      animation: {
        show: {
          type: "fade",
          from: 0,
          to: 1
        },
        hide: {
          type: "fade",
          to: 0
        }
      }
    });
  }
  _defaultOptionsRules() {
    return super._defaultOptionsRules().concat([{
      device: () => z.real().deviceType === "desktop" && !z.isSimulator(),
      options: {
        focusStateEnabled: !0
      }
    }, {
      device: () => Gn(),
      options: {
        useInkRipple: !0,
        animation: {
          show: {
            type: "pop",
            duration: 200,
            from: {
              scale: 0
            },
            to: {
              scale: 1
            }
          },
          hide: {
            type: "pop",
            duration: 200,
            from: {
              scale: 1
            },
            to: {
              scale: 0
            }
          }
        }
      }
    }]);
  }
  _init() {
    super._init(), this.$element().addClass("dx-dropdownmenu"), this._initItemClickAction(), this._initButtonClickAction();
  }
  _initItemClickAction() {
    this._itemClickAction = this._createActionByOption("onItemClick", {});
  }
  _initButtonClickAction() {
    this._buttonClickAction = this._createActionByOption("onButtonClick", {});
  }
  _initTemplates() {
    this._templateManager.addDefaultTemplates({
      content: new T_("content")
    }), super._initTemplates();
  }
  _initMarkup() {
    this._renderButton(), super._initMarkup();
  }
  _render() {
    super._render(), this.setAria({
      haspopup: !0,
      expanded: this.option("opened")
    });
  }
  _renderContentImpl() {
    this.option("opened") && this._renderPopup();
  }
  _clean() {
    var e, t;
    this._cleanFocusState(), (e = this._list) === null || e === void 0 || e.$element().remove(), (t = this._popup) === null || t === void 0 || t.$element().remove(), delete this._list, delete this._popup;
  }
  _renderButton() {
    const e = this.$element().addClass("dx-dropdownmenu-button");
    this._button = this._createComponent(e, wt, {
      icon: "overflow",
      template: "content",
      stylingMode: nn() ? "text" : "contained",
      useInkRipple: this.option("useInkRipple"),
      hoverStateEnabled: !1,
      focusStateEnabled: !1,
      onClick: (t) => {
        this.option("opened", !this.option("opened")), this._buttonClickAction(t);
      }
    });
  }
  _toggleActiveState(e, t, n) {
    this._button._toggleActiveState(e, t, n);
  }
  _toggleMenuVisibility(e) {
    var t, n;
    const s = e ?? !((t = this._popup) !== null && t !== void 0 && t.option("visible"));
    e && this._renderPopup(), (n = this._popup) === null || n === void 0 || n.toggle(s), this.setAria("expanded", s);
  }
  _renderPopup() {
    if (this._$popup)
      return;
    this._$popup = p("<div>").appendTo(this.$element());
    const {
      rtlEnabled: e,
      container: t,
      animation: n
    } = this.option();
    this._popup = this._createComponent(this._$popup, "dxPopup", {
      onInitialized(s) {
        let {
          component: o
        } = s;
        o.$wrapper().addClass("dx-dropdownmenu-popup-wrapper").addClass("dx-dropdownmenu-popup");
      },
      deferRendering: !1,
      preventScrollEvents: !1,
      contentTemplate: (s) => this._renderList(s),
      _ignoreFunctionValueDeprecation: !0,
      maxHeight: () => this._getMaxHeight(),
      position: {
        my: "top " + (e ? "left" : "right"),
        at: "bottom " + (e ? "left" : "right"),
        collision: "fit flip",
        offset: {
          v: 3
        },
        of: this.$element()
      },
      animation: n,
      onOptionChanged: (s) => {
        let {
          name: o,
          value: r
        } = s;
        o === "visible" && this.option("opened", r);
      },
      container: t,
      autoResizeEnabled: !1,
      height: "auto",
      width: "auto",
      hideOnOutsideClick: (s) => this._closeOutsideDropDownHandler(s),
      hideOnParentScroll: !0,
      shading: !1,
      dragEnabled: !1,
      showTitle: !1,
      fullScreen: !1,
      _fixWrapperPosition: !0
    });
  }
  _getMaxHeight() {
    const e = this.$element(), t = e.offset().top, n = he(fe()), s = Math.max(t, n - t - he(e));
    return Math.min(n, s - 3 - 10);
  }
  _closeOutsideDropDownHandler(e) {
    return !p(e.target).closest(this.$element()).length;
  }
  _renderList(e) {
    const t = p(e);
    t.addClass("dx-dropdownmenu-list");
    const {
      itemTemplate: n,
      onItemRendered: s
    } = this.option();
    this._list = this._createComponent(t, XY, {
      dataSource: this._getListDataSource(),
      pageLoadMode: "scrollBottom",
      indicateLoading: !1,
      noDataText: "",
      itemTemplate: n,
      onItemClick: (o) => {
        this.option("closeOnClick") && this.option("opened", !1), this._itemClickAction(o);
      },
      tabIndex: -1,
      focusStateEnabled: !1,
      activeStateEnabled: !0,
      onItemRendered: s,
      _itemAttributes: {
        role: "menuitem"
      }
    });
  }
  _itemOptionChanged(e, t, n) {
    var s;
    (s = this._list) === null || s === void 0 || s._itemOptionChanged(e, t, n), yc(this._list, e);
  }
  _getListDataSource() {
    return this.option("dataSource") ?? this.option("items");
  }
  _setListDataSource() {
    var e;
    (e = this._list) === null || e === void 0 || e.option("dataSource", this._getListDataSource()), delete this._deferRendering;
  }
  _getKeyboardListeners() {
    return super._getKeyboardListeners().concat([this._list]);
  }
  _toggleVisibility(e) {
    var t;
    super._toggleVisibility(e), (t = this._button) === null || t === void 0 || t.option("visible", e);
  }
  _optionChanged(e) {
    var t, n, s;
    const {
      name: o,
      value: r
    } = e;
    switch (o) {
      case "items":
      case "dataSource":
        this.option("opened") ? this._setListDataSource() : this._deferRendering = !0;
        break;
      case "itemTemplate":
        (t = this._list) === null || t === void 0 || t.option(o, this._getTemplate(r));
        break;
      case "onItemClick":
        this._initItemClickAction();
        break;
      case "onButtonClick":
        this._buttonClickAction();
        break;
      case "useInkRipple":
        this._invalidate();
        break;
      case "focusStateEnabled":
        (n = this._list) === null || n === void 0 || n.option(o, r), super._optionChanged(e);
        break;
      case "onItemRendered":
        (s = this._list) === null || s === void 0 || s.option(o, r);
        break;
      case "opened":
        this._deferRendering && this._setListDataSource(), this._toggleMenuVisibility(r), this._updateFocusableItemsTabIndex();
        break;
      case "closeOnClick":
        break;
      case "container":
        this._popup && this._popup.option(o, r);
        break;
      case "disabled":
        this._list && this._updateFocusableItemsTabIndex();
        break;
      default:
        super._optionChanged(e);
    }
  }
  _updateFocusableItemsTabIndex() {
    this.option("items").forEach((e) => yc(this._list, e));
  }
}
const Pp = "dx-toolbar-item-invisible";
class QY {
  constructor(e) {
    this._toolbar = e;
  }
  _initMarkup() {
    ft(() => {
      this._renderOverflowMenu(), this._renderMenuItems();
    });
  }
  _renderOverflowMenu() {
    if (!this._hasVisibleMenuItems())
      return;
    this._renderMenuButtonContainer();
    const e = p("<div>").appendTo(this._overflowMenuContainer()), t = this._toolbar._createActionByOption("onItemClick"), n = this._toolbar._getTemplateByOption("menuItemTemplate"), {
      disabled: s,
      menuContainer: o
    } = this._toolbar.option();
    this._menu = this._toolbar._createComponent(e, ZY, {
      disabled: s,
      itemTemplate: () => n,
      onItemClick: (r) => {
        t(r);
      },
      container: o,
      onOptionChanged: (r) => {
        let {
          name: a,
          value: l
        } = r;
        a === "opened" && this._toolbar.option("overflowMenuVisible", l), a === "items" && this._updateMenuVisibility(l);
      }
    });
  }
  renderMenuItems() {
    var e;
    this._menu || this._renderOverflowMenu(), (e = this._menu) === null || e === void 0 || e.option("items", this._getMenuItems()), this._menu && !this._menu.option("items").length && this._menu.option("opened", !1);
  }
  _renderMenuButtonContainer() {
    this._$overflowMenuContainer = p("<div>").appendTo(this._toolbar._$afterSection).addClass("dx-toolbar-button").addClass("dx-toolbar-menu-container");
  }
  _overflowMenuContainer() {
    return this._$overflowMenuContainer;
  }
  _updateMenuVisibility(e) {
    const t = e ?? this._getMenuItems(), n = t.length && this._hasVisibleMenuItems(t);
    this._toggleMenuVisibility(n);
  }
  _toggleMenuVisibility(e) {
    this._overflowMenuContainer() && this._overflowMenuContainer().toggleClass("dx-state-invisible", !e);
  }
  _renderMenuItems() {
    ft(() => {
      this.renderMenuItems();
    });
  }
  _dimensionChanged() {
    this.renderMenuItems();
  }
  _getToolbarItems() {
    return Wt(this._toolbar.option("items") ?? [], (e) => !this._toolbar._isMenuItem(e));
  }
  _getHiddenItems() {
    return this._toolbar._itemContainer().children(`.dx-toolbar-item-auto-hide.${Pp}`).not(".dx-state-invisible");
  }
  _getMenuItems() {
    const e = Wt(this._toolbar.option("items") ?? [], (s) => this._toolbar._isMenuItem(s)), t = this._getHiddenItems();
    return this._restoreItems = this._restoreItems ?? [], [...[].slice.call(t).map((s) => {
      const o = this._toolbar._getItemData(s), r = p(s), a = r.children();
      return x({
        menuItemTemplate: () => (this._restoreItems.push({
          container: r,
          item: a
        }), p("<div>").addClass("dx-toolbar-item-auto-hide").append(a))
      }, o);
    }), ...e];
  }
  _hasVisibleMenuItems(e) {
    const t = e ?? this._toolbar.option("items");
    let n = !1;
    const s = Be("visible"), o = Be("locateInMenu");
    return y(t, (r, a) => {
      const l = s(a, {
        functionsAsIs: !0
      }), d = o(a, {
        functionsAsIs: !0
      });
      (l !== !1 && (d === "auto" || d === "always") || a.location === "menu") && (n = !0);
    }), n;
  }
  _arrangeItems() {
    this._toolbar._$centerSection.css({
      margin: "0 auto",
      float: "none"
    }), y(this._restoreItems ?? [], (t, n) => {
      p(n.container).append(n.item);
    }), this._restoreItems = [];
    const e = ne(this._toolbar.$element());
    return this._hideOverflowItems(e), e;
  }
  _hideOverflowItems(e) {
    const t = this._toolbar.$element().find(".dx-toolbar-item-auto-hide");
    if (!t.length)
      return;
    const n = e ?? ne(this._toolbar.$element());
    p(t).removeClass(Pp);
    let s = this._getItemsWidth();
    for (; t.length && n < s; )
      t.eq(-1).addClass(Pp), s = this._getItemsWidth(), t.splice(-1, 1);
  }
  _getItemsWidth() {
    return this._toolbar._getSummaryItemsSize("width", [this._toolbar._$beforeSection, this._toolbar._$centerSection, this._toolbar._$afterSection]);
  }
  _itemOptionChanged(e, t, n) {
    if ((t === "disabled" || t === "options.disabled") && this._toolbar._isMenuItem(e)) {
      var s;
      (s = this._menu) === null || s === void 0 || s._itemOptionChanged(e, t, n);
      return;
    }
    this.renderMenuItems();
  }
  _renderItem(e, t) {
    e.locateInMenu === "auto" && t.addClass("dx-toolbar-item-auto-hide");
  }
  _optionChanged(e, t) {
    var n, s, o, r, a;
    switch (e) {
      case "disabled":
        (n = this._menu) === null || n === void 0 || n.option(e, t);
        break;
      case "overflowMenuVisible":
        (s = this._menu) === null || s === void 0 || s.option("opened", t);
        break;
      case "onItemClick":
        (o = this._menu) === null || o === void 0 || o.option(e, t);
        break;
      case "menuContainer":
        (r = this._menu) === null || r === void 0 || r.option("container", t);
        break;
      case "menuItemTemplate":
        (a = this._menu) === null || a === void 0 || a.option("itemTemplate", t);
    }
  }
}
class sA extends YO {
  _getDefaultOptions() {
    return I({}, super._getDefaultOptions(), {
      menuItemTemplate: "menuItem",
      menuContainer: void 0,
      overflowMenuVisible: !1,
      multiline: !1
    });
  }
  _isMultiline() {
    return this.option("multiline");
  }
  _dimensionChanged(e) {
    e !== "height" && (super._dimensionChanged(), this._layoutStrategy._dimensionChanged());
  }
  _initMarkup() {
    super._initMarkup(), this._updateFocusableItemsTabIndex(), this._layoutStrategy._initMarkup();
  }
  _renderToolbar() {
    super._renderToolbar(), this._renderLayoutStrategy();
  }
  _itemContainer() {
    return this._isMultiline() ? this._$toolbarItemsContainer : super._itemContainer();
  }
  _renderLayoutStrategy() {
    this.$element().toggleClass("dx-toolbar-multiline", this._isMultiline()), this._layoutStrategy = this._isMultiline() ? new _Y(this) : new QY(this);
  }
  _renderSections() {
    if (!this._isMultiline())
      return super._renderSections();
  }
  _postProcessRenderItems() {
    this._layoutStrategy._hideOverflowItems(), this._layoutStrategy._updateMenuVisibility(), super._postProcessRenderItems(), this._layoutStrategy._renderMenuItems();
  }
  _renderItem(e, t, n, s) {
    const o = super._renderItem(e, t, n, s);
    this._layoutStrategy._renderItem(t, o);
    const {
      widget: r,
      showText: a
    } = t;
    return r === "dxButton" && a === "inMenu" && o.toggleClass("dx-toolbar-text-auto-hide"), o;
  }
  _getItemsWidth() {
    return this._layoutStrategy._getItemsWidth();
  }
  _getMenuItems() {
    return this._layoutStrategy._getMenuItems();
  }
  _getToolbarItems() {
    return this._layoutStrategy._getToolbarItems();
  }
  _arrangeItems() {
    if (this.$element().is(":hidden"))
      return;
    const e = this._layoutStrategy._arrangeItems();
    this._isMultiline() || super._arrangeItems(e);
  }
  _itemOptionChanged(e, t, n, s) {
    this._isMenuItem(e) || super._itemOptionChanged(e, t, n, s), this._layoutStrategy._itemOptionChanged(e, t, n), (t === "disabled" || t === "options.disabled") && yc(this, e), t === "location" && this.repaint();
  }
  _updateFocusableItemsTabIndex() {
    this._getToolbarItems().forEach((e) => yc(this, e));
  }
  _isMenuItem(e) {
    return e.location === "menu" || e.locateInMenu === "always";
  }
  _isToolbarItem(e) {
    return e.location === void 0 || e.locateInMenu === "never";
  }
  _optionChanged(e) {
    const {
      name: t,
      value: n
    } = e;
    switch (this._layoutStrategy._optionChanged(t, n), t) {
      case "menuContainer":
      case "menuItemTemplate":
      case "overflowMenuVisible":
        break;
      case "multiline":
        this._invalidate();
        break;
      case "disabled":
        super._optionChanged(e), this._updateFocusableItemsTabIndex();
        break;
      default:
        super._optionChanged(e);
    }
  }
  updateDimensions() {
    this._dimensionChanged();
  }
}
xe("dxToolbar", sA);
const Xb = ["addRowButton", "applyFilterButton", "columnChooserButton", "exportButton", "groupPanel", "revertButton", "saveButton", "searchPanel"];
class JY extends Cd {
  init() {
    super.init(), this._editingController = this.getController("editing"), this._headerFilterController = this.getController("headerFilter"), this.createAction("onToolbarPreparing", {
      excludeValidators: ["disabled", "readOnly"]
    });
  }
  _getToolbarItems() {
    return [];
  }
  _getButtonContainer() {
    return p("<div>").addClass(this.addWidgetPrefix("toolbar-button"));
  }
  _getToolbarButtonClass(e) {
    const t = e ? ` ${e}` : "";
    return this.addWidgetPrefix("toolbar-button") + t;
  }
  _getToolbarOptions() {
    const e = this.option("toolbar"), t = {
      toolbarOptions: {
        items: this._getToolbarItems(),
        visible: e?.visible,
        disabled: e?.disabled,
        onItemRendered(s) {
          const o = s.itemData.onItemRendered;
          o && o(s);
        }
      }
    }, n = e?.items;
    if (t.toolbarOptions.items = this._normalizeToolbarItems(t.toolbarOptions.items, n), this.executeAction("onToolbarPreparing", t), t.toolbarOptions && !f(t.toolbarOptions.visible)) {
      const s = t.toolbarOptions.items;
      t.toolbarOptions.visible = !!(s != null && s.length);
    }
    return t.toolbarOptions;
  }
  _normalizeToolbarItems(e, t) {
    e.forEach((a) => {
      if (!Xb.includes(a.name))
        throw new Error(`Default toolbar item '${a.name}' is not added to DEFAULT_TOOLBAR_ITEM_NAMES`);
    });
    const n = {
      location: "after"
    }, s = Array.isArray(t);
    if (!f(t))
      return e;
    s || (t = [t]);
    const o = {};
    e.forEach((a) => {
      o[a.name] = a;
    });
    const r = t.map((a) => (te(a) && (a = {
      name: a
    }), f(a.name) && (f(o[a.name]) ? a = x(!0, {}, o[a.name], a) : Xb.includes(a.name) && (a = I({}, a, {
      visible: !1
    }))), x(!0, {}, n, a)));
    return s ? r : r[0];
  }
  _renderCore() {
    if (this._toolbar)
      this._toolbar.option(this._toolbarOptions);
    else {
      const e = this.element();
      e.addClass(this.addWidgetPrefix("header-panel"));
      const t = S.format(this.component.NAME + "-ariaToolbar"), n = p("<div>").attr("aria-label", t).appendTo(e);
      this._toolbar = this._createComponent(n, sA, this._toolbarOptions);
    }
  }
  _columnOptionChanged() {
  }
  _handleDataChanged() {
    this._requireReady && this.render();
  }
  _isDisabledDefinedByUser(e) {
    var t;
    const n = (t = this.option("toolbar")) === null || t === void 0 ? void 0 : t.items, s = n?.find((o) => o?.name === e);
    return f(s?.disabled);
  }
  render() {
    this._toolbarOptions = this._getToolbarOptions(), super.render.apply(this, arguments);
  }
  setToolbarItemDisabled(e, t) {
    const n = this._toolbar, s = this._isDisabledDefinedByUser(e);
    if (!n || s)
      return;
    const r = (n.option("items") ?? []).findIndex((l) => l.name === e);
    if (r < 0)
      return;
    const a = n.option(`items[${r}]`);
    n.option(`items[${r}].disabled`, t), a.options && n.option(`items[${r}].options.disabled`, t);
  }
  updateToolbarDimensions() {
    var e;
    (e = this._toolbar) === null || e === void 0 || e.updateDimensions();
  }
  getHeaderPanel() {
    return this.element();
  }
  getHeight() {
    return this.getElementHeight();
  }
  optionChanged(e) {
    if (e.name === "onToolbarPreparing" && (this._invalidate(), e.handled = !0), e.name === "toolbar") {
      const o = Jo(e.fullName), r = e.fullName.replace(/^toolbar\./, "");
      if (o.length === 1 || o[1] === "visible")
        this._invalidate();
      else if (o[1] === "items") {
        if (o.length === 2)
          this._invalidate();
        else if (o.length === 3) {
          var t;
          const a = this._normalizeToolbarItems(this._getToolbarItems(), e.value);
          (t = this._toolbar) === null || t === void 0 || t.option(r, a);
        } else if (o.length >= 4) {
          var n;
          (n = this._toolbar) === null || n === void 0 || n.option(r, e.value);
        }
      } else {
        var s;
        (s = this._toolbar) === null || s === void 0 || s.option(r, e.value);
      }
      e.handled = !0;
    }
    super.optionChanged(e);
  }
  isVisible() {
    return !!(this._toolbarOptions && this._toolbarOptions.visible);
  }
  allowDragging() {
  }
  hasGroupedColumns() {
  }
}
const e5 = (i) => class extends i {
  _updateDimensionsCore() {
    super._updateDimensionsCore.apply(this, arguments), this.getView("headerPanel").updateToolbarDimensions();
  }
}, oA = {
  defaultOptions: () => ({}),
  views: {
    headerPanel: JY
  },
  extenders: {
    controllers: {
      resizing: e5
    }
  }
};
oA.views.headerPanel;
J.registerModule("headerPanel", oA);
class t5 extends Rt {
  _getDefaultOptions() {
    const e = super._getDefaultOptions();
    return y(this.getGridCoreHelper().modules, function() {
      B(this.defaultOptions) && x(!0, e, this.defaultOptions());
    }), e;
  }
  _init() {
    this._activeStateUnit = ".dx-row", super._init();
  }
  _setDeprecatedOptions() {
    super._setDeprecatedOptions(), x(this._deprecatedOptions, {
      "columnChooser.allowSearch": {
        since: "23.1",
        message: 'Use the "columnChooser.search.enabled" option instead'
      },
      "columnChooser.searchTimeout": {
        since: "23.1",
        message: 'Use the "columnChooser.search.timeout" option instead'
      }
    });
  }
  _clean() {
  }
  _optionChanged(e) {
    this.getGridCoreHelper().callModuleItemsMethod(this, "optionChanged", [e]), e.handled || super._optionChanged(e);
  }
  _dimensionChanged() {
    this.updateDimensions(!0);
  }
  _visibilityChanged(e) {
    e && this.updateDimensions();
  }
  _renderContentImpl() {
    this.getView("gridView").update();
  }
  _renderContent() {
    const e = this;
    ft(() => {
      e._renderContentImpl();
    });
  }
  _dispose() {
    super._dispose(), this.getGridCoreHelper().callModuleItemsMethod(this, "dispose");
  }
  isReady() {
    return this.getController("data").isReady();
  }
  getController(e) {
    return this._controllers[e];
  }
  getView(e) {
    return this._views[e];
  }
  getGridCoreHelper() {
  }
  beginUpdate() {
    super.beginUpdate(), this.getGridCoreHelper().callModuleItemsMethod(this, "beginUpdate");
  }
  endUpdate() {
    this.getGridCoreHelper().callModuleItemsMethod(this, "endUpdate"), super.endUpdate();
  }
}
const n5 = "Specifying grid templates with the jQuery selector name is now deprecated. Use the DOM Node or the jQuery object that references this selector instead.";
J.registerModulesOrder(["stateStoring", "columns", "selection", "editorFactory", "columnChooser", "grouping", "editing", "editingRowBased", "editingFormBased", "editingCellBased", "masterDetail", "validating", "adaptivity", "data", "virtualScrolling", "columnHeaders", "filterRow", "headerPanel", "headerFilter", "sorting", "search", "rows", "pager", "columnsResizingReordering", "contextMenu", "keyboardNavigation", "errorHandling", "summary", "columnFixing", "export", "gridView"]);
class rA extends t5 {
  _defaultOptionsRules() {
    return super._defaultOptionsRules().concat([{
      device: {
        platform: "ios"
      },
      options: {
        showRowLines: !0
      }
    }, {
      device: () => Gn(),
      options: {
        showRowLines: !0,
        showColumnLines: !1,
        headerFilter: {
          height: 315
        },
        editing: {
          useIcons: !0
        },
        selection: {
          showCheckBoxesMode: "always"
        }
      }
    }, {
      device: () => ze.webkit,
      options: {
        loadingTimeout: 30,
        loadPanel: {
          animation: {
            show: {
              easing: "cubic-bezier(1, 0, 1, 0)",
              duration: 500,
              from: {
                opacity: 0
              },
              to: {
                opacity: 1
              }
            }
          }
        }
      }
    }, {
      device: (e) => e.deviceType !== "desktop",
      options: {
        grouping: {
          expandMode: "rowClick"
        }
      }
    }]);
  }
  _init() {
    super._init(), F.logHeaderFilterDeprecatedWarningIfNeed(this), J.processModules(this, J), J.callModuleItemsMethod(this, "init");
  }
  _initMarkup() {
    super._initMarkup.apply(this, arguments), this.getView("gridView").render(this.$element());
  }
  _setDeprecatedOptions() {
    super._setDeprecatedOptions(), x(this._deprecatedOptions, {
      useKeyboard: {
        since: "19.2",
        alias: "keyboardNavigation.enabled"
      },
      rowTemplate: {
        since: "21.2",
        message: 'Use the "dataRowTemplate" option instead'
      }
    });
  }
  static registerModule(e, t) {
    J.registerModule(e, t);
  }
  getGridCoreHelper() {
    return J;
  }
  _getTemplate(e) {
    let t = e;
    return te(t) && t.startsWith("#") && (t = p(e), Kc.warn(n5)), super._getTemplate(t);
  }
  focus(e) {
    this.getController("keyboardNavigation").focus(e);
  }
}
xe("dxDataGrid", rA);
const i5 = /^(\d{4})-(\d{2})-(\d{2})T(\d{2}):(\d{2}):(\d{2}(?:\.\d*)?)Z$/, aA = function(i) {
  i && y(i, (e, t) => {
    if (pe(t) || Array.isArray(t))
      aA(t);
    else if (typeof t == "string") {
      const n = i5.exec(t);
      n && (i[e] = new Date(Date.UTC(+n[1], +n[2] - 1, +n[3], +n[4], +n[5], +n[6])));
    }
  });
}, Zb = function(i) {
  const e = i.type === "sessionStorage" ? WI() : fe().localStorage;
  if (!e)
    throw new Error("E1007");
  return e;
}, Qb = function(i) {
  return f(i.storageKey) ? i.storageKey : "storage";
};
class s5 extends Ue.ViewController {
  getDataController() {
    return this.getController("data");
  }
  getExportController() {
    return this.getController("export");
  }
  getColumnsController() {
    return this.getController("columns");
  }
  init() {
    return this._state = {}, this._isLoaded = !1, this._isLoading = !1, this._windowUnloadHandler = () => {
      this._savingTimeoutID !== void 0 && this._saveState(this.state());
    }, _.on(fe(), "visibilitychange", this._windowUnloadHandler), this;
  }
  optionChanged(e) {
    const t = this;
    e.name === "stateStoring" ? (t.isEnabled() && !t.isLoading() && t.load(), e.handled = !0) : super.optionChanged(e);
  }
  dispose() {
    clearTimeout(this._savingTimeoutID), _.off(fe(), "visibilitychange", this._windowUnloadHandler);
  }
  _loadState() {
    const e = this.option("stateStoring");
    if (e.type === "custom")
      return e.customLoad && e.customLoad();
    try {
      return JSON.parse(Zb(e).getItem(Qb(e)));
    } catch (t) {
      _e.log("W1022", "State storing", t.message);
    }
  }
  _saveState(e) {
    const t = this.option("stateStoring");
    if (t.type === "custom") {
      t.customSave && t.customSave(e);
      return;
    }
    try {
      Zb(t).setItem(Qb(t), JSON.stringify(e));
    } catch (n) {
      _e.log(n.message);
    }
  }
  publicMethods() {
    return ["state"];
  }
  isEnabled() {
    return this.option("stateStoring.enabled");
  }
  isLoaded() {
    return this._isLoaded;
  }
  isLoading() {
    return this._isLoading;
  }
  load() {
    this._isLoading = !0;
    const e = It(this._loadState());
    return e.always(() => {
      this._isLoaded = !0, this._isLoading = !1;
    }).done((t) => {
      t !== null && !en(t) && this.state(t);
    }), e;
  }
  state(e) {
    const t = this;
    if (!arguments.length)
      return x(!0, {}, t._state);
    t._state = x({}, e), aA(t._state);
  }
  save() {
    const e = this;
    clearTimeout(e._savingTimeoutID), e._savingTimeoutID = setTimeout(() => {
      e._saveState(e.state()), e._savingTimeoutID = void 0;
    }, e.option("stateStoring.savingTimeout"));
  }
}
const o5 = (i) => {
  const e = i.getView("pagerView"), t = i.getController("data"), n = {
    allowedPageSizes: e ? e.getPageSizes() : void 0,
    filterPanel: {
      filterEnabled: i.option("filterPanel.filterEnabled")
    },
    filterValue: i.option("filterValue"),
    focusedRowKey: i.option("focusedRowEnabled") ? i.option("focusedRowKey") : void 0
  };
  return x(n, t.getUserState());
}, r5 = (i) => {
  const e = i.getController("columns"), t = i.getController("selection"), n = i.getController("export"), s = i.getController("data");
  e && e.columnsChanged.add(() => {
    i.updateState({
      columns: e.getUserState()
    });
  }), t && t.selectionChanged.add((o) => {
    i.updateState({
      selectedRowKeys: o.selectedRowKeys,
      selectionFilter: o.selectionFilter
    });
  }), s && (i._initialPageSize = i.option("paging.pageSize"), i._initialFilterValue = i.option("filterValue"), s.changed.add(() => {
    const o = o5(i);
    i.updateState(o);
  })), n && n.selectionOnlyChanged.add(() => {
    i.updateState({
      exportSelectionOnly: n.selectionOnly()
    });
  });
}, a5 = (i, e) => {
  const t = i.getController("filterSync"), n = i.getController("columns"), s = e.columns || e.filterValue !== void 0;
  return t ? s ? e.filterValue || t.getFilterValueFromColumns(e.columns) : i._initialFilterValue || t.getFilterValueFromColumns(n.getColumns()) : null;
}, l5 = (i) => class extends i {
  init() {
    super.init(), this._dataController.stateLoaded.add(() => {
      if (this._dataController.isLoaded() && !this._dataController.getDataSource()) {
        this.setLoading(!1), this.renderNoDataText();
        const e = this.component.getView("columnHeadersView");
        e && e.render(), this.component._fireContentReadyAction();
      }
    });
  }
}, d5 = (i) => class extends i {
  init() {
    return super.init.apply(this, arguments), r5(this), this;
  }
  isLoading() {
    return super.isLoading() || this.getDataController().isStateLoading();
  }
  state(e) {
    const t = super.state.apply(this, arguments);
    return e !== void 0 && this.applyState(x(!0, {}, e)), t;
  }
  updateState(e) {
    if (this.isEnabled()) {
      const t = this.state(), n = x({}, t, e), s = xn(t), o = xn(n);
      He(s, o) || (e = x(!0, {}, e), x(this._state, e), this.save());
    } else
      x(this._state, e);
  }
  applyState(e) {
    var t;
    const {
      allowedPageSizes: n
    } = e, {
      searchText: s
    } = e, {
      selectedRowKeys: o
    } = e, {
      selectionFilter: r
    } = e, a = this.option("scrolling.mode"), l = a === "virtual" || a === "infinite", d = this.option("pager.visible") === !0 && this.option("pager.showPageSizeSelector"), u = (t = this.getView("rowsView")) === null || t === void 0 ? void 0 : t.hasHeight();
    this.component.beginUpdate(), this.getColumnsController() && this.getColumnsController().setUserState(e.columns), this.getExportController() && this.getExportController().selectionOnly(e.exportSelectionOnly), this.option("selection.deferred") || this.option("selectedRowKeys", o || []), this.option("selectionFilter", r), n && this.option("pager.allowedPageSizes") === "auto" && (this.option("pager").allowedPageSizes = n), this.option("focusedRowEnabled") && (this.option("focusedRowIndex", -1), this.option("focusedRowKey", e.focusedRowKey ?? null)), this.component.endUpdate(), this.option("searchPanel.text", s || ""), this.option("filterValue", a5(this, e)), this.option("filterPanel.filterEnabled", e.filterPanel ? e.filterPanel.filterEnabled : !0), this.option("paging.pageIndex", (!l || u) && e.pageIndex || 0), this.option("paging.pageSize", (!l || d) && f(e.pageSize) ? e.pageSize : this._initialPageSize), this.getDataController() && this.getDataController().reset();
  }
}, u5 = (i) => class extends i {
  _shouldReturnVisibleColumns() {
    return super._shouldReturnVisibleColumns.apply(this, arguments) && (!this._stateStoringController.isEnabled() || this._stateStoringController.isLoaded());
  }
}, c5 = (i) => class extends i {
  dispose() {
    clearTimeout(this._restoreStateTimeoutID), super.dispose();
  }
  callbackNames() {
    return super.callbackNames().concat(["stateLoaded"]);
  }
  _refreshDataSource() {
    if (this._stateStoringController.isEnabled() && !this._stateStoringController.isLoaded()) {
      clearTimeout(this._restoreStateTimeoutID);
      const e = new w();
      return this._restoreStateTimeoutID = setTimeout(() => {
        this._stateStoringController.load().always(() => {
          this._restoreStateTimeoutID = null;
        }).done(() => {
          super._refreshDataSource(), this.stateLoaded.fire(), e.resolve();
        }).fail((t) => {
          this.stateLoaded.fire(), this._handleLoadError(t || "Unknown error"), e.reject();
        });
      }), e.promise();
    }
    this.isStateLoading() || super._refreshDataSource();
  }
  isLoading() {
    return super.isLoading() || this._stateStoringController.isLoading();
  }
  isStateLoading() {
    return f(this._restoreStateTimeoutID);
  }
  isLoaded() {
    return super.isLoaded() && !this.isStateLoading();
  }
}, h5 = (i) => class extends i {
  _fireSelectionChanged(e) {
    const t = this.option("selection.deferred");
    this._stateStoringController.isLoading() && t || super._fireSelectionChanged.apply(this, arguments);
  }
}, p5 = {
  defaultOptions: () => ({
    stateStoring: {
      enabled: !1,
      storageKey: null,
      type: "localStorage",
      customLoad: null,
      customSave: null,
      savingTimeout: 2e3
    }
  }),
  controllers: {
    stateStoring: s5
  },
  extenders: {
    views: {
      rowsView: l5
    },
    controllers: {
      stateStoring: d5,
      columns: u5,
      data: c5,
      selection: h5
    }
  }
};
J.registerModule("stateStoring", p5);
const g5 = "dx-select-checkboxes-hidden", Di = "selection.showCheckBoxesMode", dl = "selection.mode", lA = function(i, e) {
  const t = i.getView("rowsView"), n = i.getController("selection"), s = p(e.target).closest(".dx-data-row"), o = t.getRowIndex(s);
  o < 0 || (i.option(Di) === "onLongTap" ? n.isSelectionWithCheckboxes() ? n.stopSelectionWithCheckboxes() : n.startSelectionWithCheckboxes() : (i.option(Di) === "onClick" && n.startSelectionWithCheckboxes(), i.option(Di) !== "always" && n.changeItemSelection(o, {
    control: !0
  })));
}, m5 = function(i, e) {
  let t = 0;
  const n = i._dataController.store(), s = n && n.key(), o = Array.isArray(s);
  if (!e.length)
    return !1;
  if (o && Array.isArray(e[0]) && e[1] === "and") {
    for (let r = 0; r < e.length; r++)
      if (Array.isArray(e[r])) {
        if (e[r][0] !== s[t] || e[r][1] !== "=")
          return !0;
        t++;
      }
    return !1;
  }
  return s !== e[0];
}, f5 = (i, e) => {
  const {
    component: t
  } = e, n = t.getView("rowsView");
  t.option("renderAsync") && !t.option("selection.deferred") && (e.value = t.isRowSelected(e.row.key)), n.renderSelectCheckBoxContainer(p(i), e);
}, _5 = (i, e) => {
  const {
    column: t
  } = e, n = p(i), s = e.component.getView("columnHeadersView");
  n.addClass("dx-editor-cell"), s._renderSelectAllCheckBox(n, t), s._attachSelectAllCheckBoxClickEvent(n);
};
class C5 extends Ue.Controller {
  init() {
    const {
      deferred: e,
      selectAllMode: t,
      mode: n
    } = this.option("selection") ?? {};
    this.option("scrolling.mode") === "infinite" && !e && n === "multiple" && t === "allPages" && _e.log("W1018"), this._dataController = this.getController("data"), this._columnsController = this.getController("columns"), this._stateStoringController = this.getController("stateStoring"), this._selectionMode = n, this._isSelectionWithCheckboxes = !1, this._selection = this._createSelection(), this._updateSelectColumn(), this.createAction("onSelectionChanged", {
      excludeValidators: ["disabled", "readOnly"]
    }), this._dataPushedHandler || (this._dataPushedHandler = this._handleDataPushed.bind(this), this._dataController.pushed.add(this._dataPushedHandler));
  }
  _handleDataPushed(e) {
    this._deselectRemovedOnPush(e), this._updateSelectedOnPush(e);
  }
  _deselectRemovedOnPush(e) {
    const t = this.option("selection.deferred");
    let n = e.filter((s) => s.type === "remove").map((s) => s.key);
    if (t) {
      const s = this._dataController.items().filter((o) => o.isSelected).map((o) => o.key);
      n = n.filter((o) => s.find((r) => He(r, o)));
    }
    n.length && this.deselectRows(n);
  }
  _updateSelectedOnPush(e) {
    if (this.option("selection.deferred"))
      return;
    const n = e.filter((o) => o.type === "update"), s = this.getSelectedRowsData();
    Ho({
      keyInfo: this._selection.options,
      data: s,
      changes: n
    });
  }
  _getSelectionConfig() {
    const e = this._dataController, t = this._columnsController, n = this.option("selection") ?? {}, {
      deferred: s
    } = n, o = this.option("scrolling.mode"), r = o === "virtual" || o === "infinite", a = this.option("selection.allowSelectAll"), l = this.option("scrolling.legacyMode");
    return {
      selectedKeys: this.option("selectedRowKeys"),
      mode: this._selectionMode,
      deferred: s,
      alwaysSelectByShift: n.alwaysSelectByShift,
      maxFilterLengthInRequest: n.maxFilterLengthInRequest,
      selectionFilter: this.option("selectionFilter"),
      ignoreDisabledItems: !0,
      isVirtualPaging: r,
      sensitivity: this.option("selection.sensitivity"),
      allowLoadByRange() {
        const d = t.getGroupColumns().length > 0;
        return r && !l && !d && a && !s;
      },
      key: () => e?.key(),
      keyOf: (d) => e?.keyOf(d),
      dataFields() {
        var d;
        return (d = e.dataSource()) === null || d === void 0 ? void 0 : d.select();
      },
      load(d) {
        var u;
        return ((u = e.dataSource()) === null || u === void 0 ? void 0 : u.load(d)) || new w().resolve([]);
      },
      plainItems: (d) => e.items(!0),
      isItemSelected: (d) => d.selected,
      isSelectableItem: (d) => d?.rowType === "data" && !d.isNewRow,
      getItemData: (d) => f(d?.rowType) ? d?.oldData || d?.data : d,
      filter: () => e.getCombinedFilter(s),
      totalCount: () => e.totalCount(),
      getLoadOptions(d, u, c) {
        var h;
        const {
          sort: g,
          filter: m
        } = ((h = e.dataSource()) === null || h === void 0 ? void 0 : h.lastLoadOptions()) ?? {};
        let C = Math.min(d, u), v = Math.max(d, u);
        f(c) && (C = Math.min(c, C), v = Math.max(c, v));
        const E = v - C + 1;
        return {
          skip: C,
          take: E,
          filter: m,
          sort: g
        };
      },
      onSelectionChanged: this._updateSelectedItems.bind(this)
    };
  }
  _updateSelectColumn() {
    const e = this._columnsController, t = this.isSelectColumnVisible();
    e.addCommandColumn({
      type: "selection",
      command: "select",
      visible: t,
      visibleIndex: -1,
      dataType: "boolean",
      alignment: "center",
      cssClass: "dx-command-select",
      width: "auto",
      cellTemplate: f5,
      headerCellTemplate: _5
    }), e.columnOption("command:select", "visible", t);
  }
  _createSelection() {
    const e = this._getSelectionConfig();
    return new HO(e);
  }
  _fireSelectionChanged(e) {
    const t = this.option("selection.deferred") ? {
      selectionFilter: this.option("selectionFilter")
    } : {
      selectedRowKeys: this.option("selectedRowKeys")
    };
    this.selectionChanged.fire(t), e && this.executeAction("onSelectionChanged", e);
  }
  _updateCheckboxesState(e) {
    const {
      isDeferredMode: t
    } = e, {
      selectionFilter: n
    } = e, {
      selectedItemKeys: s
    } = e, {
      removedItemKeys: o
    } = e;
    this.option(Di) === "onClick" && ((t ? n && m5(this, n) : s.length > 1) ? this.startSelectionWithCheckboxes() : (t ? n && !n.length : s.length === 0 && o.length) && this.stopSelectionWithCheckboxes());
  }
  _updateSelectedItems(e) {
    const t = this;
    let n;
    const s = t.option("selection.deferred"), o = t._selection.selectionFilter(), r = t._dataController, a = r.items(!0), l = r.items();
    if (!a)
      return;
    const d = t.isSelectionWithCheckboxes(), u = t.getChangedItemIndexes(a), c = t.getChangedItemIndexes(l);
    t._updateCheckboxesState({
      selectedItemKeys: e.selectedItemKeys,
      removedItemKeys: e.removedItemKeys,
      selectionFilter: o,
      isDeferredMode: s
    }), (u.length || d !== t.isSelectionWithCheckboxes()) && r.updateItems({
      changeType: "updateSelection",
      itemIndexes: c
    }), s ? (t.option("selectionFilter", o), n = {}) : (e.addedItemKeys.length || e.removedItemKeys.length) && (t._selectedItemsInternalChange = !0, t.option("selectedRowKeys", e.selectedItemKeys.slice(0)), t._selectedItemsInternalChange = !1, n = {
      selectedRowsData: e.selectedItems.slice(0),
      selectedRowKeys: e.selectedItemKeys.slice(0),
      currentSelectedRowKeys: e.addedItemKeys.slice(0),
      currentDeselectedRowKeys: e.removedItemKeys.slice(0)
    }), t._fireSelectionChanged(n);
  }
  getChangedItemIndexes(e) {
    const t = this, n = [], s = this.option("selection.deferred");
    for (let o = 0, {
      length: r
    } = e; o < r; o++) {
      const a = e[o], l = t.isRowSelected(s ? a.data : a.key);
      t._selection.isDataItem(a) && a.isSelected !== l && n.push(o);
    }
    return n;
  }
  callbackNames() {
    return ["selectionChanged"];
  }
  optionChanged(e) {
    var t;
    super.optionChanged(e);
    const n = !!((t = this._selection) !== null && t !== void 0 && t.options);
    switch (e.name) {
      case "selection": {
        const s = this._selectionMode;
        if (this.init(), n && e.fullName === "selection.sensitivity" && (this._selection.options.sensitivity = e.value), e.fullName !== "selection.showCheckBoxesMode") {
          const o = this._selectionMode;
          let r = this.option("selectedRowKeys");
          s !== o && (o === "single" ? r.length > 1 && (r = [r[0]]) : o !== "multiple" && (r = [])), this.selectRows(r).always(() => {
            this._fireSelectionChanged();
          });
        }
        this._columnsController.updateColumns(), e.handled = !0;
        break;
      }
      case "selectionFilter":
        this._selection.selectionFilter(e.value), e.handled = !0;
        break;
      case "selectedRowKeys": {
        const s = e.value || [];
        Array.isArray(s) && !this._selectedItemsInternalChange && (this.component.getDataSource() || !s.length) && this.selectRows(s), e.handled = !0;
        break;
      }
    }
  }
  publicMethods() {
    return ["selectRows", "deselectRows", "selectRowsByIndexes", "getSelectedRowKeys", "getSelectedRowsData", "clearSelection", "selectAll", "deselectAll", "startSelectionWithCheckboxes", "stopSelectionWithCheckboxes", "isRowSelected"];
  }
  isRowSelected(e) {
    return this._selection.isItemSelected(e);
  }
  isSelectColumnVisible() {
    return this.option(dl) === "multiple" && (this.option(Di) === "always" || this.option(Di) === "onClick" || this._isSelectionWithCheckboxes);
  }
  _isOnePageSelectAll() {
    return this.option("selection.selectAllMode") === "page";
  }
  isSelectAll() {
    return this._selection.getSelectAllState(this._isOnePageSelectAll());
  }
  selectAll() {
    return this.option(Di) === "onClick" && this.startSelectionWithCheckboxes(), this._selection.selectAll(this._isOnePageSelectAll());
  }
  deselectAll() {
    return this._selection.deselectAll(this._isOnePageSelectAll());
  }
  clearSelection() {
    return this.selectedItemKeys([]);
  }
  refresh() {
    const e = this.option("selectedRowKeys") ?? [];
    return !this.option("selection.deferred") && e.length ? this.selectedItemKeys(e) : new w().resolve().promise();
  }
  selectedItemKeys(e, t, n, s) {
    return this._selection.selectedItemKeys(e, t, n, s);
  }
  getSelectedRowKeys(e) {
    return this._selection.getSelectedItemKeys();
  }
  selectRows(e, t) {
    return this.selectedItemKeys(e, t);
  }
  deselectRows(e) {
    return this.selectedItemKeys(e, !0, !0);
  }
  selectRowsByIndexes(e) {
    const t = this._dataController.items(), n = [];
    return Array.isArray(e) || (e = Array.prototype.slice.call(arguments, 0)), y(e, function() {
      const s = t[this];
      s && s.rowType === "data" && n.push(s.key);
    }), this.selectRows(n);
  }
  getSelectedRowsData(e) {
    return this._selection.getSelectedItems();
  }
  loadSelectedItemsWithFilter() {
    return this._selection.loadSelectedItemsWithFilter();
  }
  changeItemSelection(e, t, n) {
    t = t || {}, this.isSelectionWithCheckboxes() && (t.control = !0);
    const s = e + this._dataController.getRowIndexOffset() - this._dataController.getRowIndexOffset(!0);
    return this._selection.changeItemSelection(s, t, n);
  }
  focusedItemIndex(e) {
    const t = this;
    if (f(e))
      t._selection._focusedItemIndex = e;
    else
      return t._selection._focusedItemIndex;
  }
  isSelectionWithCheckboxes() {
    return this.option(dl) === "multiple" && (this.option(Di) === "always" || this._isSelectionWithCheckboxes);
  }
  startSelectionWithCheckboxes() {
    const e = this;
    return e.option(dl) === "multiple" && !e.isSelectionWithCheckboxes() ? (e._isSelectionWithCheckboxes = !0, e._updateSelectColumn(), !0) : !1;
  }
  stopSelectionWithCheckboxes() {
    const e = this;
    return e._isSelectionWithCheckboxes ? (e._isSelectionWithCheckboxes = !1, e._updateSelectColumn(), !0) : !1;
  }
}
const v5 = (i) => class extends i {
  init() {
    const e = this.option("selection.deferred");
    super.init.apply(this, arguments), e && this._selectionController._updateCheckboxesState({
      isDeferredMode: !0,
      selectionFilter: this.option("selectionFilter")
    });
  }
  _loadDataSource() {
    const e = this;
    return super._loadDataSource().always(() => {
      e._selectionController.refresh();
    });
  }
  _processDataItem(e, t) {
    const n = this._selectionController.isSelectColumnVisible(), s = t.isDeferredSelection = t.isDeferredSelection === void 0 ? this.option("selection.deferred") : t.isDeferredSelection, o = super._processDataItem.apply(this, arguments);
    if (o.isSelected = this._selectionController.isRowSelected(s ? o.data : o.key), n && o.values) {
      for (let r = 0; r < t.visibleColumns.length; r++)
        if (t.visibleColumns[r].command === "select") {
          o.values[r] = o.isSelected;
          break;
        }
    }
    return o;
  }
  refresh(e) {
    const t = this, n = new w();
    return super.refresh.apply(this, arguments).done(() => {
      !e || e.selection ? t._selectionController.refresh().done(n.resolve).fail(n.reject) : n.resolve();
    }).fail(n.reject), n.promise();
  }
  _handleDataChanged(e) {
    const t = this.hasLoadOperation();
    super._handleDataChanged.apply(this, arguments), t && !this._repaintChangesOnly && this._selectionController.focusedItemIndex(-1);
  }
  _applyChange(e) {
    if (e && e.changeType === "updateSelection") {
      e.items.forEach((t, n) => {
        const s = this._items[n];
        s && (s.isSelected = t.isSelected, s.values = t.values);
      });
      return;
    }
    return super._applyChange.apply(this, arguments);
  }
  _endUpdateCore() {
    const e = this._changes;
    if (e.length > 1 && e.every((n) => n.changeType === "updateSelection")) {
      const n = e.map((s) => s.itemIndexes || []).reduce((s, o) => s.concat(o));
      this._changes = [{
        changeType: "updateSelection",
        itemIndexes: n
      }];
    }
    super._endUpdateCore.apply(this, arguments);
  }
}, x5 = (i) => class extends i {
  _contextMenuPrepared(e) {
    const t = e.event;
    t.originalEvent && t.originalEvent.type !== "dxhold" || e.items && e.items.length > 0 || lA(this, t);
  }
}, y5 = (i) => class extends i {
  init() {
    super.init(), this._selectionController.selectionChanged.add(this._updateSelectAllValue.bind(this));
  }
  _updateSelectAllValue() {
    const e = this, t = e.element(), n = t && t.find(".dx-select-checkbox");
    if (t && n.length && e.option("selection.mode") === "multiple") {
      const s = e._selectionController.isSelectAll(), o = s !== !1, r = e.option("selection.allowSelectAll") ? !e._dataController.isEmpty() : o;
      n.dxCheckBox("instance").option({
        visible: r,
        value: s
      });
    }
  }
  _handleDataChanged(e) {
    super._handleDataChanged(e), (!e || e.changeType === "refresh" || e.repaintChangesOnly && e.changeType === "update") && this.waitAsyncTemplates().done(() => {
      this._updateSelectAllValue();
    });
  }
  _renderSelectAllCheckBox(e, t) {
    const n = this, s = n._dataController.isEmpty(), o = p("<div>").appendTo(e).addClass("dx-select-checkbox");
    return n.setAria("label", S.format("dxDataGrid-ariaSelectAll"), o), n._editorFactoryController.createEditor(o, x({}, t, {
      parentType: "headerRow",
      dataType: "boolean",
      value: this._selectionController.isSelectAll(),
      editorOptions: {
        visible: !s && (n.option("selection.allowSelectAll") || this._selectionController.isSelectAll() !== !1)
      },
      tabIndex: n.option("useLegacyKeyboardNavigation") ? -1 : n.option("tabIndex") || 0,
      setValue: (r, a) => {
        const l = n.option("selection.allowSelectAll");
        a.component.option("visible", l || a.component.option("value") !== !1), !(!a.event || this._selectionController.isSelectAll() === r) && (a.value && !l ? a.component.option("value", !1) : a.value ? this._selectionController.selectAll() : this._selectionController.deselectAll(), a.event.preventDefault());
      }
    })), o;
  }
  _attachSelectAllCheckBoxClickEvent(e) {
    _.on(e, Te, this.createAction((t) => {
      const {
        event: n
      } = t;
      p(n.target).closest(".dx-select-checkbox").length || _.trigger(p(n.currentTarget).children(".dx-select-checkbox"), Te), n.preventDefault();
    }));
  }
}, b5 = (i) => class extends i {
  renderSelectCheckBoxContainer(e, t) {
    t.rowType === "data" && !t.row.isNewRow ? (e.addClass("dx-editor-cell"), this._attachCheckBoxClickEvent(e), this._renderSelectCheckBox(e, t)) : F.setEmptyText(e);
  }
  _renderSelectCheckBox(e, t) {
    const n = p("<div>").addClass("dx-select-checkbox").appendTo(e);
    return this.setAria("label", S.format("dxDataGrid-ariaSelectRow"), n), this._editorFactoryController.createEditor(n, x({}, t.column, {
      parentType: "dataRow",
      dataType: "boolean",
      lookup: null,
      value: t.value,
      setValue(s, o) {
        var r;
        (o == null || (r = o.event) === null || r === void 0 ? void 0 : r.type) === "keydown" && _.trigger(o.element, Te, o);
      },
      row: t.row
    })), n;
  }
  _attachCheckBoxClickEvent(e) {
    _.on(e, Te, this.createAction(function(t) {
      const {
        event: n
      } = t, s = this.getRowIndex(p(n.currentTarget).closest(".dx-row"));
      s >= 0 && (this._selectionController.startSelectionWithCheckboxes(), this._selectionController.changeItemSelection(s, {
        shift: n.shiftKey
      }), p(n.target).closest(".dx-select-checkbox").length && this._dataController.updateItems({
        changeType: "updateSelection",
        itemIndexes: [s]
      }));
    }));
  }
  _update(e) {
    const t = this, n = t.getTableElements();
    e.changeType === "updateSelection" ? n.length > 0 && (y(n, (s, o) => {
      y(e.itemIndexes || [], (r, a) => {
        let l;
        if (e.items[a] && (l = t._getRowElements(p(o)).eq(a), l.length)) {
          const {
            isSelected: d
          } = e.items[a];
          l.toggleClass("dx-selection", d === void 0 ? !1 : d).find(".dx-select-checkbox").dxCheckBox("option", "value", d), t.setAria("selected", d, l);
        }
      });
    }), t._updateCheckboxesClass()) : super._update(e);
  }
  _createTable() {
    const e = this, t = e.option("selection.mode"), n = super._createTable.apply(e, arguments);
    return t !== "none" && ((e.option(Di) === "onLongTap" || !tn.touch) && _.on(n, R(Zs.name, "dxDataGridRowsView"), ".dx-data-row", e.createAction((s) => {
      lA(e.component, s.event), s.event.stopPropagation();
    })), _.on(n, "mousedown selectstart", e.createAction((s) => {
      const {
        event: o
      } = s;
      o.shiftKey && o.preventDefault();
    }))), n;
  }
  _createRow(e) {
    const t = super._createRow.apply(this, arguments);
    if (e) {
      const {
        isSelected: n
      } = e;
      n && t.addClass("dx-selection"), this.option(dl) !== "none" && this.setAria("selected", n, t);
    }
    return t;
  }
  _rowClickForTreeList(e) {
    super._rowClick(e);
  }
  _rowClick(e) {
    const t = this, n = e.event, s = p(n.target).closest(".dx-selection-disabled").length;
    t.isClickableElement(p(n.target)) || (!s && (t.option(dl) !== "multiple" || t.option(Di) !== "always") && t._selectionController.changeItemSelection(e.rowIndex, {
      control: bt(n),
      shift: n.shiftKey
    }) && (n.preventDefault(), e.handled = !0), super._rowClick(e));
  }
  isClickableElement(e) {
    return !!e.closest(".dx-command-select").length;
  }
  _renderCore(e) {
    const t = super._renderCore(e);
    return this._updateCheckboxesClass(), t;
  }
  _updateCheckboxesClass() {
    const e = this.getTableElements(), t = this._selectionController.isSelectColumnVisible() && !this._selectionController.isSelectionWithCheckboxes();
    y(e, (n, s) => {
      p(s).toggleClass(g5, t);
    });
  }
}, w5 = {
  defaultOptions: () => ({
    selection: {
      mode: "none",
      showCheckBoxesMode: "onClick",
      allowSelectAll: !0,
      selectAllMode: "allPages",
      deferred: !1,
      maxFilterLengthInRequest: 1500,
      alwaysSelectByShift: !1
    },
    selectionFilter: [],
    selectedRowKeys: []
  }),
  controllers: {
    selection: C5
  },
  extenders: {
    controllers: {
      data: v5,
      contextMenu: x5
    },
    views: {
      columnHeadersView: y5,
      rowsView: b5
    }
  }
};
J.registerModule("selection", w5);
const S5 = ["size"], E5 = {};
class dA extends bn {
  constructor(e) {
    super(e), this.state = {}, this.elementRef = ct(), this.__getterCache = {};
  }
  get cssStyles() {
    return this.__getterCache.cssStyles !== void 0 ? this.__getterCache.cssStyles : this.__getterCache.cssStyles = (() => {
      const {
        size: e
      } = this.props;
      return {
        fontSize: yl("fontSize", e)
      };
    })();
  }
  get restAttributes() {
    const e = this.props;
    return hi(e, S5);
  }
  componentWillUpdate(e) {
    this.props.size !== e.size && (this.__getterCache.cssStyles = void 0);
  }
  render() {
    const {
      elementRef: e,
      cssStyles: t
    } = this;
    return gt(1, "span", "dx-checkbox-icon", null, 1, {
      style: XH(t)
    }, null, e);
  }
}
dA.defaultProps = E5;
const I5 = ["dataSource", "selectedRowKeys"], D5 = {
  integrationOptions: !0
};
function ka(i, e, t) {
  return {
    path: i,
    value: e,
    previousValue: t
  };
}
function Jb(i, e, t, n, s, o) {
  if (D5[n])
    return;
  const r = yn(e), a = yn(t);
  if (e !== t)
    if (r !== a)
      i.push(ka(n, t, e));
    else if (r === "object")
      if (!pe(t))
        i.push(ka(n, t, e));
      else {
        const l = ew(e, t, s, o);
        i.push(...l.map((d) => I({}, d, {
          path: `${n}.${d.path}`
        })));
      }
    else if (r === "array")
      if (o.some((d) => s.includes(d)) && e !== t)
        i.push(ka(n, t, e));
      else if (e.length !== t.length)
        i.push(ka(n, t, e));
      else {
        const d = ew(e, t, s, o);
        [].push.apply(i, d.map((u) => I({}, u, {
          path: `${n}${u.path}`
        })));
      }
    else
      i.push(ka(n, t, e));
}
const uA = (i) => (e, t, n, s) => {
  const o = [], r = Array.isArray(e) ? (a) => {
    Jb(o, e[a], t[a], `[${a}]`, `${n}.${a}`, s);
  } : (a) => {
    Jb(o, e[a], t[a], a, `${n}.${a}`, s);
  };
  return i(e).forEach(r), Object.keys(t).filter((a) => !Object.prototype.hasOwnProperty.call(e, a) && e[a] !== t[a]).forEach((a) => {
    o.push({
      path: a,
      value: t[a],
      previousValue: e[a]
    });
  }), o;
}, ew = uA((i) => Object.keys(i)), T5 = {
  key: !0,
  ref: !0,
  children: !0,
  style: !0
}, O5 = uA((i) => Object.keys(i).filter((e) => !T5[e]));
function A5(i, e) {
  let t = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : I5;
  return O5(i, e, "", t);
}
const R5 = ["componentProps", "componentType", "templateNames"], tw = (i) => Object.keys(i).reduce((e, t) => (i[t] !== void 0 && (e[t] = i[t]), e), {});
class oC extends vs {
  constructor(e) {
    super(e), this.state = {}, this.refs = null, this.widgetRef = ct(), this.instance = null, this.prevProps = null, this.getInstance = this.getInstance.bind(this), this.setupWidget = this.setupWidget.bind(this), this.updateWidget = this.updateWidget.bind(this);
  }
  getConfig() {
    const {
      id: e
    } = dn;
    return this.context[e] ? this.context[e] : dn.defaultValue;
  }
  render() {
    return tw(gt(1, "div", this.props.componentProps.className, null, 1, I({}, this.getRestAttributes()), null, this.widgetRef));
  }
  componentWillUpdate(e, t, n) {
    super.componentWillUpdate(e, t, n);
  }
  createEffects() {
    return [new et(this.setupWidget, []), new et(this.updateWidget, [this.props.componentProps, this.getConfig(), this.props.templateNames])];
  }
  updateEffects() {
    var e;
    const t = [this.props.componentProps, this.getConfig(), this.props.templateNames];
    (e = this._effects[1]) === null || e === void 0 || e.update(t);
  }
  setupWidget() {
    const e = this.widgetRef.current, t = new this.props.componentType(e, this.getProperties());
    return this.instance = t, () => {
      t.dispose(), this.instance = null;
    };
  }
  updateWidget() {
    if (!this.instance)
      return;
    const e = A5(this.prevProps ?? {}, this.getProperties());
    e.length && (this.instance.beginUpdate(), e.forEach((t) => {
      var n;
      const {
        path: s,
        value: o
      } = t;
      (n = this.instance) === null || n === void 0 || n.option(s, o);
    }), this.instance.endUpdate()), this.prevProps = this.getProperties();
  }
  getRestAttributes() {
    const e = this.props;
    return hi(e, R5);
  }
  getProperties() {
    var e;
    const t = tw(this.props.componentProps), {
      valueChange: n
    } = t, s = x({
      rtlEnabled: (e = this.getConfig()) === null || e === void 0 ? void 0 : e.rtlEnabled,
      isRenovated: !0
    }, t);
    return n && (s.onValueChanged = (r) => {
      const {
        value: a
      } = r;
      return n(a);
    }), this.props.templateNames.forEach((r) => {
      KH(r, s) && (s[r] = (a, l, d) => {
        zH(this.props.componentProps[r], {
          item: a,
          index: l,
          container: d
        });
      });
    }), s;
  }
  getInstance() {
    return this.instance;
  }
}
const F5 = ["accessKey", "activeStateEnabled", "boundary", "className", "contentId", "disabled", "focusStateEnabled", "height", "hint", "hoverStateEnabled", "mode", "offset", "onClick", "onKeyDown", "positionSide", "rtlEnabled", "tabIndex", "target", "validationErrors", "visible", "visualContainer", "width"], k5 = I({}, dd, {
  mode: "auto",
  positionSide: "top",
  offset: Object.freeze({
    h: 0,
    v: 0
  }),
  isReactComponentWrapper: !0
});
class cA extends bn {
  constructor(e) {
    super(e), this.state = {};
  }
  get restAttributes() {
    const e = this.props;
    return hi(e, F5);
  }
  render() {
    return ki(qe(2, oC, I({
      componentType: Q_,
      componentProps: this.props,
      templateNames: []
    }, this.restAttributes)));
  }
}
cA.defaultProps = k5;
const V5 = ["accessKey", "activeStateEnabled", "aria", "children", "className", "classes", "defaultValue", "disabled", "focusStateEnabled", "height", "hint", "hoverStateEnabled", "inputAttr", "isDirty", "isValid", "name", "onClick", "onFocusIn", "onKeyDown", "readOnly", "rtlEnabled", "tabIndex", "validationError", "validationErrors", "validationMessageMode", "validationMessagePosition", "validationStatus", "value", "valueChange", "visible", "width"], P5 = (i) => {
  const {
    classes: e,
    isValid: t,
    readOnly: n
  } = i, s = {
    "dx-state-readonly": !!n,
    "dx-invalid": !t,
    [String(e)]: !!e
  };
  return Eo(s);
}, hA = I({}, qD, {
  readOnly: !1,
  name: "",
  validationError: null,
  validationErrors: null,
  validationMessageMode: "auto",
  validationMessagePosition: "bottom",
  validationStatus: "valid",
  isValid: !0,
  isDirty: !1,
  inputAttr: {},
  defaultValue: null,
  valueChange: () => {
  }
});
let pA = class extends ql {
  constructor(e) {
    super(e), this.state = {}, this.widgetRef = ct(), this.rootElementRef = ct(), this.__getterCache = {}, this.state = {
      validationMessageGuid: `dx-${new Xe()}`,
      isValidationMessageVisible: !1,
      value: this.props.value !== void 0 ? this.props.value : this.props.defaultValue
    }, this.updateValidationMessageVisibility = this.updateValidationMessageVisibility.bind(this), this.focus = this.focus.bind(this), this.blur = this.blur.bind(this), this.onFocusIn = this.onFocusIn.bind(this);
  }
  createEffects() {
    return [new et(this.updateValidationMessageVisibility, [this.props.isValid, this.props.validationStatus, this.props.validationError, this.props.validationErrors]), Yl()];
  }
  updateEffects() {
    var e;
    (e = this._effects) === null || e === void 0 || (e = e[0]) === null || e === void 0 || e.update([this.props.isValid, this.props.validationStatus, this.props.validationError, this.props.validationErrors]);
  }
  updateValidationMessageVisibility() {
    this.setState(() => ({
      isValidationMessageVisible: this.shouldShowValidationMessage
    }));
  }
  onFocusIn(e) {
    const {
      onFocusIn: t
    } = this.props;
    t?.(e);
  }
  get cssClasses() {
    return `${P5(I({}, this.props, { value: this.props.value !== void 0 ? this.props.value : this.state.value }))}`;
  }
  get shouldShowValidationMessage() {
    const {
      isValid: e,
      validationStatus: t
    } = this.props, n = this.validationErrors ?? [];
    return !(e && t !== "invalid") && n.length > 0;
  }
  get aria() {
    const {
      isValid: e,
      readOnly: t
    } = this.props, n = {
      readonly: t ? "true" : "false",
      invalid: e ? "false" : "true"
    };
    return this.shouldShowValidationMessage && (n.describedBy = this.state.validationMessageGuid), I({}, n, this.props.aria);
  }
  get validationErrors() {
    return this.__getterCache.validationErrors !== void 0 ? this.__getterCache.validationErrors : this.__getterCache.validationErrors = (() => {
      const {
        validationError: e,
        validationErrors: t
      } = this.props;
      let n = t && [...t];
      return !n && e && (n = [I({}, e)]), n;
    })();
  }
  get validationMessageTarget() {
    var e;
    return (e = this.rootElementRef) === null || e === void 0 ? void 0 : e.current;
  }
  get restAttributes() {
    const e = this.props;
    return hi(e, V5);
  }
  focus() {
    this.widgetRef.current.focus();
  }
  blur() {
    this.widgetRef.current.blur();
  }
  componentWillUpdate(e) {
    super.componentWillUpdate(), (this.props.validationError !== e.validationError || this.props.validationErrors !== e.validationErrors) && (this.__getterCache.validationErrors = void 0);
  }
  render() {
    return ki(qe(2, ah, I({
      rootElementRef: this.rootElementRef,
      aria: this.aria,
      classes: this.cssClasses,
      activeStateEnabled: this.props.activeStateEnabled,
      focusStateEnabled: this.props.focusStateEnabled,
      hoverStateEnabled: this.props.hoverStateEnabled,
      accessKey: this.props.accessKey,
      className: this.props.className,
      rtlEnabled: this.props.rtlEnabled,
      hint: this.props.hint,
      disabled: this.props.disabled,
      height: this.props.height,
      width: this.props.width,
      onFocusIn: this.props.onFocusIn,
      onClick: this.props.onClick,
      onKeyDown: this.props.onKeyDown,
      tabIndex: this.props.tabIndex,
      visible: this.props.visible
    }, this.restAttributes, {
      children: Cs([this.props.children, this.state.isValidationMessageVisible && qe(2, cA, {
        validationErrors: this.validationErrors,
        mode: this.props.validationMessageMode,
        positionSide: this.props.validationMessagePosition,
        rtlEnabled: this.props.rtlEnabled,
        target: this.validationMessageTarget,
        boundary: this.validationMessageTarget,
        visualContainer: this.validationMessageTarget,
        contentId: this.state.validationMessageGuid
      })], 0)
    }), null, this.widgetRef));
  }
};
pA.defaultProps = hA;
const M5 = ["accessKey", "activeStateEnabled", "aria", "className", "classes", "defaultValue", "disabled", "enableThreeStateBehavior", "focusStateEnabled", "height", "hint", "hoverStateEnabled", "iconSize", "inputAttr", "isDirty", "isValid", "name", "onClick", "onFocusIn", "onKeyDown", "readOnly", "rtlEnabled", "saveValueChangeEvent", "tabIndex", "text", "validationError", "validationErrors", "validationMessageMode", "validationMessagePosition", "validationStatus", "value", "valueChange", "visible", "width"], B5 = (i) => {
  const {
    text: e,
    value: t
  } = i, n = t;
  return Eo({
    "dx-checkbox": !0,
    "dx-checkbox-checked": n === !0,
    "dx-checkbox-has-text": !!e,
    "dx-checkbox-indeterminate": n === null
  });
}, $5 = I({}, hA, {
  text: "",
  enableThreeStateBehavior: !1,
  activeStateEnabled: !0,
  hoverStateEnabled: !0,
  get focusStateEnabled() {
    return z.real().deviceType === "desktop" && !z.isSimulator();
  },
  defaultValue: !1,
  valueChange: () => {
  }
});
let bc = class extends ql {
  constructor(e) {
    super(e), this.editorRef = ct(), this.state = {
      value: this.props.value !== void 0 ? this.props.value : this.props.defaultValue
    }, this.focus = this.focus.bind(this), this.blur = this.blur.bind(this), this.onWidgetClick = this.onWidgetClick.bind(this), this.keyDown = this.keyDown.bind(this);
  }
  createEffects() {
    return [Yl()];
  }
  onWidgetClick(e) {
    const {
      enableThreeStateBehavior: t,
      readOnly: n,
      saveValueChangeEvent: s
    } = this.props;
    if (!n)
      if (s?.(e), t) {
        var o, r;
        let d;
        this.setState((u) => (d = (this.props.value !== void 0 ? this.props.value : u.value) === null || ((this.props.value !== void 0 ? this.props.value : u.value) ? !1 : null), {
          value: d
        })), (o = (r = this.props).valueChange) === null || o === void 0 || o.call(r, d);
      } else {
        var a, l;
        let d;
        this.setState((u) => (d = !((this.props.value !== void 0 ? this.props.value : u.value) ?? !1), {
          value: d
        })), (a = (l = this.props).valueChange) === null || a === void 0 || a.call(l, d);
      }
  }
  keyDown(e) {
    const {
      onKeyDown: t
    } = this.props, {
      keyName: n,
      originalEvent: s,
      which: o
    } = e, r = t?.(e);
    if (r != null && r.cancel)
      return r;
    (n === "space" || o === "space") && (s.preventDefault(), this.onWidgetClick(s));
  }
  get cssClasses() {
    return B5(I({}, this.props, {
      value: this.props.value !== void 0 ? this.props.value : this.state.value
    }));
  }
  get aria() {
    const e = (this.props.value !== void 0 ? this.props.value : this.state.value) === !0, n = {
      role: "checkbox",
      checked: (this.props.value !== void 0 ? this.props.value : this.state.value) === null ? "mixed" : `${e}`
    };
    return I({}, n, this.props.aria);
  }
  get restAttributes() {
    const e = this.props;
    return hi(e, M5);
  }
  focus() {
    this.editorRef.current.focus();
  }
  blur() {
    this.editorRef.current.blur();
  }
  render() {
    const e = this.props.value !== void 0 ? this.props.value : this.state.value;
    return ki(qe(2, pA, I({
      aria: this.aria,
      classes: this.cssClasses,
      onClick: this.onWidgetClick,
      onKeyDown: this.keyDown,
      accessKey: this.props.accessKey,
      activeStateEnabled: this.props.activeStateEnabled,
      focusStateEnabled: this.props.focusStateEnabled,
      hoverStateEnabled: this.props.hoverStateEnabled,
      className: this.props.className,
      disabled: this.props.disabled,
      readOnly: this.props.readOnly,
      hint: this.props.hint,
      height: this.props.height,
      width: this.props.width,
      rtlEnabled: this.props.rtlEnabled,
      tabIndex: this.props.tabIndex,
      visible: this.props.visible,
      validationError: this.props.validationError,
      validationErrors: this.props.validationErrors,
      validationMessageMode: this.props.validationMessageMode,
      validationMessagePosition: this.props.validationMessagePosition,
      validationStatus: this.props.validationStatus,
      isValid: this.props.isValid,
      onFocusIn: this.props.onFocusIn
    }, this.restAttributes, {
      children: Cs([ki(gt(64, "input", null, null, 1, I({
        type: "hidden",
        value: `${e}`
      }, this.props.name && {
        name: this.props.name
      }))), gt(1, "div", "dx-checkbox-container", [qe(2, dA, {
        size: this.props.iconSize,
        isChecked: e === !0
      }), this.props.text && gt(1, "span", "dx-checkbox-text", this.props.text, 0)], 0)], 4)
    }), null, this.editorRef));
  }
};
function N5(i) {
  const e = ["value"];
  return Object.keys(i).reduce((t, n) => {
    const s = i[n], o = e.some((r) => r === n) ? `default${n.charAt(0).toUpperCase()}${n.slice(1)}` : n;
    return t[o] = s, t;
  }, {});
}
bc.defaultProps = $5;
const nw = [];
function L5(i) {
  nw.push(i), bc.defaultProps = Object.create(Object.prototype, Object.assign(Object.getOwnPropertyDescriptors(bc.defaultProps), Object.getOwnPropertyDescriptors(N5(ia(nw)))));
}
function H5(i, e) {
  var t;
  return (((t = i.getRootNode) === null || t === void 0 ? void 0 : t.call(i)) ?? document).querySelector(e);
}
const iw = "dx-invalid-message-auto", sw = "dx-validation-target";
class rC extends hd {
  getProps() {
    const e = super.getProps();
    return e.onFocusIn = () => {
      if (this.option("validationMessageMode") === "auto") {
        const n = p(H5(this.element(), ".dx-invalid-message.dx-overlay-wrapper"));
        n?.removeClass(iw);
        const s = 150;
        this.showValidationMessageTimeout && clearTimeout(this.showValidationMessageTimeout), this.showValidationMessageTimeout = setTimeout(() => {
          n?.addClass(iw);
        }, s);
      }
    }, e.saveValueChangeEvent = (t) => {
      this._valueChangeEventInstance = t;
    }, e;
  }
  _createElement(e) {
    super._createElement(e), this.showValidationMessageTimeout = void 0, this.validationRequest = Ie(), tt(this.$element()[0], sw, this);
  }
  _render() {
    var e;
    (e = this.option("_onMarkupRendered")) === null || e === void 0 || e();
  }
  _init() {
    super._init(), this._initialValue = this.option("value");
  }
  _initializeComponent() {
    super._initializeComponent(), this._valueChangeAction = this._createActionByOption("onValueChanged", {
      excludeValidators: ["disabled", "readOnly"]
    });
  }
  _initOptions(e) {
    super._initOptions(e), this.option(Ve.initValidationOptions(e));
  }
  _getDefaultOptions() {
    return x(super._getDefaultOptions(), {
      validationMessageOffset: {
        h: 0,
        v: 0
      },
      validationTooltipOptions: {}
    });
  }
  _bindInnerWidgetOptions(e, t) {
    const n = x({}, e.option()), s = () => this._silent(t, n);
    s(), e.on("optionChanged", s);
  }
  _raiseValidation(e, t) {
    const n = !f(e) && !f(t);
    e !== t && !n && this.validationRequest.fire({
      value: e,
      editor: this
    });
  }
  _raiseValueChangeAction(e, t) {
    var n;
    (n = this._valueChangeAction) === null || n === void 0 || n.call(this, {
      element: this.$element(),
      previousValue: t,
      value: e,
      event: this._valueChangeEventInstance
    }), this._valueChangeEventInstance = void 0;
  }
  _optionChanged(e) {
    const {
      name: t,
      previousValue: n,
      value: s
    } = e;
    switch (t && this._getActionConfigs()[t] !== void 0 && this._addAction(t), t) {
      case "value":
        this._raiseValidation(s, n), this.option("isDirty", this._initialValue !== s), this._raiseValueChangeAction(s, n);
        break;
      case "onValueChanged":
        this._valueChangeAction = this._createActionByOption("onValueChanged", {
          excludeValidators: ["disabled", "readOnly"]
        });
        break;
      case "isValid":
      case "validationError":
      case "validationErrors":
      case "validationStatus":
        this.option(Ve.synchronizeValidationOptions(e, this.option()));
    }
    super._optionChanged(e);
  }
  clear() {
    const {
      value: e
    } = this._getDefaultOptions();
    this.option({
      value: e
    });
  }
  reset() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : void 0;
    arguments.length && (this._initialValue = e), this.option("value", this._initialValue), this.option("isDirty", !1), this.option("isValid", !0);
  }
  _dispose() {
    super._dispose(), tt(this.element(), sw, null), this.showValidationMessageTimeout && clearTimeout(this.showValidationMessageTimeout);
  }
}
const W5 = ci.isEditor, gA = (i) => W5(i) || i instanceof rC;
rC.isEditor = gA;
ci.isEditor = gA;
let z5 = class extends rC {
  _useTemplates() {
    return !1;
  }
  _isFocused() {
    return this.$element()[0].classList.contains("dx-state-focused");
  }
  getSupportedKeyNames() {
    return ["space"];
  }
  getProps() {
    const e = super.getProps();
    return e.value !== null && (e.value = !!e.value), e;
  }
};
class Qs extends z5 {
  getProps() {
    const e = super.getProps();
    return e.onKeyDown = this._wrapKeyDownHandler(e.onKeyDown), e;
  }
  focus() {
    var e;
    return (e = this.viewRef) === null || e === void 0 ? void 0 : e.focus(...arguments);
  }
  blur() {
    var e;
    return (e = this.viewRef) === null || e === void 0 ? void 0 : e.blur(...arguments);
  }
  _getActionConfigs() {
    return {
      onFocusIn: {},
      onClick: {}
    };
  }
  get _propsInfo() {
    return {
      twoWay: [
        ["value", "defaultValue", "valueChange"]
      ],
      allowNull: ["defaultValue", "validationError", "validationErrors", "value"],
      elements: [],
      templates: [],
      props: ["text", "iconSize", "enableThreeStateBehavior", "activeStateEnabled", "hoverStateEnabled", "focusStateEnabled", "saveValueChangeEvent", "defaultValue", "valueChange", "readOnly", "name", "validationError", "validationErrors", "validationMessageMode", "validationMessagePosition", "validationStatus", "isValid", "isDirty", "inputAttr", "onFocusIn", "className", "accessKey", "disabled", "height", "hint", "onClick", "onKeyDown", "rtlEnabled", "tabIndex", "visible", "width", "aria", "value"]
    };
  }
  get _viewComponent() {
    return bc;
  }
}
xe("dxCheckBox", Qs);
Qs.defaultOptions = L5;
const An = "dx-treeview", rn = `${An}-node`, zi = `${rn}-container`, Mp = `${rn}-loadindicator`, Es = `${rn}-container-opened`, Va = `${rn}-is-leaf`, Nt = `${An}-item`, K5 = `${Nt}-with-checkbox`, G5 = `${Nt}-with-custom-expander-icon`, U5 = `${An}-custom-expander-icon-item-container`, j5 = `${Nt}-without-checkbox`, q5 = `${Nt}-data`, Pa = `${An}-toggle-item-visibility`, Bp = `${An}-custom-collapse-icon`, $p = `${An}-custom-expand-icon`, Y5 = `${An}-loadindicator`, X5 = `${An}-loadindicator-wrapper`, ow = `${An}-toggle-item-visibility-opened`, Zd = `${An}-select-all-item`, Qd = "data-item-id", Z5 = `${An}-root-node`, Q5 = `${An}-expander-icon-stub`;
class J5 extends KO {
  _supportedKeys() {
    const e = (s) => {
      const {
        focusedElement: o
      } = this.option(), r = p(o);
      if (!r.length)
        return;
      s.target = r, s.currentTarget = r, this._itemClickHandler(s, r.children(`.${Nt}`)), this._getEventNameByOption(this.option("expandEvent")) === R(Te, "dxTreeView_expand") && this._expandEventHandler(s);
    }, t = (s) => {
      s.preventDefault();
      const {
        focusedElement: o
      } = this.option(), r = p(o), a = this._getCheckBoxInstance(r);
      if (!a.option("disabled")) {
        const l = a.option("value");
        this._updateItemSelection(!l, r.find(`.${Nt}`).get(0), !0);
      }
    }, n = function(s, o) {
      if (!this.option("expandAllEnabled"))
        return;
      o.preventDefault();
      const r = p(this.option("focusedElement"));
      if (!r.length)
        return;
      const a = this._getItemData(r.find(`.${Nt}`));
      this._toggleExpandedNestedItems([a], s);
    };
    return I({}, super._supportedKeys(), {
      enter: this._showCheckboxes() ? t : e,
      space: this._showCheckboxes() ? t : e,
      asterisk: n.bind(this, !0),
      minus: n.bind(this, !1)
    });
  }
  _toggleExpandedNestedItems(e, t) {
    if (e)
      for (let n = 0, s = e.length; n < s; n++) {
        const o = e[n], r = this._dataAdapter.getNodeByItem(o);
        this._toggleExpandedState(r, t), this._toggleExpandedNestedItems(o.items, t);
      }
  }
  _getNodeElement(e, t) {
    const n = this._encodeString(e.internalFields.key);
    if (t)
      return t.$nodeByKey || (t.$nodeByKey = {}, this.$element().find(`.${rn}`).each(function() {
        const o = p(this), r = o.attr(Qd);
        t.$nodeByKey[r] = o;
      })), t.$nodeByKey[n] || p();
    const s = this.$element().get(0).querySelector(`[${Qd}="${n}"]`);
    return p(s);
  }
  _widgetClass() {
    return An;
  }
  _getDefaultOptions() {
    const e = x(super._getDefaultOptions(), {
      animationEnabled: !0,
      dataStructure: "tree",
      deferRendering: !0,
      expandAllEnabled: !1,
      hasItemsExpr: "hasItems",
      selectNodesRecursive: !0,
      expandNodesRecursive: !0,
      showCheckBoxesMode: "none",
      expandIcon: null,
      collapseIcon: null,
      selectAllText: S.format("dxList-selectAll"),
      onItemSelectionChanged: null,
      onItemExpanded: null,
      onItemCollapsed: null,
      scrollDirection: "vertical",
      useNativeScrolling: !0,
      virtualModeEnabled: !1,
      rootValue: 0,
      focusStateEnabled: !1,
      selectionMode: "multiple",
      expandEvent: "dblclick",
      selectByClick: !1,
      createChildren: null,
      onSelectAllValueChanged: null,
      _supportItemUrl: !1
    });
    return x(!0, e, {
      integrationOptions: {
        useDeferUpdateForTemplates: !1
      }
    });
  }
  _defaultOptionsRules() {
    return super._defaultOptionsRules().concat([{
      device: () => !tn.nativeScrolling,
      options: {
        useNativeScrolling: !1
      }
    }]);
  }
  _initSelectedItems() {
  }
  _syncSelectionOptions() {
    return w().resolve().promise();
  }
  _fireSelectionChanged() {
    this._createActionByOption("onSelectionChanged", {
      excludeValidators: ["disabled", "readOnly"]
    })();
  }
  _createSelectAllValueChangedAction() {
    this._selectAllValueChangedAction = this._createActionByOption("onSelectAllValueChanged", {
      excludeValidators: ["disabled", "readOnly"]
    });
  }
  _fireSelectAllValueChanged(e) {
    var t;
    (t = this._selectAllValueChangedAction) === null || t === void 0 || t.call(this, {
      value: e
    });
  }
  _checkBoxModeChange(e, t) {
    const n = this.option("searchEnabled"), s = this._selectAllEnabled(t), o = this._itemContainer(n, s);
    if (this._detachClickEvent(o), this._detachExpandEvent(o), t === "none" || e === "none")
      return;
    const r = this._$selectAllItem && this._$selectAllItem.length;
    switch (e) {
      case "selectAll":
        r || (this._createSelectAllValueChangedAction(), this._renderSelectAllItem());
        break;
      case "normal":
        if (r) {
          var a;
          (a = this._$selectAllItem) === null || a === void 0 || a.remove(), delete this._$selectAllItem;
        }
    }
  }
  _removeSelection() {
    const e = this;
    y(this._dataAdapter.getFullData(), (t, n) => {
      e._hasChildren(n) && e._dataAdapter.toggleSelection(n.internalFields.key, !1, !0);
    });
  }
  _optionChanged(e) {
    const {
      name: t,
      value: n,
      previousValue: s
    } = e;
    switch (t) {
      case "selectAllText":
        this._$selectAllItem && this._$selectAllItem.dxCheckBox("instance").option("text", n);
        break;
      case "showCheckBoxesMode":
        this._checkBoxModeChange(n, s), this._invalidate();
        break;
      case "scrollDirection":
        this.getScrollable().option("direction", n);
        break;
      case "useNativeScrolling":
        this.getScrollable().option("useNative", n);
        break;
      case "items":
        delete this._$selectAllItem, super._optionChanged(e);
        break;
      case "dataSource":
        super._optionChanged(e), this._initDataAdapter(), this._filter = {};
        break;
      case "hasItemsExpr":
        this._initAccessors(), this.repaint();
        break;
      case "expandEvent":
        this._attachExpandEvent();
        break;
      case "deferRendering":
      case "dataStructure":
      case "rootValue":
      case "createChildren":
      case "expandNodesRecursive":
      case "onItemSelectionChanged":
      case "onItemExpanded":
      case "onItemCollapsed":
      case "expandAllEnabled":
      case "animationEnabled":
      case "virtualModeEnabled":
      case "selectByClick":
      case "_supportItemUrl":
        break;
      case "selectionMode":
        this._initDataAdapter(), super._optionChanged(e);
        break;
      case "onSelectAllValueChanged":
        this._createSelectAllValueChangedAction();
        break;
      case "selectNodesRecursive":
        this._dataAdapter.setOption("recursiveSelection", e.value), this.repaint();
        break;
      case "expandIcon":
      case "collapseIcon":
        this.repaint();
        break;
      default:
        super._optionChanged(e);
    }
  }
  _initDataSource() {
    this._useCustomChildrenLoader() ? this._loadChildrenByCustomLoader(null).done((e) => {
      e && e.length && this.option("items", e);
    }) : (super._initDataSource(), this._isVirtualMode() && this._initVirtualMode());
  }
  _initVirtualMode() {
    const e = this._filter;
    e.custom || (e.custom = this._dataSource.filter()), e.internal || (e.internal = [this.option("parentIdExpr"), this.option("rootValue")]);
  }
  _useCustomChildrenLoader() {
    return B(this.option("createChildren")) && this._isDataStructurePlain();
  }
  _loadChildrenByCustomLoader(e) {
    const t = this.option("createChildren").call(this, e);
    return Array.isArray(t) ? w().resolve(t).promise() : t && B(t.then) ? It(t) : w().resolve([]).promise();
  }
  _combineFilter() {
    return !this._filter.custom || !this._filter.custom.length ? this._filter.internal : [this._filter.custom, this._filter.internal];
  }
  _dataSourceLoadErrorHandler() {
    this._renderEmptyMessage();
  }
  _init() {
    this._filter = {}, super._init(), this._activeStateUnit = `.${Nt}`, this._initStoreChangeHandlers();
  }
  _dataSourceChangedHandler(e) {
    const t = this.option("items");
    this._initialized && this._isVirtualMode() && t.length || this.option("items", e);
  }
  _removeTreeViewLoadIndicator() {
    this._treeViewLoadIndicator && (this._treeViewLoadIndicator.remove(), this._treeViewLoadIndicator = null);
  }
  _createTreeViewLoadIndicator() {
    return this._treeViewLoadIndicator = p("<div>").addClass(Y5), this._createComponent(this._treeViewLoadIndicator, Dn, {}), this._treeViewLoadIndicator;
  }
  _dataSourceLoadingChangedHandler(e) {
    let t;
    if (this._isVirtualMode() && (t = this._combineFilter(), this._dataSource.filter(t)), e && !this._dataSource.isLoaded()) {
      this.option("items", []);
      const n = p("<div>").addClass(X5);
      this._createTreeViewLoadIndicator().appendTo(n), this.itemsContainer().append(n), this._isVirtualMode() && this._dataSource.filter() !== t && this._dataSource.filter([]);
    } else
      this._removeTreeViewLoadIndicator();
  }
  _initStoreChangeHandlers() {
    const {
      dataStructure: e
    } = this.option();
    e === "plain" && this._dataSource && this._dataSource.store().on("inserted", (t) => {
      this.option().items = this.option("items").concat(t), this._dataAdapter.addItem(t), this._dataAdapter.isFiltered(t) && this._updateLevel(this._parentIdGetter(t));
    }).on("removed", (t) => {
      const n = this._dataAdapter.getNodeByKey(t);
      f(n) && (this.option("items")[this._dataAdapter.getIndexByKey(n.internalFields.key)] = 0, this._markChildrenItemsToRemove(n), this._removeItems(), this._dataAdapter.removeItem(t), this._updateLevel(this._parentIdGetter(n)));
    });
  }
  _markChildrenItemsToRemove(e) {
    const t = e.internalFields.childrenKeys;
    y(t, (n, s) => {
      this.option("items")[this._dataAdapter.getIndexByKey(s)] = 0, this._markChildrenItemsToRemove(this._dataAdapter.getNodeByKey(s));
    });
  }
  _removeItems() {
    const e = x(!0, [], this.option("items"));
    let t = 0;
    y(e, (n, s) => {
      s || (this.option("items").splice(n - t, 1), t++);
    });
  }
  _updateLevel(e) {
    const t = this._getContainerByParentKey(e);
    this._renderItems(t, this._dataAdapter.getChildrenNodes(e));
  }
  _getOldContainer(e) {
    if (e.length)
      return e.children(`.${zi}`);
    const t = this.getScrollable();
    return t ? p(t.content()).children() : p();
  }
  _getContainerByParentKey(e) {
    const t = this._dataAdapter.getNodeByKey(e), n = t ? this._getNodeElement(t) : [];
    this._getOldContainer(n).remove();
    const s = this._renderNodeContainer(n);
    if (this._isRootLevel(e)) {
      const o = this.getScrollable();
      o || this._renderScrollableContainer(), p(o.content()).append(s);
    }
    return s;
  }
  _isRootLevel(e) {
    return e === this.option("rootValue");
  }
  _getAccessors() {
    const e = super._getAccessors();
    return e.push("hasItems"), e;
  }
  _getDataAdapterOptions() {
    var e, t, n;
    return {
      rootValue: this.option("rootValue"),
      multipleSelection: !this._isSingleSelection(),
      recursiveSelection: this._isRecursiveSelection(),
      recursiveExpansion: this.option("expandNodesRecursive"),
      selectionRequired: this.option("selectionRequired"),
      dataType: this.option("dataStructure"),
      sort: (e = this._dataSource) === null || e === void 0 ? void 0 : e.sort(),
      langParams: (t = this._dataSource) === null || t === void 0 || (n = t.loadOptions) === null || n === void 0 || (n = n.call(t)) === null || n === void 0 ? void 0 : n.langParams
    };
  }
  _initMarkup() {
    this._renderScrollableContainer(), this._renderEmptyMessage(this._dataAdapter.getRootNodes()), super._initMarkup(), this._setAriaRole();
  }
  _setAriaRole() {
    const {
      items: e
    } = this.option();
    e && e.length && this.setAria({
      role: "tree"
    });
  }
  _renderContentImpl() {
    const e = this._renderNodeContainer();
    p(this.getScrollable().content()).append(e), !(!this.option("items") || !this.option("items").length) && (this._renderItems(e, this._dataAdapter.getRootNodes()), this._attachExpandEvent(), this._selectAllEnabled() && (this._createSelectAllValueChangedAction(), this._renderSelectAllItem(e)));
  }
  _isVirtualMode() {
    return this.option("virtualModeEnabled") && this._isDataStructurePlain() && !!this.option("dataSource");
  }
  _isDataStructurePlain() {
    const {
      dataStructure: e
    } = this.option();
    return e === "plain";
  }
  _fireContentReadyAction() {
    const e = this.getDataSource(), t = e && !e.isLoaded() || this._skipContentReadyAndItemExpanded, n = this.getScrollable();
    n && ae() && n.update(), t || super._fireContentReadyAction(), n && ae() && n.update();
  }
  _renderScrollableContainer() {
    this._scrollable = this._createComponent(p("<div>").appendTo(this.$element()), Qt, {
      useNative: this.option("useNativeScrolling"),
      direction: this.option("scrollDirection"),
      useKeyboard: !1
    });
  }
  _renderNodeContainer(e) {
    const t = p("<ul>").addClass(zi);
    if (this.setAria("role", "group", t), e != null && e.length) {
      const n = this._getItemData(e.children(`.${Nt}`));
      this._expandedGetter(n) && t.addClass(Es), t.appendTo(e);
    }
    return t;
  }
  _createDOMElement(e, t) {
    var n;
    const s = p("<li>").addClass(rn).attr(Qd, this._encodeString(t.internalFields.key)).prependTo(e), o = {
      role: "treeitem",
      label: this._displayGetter(t.internalFields.item) || "",
      level: this._getLevel(e)
    };
    return !!(t != null && (n = t.internalFields) !== null && n !== void 0 && (n = n.childrenKeys) !== null && n !== void 0 && n.length) && (o.expanded = t.internalFields.expanded || !1), this.setAria(o, s), s;
  }
  _getLevel(e) {
    const t = e.parent();
    return t.hasClass("dx-scrollable-content") ? 1 : parseInt(t.attr("aria-level")) + 1;
  }
  _showCheckboxes() {
    const {
      showCheckBoxesMode: e
    } = this.option();
    return e !== "none";
  }
  _hasCustomExpanderIcons() {
    return this.option("expandIcon") || this.option("collapseIcon");
  }
  _selectAllEnabled(e) {
    return (e ?? this.option("showCheckBoxesMode")) === "selectAll" && !this._isSingleSelection();
  }
  _renderItems(e, t) {
    const n = t.length - 1;
    for (let s = n; s >= 0; s--)
      this._renderItem(s, t[s], e);
    this._renderedItemsCount += t.length;
  }
  _renderItem(e, t, n) {
    const s = this._createDOMElement(n, t), o = t.internalFields, r = this._showCheckboxes();
    s.addClass(r ? K5 : j5), s.toggleClass("dx-state-invisible", o.item.visible === !1), this._hasCustomExpanderIcons() && (s.addClass(G5), n.addClass(U5)), this.setAria("selected", o.selected, s), this._toggleSelectedClass(s, o.selected), o.disabled && this.setAria("disabled", o.disabled, s), super._renderItem(this._renderedItemsCount + e, o.item, s), this._getNode(t.internalFields.parentKey) || s.addClass(Z5), o.item.visible !== !1 && this._renderChildren(s, t);
  }
  _setAriaSelectionAttribute() {
  }
  _renderChildren(e, t) {
    if (!this._hasChildren(t)) {
      this._addLeafClass(e), p("<div>").addClass(Q5).appendTo(this._getItem(e));
      return;
    }
    this._hasCustomExpanderIcons() ? this._renderCustomExpanderIcons(e, t) : this._renderDefaultExpanderIcons(e, t), this._shouldRenderSublevel(t.internalFields.expanded) && this._loadSublevel(t).done((n) => {
      this._renderSublevel(e, this._getActualNode(t), n);
    });
  }
  _shouldRenderSublevel(e) {
    return e || !this.option("deferRendering");
  }
  _getActualNode(e) {
    return this._dataAdapter.getNodeByKey(e.internalFields.key);
  }
  _hasChildren(e) {
    return this._isVirtualMode() || this._useCustomChildrenLoader() ? this._hasItemsGetter(e.internalFields.item) !== !1 : super._hasChildren(e);
  }
  _loadSublevel(e) {
    const t = w(), n = this._getChildNodes(e);
    return n.length ? t.resolve(n) : this._loadNestedItems(e).done((s) => {
      t.resolve(this._dataAdapter.getNodesByItems(s));
    }), t.promise();
  }
  _getItemExtraPropNames() {
    return ["url", "linkAttr"];
  }
  _addContent(e, t) {
    const {
      html: n,
      url: s
    } = t;
    if (this.option("_supportItemUrl") && s) {
      e.html(n);
      const o = this._getLinkContainer(this._getIconContainer(t), this._getTextContainer(t), t);
      e.append(o);
    } else
      super._addContent(e, t);
  }
  _postprocessRenderItem(e) {
    const {
      itemData: t,
      itemElement: n
    } = e;
    this._showCheckboxes() && this._renderCheckBox(n, this._getNode(t)), super._postprocessRenderItem(e);
  }
  _renderSublevel(e, t, n) {
    const s = this._renderNodeContainer(e), o = n.filter((r) => t.internalFields.childrenKeys.indexOf(r.internalFields.key) !== -1);
    if (this._renderItems(s, o), o.length && !t.internalFields.selected) {
      const r = o[0];
      this._updateParentsState(r, this._getNodeElement(r));
    }
    this._normalizeIconState(e, o.length), t.internalFields.expanded && s.addClass(Es);
  }
  _executeItemRenderAction(e, t, n) {
    const s = this._getNode(n);
    this._getItemRenderAction()({
      itemElement: n,
      itemIndex: e,
      itemData: t,
      node: this._dataAdapter.getPublicNode(s)
    });
  }
  _addLeafClass(e) {
    e.addClass(Va);
  }
  _expandEventHandler(e) {
    p(e.currentTarget.parentNode).hasClass(Va) || this._toggleExpandedState(e.currentTarget, void 0, e);
  }
  _attachExpandEvent() {
    const e = this._getEventNameByOption(this.option("expandEvent")), t = this._itemContainer();
    this._detachExpandEvent(t), _.on(t, e, this._itemSelector(), this._expandEventHandler.bind(this));
  }
  _detachExpandEvent(e) {
    _.off(e, ".dxTreeView_expand", this._itemSelector());
  }
  _getEventNameByOption(e) {
    return R(e === "click" ? Te : pd, "dxTreeView_expand");
  }
  _getNode(e) {
    if (!f(e))
      return null;
    if (e.internalFields)
      return e;
    if (Kr(e))
      return this._dataAdapter.getNodeByKey(e);
    const t = p(e).get(0);
    return t ? O.isElementNode(t) ? this._getNodeByElement(t) : this._dataAdapter.getNodeByItem(t) : null;
  }
  _getNodeByElement(e) {
    const t = p(e).closest(`.${rn}`), n = this._decodeString(t.attr(Qd));
    return this._dataAdapter.getNodeByKey(n);
  }
  _toggleExpandedState(e, t, n) {
    const s = this._getNode(e);
    if (!s || s.internalFields.disabled)
      return w().reject().promise();
    const o = s.internalFields.expanded;
    if (o === t)
      return w().resolve().promise();
    if (this._hasChildren(s)) {
      const r = this._getNodeElement(s);
      if (r.find(`.${Mp}:not(.dx-state-invisible)`).length)
        return w().reject().promise();
      !o && !this._nodeHasRenderedChildren(r) && this._createLoadIndicator(r);
    }
    return f(t) || (t = !o), this._dataAdapter.toggleExpansion(s.internalFields.key, t), this._updateExpandedItemsUI(s, t, n);
  }
  _nodeHasRenderedChildren(e) {
    return e.children(`.${zi}`).not(":empty").length;
  }
  _getItem(e) {
    return e.children(`.${Nt}`).eq(0);
  }
  _createLoadIndicator(e) {
    const t = this._getItem(e);
    this._createComponent(p("<div>").addClass(Mp), Dn, {}).$element().appendTo(t), t.children(`.${Pa},.${$p}`).hide();
  }
  _renderExpanderIcon(e, t, n, s) {
    n.appendTo(this._getItem(e)), n.addClass(s), t.internalFields.disabled && n.addClass("dx-state-disabled"), this._renderToggleItemVisibilityIconClick(n, t);
  }
  _renderDefaultExpanderIcons(e, t) {
    const n = this._getItem(e), s = p("<div>").addClass(Pa).appendTo(n);
    t.internalFields.expanded && (s.addClass(ow), e.parent().addClass(Es)), t.internalFields.disabled && s.addClass("dx-state-disabled"), this._renderToggleItemVisibilityIconClick(s, t);
  }
  _renderCustomExpanderIcons(e, t) {
    const {
      expandIcon: n,
      collapseIcon: s
    } = this.option(), o = cs(n ?? s), r = cs(s ?? n);
    this._renderExpanderIcon(e, t, o, $p), this._renderExpanderIcon(e, t, r, Bp);
    const a = t.internalFields.expanded;
    a && e.parent().addClass(Es), this._toggleCustomExpanderIcons(o, r, a);
  }
  _renderToggleItemVisibilityIconClick(e, t) {
    const n = R(Te, this.NAME);
    _.off(e, n), _.on(e, n, (s) => (this._toggleExpandedState(t.internalFields.key, void 0, s), !1));
  }
  _toggleCustomExpanderIcons(e, t, n) {
    t.toggle(n), e.toggle(!n);
  }
  _updateExpandedItemsUI(e, t, n) {
    const s = this._getNodeElement(e), o = !s.length || t && s.is(":hidden");
    if (this.option("expandNodesRecursive") && o) {
      const d = this._getNode(e.internalFields.parentKey);
      d && this._updateExpandedItemsUI(d, t, n);
    }
    if (!this._hasCustomExpanderIcons())
      this._getItem(s).children(`.${Pa}`).toggleClass(ow, t);
    else if (this._nodeHasRenderedChildren(s)) {
      const d = this._getItem(s), u = d.children(`.${$p}`), c = d.children(`.${Bp}`);
      this._toggleCustomExpanderIcons(u, c, t);
    }
    const r = s.children(`.${zi}`), a = r.length > 0, l = w();
    return !t || a && !r.is(":empty") ? (this._animateNodeContainer(e, t, n, l), l.promise()) : e.internalFields.childrenKeys.length === 0 && (this._isVirtualMode() || this._useCustomChildrenLoader()) ? (this._loadNestedItemsWithUpdate(e, t, n, l), l.promise()) : (this._renderSublevel(s, e, this._getChildNodes(e)), this._fireContentReadyAction(), this._animateNodeContainer(e, t, n, l), l.promise());
  }
  _loadNestedItemsWithUpdate(e, t, n, s) {
    const o = this._getNodeElement(e);
    this._loadNestedItems(e).done((r) => {
      const a = this._getActualNode(e);
      if (this._renderSublevel(o, a, this._dataAdapter.getNodesByItems(r)), !r || !r.length) {
        s.resolve();
        return;
      }
      this._fireContentReadyAction(), this._animateNodeContainer(a, t, n, s);
    });
  }
  _loadNestedItems(e) {
    if (this._useCustomChildrenLoader()) {
      const t = this._dataAdapter.getPublicNode(e);
      return this._loadChildrenByCustomLoader(t).done((n) => {
        this._areNodesExists(n) || this._appendItems(n);
      });
    }
    return this._isVirtualMode() ? (this._filter.internal = [this.option("parentIdExpr"), e.internalFields.key], this._dataSource.filter(this._combineFilter()), this._dataSource.load().done((t) => {
      this._areNodesExists(t) || this._appendItems(t);
    })) : w().resolve([]).promise();
  }
  _areNodesExists(e) {
    const t = this.keyOf(e[0]), n = this._dataAdapter.getFullData();
    return !!this._dataAdapter.getNodeByKey(t, n);
  }
  _appendItems(e) {
    const {
      items: t = []
    } = this.option();
    this.option().items = t.concat(e), this._initDataAdapter();
  }
  _animateNodeContainer(e, t, n, s) {
    const o = this._getNodeElement(e), r = o.children(`.${zi}`);
    e && s && r.length === 0 && s.resolve(), r.addClass(Es);
    const a = le(r);
    Le.stop(r, !0), Le.animate(r, {
      type: "custom",
      duration: this.option("animationEnabled") ? 400 : 0,
      from: {
        maxHeight: t ? 0 : a
      },
      to: {
        maxHeight: t ? a : 0
      },
      complete: function() {
        r.css("maxHeight", "none"), r.toggleClass(Es, t), this.setAria("expanded", t, o), this.getScrollable().update(), this._fireExpandedStateUpdatedEvent(t, e, n), s && s.resolve();
      }.bind(this)
    });
  }
  _fireExpandedStateUpdatedEvent(e, t, n) {
    if (!this._hasChildren(t) || this._skipContentReadyAndItemExpanded)
      return;
    const s = e ? "onItemExpanded" : "onItemCollapsed";
    if (f(n))
      this._itemDXEventHandler(n, s, {
        node: this._dataAdapter.getPublicNode(t)
      });
    else {
      const o = this._getNodeElement(t);
      this._itemEventHandler(o, s, {
        event: n,
        node: this._dataAdapter.getPublicNode(t)
      });
    }
  }
  _normalizeIconState(e, t) {
    const n = e.find(`.${Mp}`);
    if (n.length) {
      var s;
      (s = Dn.getInstance(n)) === null || s === void 0 || s.option("visible", !1);
    }
    const r = this._getItem(e).children(`.${Bp},.${Pa}`);
    if (t) {
      r.show();
      return;
    }
    r.removeClass(Pa), e.addClass(Va);
  }
  _emptyMessageContainer() {
    const e = this.getScrollable();
    return e ? p(e.content()) : super._emptyMessageContainer();
  }
  _renderContent() {
    const {
      items: e
    } = this.option();
    e && e.length && (this._contentAlreadyRendered = !0), super._renderContent();
  }
  _renderSelectAllItem(e) {
    const {
      selectAllText: t,
      focusStateEnabled: n
    } = this.option();
    e = e || this.$element().find(`.${zi}`).first(), this._$selectAllItem = p("<div>").addClass(Zd);
    const s = this._dataAdapter.isAllSelected();
    this._createComponent(this._$selectAllItem, Qs, {
      value: s,
      elementAttr: {
        "aria-label": "Select All"
      },
      text: t,
      focusStateEnabled: n,
      onValueChanged: this._onSelectAllCheckboxValueChanged.bind(this),
      onInitialized: (o) => {
        let {
          component: r
        } = o;
        r.registerKeyHandler("enter", () => {
          r.option("value", !r.option("value"));
        });
      }
    }), this._toggleSelectedClass(this._$selectAllItem, s), e.before(this._$selectAllItem);
  }
  _onSelectAllCheckboxValueChanged(e) {
    this._toggleSelectAll(e), this._fireSelectAllValueChanged(e.value);
  }
  _toggleSelectAll(e) {
    this._dataAdapter.toggleSelectAll(e.value), this._updateItemsUI(), this._fireSelectionChanged();
  }
  _renderCheckBox(e, t) {
    const n = p("<div>").appendTo(e);
    this._createComponent(n, Qs, {
      value: t.internalFields.selected,
      onValueChanged: this._changeCheckboxValue.bind(this),
      focusStateEnabled: !1,
      elementAttr: {
        "aria-label": S.format("CheckState")
      },
      disabled: this._disabledGetter(t)
    });
  }
  _toggleSelectedClass(e, t) {
    e.toggleClass("dx-state-selected", !!t);
  }
  _toggleNodeDisabledState(e, t) {
    const n = this._getNodeElement(e), s = n.find(`.${Nt}`).eq(0);
    this._dataAdapter.toggleNodeDisabledState(e.internalFields.key, t), s.toggleClass("dx-state-disabled", !!t), this._showCheckboxes() && this._getCheckBoxInstance(n).option("disabled", !!t);
  }
  _itemOptionChanged(e, t, n) {
    const s = this._dataAdapter.getNodeByItem(e);
    t === this.option("disabledExpr") && this._toggleNodeDisabledState(s, n);
  }
  _changeCheckboxValue(e) {
    const t = p(e.element).closest(`.${rn}`), n = this._getItem(t), s = this._getItemData(n), o = this._getNodeByElement(n), {
      value: r
    } = e;
    o && o.internalFields.selected === r || this._updateItemSelection(r, s, e.event);
  }
  _isSingleSelection() {
    const {
      selectionMode: e
    } = this.option();
    return e === "single";
  }
  _isRecursiveSelection() {
    const {
      selectionMode: e
    } = this.option();
    return this.option("selectNodesRecursive") && e !== "single";
  }
  _isLastSelectedBranch(e, t, n) {
    const s = t.indexOf(e.key);
    return s >= 0 && t.splice(s, 1), n && y(e.children, (o, r) => {
      this._isLastSelectedBranch(r, t, !0);
    }), e.parent && this._isLastSelectedBranch(e.parent, t), t.length === 0;
  }
  _isLastRequired(e) {
    const t = this.option("selectionRequired"), n = this._isSingleSelection(), s = this.getSelectedNodeKeys();
    if (t)
      return n ? s.length === 1 : this._isLastSelectedBranch(e.internalFields.publicNode, s.slice(), !0);
  }
  _updateItemSelection(e, t, n) {
    const s = this._getNode(t);
    if (!s || s.visible === !1)
      return !1;
    if (s.internalFields.selected === e)
      return !0;
    if (!e && this._isLastRequired(s)) {
      if (this._showCheckboxes()) {
        const a = this._getNodeElement(s);
        this._getCheckBoxInstance(a).option("value", !0);
      }
      return !1;
    }
    if (e && this._isSingleSelection()) {
      const a = this.getSelectedNodeKeys();
      y(a, (l, d) => {
        this._dataAdapter.toggleSelection(d, !1), this._updateItemsUI(), this._fireItemSelectionChanged(this._getNode(d));
      });
    }
    this._dataAdapter.toggleSelection(s.internalFields.key, e);
    const o = this._dataAdapter.isAllSelected(), r = this._selectAllEnabled() && this._$selectAllItem.dxCheckBox("instance").option("value") !== o;
    return this._updateItemsUI(), this._fireItemSelectionChanged(s, n), this._fireSelectionChanged(), r && this._fireSelectAllValueChanged(o), !0;
  }
  _fireItemSelectionChanged(e, t) {
    const n = t || this._findItemElementByItem(e.internalFields.item);
    (t ? this._itemDXEventHandler : this._itemEventHandler).call(this, n, "onItemSelectionChanged", {
      node: this._dataAdapter.getPublicNode(e),
      itemData: e.internalFields.item
    });
  }
  _getCheckBoxInstance(e) {
    return this._getItem(e).children(".dx-checkbox").dxCheckBox("instance");
  }
  _updateItemsUI() {
    const e = {};
    if (y(this._dataAdapter.getData(), (t, n) => {
      const s = this._getNodeElement(n, e), o = n.internalFields.selected;
      s.length && (this._toggleSelectedClass(s, o), this.setAria("selected", o, s), this._showCheckboxes() && this._getCheckBoxInstance(s).option("value", o));
    }), this._selectAllEnabled()) {
      const t = this._$selectAllItem.dxCheckBox("instance");
      t.option("onValueChanged", void 0), t.option("value", this._dataAdapter.isAllSelected()), t.option("onValueChanged", this._onSelectAllCheckboxValueChanged.bind(this));
    }
  }
  _updateParentsState(e, t) {
    if (!t)
      return;
    const n = this._dataAdapter.getNodeByKey(e.internalFields.parentKey), s = p(t.parents(`.${rn}`)[0]);
    if (this._showCheckboxes()) {
      var o;
      const r = n.internalFields.selected;
      (o = this._getCheckBoxInstance(s)) === null || o === void 0 || o.option("value", r), this._toggleSelectedClass(s, r);
    }
    n.internalFields.parentKey !== this.option("rootValue") && this._updateParentsState(n, s);
  }
  _itemEventHandlerImpl(e, t, n) {
    const s = p(e).closest(`.${rn}`).children(`.${Nt}`);
    return t(x(this._extendActionArgs(s), n));
  }
  _itemContextMenuHandler(e) {
    this._createEventHandler("onItemContextMenu", e);
  }
  _itemHoldHandler(e) {
    this._createEventHandler("onItemHold", e);
  }
  _createEventHandler(e, t) {
    const n = this._getNodeByElement(t.currentTarget);
    this._itemDXEventHandler(t, e, {
      node: this._dataAdapter.getPublicNode(n)
    });
  }
  _itemClass() {
    return Nt;
  }
  _itemDataKey() {
    return q5;
  }
  _attachClickEvent() {
    const e = this._itemContainer();
    this._detachClickEvent(e);
    const {
      clickEventNamespace: t,
      itemSelector: n,
      pointerDownEventNamespace: s,
      nodeSelector: o
    } = this._getItemClickEventData();
    _.on(e, t, n, (r) => {
      p(r.target).hasClass("dx-checkbox-icon") || p(r.target).hasClass("dx-checkbox") || this._itemClickHandler(r, p(r.currentTarget));
    }), _.on(e, s, o, (r) => {
      this._itemPointerDownHandler(r);
    });
  }
  _detachClickEvent(e) {
    const {
      clickEventNamespace: t,
      itemSelector: n,
      pointerDownEventNamespace: s,
      nodeSelector: o
    } = this._getItemClickEventData();
    _.off(e, t, n), _.off(e, s, o);
  }
  _getItemClickEventData() {
    const e = `.${this._itemClass()}`, t = `.${rn}, .${Zd}`, n = R(Te, this.NAME), s = R(ye.down, this.NAME);
    return {
      clickEventNamespace: n,
      itemSelector: e,
      pointerDownEventNamespace: s,
      nodeSelector: t
    };
  }
  _itemClick(e) {
    const t = e.args[0], s = (t.event.target[0] || t.event.target).getElementsByClassName("dx-item-url")[0];
    t.itemData.url && s && s.click();
  }
  _itemClickHandler(e, t) {
    const n = this._getItemData(t), s = this._getNodeByElement(t);
    this._itemDXEventHandler(e, "onItemClick", {
      node: this._dataAdapter.getPublicNode(s)
    }, {
      beforeExecute: this._itemClick
    }), this.option("selectByClick") && !e.isDefaultPrevented() && this._updateItemSelection(!s.internalFields.selected, n, e);
  }
  _updateSelectionToFirstItem(e, t) {
    let n = t;
    for (; n >= 0; ) {
      const s = p(e[n]);
      this._updateItemSelection(!0, s.find(`.${Nt}`).get(0)), n--;
    }
  }
  _updateSelectionToLastItem(e, t) {
    const {
      length: n
    } = e;
    let s = t;
    for (; s < n; ) {
      const o = p(e[s]);
      this._updateItemSelection(!0, o.find(`.${Nt}`).get(0)), s++;
    }
  }
  focus() {
    if (this._selectAllEnabled()) {
      _.trigger(this._$selectAllItem, "focus");
      return;
    }
    super.focus();
  }
  _focusInHandler(e) {
    this._updateFocusState(e, !0);
    const t = p(e.target).hasClass(Zd);
    if (t || this.option("focusedElement")) {
      clearTimeout(this._setFocusedItemTimeout), this._setFocusedItemTimeout = setTimeout(() => {
        const {
          focusedElement: s
        } = this.option(), o = t ? ee(this._$selectAllItem) : p(s);
        this._setFocusedItem(o);
      });
      return;
    }
    const n = this._getActiveItem();
    this.option("focusedElement", ee(n.closest(`.${rn}`)));
  }
  _itemPointerDownHandler(e) {
    if (!this.option("focusStateEnabled"))
      return;
    const t = p(e.target).closest(`.${rn}, .${Zd}`);
    if (!t.length)
      return;
    const n = t.hasClass("dx-state-disabled") ? null : t;
    this.option("focusedElement", ee(n));
  }
  _findNonDisabledNodes(e) {
    return e.not(function() {
      return p(this).children(`.${Nt}`).hasClass("dx-state-disabled");
    });
  }
  _moveFocus(e, t) {
    const n = this.option("rtlEnabled") ? "right" : "left", s = this.option("rtlEnabled") ? "left" : "right";
    this.$element().find(`.${zi}`).each(function() {
      Le.stop(this, !0);
    });
    const o = this._nodeElements();
    if (!(!o || !o.length))
      switch (e) {
        case "up": {
          const r = this._prevItem(o);
          this.option("focusedElement", ee(r));
          const a = this._getNodeItemElement(r);
          this.getScrollable().scrollToElement(a), t.shiftKey && this._showCheckboxes() && this._updateItemSelection(!0, a);
          break;
        }
        case "down": {
          const r = this._nextItem(o);
          this.option("focusedElement", ee(r));
          const a = this._getNodeItemElement(r);
          this.getScrollable().scrollToElement(a), t.shiftKey && this._showCheckboxes() && this._updateItemSelection(!0, a);
          break;
        }
        case "first": {
          const r = o.first();
          t.shiftKey && this._showCheckboxes() && this._updateSelectionToFirstItem(o, o.index(this._prevItem(o))), this.option("focusedElement", ee(r)), this.getScrollable().scrollToElement(this._getNodeItemElement(r));
          break;
        }
        case "last": {
          const r = o.last();
          t.shiftKey && this._showCheckboxes() && this._updateSelectionToLastItem(o, o.index(this._nextItem(o))), this.option("focusedElement", ee(r)), this.getScrollable().scrollToElement(this._getNodeItemElement(r));
          break;
        }
        case s:
          this._expandFocusedContainer();
          break;
        case n:
          this._collapseFocusedContainer();
          break;
        default:
          super._moveFocus.apply(this, arguments);
      }
  }
  _getNodeItemElement(e) {
    return e.find(`.${Nt}`).get(0);
  }
  _nodeElements() {
    return this.$element().find(`.${rn}`).not(":hidden");
  }
  _expandFocusedContainer() {
    const {
      focusedElement: e
    } = this.option(), t = p(e);
    if (!t.length || t.hasClass(Va))
      return;
    if (t.find(`.${zi}`).eq(0).hasClass(Es)) {
      const o = this._nextItem(this._findNonDisabledNodes(this._nodeElements()));
      this.option("focusedElement", ee(o)), this.getScrollable().scrollToElement(this._getNodeItemElement(o));
      return;
    }
    const s = this._getNodeByElement(this._getItem(t));
    this._toggleExpandedState(s, !0);
  }
  _getClosestNonDisabledNode(e) {
    do
      e = e.parent().closest(`.${rn}`);
    while (e.children(".dx-treeview-item.dx-state-disabled").length);
    return e;
  }
  _collapseFocusedContainer() {
    const {
      focusedElement: e
    } = this.option(), t = p(e);
    if (!t.length)
      return;
    const n = t.find(`.${zi}`).eq(0);
    if (!t.hasClass(Va) && n.hasClass(Es)) {
      const s = this._getNodeByElement(this._getItem(t));
      this._toggleExpandedState(s, !1);
    } else {
      const s = this._getClosestNonDisabledNode(t);
      s.length && this.option("focusedElement", ee(s)), this.getScrollable().scrollToElement(this._getNodeItemElement(s));
    }
  }
  _encodeString(e) {
    return te(e) ? encodeURI(e) : e;
  }
  _decodeString(e) {
    return te(e) ? decodeURI(e) : e;
  }
  getScrollable() {
    return this._scrollable;
  }
  updateDimensions() {
    const e = w(), t = this.getScrollable();
    return t ? t.update().done(() => {
      e.resolveWith(this);
    }) : e.resolveWith(this), e.promise();
  }
  selectItem(e) {
    return this._updateItemSelection(!0, e);
  }
  unselectItem(e) {
    return this._updateItemSelection(!1, e);
  }
  expandItem(e) {
    return this._toggleExpandedState(e, !0);
  }
  collapseItem(e) {
    return this._toggleExpandedState(e, !1);
  }
  getNodes() {
    return this._dataAdapter.getTreeNodes();
  }
  getSelectedNodes() {
    return this.getSelectedNodeKeys().map((e) => {
      const t = this._dataAdapter.getNodeByKey(e);
      return this._dataAdapter.getPublicNode(t);
    });
  }
  getSelectedNodeKeys() {
    return this._dataAdapter.getSelectedNodesKeys();
  }
  selectAll() {
    this._selectAllEnabled() ? this._$selectAllItem.dxCheckBox("instance").option("value", !0) : this._toggleSelectAll({
      value: !0
    });
  }
  unselectAll() {
    this._selectAllEnabled() ? this._$selectAllItem.dxCheckBox("instance").option("value", !1) : this._toggleSelectAll({
      value: !1
    });
  }
  _allItemsExpandedHandler() {
    this._skipContentReadyAndItemExpanded = !1, this._fireContentReadyAction();
  }
  expandAll() {
    const e = this._dataAdapter.getData(), t = [];
    this._skipContentReadyAndItemExpanded = !0, e.forEach((n) => t.push(this._toggleExpandedState(n.internalFields.key, !0))), Promise.allSettled(t).then(() => {
      var n;
      return (n = this._allItemsExpandedHandler) === null || n === void 0 ? void 0 : n.call(this);
    });
  }
  collapseAll() {
    y(this._dataAdapter.getExpandedNodesKeys(), (e, t) => {
      this._toggleExpandedState(t, !1);
    });
  }
  scrollToItem(e) {
    const t = this._getNode(e);
    if (!t)
      return w().reject().promise();
    const n = [];
    let s = t.internalFields.publicNode.parent;
    for (; s != null; )
      s.expanded || n.push(s.key), s = s.parent;
    const o = w();
    return this._expandNodes(n.reverse()).always(() => {
      const r = this._getNodeElement(t);
      r && r.length ? (this.scrollToElementTopLeft(r.get(0)), o.resolve()) : o.reject();
    }), o.promise();
  }
  scrollToElementTopLeft(e) {
    const t = this.getScrollable(), {
      scrollDirection: n,
      rtlEnabled: s
    } = this.option(), o = {
      top: 0,
      left: 0
    }, r = TO(DO, e);
    if (n !== xc) {
      const a = p(t.container()).get(0);
      o.left = s ? r.left + e.offsetWidth - a.clientWidth : r.left;
    }
    n !== IO && (o.top = r.top), t.scrollTo(o);
  }
  _expandNodes(e) {
    if (!e || e.length === 0)
      return w().resolve().promise();
    const t = w(), n = e.map((s) => this.expandItem(s));
    return W.apply(p, n).done(() => t.resolve()).fail(() => t.reject()), t.promise();
  }
  _dispose() {
    super._dispose(), clearTimeout(this._setFocusedItemTimeout), this._allItemsExpandedHandler = null;
  }
}
Xo.setEditorClass(ma);
const mA = "dx-treeview", e6 = `${mA}-node-container`, xd = J5.inherit(Xo).inherit({
  _addWidgetPrefix: (i) => `${mA}-${i}`,
  _optionChanged(i) {
    switch (i.name) {
      case "searchValue":
        this._showCheckboxes() && this._isRecursiveSelection() && this._removeSelection(), this._initDataAdapter(), this._updateSearch(), this._repaintContainer(), this.option("focusedElement", null);
        break;
      case "searchExpr":
        this._initDataAdapter(), this.repaint();
        break;
      case "searchMode":
        this.option("expandNodesRecursive") ? this._updateDataAdapter() : this._initDataAdapter(), this.repaint();
        break;
      default:
        this.callBase(i);
    }
  },
  _updateDataAdapter() {
    this._setOptionWithoutOptionChange("expandNodesRecursive", !1), this._initDataAdapter(), this._setOptionWithoutOptionChange("expandNodesRecursive", !0);
  },
  _getDataAdapterOptions() {
    return x(this.callBase(), {
      searchValue: this.option("searchValue"),
      searchMode: this.option("searchMode") || "contains",
      searchExpr: this.option("searchExpr")
    });
  },
  _getNodeContainer() {
    return this.$element().find(`.${e6}`).first();
  },
  _updateSearch() {
    if (this._searchEditor) {
      const i = this._getSearchEditorOptions();
      this._searchEditor.option(i);
    }
  },
  _repaintContainer() {
    const i = this._getNodeContainer();
    let e;
    i.length && (i.empty(), e = this._dataAdapter.getRootNodes(), this._renderEmptyMessage(e), this._renderItems(i, e), this._fireContentReadyAction());
  },
  _focusTarget() {
    return this._itemContainer(this.option("searchEnabled"));
  },
  _cleanItemContainer() {
    this.$element().empty();
  },
  _itemContainer(i, e) {
    return e ?? (e = this._selectAllEnabled()), e ? this._getNodeContainer() : this._scrollable && i ? p(this._scrollable.content()) : this.callBase();
  },
  _addWidgetClass() {
    this.$element().addClass(this._widgetClass());
  },
  _clean() {
    this.callBase(), this._removeSearchBox();
  }
});
xe("dxTreeView", xd);
const t6 = "column-chooser-mode-drag", n6 = "column-chooser-mode-select", i6 = ["showInColumnChooser", "caption", "allowHiding", "visible", "cssClass", "ownerBand"], s6 = function(i, e) {
  const t = [], n = i.isSelectMode(), s = i.option("columnChooser.selection.recursive");
  return e.length && y(e, (o, r) => {
    const a = {
      text: r.caption,
      cssClass: r.cssClass,
      allowHiding: r.allowHiding,
      expanded: !0,
      id: r.index,
      disabled: r.allowHiding === !1,
      parentId: f(r.ownerBand) ? r.ownerBand : null
    }, l = s && r.hasColumns;
    n && !l && (a.selected = r.visible), t.push(a);
  }), t;
};
class o6 extends Ue.ViewController {
  init() {
    super.init(), this._rowsView = this.getView("rowsView");
  }
  renderShowColumnChooserButton(e) {
    const t = this, n = t.addWidgetPrefix("column-chooser-button"), s = t.option("columnChooser.enabled"), o = e.find(`.${n}`);
    let r;
    s ? o.length ? o.show() : (r = p("<div>").addClass(n).appendTo(e), t._createComponent(r, wt, {
      icon: "column-chooser",
      onClick() {
        t.getView("columnChooserView").showColumnChooser();
      },
      hint: t.option("columnChooser.title"),
      integrationOptions: {}
    })) : o.hide();
  }
  getPosition() {
    const e = this.option("columnChooser.position");
    return f(e) ? e : {
      my: "right bottom",
      at: "right bottom",
      of: this._rowsView && this._rowsView.element(),
      collision: "fit",
      offset: "-2 -2",
      boundaryOffset: "2 2"
    };
  }
}
class r6 extends Cd {
  optionChanged(e) {
    e.name === "columnChooser" ? (this._initializePopupContainer(), this.render(null, "full")) : super.optionChanged(e);
  }
  publicMethods() {
    return ["showColumnChooser", "hideColumnChooser"];
  }
  _resizeCore() {
  }
  _isWinDevice() {
    return !!z.real().win;
  }
  _initializePopupContainer() {
    const e = this, t = e.addWidgetPrefix("column-chooser"), n = e.element().addClass(t), s = e.option("columnChooser"), o = this._columnChooserController.getPosition(), r = pn(), a = m_(r), l = Zt(r), d = {
      visible: !1,
      shading: !1,
      showCloseButton: !1,
      dragEnabled: !0,
      resizeEnabled: !0,
      wrapperAttr: {
        class: t
      },
      toolbarItems: [{
        text: s.title,
        toolbar: "top",
        location: a || l ? "before" : "center"
      }],
      position: o,
      width: s.width,
      height: s.height,
      rtlEnabled: e.option("rtlEnabled"),
      onHidden() {
        e._isWinDevice() && p("body").removeClass(e.addWidgetPrefix("notouch-action"));
      },
      container: s.container,
      _loopFocus: !0
    };
    a || l ? x(d, {
      showCloseButton: !0
    }) : d.toolbarItems[d.toolbarItems.length] = {
      shortcut: "cancel"
    }, f(this._popupContainer) ? this._popupContainer.option(d) : (e._popupContainer = e._createComponent(n, pi, d), e._popupContainer.on("optionChanged", (u) => {
      u.name === "visible" && e.renderCompleted.fire();
    })), this.setPopupAttributes();
  }
  setPopupAttributes() {
    const e = this.isSelectMode(), t = this._columnsController.isBandColumnsUsed();
    this._popupContainer.setAria({
      role: "dialog",
      label: S.format("dxDataGrid-columnChooserTitle")
    }), this._popupContainer.$wrapper().toggleClass(this.addWidgetPrefix(t6), !e).toggleClass(this.addWidgetPrefix(n6), e), this._popupContainer.$content().addClass(this.addWidgetPrefix("column-chooser-list")), e && !t && this._popupContainer.$content().addClass(this.addWidgetPrefix("column-chooser-plain"));
  }
  _renderCore(e) {
    if (this._popupContainer) {
      const t = !this.isSelectMode();
      !this._columnChooserList || e === "full" ? this._renderTreeView() : t && this._updateItems();
    }
  }
  _renderTreeView() {
    var e, t, n;
    const s = this, o = this._popupContainer.$content(), r = this.option("columnChooser"), a = this.isSelectMode(), l = f(r.allowSearch) ? r.allowSearch : (e = r.search) === null || e === void 0 ? void 0 : e.enabled, d = f(r.searchTimeout) ? r.searchTimeout : (t = r.search) === null || t === void 0 ? void 0 : t.timeout, u = {
      dataStructure: "plain",
      activeStateEnabled: !0,
      focusStateEnabled: !0,
      hoverStateEnabled: !0,
      itemTemplate: "item",
      showCheckBoxesMode: "none",
      rootValue: null,
      searchEnabled: l,
      searchTimeout: d,
      searchEditorOptions: (n = r.search) === null || n === void 0 ? void 0 : n.editorOptions
    };
    if (this._isWinDevice() && (u.useNativeScrolling = !1), x(u, a ? this._prepareSelectModeConfig() : this._prepareDragModeConfig()), this._columnChooserList)
      u.searchEnabled || (u.searchValue = ""), this._columnChooserList.option(u), this._updateItems();
    else {
      this._columnChooserList = this._createComponent(o, xd, u), this._updateItems();
      let c = 0;
      this._columnChooserList.on("optionChanged", (h) => {
        c = h.component.getScrollable().scrollTop();
      }), this._columnChooserList.on("contentReady", (h) => {
        qt(() => {
          h.component.getScrollable().scrollTo({
            y: c
          }), s.renderCompleted.fire();
        });
      });
    }
  }
  _prepareDragModeConfig() {
    return {
      noDataText: this.option("columnChooser").emptyPanelText,
      activeStateEnabled: !1,
      hoverStateEnabled: !1,
      itemTemplate(t, n, s) {
        p(s).text(t.text).parent().addClass(t.cssClass).addClass("dx-column-chooser-item");
      }
    };
  }
  _prepareSelectModeConfig() {
    const e = this, t = this.option("columnChooser.selection") ?? {};
    let n = !1;
    return {
      selectByClick: t.selectByClick,
      selectNodesRecursive: t.recursive,
      showCheckBoxesMode: t.allowSelectAll ? "selectAll" : "normal",
      onSelectionChanged: (s) => {
        if (n)
          return;
        const o = ((r) => {
          const a = (l, d) => l.reduce((u, c) => (u.push(c), c.children.length && a(c.children, u), u), d);
          return a(r, []);
        })(s.component.getNodes());
        s.component.beginUpdate(), n = !0, ((r, a) => {
          a.filter((l) => l.itemData.allowHiding === !1).forEach((l) => r.component.selectItem(l.key));
        })(s, o), s.component.endUpdate(), n = !1, e.component.beginUpdate(), this._isUpdatingColumnVisibility = !0, ((r) => {
          r.forEach((a) => {
            const l = a.itemData.id, d = a.selected !== !1;
            e._columnsController.columnOption(l, "visible", d);
          });
        })(o), e.component.endUpdate(), this._isUpdatingColumnVisibility = !1;
      }
    };
  }
  _updateItems() {
    const e = this.isSelectMode(), t = this._columnsController.getChooserColumns(e), n = s6(this, t);
    this._columnChooserList.option("items", n);
  }
  _updateItemsSelection(e) {
    const t = e?.map((n) => this._columnsController.columnOption(n));
    this._columnChooserList.beginUpdate(), t?.forEach((n) => {
      let {
        visible: s,
        index: o
      } = n;
      s ? this._columnChooserList.selectItem(o) : this._columnChooserList.unselectItem(o);
    }), this._columnChooserList.endUpdate();
  }
  _columnOptionChanged(e) {
    if (super._columnOptionChanged(e), this.isSelectMode() && this._columnChooserList && !this._isUpdatingColumnVisibility) {
      const {
        optionNames: n
      } = e, s = n.visible && n.length === 1, o = f(e.columnIndex) ? [e.columnIndex] : e.columnIndices;
      (i6.some((a) => n[a]) || e.changeTypes.columns && n.all) && (this._updateItemsSelection(o), s || this._updateItems());
    }
  }
  getColumnElements() {
    const e = [], t = this.isSelectMode(), n = this._columnsController.getChooserColumns(t), s = this._popupContainer && this._popupContainer.$content(), o = s && s.find(".dx-treeview-node");
    return o && n.forEach((r) => {
      const a = o.filter(`[data-item-id = '${r.index}']`), l = a.length ? a.children(".dx-column-chooser-item").get(0) : null;
      e.push(l);
    }), p(e);
  }
  getName() {
    return "columnChooser";
  }
  getColumns() {
    return this._columnsController.getChooserColumns();
  }
  allowDragging(e) {
    const t = this._columnsController.isParentColumnVisible(e.index), n = !e.visible && e.allowHiding;
    return this.isColumnChooserVisible() && t && n;
  }
  allowColumnHeaderDragging(e) {
    return !this.isSelectMode() && this.isColumnChooserVisible() && e.allowHiding;
  }
  getBoundingRect() {
    const e = this._popupContainer && this._popupContainer.$overlayContent();
    if (e && e.is(":visible")) {
      const t = e.offset();
      return {
        left: t.left,
        top: t.top,
        right: t.left + Ee(e),
        bottom: t.top + he(e)
      };
    }
    return null;
  }
  showColumnChooser() {
    this._popupContainer || (this._initializePopupContainer(), this.render()), this._popupContainer.show(), this._isWinDevice() && p("body").addClass(this.addWidgetPrefix("notouch-action"));
  }
  hideColumnChooser() {
    this._popupContainer && this._popupContainer.hide();
  }
  isColumnChooserVisible() {
    const e = this._popupContainer;
    return e && e.option("visible");
  }
  isSelectMode() {
    return this.option("columnChooser.mode") === "select";
  }
  hasHiddenColumns() {
    const e = this.option("columnChooser.enabled"), t = this.getColumns().filter((n) => !n.visible);
    return e && t.length;
  }
}
const a6 = (i) => class extends i {
  _getToolbarItems() {
    const e = super._getToolbarItems();
    return this._appendColumnChooserItem(e);
  }
  _appendColumnChooserItem(e) {
    const t = this;
    if (t.option("columnChooser.enabled")) {
      const s = function() {
        t.component.getView("columnChooserView").showColumnChooser();
      }, o = function(l) {
        p(l.element).addClass(t._getToolbarButtonClass(t.addWidgetPrefix("column-chooser-button")));
      }, r = t.option("columnChooser.title"), a = {
        widget: "dxButton",
        options: {
          icon: "column-chooser",
          onClick: s,
          hint: r,
          text: r,
          onInitialized: o,
          elementAttr: {
            "aria-haspopup": "dialog"
          }
        },
        showText: "inMenu",
        location: "after",
        name: "columnChooserButton",
        locateInMenu: "auto",
        sortIndex: 40
      };
      e.push(a);
    }
    return e;
  }
  optionChanged(e) {
    e.name === "columnChooser" ? (this._invalidate(), e.handled = !0) : super.optionChanged(e);
  }
}, l6 = (i) => class extends i {
  allowMoveColumn(e, t, n, s) {
    return this.option("columnChooser.mode") === "select" && s === "columnChooser" ? !1 : super.allowMoveColumn(e, t, n, s);
  }
}, d6 = (i) => class extends i {
  allowDragging(e) {
    const t = !this._columnChooserView.isSelectMode(), n = this._columnChooserView.isColumnChooserVisible();
    return t && n && e.allowHiding || super.allowDragging(e);
  }
}, aC = {
  defaultOptions: () => ({
    columnChooser: {
      enabled: !1,
      search: {
        enabled: !1,
        timeout: 500,
        editorOptions: {}
      },
      selection: {
        allowSelectAll: !1,
        selectByClick: !1,
        recursive: !1
      },
      position: void 0,
      mode: "dragAndDrop",
      width: 250,
      height: 260,
      title: S.format("dxDataGrid-columnChooserTitle"),
      emptyPanelText: S.format("dxDataGrid-columnChooserEmptyText"),
      container: void 0
    }
  }),
  controllers: {
    columnChooser: o6
  },
  views: {
    columnChooserView: r6
  },
  extenders: {
    views: {
      headerPanel: a6,
      columnHeadersView: d6
    },
    controllers: {
      columns: l6
    }
  }
};
aC.controllers.columnChooser;
aC.views.columnChooserView;
J.registerModule("columnChooser", aC);
function Zo(i, e) {
  const t = hs(e.group), n = [];
  for (let s = 0; s < i.length; s++)
    n.push([t[s].selector, "=", i[s]]);
  return e.filter && n.push(e.filter), F.combineFilters(n);
}
function fA(i, e, t) {
  const n = hs(e.group);
  let s = [];
  for (let o = t ? i.length - 1 : 0; o < i.length; o++) {
    const r = [];
    for (let a = 0; a <= o; a++) {
      const {
        selector: l
      } = n[a];
      if (o === a && (i[a] === null || i[a] === !1 || i[a] === !0))
        i[a] === !1 ? r.push([l, "=", n[a].desc ? !0 : null]) : (i[a] ? !n[a].desc : n[a].desc) ? r.push([l, "<>", i[a]]) : (r.push([l, "<>", null]), r.push([l, "=", null]));
      else {
        const d = [l, o === a ? n[a].desc ? ">" : "<" : "=", i[a]];
        d[1] === "<" ? r.push([d, "or", [l, "=", null]]) : r.push(d);
      }
    }
    s.push(J.combineFilters(r));
  }
  return s = J.combineFilters(s, "or"), J.combineFilters([s, e.filter]);
}
const rw = function(i, e) {
  const {
    hash: t
  } = i;
  return t && t[JSON.stringify(e)];
}, u6 = function(i, e) {
  let t = 0, n = i.length - 1;
  if (!i.length)
    return 0;
  do {
    const o = n + t >> 1;
    i[o].offset > e ? n = o : t = o;
  } while (n - t > 1);
  let s;
  for (s = t; s <= n && !(i[s].offset > e); s++)
    ;
  return s;
}, _A = function(i, e, t) {
  for (let n = 0; n < i.length; n++)
    e + 1 >= t ? i[n].children = [] : _A(i[n].children, e + 1, t);
}, CA = function(i, e, t) {
  let n = 0;
  if (e)
    if (!t)
      n = e.length;
    else
      for (let s = 0; s < e.length; s++)
        i.isGroupItemCountable(e[s]) && n++, n += CA(i, e[s].items, t - 1);
  return n;
};
let vA = class {
  constructor(e) {
    this._dataSource = e, this.reset();
  }
  reset() {
    this._groupsInfo = [], this._totalCountCorrection = 0;
  }
  totalCountCorrection() {
    return this._totalCountCorrection;
  }
  updateTotalItemsCount(e) {
    this._totalCountCorrection = e || 0;
  }
  isGroupItemCountable(e) {
    return !this._isVirtualPaging() || !e.isContinuation;
  }
  _isVirtualPaging() {
    const e = this._dataSource.option("scrolling.mode");
    return e === "virtual" || e === "infinite";
  }
  itemsCount() {
    const t = this._dataSource._dataSource, n = J.normalizeSortingInfo(t.group() || []).length;
    return CA(this, t.items(), n);
  }
  foreachGroups(e, t, n, s, o) {
    const r = this;
    return function a(l, d, u, c) {
      const h = [];
      function g(C, v, E, T) {
        const V = v && C(v, E);
        return V && T.push(V), V;
      }
      for (let C = 0; C < l.length; C++) {
        if (c.push(l[C].data), !u && g(d, l[C].data, c, h) === !1)
          return !1;
        if (!l[C].data || l[C].data.isExpanded || n) {
          const {
            children: v
          } = l[C], E = v.length && a(v, d, u, c);
          if (E && h.push(E), E === !1)
            return !1;
        }
        if (u && g(d, l[C].data, c, h) === !1)
          return !1;
        (!l[C].data || l[C].data.offset !== l[C].offset) && (s = !0), c.pop();
      }
      const m = o && c.slice(0);
      return s && W.apply(p, h).always(() => {
        r._updateGroupInfoOffsets(l, m);
      });
    }(r._groupsInfo, e, t, []);
  }
  _updateGroupInfoOffsets(e, t) {
    t = t || [];
    for (let n = 0; n < e.length; n++) {
      const s = e[n];
      if (s.data && s.data.offset !== s.offset) {
        s.offset = s.data.offset;
        for (let o = 0; o < t.length; o++)
          t[o].offset = s.offset;
      }
    }
    e.sort((n, s) => n.offset - s.offset);
  }
  findGroupInfo(e) {
    let t, n = this._groupsInfo;
    for (let s = 0; n && s < e.length; s++)
      t = rw(n, e[s]), n = t && t.children;
    return t && t.data;
  }
  addGroupInfo(e) {
    const t = this;
    let n;
    const {
      path: s
    } = e;
    let o = t._groupsInfo;
    for (let r = 0; r < s.length; r++) {
      if (n = rw(o, s[r]), !n) {
        n = {
          key: s[r],
          offset: e.offset,
          data: {
            offset: e.offset,
            isExpanded: !0,
            path: s.slice(0, r + 1)
          },
          children: []
        };
        const a = u6(o, e.offset);
        o.splice(a, 0, n), o.hash = o.hash || {}, o.hash[JSON.stringify(n.key)] = n;
      }
      r === s.length - 1 && (n.data = e, n.offset !== e.offset && t._updateGroupInfoOffsets(o)), o = n.children;
    }
  }
  allowCollapseAll() {
    return !0;
  }
  refresh(e) {
    const t = this, {
      storeLoadOptions: n
    } = e, s = hs(n.group || []), o = "_group" in t ? hs(t._group || []) : s;
    let r = Math.min(o.length, s.length);
    t._group = n.group;
    for (let a = 0; a < r; a++)
      if (o[a].selector !== s[a].selector) {
        r = a;
        break;
      }
    r ? _A(t._groupsInfo, 0, r) : t.reset();
  }
  handleDataLoading() {
  }
  handleDataLoaded(e, t) {
    t(e);
  }
  handleDataLoadedCore(e, t) {
    t(e);
  }
};
function Bm(i, e, t, n) {
  if (n = n || 0, e > 1 && t > 0) {
    let s = i - Math.floor(i / e) * e || e;
    return s += t - n - 2, s < 0 && (s += e), Math.floor(s / (e - n - 1));
  }
  return 0;
}
const Ma = function(i, e, t) {
  return i.foreachGroups((n, s) => {
    if (n.isExpanded)
      return e(n, s);
  }, !0, !1, t, t);
}, lC = function(i, e, t, n, s, o, r) {
  let a;
  if (n.items = n.items || [], n.paths = n.paths || [], n.count = n.count || 0, n.lastCount = n.lastCount || 0, !!t)
    for (let l = 0; l < e.length; l++) {
      const d = e[l];
      if (d.items !== void 0) {
        if (s.push(d.key), o)
          a = !0;
        else {
          const u = i.findGroupInfo(s);
          a = u && u.isExpanded;
        }
        a ? d.items ? lC(i, d.items, t - 1, n, s, o, r) : t === 1 && d.count && (!o || r) && (n.items.push(d), n.paths.push(s.slice(0)), n.count += n.lastCount, n.lastCount = d.count) : (d.collapsedItems = d.items, d.items = null), s.pop();
      }
    }
}, c6 = function(i, e, t, n, s) {
  const o = i.findGroupInfo(n);
  let r;
  o ? (t ? o.count = e.count > 0 ? e.count : e.items && e.items.length || 0 : e.count = o.count || e.count, o.offset = s) : (t && (r = e.count > 0 ? e.count : e.items.length), i.addGroupInfo({
    isExpanded: i._isGroupExpanded(n.length - 1),
    path: n.slice(0),
    offset: s,
    count: r || 0
  }));
}, dC = function(i, e, t, n, s, o, r) {
  const l = (e.group ? e.group.length : 0) === n, d = e.remoteOperations.paging;
  let u = 0, c = 0, h;
  if (s = s || 0, o = o || [], d && !r && (u = s === 0 ? e.skip || 0 : e.skips[s - 1] || 0), s >= n)
    return t.length;
  for (let g = 0; g < t.length; g++) {
    const m = t[g];
    if (m) {
      if (o.push(m.key), !m.count && !m.items || m.items === void 0 || (c6(i, m, l, o, u + g), h = m.items ? dC(i, e, m.items, n, s + 1, o, g) : m.count || -1, h < 0))
        return -1;
      c += h, o.pop();
    }
  }
  return c;
}, Np = function(i, e) {
  return i && i.length && i[e] && !!i[e].isExpanded;
}, aw = function(i, e, t) {
  let n, s = t;
  for (let o = 0; o < i.length; o++)
    n = i[o].offset + 1, o > 0 && (n += i[o - 1].childrenTotalCount, e && (n += Bm(s, e, n, o - 1) * o)), s += n;
  return s;
};
function xA(i, e, t, n) {
  const s = e.items[n], o = i.skips && i.skips[t], r = i.takes && i.takes[t], a = n === e.items.length - 1, l = n === 0, d = l && o || 0, u = s.count > r + d;
  l && o !== void 0 && (s.isContinuation = !0), a && r !== void 0 && u && (s.isContinuationOnNextPage = !0);
}
function h6(i, e, t) {
  const n = t - 1, s = i.group ? i.group.length : 0;
  e.skip = i.skips && i.skips[n], i.takes && i.takes[n] !== void 0 && (s === t ? e.take = e.count ? e.count - (e.skip || 0) : 0 : e.take = 0, e.take += i.takes[n]);
}
function yA(i) {
  return !Array.isArray(i);
}
function lw(i) {
  yA(i.data) || (i.data = new w());
}
function bA(i, e, t, n, s, o) {
  e.isCustomLoading || (n = {}, lC(i, o, t, n, []), h6(e, n, t));
  const r = e.group ? e.group.length : 0;
  n.paths.length && r - t > 0 ? (lw(e), p6(i, e, n, t, s, o)) : n.paths.length && e.storeLoadOptions.group ? (lw(e), g6(i, e, n, o)) : yA(e.data) && e.data.resolve(o);
}
function p6(i, e, t, n, s, o) {
  const r = e.group || [], a = r[s + 1], l = [];
  y(t.paths, (d) => {
    var u;
    const c = {
      requireTotalCount: !1,
      requireGroupCount: !0,
      group: [a],
      groupSummary: e.storeLoadOptions.groupSummary,
      filter: Zo(t.paths[d], {
        filter: e.storeLoadOptions.filter,
        group: r
      }),
      select: e.storeLoadOptions.select,
      langParams: (u = e.storeLoadOptions) === null || u === void 0 ? void 0 : u.langParams
    };
    d === 0 && (c.skip = t.skip || 0), d === t.paths.length - 1 && (c.take = t.take);
    const h = c.take === 0 ? [] : i._dataSource.loadFromStore(c);
    W(h).done((g) => {
      const m = t.items[d];
      xA(e, t, s, d), m.items = g;
    }), l.push(h);
  }), W.apply(null, l).done(() => {
    dC(i, e, o, n + 1), bA(i, e, n + 1, t, s + 1, o);
  });
}
function g6(i, e, t, n) {
  const s = [], o = e.group || [];
  y(t.paths, (d, u) => {
    s.push(Zo(u, {
      group: e.isCustomLoading ? e.storeLoadOptions.group : o
    }));
  });
  let {
    filter: r
  } = e.storeLoadOptions;
  e.storeLoadOptions.isLoadingAll || (r = J.combineFilters([r, J.combineFilters(s, "or")]));
  const a = x({}, e.storeLoadOptions, {
    requireTotalCount: !1,
    requireGroupCount: !1,
    group: null,
    sort: o.concat(J.normalizeSortingInfo(e.storeLoadOptions.sort || [])),
    filter: r
  }), l = i._dataSource.isLastLevelGroupItemsPagingLocal();
  l || (a.skip = t.skip, a.take = t.take), W(t.take === 0 ? [] : i._dataSource.loadFromStore(a)).done((d) => {
    l && (d = i._dataSource.sortLastLevelGroupItems(d, o, t.paths), d = t.skip ? d.slice(t.skip) : d, d = t.take ? d.slice(0, t.take) : d), y(t.items, (u, c) => {
      const h = c.count - (u === 0 && t.skip || 0), g = d.splice(0, h);
      xA(e, t, o.length - 1, u), c.items = g;
    }), e.data.resolve(n);
  }).fail(e.data.reject);
}
const Lp = function(i, e) {
  const t = new w(), n = !!(e.group && e.group.length), s = x({
    skip: 0,
    take: 1,
    requireGroupCount: n,
    requireTotalCount: !n
  }, e, {
    group: n ? e.group : null
  });
  return i.load(s).done((o, r) => {
    const a = r && (n ? r.groupCount : r.totalCount);
    if (!isFinite(a)) {
      t.reject(vt.Error(n ? "E4022" : "E4021"));
      return;
    }
    t.resolve(a);
  }).fail(t.reject.bind(t)), t;
};
let dw = class extends vA {
  updateTotalItemsCount(e) {
    let t = 0;
    const n = e.extra && e.extra.totalCount || 0, s = e.extra && e.extra.groupCount || 0, o = this._dataSource.pageSize(), r = this._isVirtualPaging();
    Ma(this, (a) => {
      a.childrenTotalCount = 0;
    }), Ma(this, (a, l) => {
      const d = aw(l, r ? 0 : o, t);
      let u = a.count + a.childrenTotalCount;
      r || (u += Bm(d, o, u, l.length - 1)), l[l.length - 2] ? l[l.length - 2].childrenTotalCount += u : t += u;
    }), super.updateTotalItemsCount(t - n + s);
  }
  _isGroupExpanded(e) {
    const t = this._dataSource.group();
    return Np(t, e);
  }
  _updatePagingOptions(e, t) {
    const n = this, s = n._isVirtualPaging(), o = n._dataSource.pageSize(), r = [], a = [];
    let l = 0, d = 0;
    e.take && (Ma(this, (u) => {
      u.childrenTotalCount = 0, u.skipChildrenTotalCount = 0;
    }), Ma(n, (u, c) => {
      let h, g = 0, m = 0;
      const C = aw(c, s ? 0 : o, d);
      let v = 0, E = 0, T = u.count + u.childrenTotalCount, V = T;
      t && t(u, C);
      const $ = e.skip - C;
      C <= e.skip + e.take && T && (h = e.take, s || (v = Bm(C, o, T, c.length - 1), T += v * c.length, V += v, o && $ >= 0 && (g = c.length, m = c.length - 1, E = Math.floor($ / o))), $ >= 0 ? (C + T > e.skip && r.unshift($ - E * g - u.skipChildrenTotalCount), C + T >= e.skip + h && a.unshift(h - g - u.childrenTotalCount + u.skipChildrenTotalCount)) : C + T >= e.skip + h && a.unshift(h + $ - u.childrenTotalCount)), C <= e.skip && (c[c.length - 2] ? c[c.length - 2].skipChildrenTotalCount += Math.min(V, $ + 1 - E * m) : l += Math.min(V, $ + 1)), C <= e.skip + h && (T = Math.min(V, $ + h - (E + 1) * m), c[c.length - 2] ? c[c.length - 2].childrenTotalCount += T : d += T);
    }), e.skip -= l, e.take -= d - l), e.skips = r, e.takes = a;
  }
  changeRowExpand(e) {
    const t = this.findGroupInfo(e), n = this._dataSource, s = n.remoteOperations().groupPaging, o = J.normalizeSortingInfo(n.group());
    return t ? (t.isExpanded = !t.isExpanded, s && t.isExpanded && e.length < o.length ? Lp(n, {
      filter: Zo(e, {
        filter: n.lastLoadOptions().filter,
        group: n.group()
      }),
      group: [o[e.length]],
      select: n.select()
    }).done((r) => {
      t.count = r;
    }) : new w().resolve()) : new w().reject();
  }
  handleDataLoading(e) {
    const t = this, {
      storeLoadOptions: n
    } = e, s = J.normalizeSortingInfo(n.group || e.loadOptions.group);
    if (!(e.isCustomLoading || !s.length)) {
      if (e.remoteOperations.grouping) {
        const o = t._dataSource.remoteOperations().paging;
        n.group = J.normalizeSortingInfo(n.group), n.group.forEach((r, a) => {
          const l = a === n.group.length - 1;
          r.isExpanded = !o || !l;
        });
      }
      e.group = e.group || s, e.remoteOperations.paging ? (e.skip = n.skip, e.take = n.take, n.requireGroupCount = !0, n.group = s.slice(0, 1), t._updatePagingOptions(e), n.skip = e.skip, n.take = e.take) : (e.skip = e.loadOptions.skip, e.take = e.loadOptions.take, t._updatePagingOptions(e));
    }
  }
  handleDataLoadedCore(e, t) {
    const n = this, s = J.normalizeSortingInfo(e.storeLoadOptions.group || e.loadOptions.group).length, o = e.group ? e.group.length : 0;
    let r;
    const a = {};
    if (e.isCustomLoading)
      t(e), lC(n, e.data, s, a, [], e.isCustomLoading, e.storeLoadOptions.isLoadingAll);
    else {
      if (e.remoteOperations.paging || n.foreachGroups((l) => {
        l.count = 0;
      }), r = dC(n, e, e.data, s), r < 0) {
        e.data = new w().reject(_e.Error("E1037"));
        return;
      }
      if (e.remoteOperations.paging || s && e.extra && e.loadOptions.requireTotalCount && (e.extra.totalCount = r, e.extra.groupCount = e.data.length), o && e.storeLoadOptions.requireGroupCount && !isFinite(e.extra.groupCount)) {
        e.data = new w().reject(vt.Error("E4022"));
        return;
      }
      n.updateTotalItemsCount(e), e.remoteOperations.paging || (n._updatePagingOptions(e), e.lastLoadOptions.skips = e.skips, e.lastLoadOptions.takes = e.takes), t(e), e.remoteOperations.paging || n._processPaging(e, s);
    }
    bA(n, e, s, a, 0, e.data);
  }
  _processSkips(e, t, n) {
    if (!n)
      return;
    const s = e[0], o = t[0], r = s && s.items;
    o !== void 0 && (s.isContinuation = !0, r && (s.items = r.slice(o), this._processSkips(s.items, t.slice(1), n - 1)));
  }
  _processTakes(e, t, n, s, o) {
    if (!s || !e)
      return;
    o = o || [];
    const r = e[e.length - 1];
    let a = r && r.items;
    const l = n[0], d = t[0];
    if (r) {
      const u = r.count - (r.isContinuation && d || 0) || a.length;
      l !== void 0 && u > l && (r.isContinuationOnNextPage = !0, o.forEach((c) => {
        c.isContinuationOnNextPage = !0;
      }), a && (a = a.slice(0, l), r.items = a)), o.push(r), this._processTakes(a, t.slice(1), n.slice(1), s - 1, o);
    }
  }
  _processPaging(e, t) {
    this._processSkips(e.data, e.skips, t), this._processTakes(e.data, e.skips, e.takes, t);
  }
  isLastLevelGroupItemsPagingLocal() {
    return !1;
  }
  sortLastLevelGroupItems(e) {
    return e;
  }
  refresh(e, t) {
    const n = this, s = n._dataSource, {
      storeLoadOptions: o
    } = e, r = e.group || e.storeLoadOptions.group, a = J.normalizeSortingInfo(n._group);
    let l, d;
    function u(c, h) {
      h.length === d + 1 && (c.isExpanded = l);
    }
    for (d = 0; d < a.length; d++)
      l = Np(r, d), Np(n._group, d) !== l && n.foreachGroups(u);
    if (super.refresh.apply(this, arguments), r && e.remoteOperations.paging && t.reload)
      return Ma(n, (c) => {
        const h = Lp(s, {
          filter: Zo(c.path, {
            filter: o.filter,
            group: r
          }),
          group: r.slice(c.path.length),
          select: o.select
        }), g = Lp(s, {
          filter: fA(c.path, {
            filter: o.filter,
            group: r
          }, !0),
          group: r.slice(c.path.length - 1, c.path.length),
          select: o.select
        });
        return W(g, h).done((m, C) => {
          m = parseInt(m.length ? m[0] : m), C = parseInt(C.length ? C[0] : C), c.offset = m, c.count !== C && (c.count = C, n.updateTotalItemsCount(e));
        });
      }, !0);
  }
};
const Hp = function(i, e) {
  const t = new w(), n = x({
    skip: 0,
    take: 1,
    requireTotalCount: !0
  }, e);
  return i.load(n).done((s, o) => {
    t.resolve(o && o.totalCount);
  }).fail(t.reject.bind(t)), t;
}, ku = function(i, e, t) {
  return i.foreachGroups((n) => {
    if (!n.isExpanded)
      return e(n);
  }, !1, !1, t, !0);
}, uw = function(i, e) {
  let t = 0, n = e || 0;
  return e && (ku(i, (s) => {
    if (s.offset - t >= e)
      return !1;
    t += s.count - 1;
  }), n += t), n;
}, wA = function(i, e, t, n, s, o) {
  let r = 0, a = !1;
  for (let l = 0; l < e.length; l++) {
    const d = e[l];
    if (d.items !== void 0) {
      t.push(d.key);
      const u = i.findGroupInfo(t);
      if (u && !u.isExpanded)
        d.collapsedItems = d.items, d.items = null, n += u.count, o--, o < 0 && r++, s && (a = !0);
      else if (d.items) {
        const c = wA(i, d.items, t, n, s, o);
        s && (c.offset - n > 1 ? d.isContinuation = !0 : a = !0), n = c.offset, o = c.take, o < 0 && (d.items.length ? d.isContinuationOnNextPage = !0 : r++);
      }
      t.pop();
    } else
      s && (a = !0), n++, o--, o < 0 && r++;
    s = !1;
  }
  return a && e.splice(0, 1), r && e.splice(-r, r), {
    offset: n,
    take: o
  };
}, m6 = function(i, e) {
  if (i.length !== e.length)
    return !1;
  for (let t = 0; t < i.length; t++)
    if (!gd(null, i[t], e[t]))
      return !1;
  return !0;
}, $m = function(i, e, t, n, s) {
  if (e) {
    for (let o = 0; o < e.length; o++) {
      const r = e[o];
      if ("key" in r && r.items !== void 0) {
        t.push(r.key), s && m6(s.path, t) && !r.isContinuation && (s.offset = n);
        const a = i.findGroupInfo(t);
        a && !r.isContinuation && (a.offset = n), a && !a.isExpanded ? n += a.count : n = $m(i, r.items, t, n, s), t.pop();
      } else
        n++;
    }
    return n;
  }
}, f6 = function(i, e) {
  if (e.group) {
    const t = J.normalizeSortingInfo(e.group), n = J.normalizeSortingInfo(i.sort);
    i.sort = ps.arrangeSortingInfo(t, n), delete e.group;
  }
}, _6 = function(i, e, t) {
  const n = J.normalizeSortingInfo(t || e.group);
  let s = [];
  for (let o = 0; o < i.length; o++) {
    const r = [];
    for (let a = 0; a <= o; a++)
      r.push([n[a].selector, o === a ? "<>" : "=", i[a]]);
    s.push(J.combineFilters(r));
  }
  return s = J.combineFilters(s, "or"), J.combineFilters([s, e.filter]);
}, SA = function(i, e) {
  let t = i.count || i.items.length;
  if (!i.count && e > 1) {
    t = 0;
    for (let n = 0; n < i.items.length; n++)
      t += SA(i.items[n], e - 1);
  }
  return t;
};
class cw extends vA {
  handleDataLoading(e) {
    const {
      storeLoadOptions: t
    } = e, n = [];
    let s = 0, o = !1, r;
    const {
      group: a
    } = e.loadOptions;
    let l = 0;
    if (f6(t, e.loadOptions), e.group = e.group || a, e.isCustomLoading)
      return;
    const d = x({}, t);
    d.skip = uw(this, t.skip), d.skip && d.take && a && (d.skip--, d.take++, o = !0), d.take && a && (r = d.take, d.take++), ku(this, (u) => {
      if (u.offset >= d.skip + d.take + l)
        return !1;
      u.offset >= d.skip + l && u.count && (l += u.count - 1, n.push(u), s += u.count);
    }), y(n, function() {
      d.filter = _6(this.path, d, a);
    }), e.storeLoadOptions = d, e.collapsedGroups = n, e.collapsedItemsCount = s, e.skip = d.skip || 0, e.skipFirstItem = o, e.take = r;
  }
  handleDataLoaded(e, t) {
    const n = this, {
      collapsedGroups: s
    } = e, o = J.normalizeSortingInfo(e.group), r = o.length;
    function a(l, d, u, c, h) {
      if (!l || !d.length || !u.length)
        return;
      let g, m;
      const C = Mt(d[0], !0);
      for (m = 0; m < l.length && (g = Mt(l[m].key, !0), !(h >= c.offset || C === g)); m++)
        h += SA(l[m], u.length);
      (!l.length || C !== g) && l.splice(m, 0, {
        key: d[0],
        items: [],
        count: d.length === 1 ? c.count : void 0
      }), a(l[m].items, d.slice(1), u.slice(1), c, h);
    }
    if (e.collapsedItemsCount && e.extra && e.extra.totalCount >= 0 && (e.extra._totalCountWasIncreasedByCollapsedItems || (e.extra.totalCount += e.collapsedItemsCount, e.extra._totalCountWasIncreasedByCollapsedItems = !0)), t(e), r) {
      let {
        data: l
      } = e;
      const d = un(l);
      if (ps.multiLevelGroup(d, o).enumerate().done((u) => {
        l = u;
      }), s)
        for (let u = 0; u < s.length; u++)
          a(l, s[u].path, o, s[u], e.skip);
      e.isCustomLoading || wA(n, l, [], e.skip, e.skipFirstItem, e.take), e.data = l;
    }
  }
  isGroupItemCountable(e) {
    return e.items === null;
  }
  updateTotalItemsCount() {
    let e = 0;
    ku(this, (t) => {
      t.count && (e -= t.count - 1);
    }), super.updateTotalItemsCount(e);
  }
  changeRowExpand(e) {
    const t = this, n = t._dataSource, s = n.beginPageIndex ? n.beginPageIndex() : n.pageIndex(), o = n.items(), r = uw(t, s * n.pageSize());
    let a = t.findGroupInfo(e), l;
    return a && !a.isExpanded ? l = new w().resolve(a.count) : l = Hp(n, {
      filter: Zo(e, {
        filter: n.filter(),
        group: n.group()
      })
    }), W(l).done((d) => {
      d = parseInt(d.length ? d[0] : d), a ? ($m(t, o, [], r), a.isExpanded = !a.isExpanded, a.count = d) : (a = {
        offset: -1,
        count: d,
        path: e,
        isExpanded: !1
      }, $m(t, o, [], r, a), a.offset >= 0 && t.addGroupInfo(a)), t.updateTotalItemsCount();
    }).fail(function() {
      n._eventsStrategy.fireEvent("loadError", arguments);
    });
  }
  allowCollapseAll() {
    return !1;
  }
  refresh(e, t) {
    const n = this, {
      storeLoadOptions: s
    } = e, o = n._dataSource;
    if (super.refresh.apply(this, arguments), t.reload)
      return ku(n, (r) => {
        const a = Hp(o, {
          filter: Zo(r.path, s)
        }), l = Hp(o, {
          filter: fA(r.path, s)
        });
        return W(l, a).done((d, u) => {
          d = parseInt(d.length ? d[0] : d), u = parseInt(u.length ? u[0] : u), r.offset = d, r.count !== u && (r.count = u, n.updateTotalItemsCount());
        });
      }, !0);
  }
}
const C6 = (i) => class extends i {
  init() {
    super.init.apply(this, arguments), this._initGroupingHelper();
  }
  _initGroupingHelper(e) {
    const t = this._grouping, n = this.option("grouping.autoExpandAll"), s = this.option("focusedRowEnabled"), o = e ? e.remoteOperations : this.remoteOperations();
    o.filtering && o.sorting && o.paging && !o.grouping && (n || !s) ? (!t || t instanceof dw) && (this._grouping = new cw(this)) : (!t || t instanceof cw) && (this._grouping = new dw(this));
  }
  totalItemsCount() {
    const e = super.totalItemsCount();
    return e > 0 && this._dataSource.group() && this._dataSource.requireTotalCount() ? e + this._grouping.totalCountCorrection() : e;
  }
  itemsCount() {
    return this._dataSource.group() ? this._grouping.itemsCount() || 0 : super.itemsCount.apply(this, arguments);
  }
  allowCollapseAll() {
    return this._grouping.allowCollapseAll();
  }
  isGroupItemCountable(e) {
    return this._grouping.isGroupItemCountable(e);
  }
  isRowExpanded(e) {
    const t = this._grouping.findGroupInfo(e);
    return t ? t.isExpanded : !this._grouping.allowCollapseAll();
  }
  collapseAll(e) {
    return this._collapseExpandAll(e, !1);
  }
  expandAll(e) {
    return this._collapseExpandAll(e, !0);
  }
  _collapseExpandAll(e, t) {
    const n = this, s = n._dataSource, o = s.group(), r = J.normalizeSortingInfo(o || []);
    if (r.length) {
      for (let a = 0; a < r.length; a++)
        e === void 0 || e === a ? r[a].isExpanded = t : o && o[a] && (r[a].isExpanded = o[a].isExpanded);
      s.group(r), n._grouping.foreachGroups((a, l) => {
        (e === void 0 || e === l.length - 1) && (a.isExpanded = t);
      }, !1, !0), n.resetPagesCache();
    }
    return !0;
  }
  refresh() {
    return super.refresh.apply(this, arguments), this._grouping.refresh.apply(this._grouping, arguments);
  }
  changeRowExpand(e) {
    const t = this, n = t._dataSource;
    if (n.group())
      return n.beginLoading(), t._lastLoadOptions && (t._lastLoadOptions.groupExpand = !0), t._changeRowExpandCore(e).always(() => {
        n.endLoading();
      });
  }
  _changeRowExpandCore(e) {
    return this._grouping.changeRowExpand(e);
  }
  _hasGroupLevelsExpandState(e, t) {
    if (e && Array.isArray(e)) {
      for (let n = 0; n < e.length; n++)
        if (e[n].isExpanded === t)
          return !0;
    }
  }
  _customizeRemoteOperations(e, t) {
    const {
      remoteOperations: n
    } = e;
    e.storeLoadOptions.group ? (n.grouping && !e.isCustomLoading && (!n.groupPaging || this._hasGroupLevelsExpandState(e.storeLoadOptions.group, !0)) && (n.paging = !1), !n.grouping && (!n.sorting || !n.filtering || e.isCustomLoading || this._hasGroupLevelsExpandState(e.storeLoadOptions.group, !1)) && (n.paging = !1)) : !e.isCustomLoading && n.paging && t.grouping && this.resetCache(), super._customizeRemoteOperations.apply(this, arguments);
  }
  _handleDataLoading(e) {
    return super._handleDataLoading(e), this._initGroupingHelper(e), this._grouping.handleDataLoading(e);
  }
  _handleDataLoaded(e) {
    return this._grouping.handleDataLoaded(e, super._handleDataLoaded.bind(this));
  }
  _handleDataLoadedCore(e) {
    return this._grouping.handleDataLoadedCore(e, super._handleDataLoadedCore.bind(this));
  }
};
gh.extend(C6);
const v6 = (i) => class extends i {
  init() {
    super.init(), this.createAction("onRowExpanding"), this.createAction("onRowExpanded"), this.createAction("onRowCollapsing"), this.createAction("onRowCollapsed");
  }
  _beforeProcessItems(e) {
    const t = this._columnsController.getGroupColumns();
    return e = super._beforeProcessItems(e), e.length && t.length && (e = this._processGroupItems(e, t.length)), e;
  }
  _processItem(e, t) {
    return f(e.groupIndex) && te(e.rowType) && e.rowType.indexOf("group") === 0 ? (e = this._processGroupItem(e, t), t.dataIndex = 0) : e = super._processItem.apply(this, arguments), e;
  }
  _processGroupItem(e, t) {
    return e;
  }
  _processGroupItems(e, t, n) {
    const s = this, o = s._columnsController.getGroupColumns(), r = o[o.length - t];
    if (!n) {
      const l = s.option("scrolling.mode");
      n = {
        collectContinuationItems: l !== "virtual" && l !== "infinite",
        resultItems: [],
        path: [],
        values: []
      };
    }
    const {
      resultItems: a
    } = n;
    if (n.data && (n.collectContinuationItems || !n.data.isContinuation) && a.push({
      rowType: "group",
      data: n.data,
      groupIndex: n.path.length - 1,
      isExpanded: !!n.data.items,
      key: n.path.slice(0),
      values: n.values.slice(0)
    }), e)
      if (t === 0)
        a.push.apply(a, e);
      else
        for (let l = 0; l < e.length; l++) {
          const d = e[l];
          d && "items" in d ? (n.data = d, n.path.push(d.key), n.values.push(r && r.deserializeValue && !r.calculateDisplayValue ? r.deserializeValue(d.key) : d.key), s._processGroupItems(d.items, t - 1, n), n.data = void 0, n.path.pop(), n.values.pop()) : a.push(d);
        }
    return a;
  }
  publicMethods() {
    return super.publicMethods().concat(["collapseAll", "expandAll", "isRowExpanded", "expandRow", "collapseRow"]);
  }
  collapseAll(e) {
    const t = this._dataSource;
    t && t.collapseAll(e) && (t.pageIndex(0), t.reload());
  }
  expandAll(e) {
    const t = this._dataSource;
    t && t.expandAll(e) && (t.pageIndex(0), t.reload());
  }
  changeRowExpand(e) {
    const t = this, n = t.isRowExpanded(e), s = {
      key: e,
      expanded: n
    };
    return t.executeAction(n ? "onRowCollapsing" : "onRowExpanding", s), s.cancel ? new w().resolve() : W(t._changeRowExpandCore(e)).done(() => {
      s.expanded = !n, t.executeAction(n ? "onRowCollapsed" : "onRowExpanded", s);
    });
  }
  _changeRowExpandCore(e) {
    const t = this, n = this._dataSource, s = new w();
    return n ? W(n.changeRowExpand(e)).done(() => {
      t.load().done(s.resolve).fail(s.reject);
    }).fail(s.reject) : s.resolve(), s;
  }
  isRowExpanded(e) {
    const t = this._dataSource;
    return t && t.isRowExpanded(e);
  }
  expandRow(e) {
    return this.isRowExpanded(e) ? new w().resolve() : this.changeRowExpand(e);
  }
  collapseRow(e) {
    return this.isRowExpanded(e) ? this.changeRowExpand(e) : new w().resolve();
  }
  optionChanged(e) {
    e.name === "grouping" && (e.name = "dataSource"), super.optionChanged(e);
  }
}, uC = function(i, e) {
  const t = this._columnsController;
  switch (e.itemData.value) {
    case "group": {
      const n = t._dataSource.group() || [];
      t.columnOption(i.dataField, "groupIndex", n.length);
      break;
    }
    case "ungroup":
      t.columnOption(i.dataField, "groupIndex", -1);
      break;
    case "ungroupAll":
      this.component.clearGrouping();
  }
}, EA = (i) => {
  const e = i?.visible;
  return e === "auto" ? z.current().deviceType === "desktop" : !!e;
}, IA = (i, e) => {
  const t = EA(i), n = i?.allowColumnDragging && e.allowGrouping;
  return t && !!n;
}, x6 = (i) => class extends i {
  _getToolbarItems() {
    const e = super._getToolbarItems();
    return this._appendGroupingItem(e);
  }
  _appendGroupingItem(e) {
    if (this._isGroupPanelVisible()) {
      let t = !1;
      const n = {
        template: () => {
          const s = p("<div>").addClass("dx-datagrid-group-panel");
          return this._updateGroupPanelContent(s), rl("groupPanel", this, s, void 0, this._handleActionKeyDown.bind(this)), s;
        },
        name: "groupPanel",
        onItemRendered: () => {
          t && this.renderCompleted.fire(), t = !0;
        },
        location: "before",
        locateInMenu: "never",
        sortIndex: 1
      };
      e.push(n), this.updateToolbarDimensions();
    }
    return e;
  }
  _handleActionKeyDown(e) {
    const {
      event: t
    } = e, n = p(t.target), s = n.closest(".dx-group-panel-item").index(), o = this._columnsController.getGroupColumns()[s], r = o && o.index;
    n.is(".dx-header-filter") ? this._headerFilterController.showHeaderFilterMenu(r, !0) : this._processGroupItemAction(r), t.preventDefault();
  }
  _isGroupPanelVisible() {
    return EA(this.option("groupPanel"));
  }
  _renderGroupPanelItems(e, t) {
    const n = this;
    e.empty(), y(t, (s, o) => {
      n._createGroupPanelItem(e, o);
    }), O_(this);
  }
  _createGroupPanelItem(e, t) {
    const n = p("<div>").addClass(t.cssClass).addClass("dx-group-panel-item").data("columnData", t).appendTo(e).text(t.caption);
    return fU(this, n), n;
  }
  _columnOptionChanged(e) {
    if (!this._requireReady && !J.checkChanges(e.optionNames, ["width", "visibleWidth"])) {
      const t = this.element(), n = t && t.find(".dx-datagrid-group-panel");
      n && n.length && (this._updateGroupPanelContent(n), this.updateToolbarDimensions(), this.renderCompleted.fire());
    }
    super._columnOptionChanged();
  }
  _updateGroupPanelContent(e) {
    const t = this.getColumns(), n = this.option("groupPanel");
    this._renderGroupPanelItems(e, t), n.allowColumnDragging && !t.length && (p("<div>").addClass("dx-group-panel-message").text(n.emptyPanelText).appendTo(e), e.closest(".dx-toolbar-item").addClass("dx-toolbar-label"), e.closest(".dx-toolbar-label").css("maxWidth", "none"));
  }
  allowDragging(e) {
    const t = this.option("groupPanel");
    return IA(t, e);
  }
  getColumnElements() {
    const e = this.element();
    return e && e.find(".dx-group-panel-item");
  }
  getColumns() {
    return this._columnsController.getGroupColumns();
  }
  getBoundingRect() {
    const e = this.element();
    if (e && e.find(".dx-datagrid-group-panel").length) {
      const t = e.offset();
      return {
        top: t.top,
        bottom: t.top + le(e)
      };
    }
    return null;
  }
  getName() {
    return "group";
  }
  getContextMenuItems(e) {
    const t = this, n = t.option("grouping.contextMenuEnabled"), s = p(e.targetElement).closest(".dx-group-panel-item");
    let o;
    if (s.length && (e.column = s.data("columnData")), n && e.column) {
      const {
        column: r
      } = e;
      if (f(r.allowGrouping) ? r.allowGrouping : !0) {
        const l = f(r.groupIndex) && r.groupIndex > -1, d = t.option("grouping.texts"), u = uC.bind(t, r);
        o = [{
          text: d.ungroup,
          value: "ungroup",
          disabled: !l,
          onItemClick: u
        }, {
          text: d.ungroupAll,
          value: "ungroupAll",
          onItemClick: u
        }];
      }
    }
    return o;
  }
  hasGroupedColumns() {
    return this._isGroupPanelVisible() && !!this.getColumns().length;
  }
  optionChanged(e) {
    e.name === "groupPanel" ? (this._invalidate(), e.handled = !0) : super.optionChanged(e);
  }
}, y6 = (i) => class extends i {
  getContextMenuItems(e) {
    const t = this, n = t.option("grouping.contextMenuEnabled");
    let s;
    if (n && e.row && e.row.rowType === "group") {
      const r = t._columnsController.columnOption(`groupIndex:${e.row.groupIndex}`);
      if (r && r.allowGrouping) {
        const a = t.option("grouping.texts"), l = uC.bind(t, r);
        s = [], s.push({
          text: a.ungroup,
          value: "ungroup",
          onItemClick: l
        }, {
          text: a.ungroupAll,
          value: "ungroupAll",
          onItemClick: l
        });
      }
    }
    return s;
  }
  _rowClick(e) {
    const t = this, n = t.option("grouping.expandMode"), o = t.option("scrolling.mode") !== "infinite" && n === "rowClick" && p(e.event.target).closest(".dx-group-row").length, r = p(e.event.target).closest(".dx-datagrid-expand").length;
    (o || r) && t._changeGroupRowState(e), super._rowClick(e);
  }
  _changeGroupRowState(e) {
    const t = this._dataController.items()[e.rowIndex], n = this._columnsController.columnOption(`groupIndex:${t.groupIndex}`, "allowCollapsing");
    (t.rowType === "data" || t.rowType === "group" && n !== !1) && (this._dataController.changeRowExpand(t.key, !0), e.event.preventDefault(), e.handled = !0);
  }
}, b6 = (i) => class extends i {
  getContextMenuItems(e) {
    const t = this, n = t.option("grouping.contextMenuEnabled");
    let s = super.getContextMenuItems(e);
    if (n && e.row && (e.row.rowType === "header" || e.row.rowType === "detailAdaptive")) {
      const {
        column: o
      } = e;
      if (!o.command && (!f(o.allowGrouping) || o.allowGrouping)) {
        const r = t.option("grouping.texts"), a = f(o.groupIndex) && o.groupIndex > -1, l = uC.bind(t, o);
        s = s || [], s.push({
          text: r.groupByThisColumn,
          value: "group",
          beginGroup: !0,
          disabled: a,
          onItemClick: l
        }), o.showWhenGrouped && s.push({
          text: r.ungroup,
          value: "ungroup",
          disabled: !a,
          onItemClick: l
        }), s.push({
          text: r.ungroupAll,
          value: "ungroupAll",
          onItemClick: l
        });
      }
    }
    return s;
  }
  allowDragging(e) {
    const t = this.option("groupPanel");
    return IA(t, e) || super.allowDragging(e);
  }
};
J.registerModule("grouping", {
  defaultOptions: () => ({
    grouping: {
      autoExpandAll: !0,
      allowCollapsing: !0,
      contextMenuEnabled: !1,
      expandMode: "buttonClick",
      texts: {
        groupContinuesMessage: S.format("dxDataGrid-groupContinuesMessage"),
        groupContinuedMessage: S.format("dxDataGrid-groupContinuedMessage"),
        groupByThisColumn: S.format("dxDataGrid-groupHeaderText"),
        ungroup: S.format("dxDataGrid-ungroupHeaderText"),
        ungroupAll: S.format("dxDataGrid-ungroupAllText")
      }
    },
    groupPanel: {
      visible: !1,
      emptyPanelText: S.format("dxDataGrid-groupPanelEmptyText"),
      allowColumnDragging: !0
    }
  }),
  extenders: {
    controllers: {
      data: v6,
      columns: (i) => class extends i {
        _getExpandColumnOptions() {
          const e = super._getExpandColumnOptions.apply(this, arguments);
          return e.cellTemplate = J.getExpandCellTemplate(), e;
        }
      },
      editing: (i) => class extends i {
        _isProcessedItem(e) {
          return f(e.groupIndex) && te(e.rowType) && e.rowType.indexOf("group") === 0;
        }
      }
    },
    views: {
      headerPanel: x6,
      rowsView: y6,
      columnHeadersView: b6
    }
  }
});
const w6 = (i) => class extends i {
  _getExpandColumnsCore() {
    const e = super._getExpandColumnsCore();
    return this.option("masterDetail.enabled") && e.push({
      type: "detailExpand",
      cellTemplate: F.getExpandCellTemplate()
    }), e;
  }
}, Wp = function(i) {
  i._expandedItems = [], i._isExpandAll = i.option("masterDetail.autoExpandAll");
}, S6 = (i) => class extends i {
  init() {
    Wp(this), super.init();
  }
  expandAll(e) {
    const t = this;
    e < 0 ? (t._isExpandAll = !0, t._expandedItems = [], t.updateItems()) : super.expandAll.apply(t, arguments);
  }
  collapseAll(e) {
    const t = this;
    e < 0 ? (t._isExpandAll = !1, t._expandedItems = [], t.updateItems()) : super.collapseAll.apply(t, arguments);
  }
  isRowExpandedHack() {
    return super.isRowExpanded.apply(this, arguments);
  }
  isRowExpanded(e) {
    const t = this, n = F.getIndexByKey(e, t._expandedItems);
    return Array.isArray(e) ? super.isRowExpanded.apply(t, arguments) : !!(t._isExpandAll ^ (n >= 0 && t._expandedItems[n].visible));
  }
  _getRowIndicesForExpand(e) {
    const t = this.getRowIndexByKey(e);
    return [t, t + 1];
  }
  _changeRowExpandCore(e) {
    const t = this;
    let n;
    if (Array.isArray(e))
      n = super._changeRowExpandCore.apply(t, arguments);
    else {
      const s = F.getIndexByKey(e, t._expandedItems);
      if (s >= 0) {
        const {
          visible: o
        } = t._expandedItems[s];
        t._expandedItems[s].visible = !o;
      } else
        t._expandedItems.push({
          key: e,
          visible: !0
        });
      t.updateItems({
        changeType: "update",
        rowIndices: t._getRowIndicesForExpand(e)
      }), n = new w().resolve();
    }
    return n;
  }
  _processDataItemHack() {
    return super._processDataItem.apply(this, arguments);
  }
  _processDataItem(e, t) {
    const n = super._processDataItem.apply(this, arguments);
    return n.isExpanded = this.isRowExpanded(n.key), t.detailColumnIndex === void 0 && (t.detailColumnIndex = -1, y(t.visibleColumns, (s, o) => {
      if (o.command === "expand" && !f(o.groupIndex))
        return t.detailColumnIndex = s, !1;
    })), t.detailColumnIndex >= 0 && (n.values[t.detailColumnIndex] = n.isExpanded), n;
  }
  _processItemsHack() {
    return super._processItems.apply(this, arguments);
  }
  _processItems(e, t) {
    const n = this, {
      changeType: s
    } = t, o = [];
    return e = super._processItems.apply(n, arguments), s === "loadingAll" ? e : (s === "refresh" && (n._expandedItems = Wt(n._expandedItems, (r) => r.visible)), y(e, (r, a) => {
      o.push(a);
      const l = F.getIndexByKey(a.key, n._expandedItems);
      a.rowType === "data" && (a.isExpanded || l >= 0) && !a.isNewRow && o.push({
        visible: a.isExpanded,
        rowType: "detail",
        key: a.key,
        data: a.data,
        values: []
      });
    }), o);
  }
  optionChanged(e) {
    const t = this;
    let n, s;
    if (e.name === "masterDetail") {
      switch (e.name = "dataSource", e.fullName) {
        case "masterDetail": {
          const o = e.value || {}, r = e.previousValue || {};
          n = o.enabled !== r.enabled, s = o.autoExpandAll !== r.autoExpandAll;
          break;
        }
        case "masterDetail.template":
          Wp(t);
          break;
        case "masterDetail.enabled":
          n = !0;
          break;
        case "masterDetail.autoExpandAll":
          s = !0;
      }
      (n || s) && Wp(t);
    }
    super.optionChanged(e);
  }
}, E6 = (i) => class extends i {
  fireContentReadyAction() {
    super.fireContentReadyAction.apply(this, arguments), this._updateParentDataGrids(this.component.$element());
  }
  _updateParentDataGrids(e) {
    const t = e.closest(".dx-master-detail-row");
    t.length && W(this._updateMasterDataGrid(t, e)).done(() => {
      this._updateParentDataGrids(t.parent());
    });
  }
  _updateMasterDataGrid(e, t) {
    const n = p(e).data("options"), s = p(e).closest(`.${this.getWidgetContainerClass()}`).parent().data("dxDataGrid");
    if (n && s)
      return this._updateMasterDataGridCore(s, n);
  }
  _updateMasterDataGridCore(e, t) {
    var n, s;
    const o = w();
    if ((n = e.getView("rowsView")) !== null && n !== void 0 && (s = n.isFixedColumns) !== null && s !== void 0 && s.call(n))
      this._updateFixedMasterDetailGrids(e, t.rowIndex, p(t.rowElement)).done(o.resolve);
    else {
      if (e.option("scrolling.useNative") === !0) {
        e.updateDimensions().done(() => o.resolve(!0));
        return;
      }
      const r = e.getScrollable();
      r ? r?.update().done(() => o.resolve()) : o.resolve();
    }
    return o.promise();
  }
  _updateFixedMasterDetailGrids(e, t, n) {
    const s = w(), o = p(e.getRowElement(t)), r = p(e.getView("rowsView").getTableElements()), a = o?.length === 2 && le(o.eq(0)) !== le(o.eq(1)), l = r?.length === 2 && le(r.eq(0)) !== le(r.eq(1));
    if (a || l) {
      const d = ne(n);
      return e.updateDimensions().done(() => {
        const u = this.option("columnAutoWidth") && e.option("scrolling.useNative") === !0, c = u && d !== ne(n);
        u && c ? this.updateDimensions().done(() => s.resolve(!0)) : s.resolve(!0);
      }), s.promise();
    }
    return w().resolve();
  }
  _toggleBestFitMode(e) {
    if (super._toggleBestFitMode.apply(this, arguments), this.option("masterDetail.template")) {
      const t = this._rowsView.getTableElement();
      t && t.find(".dx-master-detail-cell").css("maxWidth", e ? 0 : "");
    }
  }
}, I6 = (i) => class extends i {
  _getCellTemplate(e) {
    const t = this, {
      column: n
    } = e, s = this._editingController, o = s && s.isEditRow(e.rowIndex);
    let r;
    return n.command === "detail" && !o ? r = t.option("masterDetail.template") || {
      allowRenderToDetachedContainer: !1,
      render: t._getDefaultTemplate(n)
    } : r = super._getCellTemplate.apply(t, arguments), r;
  }
  _isDetailRow(e) {
    return e && e.rowType && e.rowType.indexOf("detail") === 0;
  }
  _createRow(e) {
    const t = super._createRow.apply(this, arguments);
    return e && this._isDetailRow(e) && (this.option("showRowLines") && t.addClass("dx-row-lines"), t.addClass("dx-master-detail-row"), f(e.visible) && t.toggle(e.visible)), t;
  }
  _renderCells(e, t) {
    const {
      row: n
    } = t;
    n.rowType && this._isDetailRow(n) ? this._needRenderCell(0, t.columnIndices) && this._renderMasterDetailCell(e, n, t) : super._renderCells.apply(this, arguments);
  }
  _renderMasterDetailCell(e, t, n) {
    const s = this._columnsController.getVisibleColumns(), o = this._renderCell(e, {
      value: null,
      row: t,
      rowIndex: t.rowIndex,
      column: {
        command: "detail"
      },
      columnIndex: 0,
      change: n.change
    });
    return o.addClass("dx-cell-focus-disabled").addClass("dx-master-detail-cell").attr("colSpan", s.length), t.isEditing || o.attr("aria-roledescription", S.format("dxDataGrid-masterDetail")), o;
  }
}, D6 = {
  defaultOptions: () => ({
    masterDetail: {
      enabled: !1,
      autoExpandAll: !1,
      template: null
    }
  }),
  extenders: {
    controllers: {
      columns: w6,
      data: S6,
      resizing: E6
    },
    views: {
      rowsView: I6
    }
  }
};
J.registerModule("masterDetail", D6);
xe("dxTextEditor", J_);
const T6 = "dx-numberbox-spin", O6 = "dx-numberbox-spin-button", DA = "dxNumberBox", hw = R(ye.up, DA), pw = R(ye.cancel, DA);
class xr extends Rt {
  _getDefaultOptions() {
    return I({}, super._getDefaultOptions(), {
      direction: "up",
      onChange: null,
      activeStateEnabled: !0,
      hoverStateEnabled: !0
    });
  }
  _initMarkup() {
    super._initMarkup();
    const {
      direction: e
    } = this.option(), t = `${T6}-${e}`;
    this.$element().addClass(O6).addClass(t), this._spinIcon = p("<div>").addClass(`${t}-icon`).appendTo(this.$element());
  }
  _render() {
    super._render();
    const e = R(ye.down, this.NAME), t = this.$element();
    _.off(t, e), _.on(t, e, this._spinDownHandler.bind(this)), this._spinChangeHandler = this._createActionByOption("onChange");
  }
  _spinDownHandler(e) {
    e.preventDefault(), this._clearTimer(), _.on(this.$element(), Zs.name, () => {
      this._feedBackDeferred = w(), i4(this._feedBackDeferred), this._spinChangeHandler({
        event: e
      }), this._holdTimer = setInterval(this._spinChangeHandler, 100, {
        event: e
      });
    });
    const t = O.getDocument();
    _.on(t, hw, this._clearTimer.bind(this)), _.on(t, pw, this._clearTimer.bind(this)), this._spinChangeHandler({
      event: e
    });
  }
  _dispose() {
    this._clearTimer(), super._dispose();
  }
  _clearTimer() {
    _.off(this.$element(), Zs.name);
    const e = O.getDocument();
    _.off(e, hw), _.off(e, pw), this._feedBackDeferred && this._feedBackDeferred.resolve(), this._holdTimer && clearInterval(this._holdTimer);
  }
  _optionChanged(e) {
    switch (e.name) {
      case "onChange":
      case "direction":
        this._invalidate();
        break;
      default:
        super._optionChanged(e);
    }
  }
}
const A6 = "dx-numberbox-spin", R6 = "dx-numberbox-spin-container", F6 = "dx-numberbox-spin-touch-friendly";
class k6 extends mh {
  _attachEvents(e, t) {
    const {
      editor: n
    } = this, s = R(ye.down, n.NAME), o = t.children(), r = n._createAction((a) => n._spinButtonsPointerDownHandler(a));
    _.off(t, s), _.on(t, s, (a) => r({
      event: a
    })), xr.getInstance(o.eq(0)).option("onChange", (a) => n._spinUpChangeHandler(a)), xr.getInstance(o.eq(1)).option("onChange", (a) => n._spinDownChangeHandler(a));
  }
  _create() {
    const {
      editor: e
    } = this, t = p("<div>").addClass(R6), n = p("<div>").appendTo(t), s = p("<div>").appendTo(t), o = this._getOptions();
    return this._addToContainer(t), e._createComponent(n, xr, x({
      direction: "up"
    }, o)), e._createComponent(s, xr, x({
      direction: "down"
    }, o)), this._legacyRender(e.$element(), this._isTouchFriendly(), o.visible), {
      instance: t,
      $element: t
    };
  }
  _getOptions() {
    const {
      editor: e
    } = this, t = this._isVisible(), n = e.option("disabled");
    return {
      visible: t,
      disabled: n
    };
  }
  _isVisible() {
    const {
      editor: e
    } = this;
    return super._isVisible() && e.option("showSpinButtons");
  }
  _isTouchFriendly() {
    const {
      editor: e
    } = this;
    return e.option("showSpinButtons") && e.option("useLargeSpinButtons");
  }
  _legacyRender(e, t, n) {
    e.toggleClass(F6, t), e.toggleClass(A6, n);
  }
  update() {
    if (super.update()) {
      const {
        editor: t,
        instance: n
      } = this, s = t.$element(), o = this._isVisible(), r = this._isTouchFriendly(), a = n.children(), l = xr.getInstance(a.eq(0)), d = xr.getInstance(a.eq(1)), u = this._getOptions();
      l.option(u), d.option(u), this._legacyRender(s, r, o);
    }
  }
}
const V6 = Math, P6 = "dx-numberbox", M6 = ["tab", "del", "backspace", "leftArrow", "rightArrow", "home", "end", "enter"];
class B6 extends J_ {
  _supportedKeys() {
    return I({}, super._supportedKeys(), {
      upArrow(e) {
        bt(e) || (e.preventDefault(), e.stopPropagation(), this._spinUpChangeHandler(e));
      },
      downArrow(e) {
        bt(e) || (e.preventDefault(), e.stopPropagation(), this._spinDownChangeHandler(e));
      },
      enter() {
      }
    });
  }
  _getDefaultOptions() {
    return I({}, super._getDefaultOptions(), {
      value: 0,
      min: void 0,
      max: void 0,
      step: 1,
      showSpinButtons: !1,
      useLargeSpinButtons: !0,
      mode: "text",
      invalidValueMessage: S.format("dxNumberBox-invalidValueMessage"),
      buttons: void 0
    });
  }
  _useTemplates() {
    return !1;
  }
  _getDefaultButtons() {
    return super._getDefaultButtons().concat([{
      name: "spins",
      Ctor: k6
    }]);
  }
  _isSupportInputMode() {
    const e = parseFloat(ze.version);
    return ze.chrome && e >= 66 || ze.safari && e >= 12;
  }
  _defaultOptionsRules() {
    return super._defaultOptionsRules().concat([{
      device: () => z.real().generic && !z.isSimulator(),
      options: {
        useLargeSpinButtons: !1
      }
    }, {
      device: function() {
        return z.real().deviceType !== "desktop" && !this._isSupportInputMode();
      }.bind(this),
      options: {
        mode: "number"
      }
    }]);
  }
  _initMarkup() {
    this._renderSubmitElement(), this.$element().addClass(P6), super._initMarkup(), this._toggleTabIndex();
  }
  _getDefaultAttributes() {
    const e = super._getDefaultAttributes();
    return e.inputmode = "decimal", e;
  }
  _renderContentImpl() {
    this.option("isValid") && this._validateValue(this.option("value")), this.setAria("role", "spinbutton");
  }
  _renderSubmitElement() {
    this._$submitElement = p("<input>").attr("type", "hidden").appendTo(this.$element()), this._setSubmitValue(this.option("value"));
  }
  _setSubmitValue(e) {
    this._getSubmitElement().val(_E(e));
  }
  _getSubmitElement() {
    return this._$submitElement;
  }
  _keyPressHandler(e) {
    super._keyPressHandler();
    const t = im(e);
    if (!/[\d.,eE\-+]/.test(t)) {
      const s = Ye(e);
      if (bt(e) || s && M6.includes(s))
        return;
      e.preventDefault();
      return;
    }
    this._keyPressed = !0;
  }
  _onMouseWheel(e) {
    e.delta > 0 ? this._spinValueChange(1, e) : this._spinValueChange(-1, e);
  }
  _renderValue() {
    const e = this._input().val(), t = this.option("value");
    (!e.length || Number(e) !== t) && (this._forceValueRender(), this._toggleEmptinessEventHandler());
    const n = f(t) ? null : S.format("dxNumberBox-noDataText");
    return this.setAria({
      valuenow: Qe(t, ""),
      valuetext: n
    }), this.option("text", this._input().val()), this._updateButtons(), w().resolve();
  }
  _forceValueRender() {
    const e = this.option("value"), t = Number(e), n = isNaN(t) ? "" : this._applyDisplayValueFormatter(e);
    this._renderDisplayText(n);
  }
  _applyDisplayValueFormatter(e) {
    const {
      displayValueFormatter: t
    } = this.option();
    return t?.(e);
  }
  _renderProps() {
    this._input().prop({
      min: this.option("min"),
      max: this.option("max"),
      step: this.option("step")
    }), this.setAria({
      valuemin: Qe(this.option("min"), ""),
      valuemax: Qe(this.option("max"), "")
    });
  }
  _spinButtonsPointerDownHandler() {
    const e = this._input();
    !this.option("useLargeSpinButtons") && O.getActiveElement() !== e[0] && _.trigger(e, "focus");
  }
  _spinUpChangeHandler(e) {
    this.option("readOnly") || this._spinValueChange(1, e.event || e);
  }
  _spinDownChangeHandler(e) {
    this.option("readOnly") || this._spinValueChange(-1, e.event || e);
  }
  _spinValueChange(e, t) {
    const n = parseFloat(this.option("step"));
    if (n === 0)
      return;
    let s = parseFloat(this._normalizeInputValue()) || 0;
    s = this._correctRounding(s, n * e);
    const o = this.option("min"), r = this.option("max");
    f(o) && (s = Math.max(o, s)), f(r) && (s = Math.min(r, s)), this._saveValueChangeEvent(t), this.option("value", s);
  }
  _correctRounding(e, t) {
    const n = /[,.](.*)/, s = n.test(e), o = n.test(t);
    if (s || o) {
      const r = s ? n.exec(e)[0].length : 0, a = o ? n.exec(t)[0].length : 0, l = V6.max(r, a);
      return e = this._round(e + t, l), e;
    }
    return e + t;
  }
  _round(e, t) {
    t = t || 0;
    const n = 10 ** t;
    return e *= n, e = Math.round(e) / n, e;
  }
  _renderValueChangeEvent() {
    super._renderValueChangeEvent();
    const e = R("focusout", "NumberBoxForceValueChange");
    _.off(this.element(), e), _.on(this.element(), e, this._forceRefreshInputValue.bind(this));
  }
  _forceRefreshInputValue() {
    const {
      mode: e
    } = this.option();
    if (e === "number")
      return;
    const t = this._input(), n = this._applyDisplayValueFormatter(this.option("value"));
    t.val(null), t.val(n);
  }
  _valueChangeEventHandler(e) {
    const t = this._input(), n = this._normalizeText(), s = this._parseValue(n), o = n !== "." && n !== "-";
    if (this._isValueValid() && !this._validateValue(s)) {
      t.val(this._applyDisplayValueFormatter(s));
      return;
    }
    o && super._valueChangeEventHandler(e, isNaN(s) ? null : s), this._applyValueBoundaries(n, s), this.validationRequest.fire({
      value: s,
      editor: this
    });
  }
  _applyValueBoundaries(e, t) {
    const n = this._isValueIncomplete(e), s = this._isValueInRange(e);
    !n && !s && t !== null && Number(e) !== t && this._input().val(this._applyDisplayValueFormatter(t));
  }
  _replaceCommaWithPoint(e) {
    return e.replace(",", ".");
  }
  _inputIsInvalid() {
    const {
      mode: e
    } = this.option(), t = e === "number", n = this._input().get(0).validity;
    return t && n?.badInput;
  }
  _renderDisplayText(e) {
    this._inputIsInvalid() || super._renderDisplayText(e);
  }
  _isValueIncomplete(e) {
    return /(^-$)|(^-?\d*\.$)|(\d+e-?$)/i.test(e);
  }
  _isValueInRange(e) {
    return ss(e, this.option("min"), this.option("max"));
  }
  _isNumber(e) {
    return this._parseValue(e) !== null;
  }
  _validateValue(e) {
    const t = this._normalizeText(), n = this._isValueValid();
    let s = !0;
    const o = this._isNumber(t);
    return isNaN(Number(e)) && (s = !1), !e && n ? s = !0 : !o && !n && (s = !1), this.option({
      isValid: s,
      validationError: s ? null : {
        editorSpecific: !0,
        message: this.option("invalidValueMessage")
      }
    }), s;
  }
  _normalizeInputValue() {
    return this._parseValue(this._normalizeText());
  }
  _normalizeText() {
    const e = this._input().val().trim();
    return this._replaceCommaWithPoint(e);
  }
  _parseValue(e) {
    const t = parseFloat(e);
    return isNaN(t) ? null : Lt(t, this.option("min"), this.option("max"));
  }
  _clearValue() {
    this._inputIsInvalid() && (this._input().val(""), this._validateValue()), super._clearValue();
  }
  clear() {
    this.option("value") === null ? (this.option("text", ""), this._input().length && this._renderValue()) : this.option("value", null);
  }
  _optionChanged(e) {
    switch (e.name) {
      case "value":
        this._validateValue(e.value), this._setSubmitValue(e.value), super._optionChanged(e), this._resumeValueChangeAction();
        break;
      case "step":
        this._renderProps();
        break;
      case "min":
      case "max":
        this._renderProps(), this.option("value", this._parseValue(this.option("value")));
        break;
      case "showSpinButtons":
      case "useLargeSpinButtons":
        this._updateButtons(["spins"]);
        break;
      case "invalidValueMessage":
        break;
      default:
        super._optionChanged(e);
    }
  }
}
const Vu = function(i) {
  let e = 0, t = 0;
  for (let n = 0; n < i.length; ++n)
    if (i[n] === "'" && e++, i[n] === "." && (++t, e % 2 === 0))
      return {
        occurrence: t,
        index: n
      };
  return {
    occurrence: 1,
    index: -1
  };
}, Nm = function(i, e, t) {
  let n = -1;
  for (; t-- && n++ < i.length; )
    n = i.indexOf(e, n);
  return n;
}, Lm = function(i, e) {
  return e === -1 ? [i] : [i.slice(0, e), i.slice(e + 1)];
}, $6 = function(i, e) {
  return i && tD(i / 100, e);
}, wc = function(i, e) {
  if (typeof e == "string") {
    const t = e.split(";"), n = We.getSign(i, e);
    t[1] = t[1] || `-${t[0]}`, e = t[n < 0 ? 1 : 0], e = ((a) => a.replace(/'([^']*)'/g, (l) => l.split("").map(() => " ").join("").substr(2)))(e);
    const o = /^[^#0.,]*/.exec(e)[0].length, r = /[^#0.,]*$/.exec(e)[0].length;
    return {
      start: o,
      end: i.length - r
    };
  }
  return {
    start: 0,
    end: i.length
  };
}, gw = function(i, e) {
  const t = We.getDecimalSeparator(), n = new RegExp(`[^0-9${ns(t)}]`, "g");
  return e.slice(0, i).replace(n, "").length;
}, mw = function(i) {
  return i.split("").reverse().join("");
}, fw = function(i, e) {
  if (!i)
    return -1;
  const t = /[0-9]/g;
  let n = 1, s = null, o = t.exec(e);
  for (; o; ) {
    if (s = o.index, n >= i)
      return s;
    n++, o = t.exec(e);
  }
  return s === null ? e.length : s;
}, N6 = function(i) {
  return i.replace(/[^0-9e]+$/, "");
}, Io = function(i, e) {
  return i.start === void 0 && (i = {
    start: i,
    end: i
  }), {
    start: i.start + e,
    end: i.end + e
  };
}, L6 = function(i, e, t, n) {
  t = Io(t, 0);
  const s = We.getDecimalSeparator(), o = H6(i), r = Vu(n).occurrence, a = o ? 0 : Nm(i, s, r), l = Nm(e, s, r), d = Lm(i, a), u = Lm(e, l);
  if (a !== -1 && t.start > a) {
    const E = t.start - a - 1, T = gw(E, d[1]), V = u[1] ? l + 1 + fw(T, u[1]) + 1 : e.length;
    return Ms(V, e, n);
  }
  const h = N6(u[0]), g = d[0].length - t.start, m = gw(g, mw(d[0])), C = fw(m, mw(h)), v = h.length - (C + 1);
  return Ms(v, e, n);
};
function H6(i) {
  return i.length === 1 && !!i.match(/^[,.][0-9]*$/g);
}
const W6 = function(i, e, t) {
  i = Io(i, 0);
  const n = Ms(i, e, t);
  return i.start >= n.start && i.end <= n.end;
};
function Ms(i, e, t) {
  i = Io(i, 0);
  const n = wc(e, t);
  return {
    start: Lt(i.start, n.start, n.end),
    end: Lt(i.end, n.start, n.end)
  };
}
const z6 = function(i, e, t) {
  const n = wc(i, t);
  return wc(e, t).start - n.start;
};
class Sc extends B6 {
  _getDefaultOptions() {
    return I({}, super._getDefaultOptions(), {
      useMaskBehavior: !0,
      format: null
    });
  }
  _isDeleteKey(e) {
    return e === "del";
  }
  _supportedKeys() {
    return this._useMaskBehavior() ? I({}, super._supportedKeys(), {
      minus: this._revertSign.bind(this),
      del: this._removeHandler.bind(this),
      backspace: this._removeHandler.bind(this),
      leftArrow: this._arrowHandler.bind(this, -1),
      rightArrow: this._arrowHandler.bind(this, 1),
      home: this._moveCaretToBoundaryEventHandler.bind(this, 1),
      enter: this._updateFormattedValue.bind(this),
      end: this._moveCaretToBoundaryEventHandler.bind(this, -1)
    }) : super._supportedKeys();
  }
  _getTextSeparatorIndex(e) {
    const t = We.getDecimalSeparator(), n = Vu(this.option("format")).occurrence;
    return Nm(e, t, n);
  }
  _focusInHandler(e) {
    this._preventNestedFocusEvent(e) || (this.clearCaretTimeout(), this._caretTimeout = setTimeout(() => {
      this._caretTimeout = void 0;
      const t = this._caret();
      if (t.start === t.end && this._useMaskBehavior()) {
        const n = this._getInputVal(), s = this._getTextSeparatorIndex(n);
        s >= 0 ? this._caret({
          start: s,
          end: s
        }) : this._moveCaretToBoundaryEventHandler(-1, e);
      }
    }, 0)), super._focusInHandler(e);
  }
  _focusOutHandler(e) {
    const t = !this._preventNestedFocusEvent(e);
    t && (this._focusOutOccurs = !0, this._useMaskBehavior() && this._updateFormattedValue()), super._focusOutHandler(e), t && (this._focusOutOccurs = !1);
  }
  _hasValueBeenChanged(e) {
    const t = this._getFormatPattern(), n = this.option("value");
    return (this._format(n, t) || "") !== e;
  }
  _updateFormattedValue() {
    const e = this._getInputVal();
    if (this._hasValueBeenChanged(e)) {
      this._updateParsedValue(), this._adjustParsedValue(), this._setTextByParsedValue();
      const {
        value: t
      } = this.option();
      this._parsedValue !== t && _.trigger(this._input(), "change");
    }
  }
  _arrowHandler(e, t) {
    if (!this._useMaskBehavior())
      return;
    const n = this._getInputVal(), s = this._getFormatPattern();
    let o = Io(this._caret(), e);
    W6(o, n, s) || (o = e === 1 ? o.end : o.start, t.preventDefault(), this._caret(Ms(o, n, s)));
  }
  _moveCaretToBoundary(e) {
    const t = wc(this._getInputVal(), this._getFormatPattern()), n = Io(e === 1 ? t.start : t.end, 0);
    this._caret(n);
  }
  _moveCaretToBoundaryEventHandler(e, t) {
    !this._useMaskBehavior() || t != null && t.shiftKey || (this._moveCaretToBoundary(e), t?.preventDefault());
  }
  _shouldMoveCaret(e, t) {
    const n = We.getDecimalSeparator(), s = e.charAt(t.end) === n;
    return (this._lastKey === n || this._lastKey === "." || this._lastKey === ",") && s;
  }
  _getInputVal() {
    return We.convertDigits(this._input().val(), !0);
  }
  _keyboardHandler(e) {
    if (this.clearCaretTimeout(), this._lastKey = We.convertDigits(im(e), !0), this._lastKeyName = Ye(e), !this._shouldHandleKey(e.originalEvent))
      return super._keyboardHandler(e);
    const t = this._getInputVal(), n = this._caret();
    let s;
    this._lastKeyName === "minus" ? s = "" : s = e.which === 110 ? We.getDecimalSeparator() : this._lastKey;
    const o = this._tryParse(t, n, s);
    return this._shouldMoveCaret(t, n) && (this._moveCaret(1), e.originalEvent.preventDefault()), o === void 0 ? this._lastKeyName !== "minus" && e.originalEvent.preventDefault() : this._parsedValue = o, super._keyboardHandler(e);
  }
  _keyPressHandler(e) {
    this._useMaskBehavior() || super._keyPressHandler(e);
  }
  _removeHandler(e) {
    const t = this._caret(), n = this._getInputVal();
    let {
      start: s
    } = t, {
      end: o
    } = t;
    this._lastKey = im(e), this._lastKeyName = Ye(e);
    const r = this._isDeleteKey(this._lastKeyName), a = !r;
    if (s === o) {
      const c = s;
      if (a && c > 0 || r && c < n.length)
        r && o++, a && s--;
      else {
        e.preventDefault();
        return;
      }
    }
    const l = n.slice(s, o);
    if (this._isStub(l)) {
      this._moveCaret(r ? 1 : -1), (this._parsedValue < 0 || 1 / this._parsedValue === -1 / 0) && (this._revertSign(e), this._setTextByParsedValue(), this.option("valueChangeEvent").split(" ").includes("input") && _.trigger(this._input(), "input")), e.preventDefault();
      return;
    }
    const d = We.getDecimalSeparator();
    if (l === d) {
      const c = n.indexOf(d);
      this._isNonStubAfter(c + 1) && (this._moveCaret(r ? 1 : -1), e.preventDefault());
      return;
    }
    if (o - s < n.length && this._replaceSelectedText(n, {
      start: s,
      end: o
    }, "").search(/[0-9]/) < 0 && this._isValueInRange(0)) {
      this._parsedValue = this._parsedValue < 0 || 1 / this._parsedValue === -1 / 0 ? -0 : 0;
      return;
    }
    const u = this._tryParse(n, {
      start: s,
      end: o
    }, "");
    u === void 0 ? e.preventDefault() : this._parsedValue = u;
  }
  _isPercentFormat() {
    return this._getFormatPattern().replace(/'[^']+'/g, "").indexOf("%") !== -1;
  }
  _parse(e, t) {
    const n = this.option("format"), s = B(n.parser), o = s ? n.parser : We.parse;
    let r = 0;
    if (!s) {
      const a = Vu(t).index, l = this._getTextSeparatorIndex(e), d = a !== -1 ? a : t.length, u = l !== -1 ? l : e.length;
      u > d && t.indexOf("#") === -1 && (r = u - d);
    }
    return e = e.substr(r), o(e, t);
  }
  _format(e, t) {
    const n = this.option("format"), s = n?.formatter || n, o = B(s) ? s : We.format;
    return e === null ? "" : o(e, t);
  }
  _getFormatPattern() {
    return this._currentFormat || this._updateFormat(), this._currentFormat;
  }
  _updateFormat() {
    const {
      format: e
    } = this.option(), t = B(e?.parser), n = te(e) && (e.includes("0") || e.includes("#")), s = e === "exponential" || e?.type === "exponential", o = t || n || s;
    this._currentFormat = o ? e : BG((r) => {
      const a = this._format(r, e);
      return We.convertDigits(a, !0);
    });
  }
  _getFormatForSign(e) {
    const t = this._getFormatPattern();
    if (te(t)) {
      const s = t.split(";"), o = We.getSign(e, t);
      return s[1] = s[1] || `-${s[0]}`, o < 0 ? s[1] : s[0];
    }
    return We.getSign(e) < 0 ? "-" : "";
  }
  _removeStubs(e, t) {
    const n = this._getFormatForSign(e), s = We.getThousandsSeparator(), o = this._getStubs(n);
    let r = e;
    if (o.length) {
      const a = o[0], l = new RegExp(`(${ns(o[1] || "")})$`, "g"), d = new RegExp(`[-${ns(t ? "" : s)}]`, "g");
      r = r.replace(a, "").replace(l, "").replace(d, "");
    }
    return r;
  }
  _getStubs(e) {
    const t = /[^']([#0.,]+)/g.exec(e), n = t && t[0].trim();
    return e.split(n).map((s) => s.replace(/'/g, ""));
  }
  _truncateToPrecision(e, t) {
    if (f(e)) {
      const n = e.toString(), s = n.indexOf(".");
      if (n && s > -1) {
        const o = parseFloat(n.substr(0, s + t + 1));
        return isNaN(o) ? e : o;
      }
    }
    return e;
  }
  _tryParse(e, t, n) {
    const s = t.start !== t.end, o = s && t.start === 0 && t.end === e.length, r = We.getDecimalSeparator();
    if (o && n === r)
      return 0;
    const a = this._replaceSelectedText(e, t, n), l = this._getFormatPattern();
    let d = this._getParsedValue(a, l);
    const u = !l.parser && this._getPrecisionLimits(a).max, c = d !== this._parsedValue, h = n === r && u === 0, g = !s && !c && n !== "-" && this._isStub(n);
    if (h || g || (this._removeStubs(a) === "" && (d = Math.abs(0 * this._parsedValue)), isNaN(d)))
      return;
    const m = d === null ? this._parsedValue : d;
    if (d = u ? this._truncateToPrecision(m, u) : d, !l.parser && this._isPercentFormat()) {
      const C = this._getIntervalFromPrecision(u);
      return $6(d, C);
    }
    return d;
  }
  _getIntervalFromPrecision(e) {
    return e < 1 ? 1 : 10 ** -e;
  }
  _getParsedValue(e, t) {
    const n = We.getSign(e, t?.formatter || t), s = this._removeStubs(e, !0), o = this._parse(s, t), r = o < 0 ? -1 : 1;
    return $e(o) && n !== r ? n * o : o;
  }
  _isValueIncomplete(e) {
    if (!this._useMaskBehavior())
      return super._isValueIncomplete(e);
    const t = this._caret(), n = We.getDecimalSeparator(), s = this._getTextSeparatorIndex(e), o = s >= 0 && s < t.start, r = this._removeStubs(e, !0).split(n);
    if (!o || r.length !== 2)
      return !1;
    const a = r[1].length, d = !!this._getFormatPattern().parser, u = !d && this._getPrecisionLimits(this._getFormatPattern()), c = d ? !0 : ss(a, u.min, u.max), h = r[1].charAt(a - 1) === "0";
    return c && (h || !a);
  }
  _isValueInRange(e) {
    const t = Qe(this.option("min"), -1 / 0), n = Qe(this.option("max"), 1 / 0);
    return ss(e, t, n);
  }
  _setInputText(e) {
    const t = We.convertDigits(e, !0), n = L6(this._getInputVal(), t, this._caret(), this._getFormatPattern());
    this._input().val(e), this._toggleEmptinessEventHandler(), this._formattedValue = e, this._focusOutOccurs || this._caret(n);
  }
  _useMaskBehavior() {
    const {
      useMaskBehavior: e
    } = this.option();
    return !!this.option("format") && e;
  }
  _renderInputType() {
    const {
      mode: e
    } = this.option(), t = e === "number", n = z.real().deviceType === "desktop";
    this._useMaskBehavior() && t ? this._setInputType(n || this._isSupportInputMode() ? "text" : "tel") : super._renderInputType();
  }
  _isChar(e) {
    return te(e) && e.length === 1;
  }
  _moveCaret(e) {
    if (!e)
      return;
    const t = Io(this._caret(), e), n = Ms(t, this._getInputVal(), this._getFormatPattern());
    this._caret(n);
  }
  _shouldHandleKey(e) {
    const t = Ye(e), n = bt(e) || e.altKey || e.shiftKey || !this._isChar(t), s = t === "minus";
    return this._useMaskBehavior() && !n && !s;
  }
  _renderInput() {
    super._renderInput(), this._renderFormatter();
  }
  _renderFormatter() {
    this._clearCache(), this._detachFormatterEvents(), this._useMaskBehavior() && this._attachFormatterEvents();
  }
  _detachFormatterEvents() {
    _.off(this._input(), ".dxNumberFormatter");
  }
  _isInputFromPaste(e) {
    var t;
    const n = (t = e.originalEvent) === null || t === void 0 ? void 0 : t.inputType;
    return f(n) ? n === "insertFromPaste" : this._isValuePasted;
  }
  _attachFormatterEvents() {
    const e = this._input();
    _.on(e, R("input", "dxNumberFormatter"), (t) => {
      this._formatValue(t), this._isValuePasted = !1;
    }), _.on(e, R("dxclick", "dxNumberFormatter"), () => {
      this._caretTimeout || (this._caretTimeout = setTimeout(() => {
        this._caretTimeout = void 0, this._caret(Ms(this._caret(), this._getInputVal(), this._getFormatPattern()));
      }, 0));
    }), _.on(e, pd, () => {
      this.clearCaretTimeout();
    });
  }
  clearCaretTimeout() {
    clearTimeout(this._caretTimeout), this._caretTimeout = void 0;
  }
  _forceRefreshInputValue() {
    if (!this._useMaskBehavior())
      return super._forceRefreshInputValue();
  }
  _isNonStubAfter(e) {
    const t = this._getInputVal().slice(e);
    return t && !this._isStub(t, !0);
  }
  _isStub(e, t) {
    const s = `^[^0-9${ns(We.getDecimalSeparator())}]+$`;
    return new RegExp(s, "g").test(e) && (t || this._isChar(e));
  }
  _parseValue(e) {
    return this._useMaskBehavior() ? this._parsedValue : super._parseValue(e);
  }
  _getPrecisionLimits(e) {
    const t = this._getFormatForSign(e), n = Vu(t).index, s = (Lm(t, n)[1] || "").replace(/[^#0]/g, ""), o = s.replace(/^(0*)#*/, "$1").length, r = s.length;
    return {
      min: o,
      max: r
    };
  }
  _revertSign(e) {
    if (!this._useMaskBehavior())
      return;
    const t = this._caret();
    if (t.start !== t.end) {
      if (Ye(e) === "minus") {
        this._applyRevertedSign(e, t, !0);
        return;
      }
      this._caret(Ms(0, this._getInputVal(), this._getFormatPattern()));
    }
    this._applyRevertedSign(e, t);
  }
  _applyRevertedSign(e, t, n) {
    const s = -1 * Qe(this._parsedValue, null);
    if ((this._isValueInRange(s) || s === 0) && (this._parsedValue = s, n)) {
      const o = this._getFormatPattern(), r = this._getInputVal();
      this._setTextByParsedValue(), e.preventDefault();
      const a = this._getInputVal(), l = z6(r, a, o);
      t = Io(t, l);
      const d = Ms(t, a, o);
      this._caret(d);
    }
  }
  _removeMinusFromText(e, t) {
    return this._lastKeyName === "minus" && e.charAt(t.start - 1) === "-" ? this._replaceSelectedText(e, {
      start: t.start - 1,
      end: t.start
    }, "") : e;
  }
  _setTextByParsedValue() {
    const e = this._getFormatPattern(), t = this._parseValue(), n = this._format(t, e) || "";
    this._setInputText(n);
  }
  _formatValue(e) {
    let t = this._getInputVal();
    const n = this._caret(), s = this._removeMinusFromText(t, n), o = s !== t;
    if (t = s, !this._isInputFromPaste(e) && this._isValueIncomplete(s)) {
      this._formattedValue = t, o && this._setTextByParsedValue();
      return;
    }
    if (We.convertDigits(this._formattedValue, !0) !== t) {
      const a = this._tryParse(t, n, "");
      f(a) && (this._parsedValue = a);
    }
    this._setTextByParsedValue();
  }
  _renderDisplayText() {
    this._useMaskBehavior() ? this._toggleEmptinessEventHandler() : super._renderDisplayText.apply(this, arguments);
  }
  _renderValue() {
    if (this._useMaskBehavior()) {
      const {
        value: e
      } = this.option();
      this._parsedValue = e, this._setTextByParsedValue();
    }
    return super._renderValue();
  }
  _updateParsedValue() {
    const e = this._getInputVal();
    this._parsedValue = this._tryParse(e, this._caret());
  }
  _adjustParsedValue() {
    if (!this._useMaskBehavior())
      return;
    const t = this._removeStubs(this._getInputVal()) ? this._parseValue() : null;
    if (!$e(t)) {
      this._parsedValue = t;
      return;
    }
    this._parsedValue = Lt(t, this.option("min"), this.option("max"));
  }
  _valueChangeEventHandler(e) {
    if (!this._useMaskBehavior())
      return super._valueChangeEventHandler(e);
    const t = this._caret();
    this._saveValueChangeEvent(e), this._lastKey = null, this._lastKeyName = null, this._updateParsedValue(), this._adjustParsedValue(), this.option("value", this._parsedValue), t && this._caret(t);
  }
  _optionChanged(e) {
    switch (e.name) {
      case "format":
      case "useMaskBehavior":
        this._renderInputType(), this._updateFormat(), this._renderFormatter(), this._renderValue(), this._refreshValueChangeEvent(), this._refreshEvents();
        break;
      case "min":
      case "max":
        this._adjustParsedValue(), super._optionChanged(e);
        break;
      default:
        super._optionChanged(e);
    }
  }
  _clearCache() {
    delete this._formattedValue, delete this._lastKey, delete this._lastKeyName, delete this._parsedValue, delete this._focusOutOccurs, clearTimeout(this._caretTimeout), delete this._caretTimeout;
  }
  _clean() {
    this._clearCache(), super._clean();
  }
}
xe("dxNumberBox", Sc);
class TA extends ci {
  _supportedKeys() {
    return I({}, super._supportedKeys(), {
      space: function(e) {
        e.preventDefault(), this._clickAction({
          event: e
        });
      }
    });
  }
  _getDefaultOptions() {
    return I({}, super._getDefaultOptions(), {
      hoverStateEnabled: !0,
      activeStateEnabled: !0,
      value: !1
    });
  }
  _canValueBeChangedByClick() {
    return !0;
  }
  _defaultOptionsRules() {
    return super._defaultOptionsRules().concat([{
      device: () => z.real().deviceType === "desktop" && !z.isSimulator(),
      options: {
        focusStateEnabled: !0
      }
    }]);
  }
  _init() {
    super._init(), this.$element().addClass("dx-radiobutton");
  }
  _initMarkup() {
    super._initMarkup(), this._renderIcon(), this._renderCheckedState(this.option("value")), this._renderClick(), this.setAria("role", "radio");
  }
  _renderIcon() {
    this._$icon = p("<div>").addClass("dx-radiobutton-icon"), p("<div>").addClass("dx-radiobutton-icon-dot").appendTo(this._$icon), this.$element().append(this._$icon);
  }
  _renderCheckedState(e) {
    this.$element().toggleClass("dx-radiobutton-checked", e).find(".dx-radiobutton-icon").toggleClass("dx-radiobutton-icon-checked", e), this.setAria("checked", e);
  }
  _renderClick() {
    const e = R(Te, this.NAME);
    this._clickAction = this._createAction((t) => {
      this._clickHandler(t.event);
    }), _.off(this.$element(), e), _.on(this.$element(), e, (t) => {
      var n;
      (n = this._clickAction) === null || n === void 0 || n.call(this, {
        event: t
      });
    });
  }
  _clickHandler(e) {
    this._saveValueChangeEvent(e), this.option("value", !0);
  }
  _optionChanged(e) {
    e.name === "value" ? (this._renderCheckedState(e.value), super._optionChanged(e)) : super._optionChanged(e);
  }
}
xe("dxRadioButton", TA);
const cC = "dxListEditDecorator", K6 = R(ZO, cC), G6 = R(QO, cC), U6 = R(iC, cC);
class j6 extends se.inherit({}) {
  ctor(e) {
    this._list = e, this._init();
  }
  _shouldHandleSwipe() {
    return !1;
  }
  _init() {
  }
  _attachSwipeEvent(e) {
    const t = {
      itemSizeFunc: function() {
        return this._clearSwipeCache && (this._itemWidthCache = ne(this._list.$element()), this._clearSwipeCache = !1), this._itemWidthCache;
      }.bind(this)
    };
    _.on(e.$itemElement, K6, t, this._itemSwipeStartHandler.bind(this)), _.on(e.$itemElement, G6, this._itemSwipeUpdateHandler.bind(this)), _.on(e.$itemElement, U6, this._itemSwipeEndHandler.bind(this));
  }
  _itemSwipeStartHandler(e) {
    const t = p(e.currentTarget);
    if (t.is(".dx-state-disabled, .dx-state-disabled *")) {
      e.cancel = !0;
      return;
    }
    clearTimeout(this._list._inkRippleTimer), this._swipeStartHandler(t, e);
  }
  _itemSwipeUpdateHandler(e) {
    const t = p(e.currentTarget);
    this._swipeUpdateHandler(t, e);
  }
  _itemSwipeEndHandler(e) {
    const t = p(e.currentTarget);
    this._swipeEndHandler(t, e), this._clearSwipeCache = !0;
  }
  beforeBag(e) {
  }
  afterBag() {
  }
  _commonOptions() {
    return {
      activeStateEnabled: this._list.option("activeStateEnabled"),
      hoverStateEnabled: this._list.option("hoverStateEnabled"),
      focusStateEnabled: this._list.option("focusStateEnabled")
    };
  }
  modifyElement(e) {
    this._shouldHandleSwipe() && (this._attachSwipeEvent(e), this._clearSwipeCache = !0);
  }
  afterRender() {
  }
  handleClick(e, t) {
  }
  handleKeyboardEvents(e, t) {
  }
  handleEnterPressing() {
  }
  handleContextMenu(e) {
  }
  _swipeStartHandler(e, t) {
  }
  _swipeUpdateHandler(e, t) {
  }
  _swipeEndHandler(e, t) {
  }
  visibilityChange() {
  }
  getExcludedSelectors() {
  }
  dispose() {
  }
}
const OA = {};
function q6(i, e, t) {
  const n = OA, s = {};
  s[i] = n[i] ? n[i] : {}, s[i][e] = t, x(n, s);
}
const _w = "dx-list-select-decorator-enabled", Y6 = "dx-list-select-checkbox-container", X6 = "dx-list-select-checkbox", Z6 = "dx-list-select-radiobutton-container", Q6 = "dx-list-select-radiobutton", Cw = R(Te, "dxListEditDecorator");
class J6 extends j6 {
  _init() {
    super._init.apply(this, arguments);
    const e = this._list.option("selectionMode");
    this._singleStrategy = e === "single", this._containerClass = this._singleStrategy ? Z6 : Y6, this._controlClass = this._singleStrategy ? Q6 : X6, this._controlWidget = this._singleStrategy ? TA : Qs, this._list.$element().addClass(_w);
  }
  beforeBag(e) {
    const {
      $itemElement: t
    } = e, n = e.$container.addClass(this._containerClass), s = p("<div>").addClass(this._controlClass).appendTo(n);
    new this._controlWidget(s, x(this._commonOptions(), {
      value: this._isSelected(t),
      elementAttr: {
        "aria-label": S.format("CheckState")
      },
      focusStateEnabled: !1,
      hoverStateEnabled: !1,
      onValueChanged: (o) => {
        let {
          value: r,
          component: a,
          event: l
        } = o;
        !!l && (a._valueChangeEventInstance = void 0, a.option("value", !r));
      }
    }));
  }
  modifyElement(e) {
    super.modifyElement.apply(this, arguments);
    const {
      $itemElement: t
    } = e, n = this._controlWidget.getInstance(t.find(`.${this._controlClass}`));
    _.on(t, "stateChanged", (s, o) => {
      n.option("value", o);
    });
  }
  _updateSelectAllState() {
    this._$selectAll && this._selectAllCheckBox.option("value", this._list.isSelectAll());
  }
  afterRender() {
    this._list.option("selectionMode") === "all" && (this._$selectAll ? this._updateSelectAllState() : this._renderSelectAll());
  }
  handleKeyboardEvents(e, t) {
    const n = !t, s = this._list, o = this._$selectAll, r = s._getLastItemIndex();
    return !!o && (t && e === 0 || n && e === r) ? (s.option("focusedElement", o), s.scrollToItem(s.option("focusedElement")), !0) : !1;
  }
  handleEnterPressing(e) {
    var t;
    if ((t = this._$selectAll) !== null && t !== void 0 && t.hasClass("dx-state-focused"))
      return e.target = this._$selectAll.get(0), this._selectAllHandler(e), !0;
  }
  _renderSelectAll() {
    this._$selectAll = p("<div>").addClass("dx-list-select-all");
    const e = this._list._supportedKeys().downArrow.bind(this._list), t = p("<div>").addClass("dx-list-select-all-checkbox").appendTo(this._$selectAll);
    this._selectAllCheckBox = this._list._createComponent(t, Qs, {
      elementAttr: {
        "aria-label": S.format("dxList-selectAll")
      },
      focusStateEnabled: !1,
      hoverStateEnabled: !1
    }), this._selectAllCheckBox.registerKeyHandler("downArrow", e), p("<div>").addClass("dx-list-select-all-label").text(this._list.option("selectAllText")).appendTo(this._$selectAll), this._list.itemsContainer().prepend(this._$selectAll), this._updateSelectAllState(), this._updateSelectAllAriaLabel(), this._attachSelectAllHandler();
  }
  _attachSelectAllHandler() {
    this._selectAllCheckBox.option("onValueChanged", (e) => {
      let {
        value: t,
        event: n,
        component: s
      } = e;
      if (!!n) {
        s._setOptionWithoutOptionChange("value", !t);
        return;
      }
      this._updateSelectAllAriaLabel(), this._list._createActionByOption("onSelectAllValueChanged")({
        value: t
      });
    }), _.off(this._$selectAll, Cw), _.on(this._$selectAll, Cw, this._selectAllHandler.bind(this));
  }
  _updateSelectAllAriaLabel() {
    if (!this._$selectAll)
      return;
    const {
      value: e
    } = this._selectAllCheckBox.option(), n = e === void 0 ? "indeterminate" : e ? "checked" : "notChecked", s = `${S.format("dxList-selectAll")}, ${S.format(`dxList-selectAll-${n}`)}`;
    this._$selectAll.attr({
      "aria-label": s
    });
  }
  _selectAllHandler(e) {
    var t;
    e.stopPropagation(), this._list._saveSelectionChangeEvent(e);
    const {
      value: n
    } = this._selectAllCheckBox.option();
    let s;
    return n !== !0 ? s = this._selectAllItems() : s = this._unselectAllItems(), this._list.option("focusedElement", (t = this._$selectAll) === null || t === void 0 ? void 0 : t.get(0)), s;
  }
  _checkSelectAllCapability() {
    const e = this._list, t = e._dataController;
    return e.option("selectAllMode") === "allPages" && e.option("grouped") && !t.group() ? (_e.log("W1010"), !1) : !0;
  }
  _selectAllItems() {
    return this._checkSelectAllCapability() ? this._list._selection.selectAll(this._list.option("selectAllMode") === "page") : w().resolve();
  }
  _unselectAllItems() {
    return this._checkSelectAllCapability() ? this._list._selection.deselectAll(this._list.option("selectAllMode") === "page") : w().resolve();
  }
  _isSelected(e) {
    return this._list.isItemSelected(e);
  }
  dispose() {
    this._disposeSelectAll(), this._list.$element().removeClass(_w), super.dispose.apply(this, arguments);
  }
  _disposeSelectAll() {
    this._$selectAll && (this._$selectAll.remove(), this._$selectAll = null);
  }
}
q6("selection", "default", J6);
const hC = x({}, NO, {
  _dataExpressionDefaultOptions: () => ({
    items: [],
    dataSource: null,
    itemTemplate: "item",
    value: null,
    valueExpr: "this",
    displayExpr: void 0
  }),
  _initDataExpressions() {
    this._compileValueGetter(), this._compileDisplayGetter(), this._initDynamicTemplates(), this._initDataSource(), this._itemsToDataSource();
  },
  _itemsToDataSource() {
    this.option("dataSource") || (this._dataSource = new In({
      store: new _d(this.option("items")),
      pageSize: 0
    }), this._initDataController());
  },
  _compileDisplayGetter() {
    this._displayGetter = Be(this._displayGetterExpr());
  },
  _displayGetterExpr() {
    return this.option("displayExpr");
  },
  _compileValueGetter() {
    this._valueGetter = Be(this._valueGetterExpr());
  },
  _valueGetterExpr() {
    return this.option("valueExpr") || "this";
  },
  _loadValue(i) {
    const e = w();
    return i = this._unwrappedValue(i), f(i) ? (this._loadSingle(this._valueGetterExpr(), i).done((t) => {
      this._isValueEquals(this._valueGetter(t), i) ? e.resolve(t) : e.reject();
    }).fail(() => {
      e.reject();
    }), this._loadValueDeferred = e, e.promise()) : e.reject().promise();
  },
  _rejectValueLoading() {
    var i;
    (i = this._loadValueDeferred) === null || i === void 0 || i.reject({
      shouldSkipCallback: !0
    });
  },
  _getCurrentValue() {
    return this.option("value");
  },
  _unwrappedValue(i) {
    return i = i ?? this._getCurrentValue(), i && this._dataSource && this._valueGetterExpr() === "this" && (i = this._getItemKey(i)), Bt.unwrap(i);
  },
  _getItemKey(i) {
    const e = this._dataSource.key();
    if (Array.isArray(e)) {
      const t = {};
      for (let n = 0, s = e.length; n < s; n++)
        t[e[n]] = i[e[n]];
      return t;
    }
    return e && typeof i == "object" && (i = i[e]), i;
  },
  _isValueEquals(i, e) {
    const t = this._dataSource && this._dataSource.key();
    let n = this._compareValues(i, e);
    return !n && t && f(i) && f(e) && (Array.isArray(t) ? n = this._compareByCompositeKey(i, e, t) : n = this._compareByKey(i, e, t)), n;
  },
  _compareByCompositeKey(i, e, t) {
    const n = X;
    if (!n(i) || !n(e))
      return !1;
    for (let s = 0, o = t.length; s < o; s++)
      if (i[t[s]] !== e[t[s]])
        return !1;
    return !0;
  },
  _compareByKey(i, e, t) {
    const n = Bt.unwrap, s = Qe(n(i[t]), i), o = Qe(n(e[t]), e);
    return this._compareValues(s, o);
  },
  _compareValues: (i, e) => Mt(i, !0) === Mt(e, !0),
  _initDynamicTemplates: M,
  _setCollectionWidgetItemTemplate() {
    this._initDynamicTemplates(), this._setCollectionWidgetOption("itemTemplate", this.option("itemTemplate"));
  },
  _getCollectionKeyExpr() {
    const i = this.option("valueExpr");
    return te(i) && i !== "this" || B(i) ? i : null;
  },
  _dataExpressionOptionChanged(i) {
    switch (i.name) {
      case "items":
        this._itemsToDataSource(), this._setCollectionWidgetOption("items");
        break;
      case "dataSource":
        this._initDataSource();
        break;
      case "itemTemplate":
        this._setCollectionWidgetItemTemplate();
        break;
      case "valueExpr":
        this._compileValueGetter();
        break;
      case "displayExpr":
        this._compileDisplayGetter(), this._initDynamicTemplates(), this._setCollectionWidgetOption("displayExpr");
    }
  }
}), AA = [], Ch = function(i, e, t) {
  AA.push({
    enabled: i,
    decoratorType: e,
    decoratorSubType: t
  });
};
Ch(function() {
  return this.option("menuItems").length;
}, () => "menu", function() {
  return this.option("menuMode");
});
Ch(function() {
  return !this.option("menuItems").length && this.option("allowItemDeleting");
}, function() {
  const i = this.option("itemDeleteMode");
  return i === "toggle" || i === "slideButton" || i === "swipe" || i === "static" ? "delete" : "menu";
}, function() {
  let i = this.option("itemDeleteMode");
  return i === "slideItem" && (i = "slide"), i;
});
Ch(function() {
  return this.option("selectionMode") !== "none" && this.option("showSelectionControls");
}, () => "selection", () => "default");
Ch(function() {
  return this.option("itemDragging.allowReordering") || this.option("itemDragging.allowDropInsideItem") || this.option("itemDragging.group");
}, () => "reorder", () => "default");
class e9 extends se.inherit({}) {
  ctor(e) {
    this._list = e, this._fetchRequiredDecorators();
  }
  dispose() {
    var e;
    (e = this._decorators) !== null && e !== void 0 && e.length && y(this._decorators, (t, n) => {
      n.dispose();
    });
  }
  _fetchRequiredDecorators() {
    this._decorators = [], y(AA, (e, t) => {
      if (t.enabled.call(this._list)) {
        const s = t.decoratorType.call(this._list), o = t.decoratorSubType.call(this._list), r = this._createDecorator(s, o);
        this._decorators.push(r);
      }
    });
  }
  _createDecorator(e, t) {
    const n = this._findDecorator(e, t);
    return new n(this._list);
  }
  _findDecorator(e, t) {
    var n;
    const s = (n = OA[e]) === null || n === void 0 ? void 0 : n[t];
    if (!s)
      throw _e.Error("E1012", e, t);
    return s;
  }
  modifyItemElement(e) {
    const t = p(e.itemElement), n = {
      $itemElement: t
    };
    this._prependBeforeBags(t, n), this._appendAfterBags(t, n), this._applyDecorators("modifyElement", n);
  }
  afterItemsRendered() {
    this._applyDecorators("afterRender");
  }
  _prependBeforeBags(e, t) {
    const n = this._collectDecoratorsMarkup("beforeBag", t, "dx-list-item-before-bag");
    e.prepend(n);
  }
  _appendAfterBags(e, t) {
    const n = this._collectDecoratorsMarkup("afterBag", t, "dx-list-item-after-bag");
    e.append(n);
  }
  _collectDecoratorsMarkup(e, t, n) {
    const s = p("<div>");
    return y(this._decorators, function() {
      const o = p("<div>").addClass(n);
      this[e](x({
        $container: o
      }, t)), o.children().length && s.append(o);
    }), s.children();
  }
  _applyDecorators(e, t) {
    y(this._decorators, function() {
      this[e](t);
    });
  }
  _handlerExists(e) {
    if (!this._decorators)
      return !1;
    const t = this._decorators, {
      length: n
    } = t;
    for (let s = 0; s < n; s++)
      if (t[s][e] !== M)
        return !0;
    return !1;
  }
  _eventHandler(e, t, n) {
    if (!this._decorators)
      return !1;
    let s = !1;
    const o = this._decorators, {
      length: r
    } = o;
    for (let a = 0; a < r && (s = o[a][e](t, n), !s); a++)
      ;
    return s;
  }
  handleClick(e, t) {
    return this._eventHandler("handleClick", e, t);
  }
  handleKeyboardEvents(e, t) {
    return this._eventHandler("handleKeyboardEvents", e, t);
  }
  handleEnterPressing(e) {
    return this._eventHandler("handleEnterPressing", e);
  }
  contextMenuHandlerExists() {
    return this._handlerExists("handleContextMenu");
  }
  handleContextMenu(e, t) {
    return this._eventHandler("handleContextMenu", e, t);
  }
  getExcludedItemSelectors() {
    const e = [];
    return this._applyDecorators("getExcludedSelectors", e), e.join(",");
  }
}
const vw = (i) => (i.group << 20) + i.item, fo = (i) => ({
  group: i >> 20,
  item: 1048575 & i
});
class t9 extends Y_ {
  _groupElements() {
    return this._collectionWidget._itemContainer().find(".dx-list-group");
  }
  _groupItemElements(e) {
    return e.find(".dx-list-item");
  }
  getIndexByItemData(e) {
    var t;
    const n = this._collectionWidget.option("items");
    let s = !1;
    return e ? ((t = e.items) !== null && t !== void 0 && t.length && (e = e.items[0]), y(n, (o, r) => {
      if (!r.items || (y(r.items, (a, l) => l !== e ? !0 : (s = {
        group: o,
        item: a
      }, !1)), s))
        return !1;
    }), s) : !1;
  }
  getItemDataByIndex(e) {
    var t;
    const n = this._collectionWidget.option("items");
    return $e(e) ? this.itemsGetter()[e] : e && ((t = n[e.group]) === null || t === void 0 ? void 0 : t.items[e.item]) || null;
  }
  itemsGetter() {
    let e = [];
    const {
      items: t
    } = this._collectionWidget.option();
    for (let s = 0; s < t.length; s++) {
      var n;
      (n = t[s]) !== null && n !== void 0 && n.items ? e = e.concat(t[s].items) : e.push(t[s]);
    }
    return e;
  }
  deleteItemAtIndex(e) {
    const t = fo(e);
    this._collectionWidget.option("items")[t.group].items.splice(t.item, 1);
  }
  getKeysByItems(e) {
    let t = [], n;
    for (n = 0; n < e.length; n++) {
      var s;
      (s = e[n]) !== null && s !== void 0 && s.items ? t = t.concat(e[n].items) : t.push(e[n]);
    }
    const o = [];
    for (n = 0; n < t.length; n++)
      o.push(this._collectionWidget.keyOf(t[n]));
    return o;
  }
  getIndexByKey(e, t) {
    const n = t || this._collectionWidget.option("items");
    let s = -1;
    const o = this;
    return y(n, (r, a) => {
      if (a.items && (y(a.items, (l, d) => {
        const u = o._collectionWidget.keyOf(d);
        if (o._equalKeys(u, e))
          return s = {
            group: r,
            item: l
          }, !1;
      }), s !== -1))
        return !1;
    }), s;
  }
  _getGroups(e) {
    const n = this._collectionWidget._dataController.group();
    return n ? ps.queryByOptions(un(e), {
      group: n
    }).toArray() : this._collectionWidget.option("items");
  }
  getItemsByKeys(e, t) {
    const n = [], s = this._getGroups(t), o = {}, r = (a) => {
      const l = this.getIndexByKey(a, s), d = l && s[l.group];
      if (d)
        return {
          groupKey: d.key,
          item: d.items[l.item]
        };
    };
    return y(e, (a, l) => {
      const d = r(l);
      if (!d)
        return;
      const {
        groupKey: u
      } = d, {
        item: c
      } = d;
      let h = o[u];
      h || (h = {
        key: u,
        items: []
      }, o[u] = h, n.push(h)), h.items.push(c);
    }), n;
  }
  moveItemAtIndexToIndex(e, t) {
    const n = this._collectionWidget.option("items"), s = fo(e), o = fo(t), r = n[s.group].items, a = n[o.group].items, l = r[s.item];
    r.splice(s.item, 1), a.splice(o.item, 0, l);
  }
  _isItemIndex(e) {
    return e && $e(e.group) && $e(e.item);
  }
  _getNormalizedItemIndex(e) {
    const t = p(e), n = t.closest(".dx-list-group");
    return n.length ? vw({
      group: this._groupElements().index(n),
      item: this._groupItemElements(n).index(t)
    }) : -1;
  }
  _normalizeItemIndex(e) {
    return vw(e);
  }
  _denormalizeItemIndex(e) {
    return fo(e);
  }
  _getItemByNormalizedIndex(e) {
    const t = fo(e), n = this._groupElements().eq(t.group);
    return this._groupItemElements(n).eq(t.item);
  }
  _itemsFromSameParent(e, t) {
    return fo(e).group === fo(t).group;
  }
}
class n9 extends _h {
  _supportedKeys() {
    const e = this, t = super._supportedKeys(), n = (s, o) => {
      const r = this._editStrategy, {
        focusedElement: a
      } = this.option(), l = r.getNormalizedIndex(a);
      if (!(l === this._getLastItemIndex() && this._dataController.isLoading()))
        if (s.shiftKey && e.option("itemDragging.allowReordering")) {
          const u = l + (o ? -1 : 1), c = r.getItemElement(u);
          this.option("grouped") && p(a).parent().get(0) !== c.parent().get(0) || (this.reorderItem(a, c), this.scrollToItem(a)), s.preventDefault();
        } else
          this._editProvider.handleKeyboardEvents(l, o) || (o ? t.upArrow(s) : t.downArrow(s));
    };
    return I({}, t, {
      del: (s) => {
        e.option("allowItemDeleting") && (s.preventDefault(), e.deleteItem(e.option("focusedElement")));
      },
      upArrow: (s) => n(s, !0),
      downArrow: (s) => n(s),
      enter: function(s) {
        this._editProvider.handleEnterPressing(s) || t.enter.apply(this, arguments);
      },
      space: function(s) {
        this._editProvider.handleEnterPressing(s) || t.space.apply(this, arguments);
      }
    });
  }
  _updateSelection() {
    this._editProvider.afterItemsRendered(), super._updateSelection();
  }
  _getLastItemIndex() {
    return this._itemElements().length - 1;
  }
  _refreshItemElements() {
    super._refreshItemElements();
    const e = this._editProvider.getExcludedItemSelectors();
    e.length && (this._itemElementsCache = this._itemElementsCache.not(e));
  }
  _isItemStrictEquals(e, t) {
    const n = e?.__dx_key__;
    return n && !this.key() && this._selection.isItemSelected(n) ? !1 : super._isItemStrictEquals(e, t);
  }
  _getDefaultOptions() {
    return x(super._getDefaultOptions(), {
      showSelectionControls: !1,
      selectionMode: "none",
      selectAllMode: "page",
      onSelectAllValueChanged: null,
      selectAllText: S.format("dxList-selectAll"),
      menuItems: [],
      menuMode: "context",
      allowItemDeleting: !1,
      itemDeleteMode: "static",
      itemDragging: {}
    });
  }
  _defaultOptionsRules() {
    return super._defaultOptionsRules().concat([{
      device: (e) => e.platform === "ios",
      options: {
        menuMode: "slide",
        itemDeleteMode: "slideItem"
      }
    }, {
      device: {
        platform: "android"
      },
      options: {
        itemDeleteMode: "swipe"
      }
    }]);
  }
  _init() {
    super._init(), this._initEditProvider();
  }
  _initDataSource() {
    if (super._initDataSource(), !this._isPageSelectAll()) {
      var e;
      (e = this._dataSource) === null || e === void 0 || e.requireTotalCount(!0);
    }
  }
  _isPageSelectAll() {
    const {
      selectAllMode: e
    } = this.option();
    return e === "page";
  }
  _initEditProvider() {
    this._editProvider = new e9(this);
  }
  _disposeEditProvider() {
    this._editProvider && this._editProvider.dispose();
  }
  _refreshEditProvider() {
    this._disposeEditProvider(), this._initEditProvider();
  }
  _initEditStrategy() {
    this.option("grouped") ? this._editStrategy = new t9(this) : super._initEditStrategy();
  }
  _initMarkup() {
    this._refreshEditProvider(), super._initMarkup();
  }
  _renderItems() {
    super._renderItems(...arguments), this._editProvider.afterItemsRendered();
  }
  _renderItem(e, t, n, s) {
    const {
      showSelectionControls: o,
      selectionMode: r
    } = this.option(), a = super._renderItem(e, t, n, s);
    return o && r !== "none" && this._updateItemAriaLabel(a, t), a;
  }
  _updateItemAriaLabel(e, t) {
    var n;
    const s = ((n = this._displayGetter) === null || n === void 0 ? void 0 : n.call(this, t)) ?? t?.text ?? t;
    this.setAria("label", X(s) ? S.format("dxList-listAriaLabel-itemContent") : s, e);
  }
  _selectedItemClass() {
    return "dx-list-item-selected";
  }
  _itemResponseWaitClass() {
    return "dx-list-item-response-wait";
  }
  _itemClickHandler(e) {
    const t = p(e.currentTarget);
    t.is(".dx-state-disabled, .dx-state-disabled *") || this._editProvider.handleClick(t, e) || (this._saveSelectionChangeEvent(e), super._itemClickHandler(...arguments));
  }
  _shouldFireContextMenuEvent() {
    return super._shouldFireContextMenuEvent(...arguments) || this._editProvider.contextMenuHandlerExists();
  }
  _itemHoldHandler(e) {
    const t = p(e.currentTarget);
    if (t.is(".dx-state-disabled, .dx-state-disabled *"))
      return;
    if (Zl(e) && this._editProvider.handleContextMenu(t, e)) {
      e.handledByEditProvider = !0;
      return;
    }
    super._itemHoldHandler(...arguments);
  }
  _getItemContainer(e) {
    if (this.option("grouped")) {
      var t;
      const n = (t = this._editStrategy.getIndexByItemData(e)) === null || t === void 0 ? void 0 : t.group;
      return this._getGroupContainerByIndex(n);
    }
    return super._getItemContainer(e);
  }
  _itemContextMenuHandler(e) {
    const t = p(e.currentTarget);
    if (t.is(".dx-state-disabled, .dx-state-disabled *"))
      return;
    if (!e.handledByEditProvider && this._editProvider.handleContextMenu(t, e)) {
      e.preventDefault();
      return;
    }
    super._itemContextMenuHandler(...arguments);
  }
  _postprocessRenderItem(e) {
    super._postprocessRenderItem(...arguments), this._editProvider.modifyItemElement(e);
  }
  _clean() {
    this._disposeEditProvider(), super._clean();
  }
  focusListItem(e) {
    const t = this._editStrategy.getItemElement(e);
    this.option("focusedElement", t), this.focus(), this.scrollToItem(this.option("focusedElement"));
  }
  _getFlatIndex() {
    const {
      selectedIndex: e = Lr
    } = this.option();
    if ($e(e) || !e)
      return e;
    const t = this._editStrategy.getItemElement(e);
    return this.getFlatIndexByItemElement(t);
  }
  _optionChanged(e) {
    switch (e.name) {
      case "selectAllMode":
        this._initDataSource(), this._dataController.pageIndex(0), this._dataController.load();
        break;
      case "grouped":
        this._clearSelectedItems(), delete this._renderingGroupIndex, this._initEditStrategy(), super._optionChanged(e);
        break;
      case "showSelectionControls":
      case "menuItems":
      case "menuMode":
      case "allowItemDeleting":
      case "itemDeleteMode":
      case "itemDragging":
      case "selectAllText":
        this._invalidate();
        break;
      case "onSelectAllValueChanged":
        break;
      default:
        super._optionChanged(e);
    }
  }
  selectAll() {
    return this._selection.selectAll(this._isPageSelectAll());
  }
  unselectAll() {
    return this._selection.deselectAll(this._isPageSelectAll());
  }
  isSelectAll() {
    return this._selection.getSelectAllState(this._isPageSelectAll());
  }
  getFlatIndexByItemElement(e) {
    return this._itemElements().index(e);
  }
  getItemElementByFlatIndex(e) {
    const t = this._itemElements();
    return e < 0 || e >= t.length ? p() : t.eq(e);
  }
  getItemByIndex(e) {
    return this._editStrategy.getItemDataByIndex(e);
  }
  deleteItem(e) {
    const t = this._editStrategy, n = t.getNormalizedIndex(e), {
      focusedElement: s,
      focusStateEnabled: o
    } = this.option(), r = s ? t.getNormalizedIndex(s) : n, l = r === this._getLastItemIndex() || n < r ? r - 1 : r;
    return super.deleteItem(e).done(function() {
      o && this.focusListItem(l);
    });
  }
}
const fa = n9.inherit(Xo).inherit({
  _addWidgetPrefix: (i) => `dx-list-${i}`,
  _getCombinedFilter() {
    const i = this._dataController, e = {
      filter: i.filter()
    };
    i.addSearchFilter(e);
    const {
      filter: t
    } = e;
    return t;
  },
  _initDataSource() {
    const i = this.option("searchValue"), e = this.option("searchExpr"), t = this.option("searchMode");
    this.callBase();
    const n = this._dataController;
    i?.length && n.searchValue(i), t.length && n.searchOperation(Xo.getOperationBySearchMode(t)), e && n.searchExpr(e);
  }
});
xe("dxList", fa);
const i9 = "dx-dropdowneditor-button-visible", s9 = "dxDropDownEditor-selectLabel";
let o9 = class extends mh {
  constructor(e, t, n) {
    super(e, t, n), this.currentTemplate = null;
  }
  _attachEvents(e) {
    const {
      editor: t
    } = this;
    e.option("onClick", (n) => {
      var s;
      if ((s = t._shouldCallOpenHandler) !== null && s !== void 0 && s.call(t)) {
        t._openHandler(n);
        return;
      }
      !t.option("openOnFieldClick") && t._openHandler(n);
    }), _.on(e.$element(), "mousedown", (n) => {
      t.$element().is(".dx-state-focused") && n.preventDefault();
    });
  }
  _create() {
    const {
      editor: e
    } = this, t = p("<div>"), n = this._getOptions();
    this._addToContainer(t);
    const s = e._createComponent(t, wt, x({}, n, {
      elementAttr: {
        "aria-label": S.format(s9)
      }
    }));
    return this._legacyRender(e.$element(), t, n.visible), {
      $element: t,
      instance: s
    };
  }
  _getOptions() {
    const {
      editor: e
    } = this, t = this._isVisible(), s = {
      focusStateEnabled: !1,
      hoverStateEnabled: !1,
      activeStateEnabled: !1,
      useInkRipple: !1,
      disabled: e.option("readOnly"),
      visible: t
    };
    return this._addTemplate(s), s;
  }
  _isVisible() {
    const {
      editor: e
    } = this;
    return super._isVisible() && e.option("showDropDownButton");
  }
  _legacyRender(e, t, n) {
    e.toggleClass(i9, n), t && t.removeClass("dx-button").removeClass("dx-button-mode-contained").addClass("dx-dropdowneditor-button");
  }
  _isSameTemplate() {
    return this.editor.option("dropDownButtonTemplate") === this.currentTemplate;
  }
  _addTemplate(e) {
    this._isSameTemplate() || (e.template = this.editor._getTemplateByOption("dropDownButtonTemplate"), this.currentTemplate = this.editor.option("dropDownButtonTemplate"));
  }
  update() {
    if (super.update()) {
      const {
        editor: t,
        instance: n
      } = this, s = t.$element(), o = this._getOptions();
      n?.option(o), this._legacyRender(s, n?.$element(), o.visible);
    }
  }
};
const Ec = function(i) {
  if (ae())
    return Ee(i);
}, pC = function(i) {
  return i === null && (i = void 0), typeof i == "function" && (i = i()), i;
}, r9 = "dx-dropdowneditor", xw = "dx-dropdowneditor-input-wrapper", Jd = "dx-dropdowneditor-overlay", a9 = "dx-dropdowneditor-overlay-flipped", l9 = "dx-dropdowneditor-active", d9 = "dx-dropdowneditor-field-clickable", u9 = "dx-dropdowneditor-field-template-wrapper", yw = z.current().platform === "ios";
function bw() {
  return p("<div>").addClass(u9);
}
class vh extends ma {
  _supportedKeys() {
    return I({}, super._supportedKeys(), {
      tab: (e) => {
        if (!this.option("opened"))
          return;
        if (!this._popup.getFocusableElements().length) {
          this.close();
          return;
        }
        const t = e.shiftKey ? this._getLastPopupElement() : this._getFirstPopupElement();
        t && (_.trigger(t, "focus"), t.select()), e.preventDefault();
      },
      escape: (e) => (this.option("opened") && e.preventDefault(), this.close(), !0),
      upArrow: (e) => !bt(e) && (e.preventDefault(), e.stopPropagation(), e.altKey) ? (this.close(), !1) : !0,
      downArrow: (e) => !bt(e) && (e.preventDefault(), e.stopPropagation(), e.altKey) ? (this._validatedOpening(), !1) : !0,
      enter: (e) => (this.option("opened") && (e.preventDefault(), this._valueChangeEventHandler(e)), !0)
    });
  }
  _getDefaultButtons() {
    return super._getDefaultButtons().concat([{
      name: "dropDown",
      Ctor: o9
    }]);
  }
  _getDefaultOptions() {
    return I({}, super._getDefaultOptions(), {
      value: null,
      onOpened: null,
      onClosed: null,
      opened: !1,
      acceptCustomValue: !0,
      applyValueMode: "instantly",
      deferRendering: !0,
      activeStateEnabled: !0,
      dropDownButtonTemplate: "dropDownButton",
      fieldTemplate: null,
      openOnFieldClick: !1,
      showDropDownButton: !0,
      buttons: void 0,
      dropDownOptions: {
        showTitle: !1
      },
      popupPosition: this._getDefaultPopupPosition(),
      onPopupInitialized: null,
      applyButtonText: S.format("OK"),
      cancelButtonText: S.format("Cancel"),
      buttonsLocation: "default",
      useHiddenSubmitElement: !1,
      validationMessagePosition: "auto"
    });
  }
  _useTemplates() {
    return !0;
  }
  _getDefaultPopupPosition(e) {
    const t = ro(e);
    return {
      offset: {
        h: 0,
        v: -1
      },
      my: `${t} top`,
      at: `${t} bottom`,
      collision: "flip flip"
    };
  }
  _defaultOptionsRules() {
    return super._defaultOptionsRules().concat([{
      device(e) {
        return e.platform === "generic";
      },
      options: {
        popupPosition: {
          offset: {
            v: 0
          }
        }
      }
    }]);
  }
  _inputWrapper() {
    return this.$element().find(`.${xw}`).first();
  }
  _init() {
    super._init(), this._initVisibilityActions(), this._initPopupInitializedAction();
    const {
      rtlEnabled: e,
      dropDownOptions: t
    } = this.option();
    this._updatePopupPosition(e), this._options.cache("dropDownOptions", t);
  }
  _updatePopupPosition(e) {
    const {
      my: t,
      at: n
    } = this._getDefaultPopupPosition(e), s = this.option("popupPosition");
    this.option("popupPosition", x({}, s, {
      my: t,
      at: n
    }));
  }
  _initVisibilityActions() {
    this._openAction = this._createActionByOption("onOpened", {
      excludeValidators: ["disabled", "readOnly"]
    }), this._closeAction = this._createActionByOption("onClosed", {
      excludeValidators: ["disabled", "readOnly"]
    });
  }
  _initPopupInitializedAction() {
    this._popupInitializedAction = this._createActionByOption("onPopupInitialized", {
      excludeValidators: ["disabled", "readOnly"]
    });
  }
  _initMarkup() {
    this._renderSubmitElement(), super._initMarkup(), this.$element().addClass("dx-dropdowneditor"), this.setAria("role", this._getAriaRole());
  }
  _render() {
    this._detachFocusEvents(), super._render(), this._renderOpenHandler(), this._attachFocusOutHandler(), this._renderOpenedState();
  }
  _renderContentImpl() {
    this.option("deferRendering") || this._createPopup();
  }
  _renderInput() {
    super._renderInput(), this._renderTemplateWrapper(), this._wrapInput(), this._setDefaultAria();
  }
  _wrapInput() {
    this._$container = this.$element().wrapInner(p("<div>").addClass(xw)).children().eq(0);
  }
  _getAriaHasPopup() {
    return "true";
  }
  _getAriaAutocomplete() {
    return "none";
  }
  _getAriaRole() {
    return "combobox";
  }
  _setDefaultAria() {
    this.setAria({
      haspopup: this._getAriaHasPopup(),
      autocomplete: this._getAriaAutocomplete(),
      role: this._getAriaRole()
    });
  }
  _readOnlyPropValue() {
    return !this._isEditable() || super._readOnlyPropValue();
  }
  _cleanFocusState() {
    super._cleanFocusState(), this.option("fieldTemplate") && this._detachFocusEvents();
  }
  _getFieldTemplate() {
    return this.option("fieldTemplate") && this._getTemplateByOption("fieldTemplate");
  }
  _renderMask() {
    this.option("fieldTemplate") || super._renderMask();
  }
  _renderField() {
    const e = this._getFieldTemplate();
    e && this._renderTemplatedField(e, this._fieldRenderData());
  }
  _renderPlaceholder() {
    !!this._getFieldTemplate() || super._renderPlaceholder();
  }
  _renderValue() {
    return this.option("useHiddenSubmitElement") && this._setSubmitValue(), super._renderValue().always(this._renderField.bind(this));
  }
  _getButtonsContainer() {
    return this._getFieldTemplate() ? this._$container : this._$textEditorContainer;
  }
  _renderTemplateWrapper() {
    this._getFieldTemplate() && (this._$templateWrapper || (this._$templateWrapper = bw().prependTo(this.$element())));
  }
  _renderTemplatedField(e, t) {
    const n = qs(this._input());
    this._detachKeyboardEvents(), this._detachFocusEvents(), this._$textEditorContainer.remove();
    const s = bw();
    this._$templateWrapper.replaceWith(s), this._$templateWrapper = s;
    const o = Symbol("renderContext");
    this._activeRenderContext = o, e.render({
      model: t,
      container: ee(this._$templateWrapper),
      onRendered: () => {
        if (this._activeRenderContext !== o)
          return;
        const r = this._input();
        if (!r.length)
          throw _e.Error("E1010");
        this._integrateInput(), n && (ze.mozilla ? r.get(0).focus({
          preventScroll: !0
        }) : _.trigger(r, "focus"));
      }
    });
  }
  _integrateInput() {
    const {
      isValid: e
    } = this.option();
    this._renderFocusState(), this._refreshValueChangeEvent(), this._refreshEvents(), this._refreshEmptinessEvent(), this._setDefaultAria(), this._setFieldAria(), this._toggleValidationClasses(!e);
    const {
      _onMarkupRendered: t
    } = this.option();
    t?.();
  }
  _refreshEmptinessEvent() {
    _.off(this._input(), "input blur", this._toggleEmptinessEventHandler), this._renderEmptinessEvent();
  }
  _fieldRenderData() {
    return this.option("value");
  }
  _initTemplates() {
    this._templateManager.addDefaultTemplates({
      dropDownButton: new sa((e) => {
        const t = p("<div>").addClass("dx-dropdowneditor-icon");
        p(e.container).append(t);
      })
    }), super._initTemplates();
  }
  _renderOpenHandler() {
    const e = this._inputWrapper(), t = R(Te, this.NAME), {
      openOnFieldClick: n
    } = this.option();
    _.off(e, t), _.on(e, t, this._getInputClickHandler(n)), this.$element().toggleClass(d9, n), n && (this._openOnFieldClickAction = this._createAction(this._openHandler.bind(this)));
  }
  _attachFocusOutHandler() {
    yw && (this._detachFocusOutEvents(), _.on(this._inputWrapper(), R("focusout", this.NAME), (e) => {
      const t = e.relatedTarget;
      t && this.option("opened") && this._isTargetOutOfComponent(t) && this.close();
    }));
  }
  _isTargetOutOfComponent(e) {
    const t = this.content ? p(this.content()).closest(`.${Jd}`) : this._$popup;
    return p(e).closest(`.${Jd}`, t).length === 0;
  }
  _detachFocusOutEvents() {
    yw && _.off(this._inputWrapper(), R("focusout", this.NAME));
  }
  _getInputClickHandler(e) {
    return e ? (t) => {
      this._executeOpenAction(t);
    } : () => {
      this._focusInput();
    };
  }
  _openHandler() {
    this._toggleOpenState();
  }
  _executeOpenAction(e) {
    var t;
    (t = this._openOnFieldClickAction) === null || t === void 0 || t.call(this, {
      event: e
    });
  }
  _keyboardEventBindingTarget() {
    return this._input();
  }
  _focusInput() {
    return this.option("disabled") ? !1 : (this.option("focusStateEnabled") && !qs(this._input()) && (this._resetCaretPosition(), _.trigger(this._input(), "focus")), !0);
  }
  _resetCaretPosition() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : !1;
    const t = this._input().get(0);
    if (t) {
      const {
        value: n
      } = t, s = f(n) && (e || this._isEditable()) ? n.length : 0;
      this._caret({
        start: s,
        end: s
      }, !0);
    }
  }
  _isEditable() {
    const {
      acceptCustomValue: e
    } = this.option();
    return e;
  }
  _toggleOpenState(e) {
    this._focusInput() && (this.option("readOnly") || (e = arguments.length ? e : !this.option("opened"), this.option("opened", e)));
  }
  _getControlsAria() {
    return this._popup && this._popupContentId;
  }
  _renderOpenedState() {
    const e = this.option("opened");
    e && this._createPopup(), this.$element().toggleClass(l9, e), this._setPopupOption("visible", e);
    const t = {
      expanded: e,
      controls: this._getControlsAria()
    };
    this.setAria(t), this.setAria("owns", e ? this._popupContentId : void 0, this.$element());
  }
  _createPopup() {
    this._$popup || (this._$popup = p("<div>").addClass(Jd).appendTo(this.$element()), this._renderPopup(), this._renderPopupContent(), this._setPopupAriaLabel());
  }
  _setPopupAriaLabel() {
    const e = this._popup.$overlayContent();
    this.setAria("label", "Dropdown", e);
  }
  _renderPopupContent() {
  }
  _renderPopup() {
    const e = x(this._popupConfig(), this._options.cache("dropDownOptions"));
    delete e.closeOnOutsideClick, this._popup = this._createComponent(this._$popup, pi, e), this._popup.on({
      showing: this._popupShowingHandler.bind(this),
      shown: this._popupShownHandler.bind(this),
      hiding: this._popupHidingHandler.bind(this),
      hidden: this._popupHiddenHandler.bind(this),
      contentReady: this._contentReadyHandler.bind(this)
    }), this._attachPopupKeyHandler(), this._contentReadyHandler(), this._setPopupContentId(this._popup.$content()), this._bindInnerWidgetOptions(this._popup, "dropDownOptions");
  }
  _attachPopupKeyHandler() {
    _.on(this._popup.$overlayContent(), R("keydown", this.NAME), (e) => this._popupKeyHandler(e));
  }
  _popupKeyHandler(e) {
    switch (Ye(e)) {
      case "tab":
        this._popupTabHandler(e);
        break;
      case "escape":
        this._popupEscHandler();
    }
  }
  _popupTabHandler(e) {
    const t = p(e.target), n = e.shiftKey && t.is(this._getFirstPopupElement());
    (!e.shiftKey && t.is(this._getLastPopupElement()) || n) && (_.trigger(this.field(), "focus"), e.preventDefault());
  }
  _popupEscHandler() {
    _.trigger(this._input(), "focus"), this.close();
  }
  _setPopupContentId(e) {
    this._popupContentId = `dx-${new Xe()}`, this.setAria("id", this._popupContentId, e);
  }
  _contentReadyHandler() {
  }
  _popupConfig() {
    return {
      onInitialized: this._getPopupInitializedHandler(),
      position: x(this.option("popupPosition"), {
        of: this.$element()
      }),
      showTitle: this.option("dropDownOptions.showTitle"),
      _ignoreFunctionValueDeprecation: !0,
      width: () => Ec(this.$element()),
      height: "auto",
      shading: !1,
      hideOnParentScroll: !0,
      hideOnOutsideClick: (e) => this._closeOutsideDropDownHandler(e),
      animation: {
        show: {
          type: "fade",
          duration: 0,
          from: 0,
          to: 1
        },
        hide: {
          type: "fade",
          duration: 400,
          from: 1,
          to: 0
        }
      },
      deferRendering: !1,
      focusStateEnabled: !1,
      showCloseButton: !1,
      dragEnabled: !1,
      toolbarItems: this._getPopupToolbarItems(),
      onPositioned: this._popupPositionedHandler.bind(this),
      fullScreen: !1,
      contentTemplate: null,
      _hideOnParentScrollTarget: this.$element(),
      _wrapperClassExternal: Jd,
      _ignorePreventScrollEventsDeprecation: !0
    };
  }
  _popupInitializedHandler() {
  }
  _getPopupInitializedHandler() {
    const e = this.option("onPopupInitialized");
    return (t) => {
      this._popupInitializedHandler(), e && this._popupInitializedAction({
        popup: t.component
      });
    };
  }
  _dimensionChanged() {
    if (ae() && !this.$element().is(":visible")) {
      this.close();
      return;
    }
    this._updatePopupWidth();
  }
  _updatePopupWidth() {
    pC(this.option("dropDownOptions.width")) === void 0 && this._setPopupOption("width", () => Ec(this.$element()));
  }
  _popupPositionedHandler(e) {
    var t;
    const {
      labelMode: n,
      stylingMode: s
    } = this.option();
    if (!this._popup)
      return;
    const o = this._popup.$overlayContent(), r = (t = e.position) === null || t === void 0 || (t = t.v) === null || t === void 0 ? void 0 : t.flip, a = n !== "hidden" && n !== "outside" && s === "outlined";
    if (e.position && o.toggleClass(a9, r), r && a && this._label.isVisible()) {
      const l = this._label.$element();
      Ot(o, {
        top: Nn(o).top - parseInt(l.css("fontSize"))
      });
    }
  }
  _popupShowingHandler() {
  }
  _popupHidingHandler() {
    this.option("opened", !1);
  }
  _popupShownHandler() {
    var e;
    this._openAction(), (e = this._validationMessage) === null || e === void 0 || e.option("positionSide", this._getValidationMessagePositionSide());
  }
  _popupHiddenHandler() {
    var e;
    this._closeAction(), (e = this._validationMessage) === null || e === void 0 || e.option("positionSide", this._getValidationMessagePositionSide());
  }
  _getValidationMessagePositionSide() {
    var e;
    const {
      validationMessagePosition: t
    } = this.option();
    if (t !== "auto")
      return t;
    let n = "bottom";
    if ((e = this._popup) !== null && e !== void 0 && e.option("visible")) {
      const {
        top: s
      } = Un.setup(this.$element()), {
        top: o
      } = Un.setup(this._popup.$content());
      n = s + this.option("popupPosition").offset.v > o ? "bottom" : "top";
    }
    return n;
  }
  _closeOutsideDropDownHandler(e) {
    const {
      target: t
    } = e, n = p(t), s = this.getButton("dropDown"), o = s?.$element(), r = !!n.closest(this.$element()).length, a = !!n.closest(o).length;
    return !r && !a;
  }
  _clean() {
    delete this._openOnFieldClickAction, delete this._$templateWrapper, this._$popup && (this._$popup.remove(), delete this._$popup, delete this._popup), super._clean();
  }
  _setPopupOption(e, t) {
    this._setWidgetOption("_popup", arguments);
  }
  _validatedOpening() {
    this.option("readOnly") || this._toggleOpenState(!0);
  }
  _getPopupToolbarItems() {
    const {
      applyValueMode: e
    } = this.option();
    return e === "useButtons" ? this._popupToolbarItemsConfig() : [];
  }
  _getFirstPopupElement() {
    return p(this._popup.getFocusableElements()).first();
  }
  _getLastPopupElement() {
    return p(this._popup.getFocusableElements()).last();
  }
  _popupToolbarItemsConfig() {
    const e = [{
      shortcut: "done",
      options: {
        onClick: this._applyButtonHandler.bind(this),
        text: this.option("applyButtonText")
      }
    }, {
      shortcut: "cancel",
      options: {
        onClick: this._cancelButtonHandler.bind(this),
        text: this.option("cancelButtonText")
      }
    }];
    return this._applyButtonsLocation(e);
  }
  _applyButtonsLocation(e) {
    const {
      buttonsLocation: t
    } = this.option(), n = e;
    if (t !== "default") {
      const s = er(t);
      y(n, (o, r) => {
        x(r, {
          toolbar: s[0],
          location: s[1]
        });
      });
    }
    return n;
  }
  _applyButtonHandler(e) {
    this.close(), this.option("focusStateEnabled") && this.focus();
  }
  _cancelButtonHandler() {
    this.close(), this.option("focusStateEnabled") && this.focus();
  }
  _popupOptionChanged(e) {
    const t = Rt.getOptionsFromContainer(e);
    this._setPopupOption(t);
    const n = Object.keys(t);
    (n.includes("width") || n.includes("height")) && this._dimensionChanged();
  }
  _renderSubmitElement() {
    this.option("useHiddenSubmitElement") && (this._$submitElement = p("<input>").attr("type", "hidden").appendTo(this.$element()));
  }
  _setSubmitValue() {
    const {
      value: e
    } = this.option();
    this._getSubmitElement().val(e);
  }
  _getSubmitElement() {
    return this.option("useHiddenSubmitElement") ? this._$submitElement : super._getSubmitElement();
  }
  _dispose() {
    this._detachFocusOutEvents(), super._dispose();
  }
  _optionChanged(e) {
    var t;
    const {
      name: n,
      value: s
    } = e;
    switch (n) {
      case "width":
      case "height":
        super._optionChanged(e), (t = this._popup) === null || t === void 0 || t.repaint();
        break;
      case "opened":
        this._renderOpenedState();
        break;
      case "onOpened":
      case "onClosed":
        this._initVisibilityActions();
        break;
      case "onPopupInitialized":
        this._initPopupInitializedAction();
        break;
      case "fieldTemplate":
      case "acceptCustomValue":
      case "openOnFieldClick":
        this._invalidate();
        break;
      case "dropDownButtonTemplate":
      case "showDropDownButton":
        this._updateButtons(["dropDown"]);
        break;
      case "dropDownOptions": {
        this._popupOptionChanged(e);
        const {
          dropDownOptions: o
        } = this.option();
        this._options.cache("dropDownOptions", o);
        break;
      }
      case "popupPosition":
        break;
      case "deferRendering":
        ae() && this._createPopup();
        break;
      case "applyValueMode":
      case "applyButtonText":
      case "cancelButtonText":
      case "buttonsLocation":
        this._setPopupOption("toolbarItems", this._getPopupToolbarItems());
        break;
      case "useHiddenSubmitElement":
        this._$submitElement && (this._$submitElement.remove(), this._$submitElement = void 0), this._renderSubmitElement();
        break;
      case "rtlEnabled":
        this._updatePopupPosition(s), super._optionChanged(e);
        break;
      default:
        super._optionChanged(e);
    }
  }
  open() {
    this.option("opened", !0);
  }
  close() {
    this.option("opened", !1);
  }
  field() {
    return ee(this._input());
  }
  content() {
    return this._popup ? this._popup.content() : null;
  }
}
xe("dxDropDownEditor", vh);
const ww = fe(), c9 = ["startswith", "contains", "endwith", "notcontains"], Sw = z.real().platform !== "android";
class gC extends vh {
  _supportedKeys() {
    const e = super._supportedKeys();
    return I({}, e, {
      tab(t) {
        if (this._allowSelectItemByTab()) {
          this._saveValueChangeEvent(t);
          const n = p(this._list.option("focusedElement"));
          n.length && this._setSelectedElement(n);
        }
        e.tab(t);
      },
      space: M,
      home: M,
      end: M
    });
  }
  _allowSelectItemByTab() {
    const {
      opened: e,
      applyValueMode: t
    } = this.option();
    return e && t === "instantly";
  }
  _setSelectedElement(e) {
    const t = this._valueGetter(this._list._getItemData(e));
    this._setValue(t);
  }
  _setValue(e) {
    this.option("value", e);
  }
  _getDefaultOptions() {
    return I({}, super._getDefaultOptions(), hC._dataExpressionDefaultOptions(), {
      displayValue: void 0,
      searchEnabled: !1,
      searchMode: "contains",
      searchTimeout: 500,
      minSearchLength: 0,
      searchExpr: null,
      valueChangeEvent: "input change keyup",
      selectedItem: null,
      noDataText: S.format("dxCollectionWidget-noDataText"),
      encodeNoDataText: !1,
      onSelectionChanged: null,
      onItemClick: M,
      showDataBeforeSearch: !1,
      grouped: !1,
      groupTemplate: "group",
      popupPosition: {
        my: "left top",
        at: "left bottom",
        offset: {
          h: 0,
          v: 0
        },
        collision: "flip"
      },
      wrapItemText: !1,
      useItemTextAsTitle: !1
    });
  }
  _defaultOptionsRules() {
    return super._defaultOptionsRules().concat([{
      device: {
        platform: "ios"
      },
      options: {
        popupPosition: {
          offset: {
            v: -1
          }
        }
      }
    }, {
      device: {
        platform: "generic"
      },
      options: {
        buttonsLocation: "bottom center"
      }
    }]);
  }
  _setOptionsByReference() {
    super._setOptionsByReference(), x(this._optionsByReference, {
      value: !0,
      selectedItem: !0,
      displayValue: !0
    });
  }
  _init() {
    super._init(), this._initDataExpressions(), this._initActions(), this._setListDataSource(), this._validateSearchMode(), this._clearSelectedItem(), this._initItems();
  }
  _setListFocusedElementOptionChange() {
    this._list._updateParentActiveDescendant = this._updateActiveDescendant.bind(this);
  }
  _initItems() {
    const {
      items: e
    } = this.option();
    e && !e.length && this._dataSource && (this.option().items = this._dataSource.items());
  }
  _initActions() {
    this._initContentReadyAction(), this._initSelectionChangedAction(), this._initItemClickAction();
  }
  _initContentReadyAction() {
    this._contentReadyAction = this._createActionByOption("onContentReady", {
      excludeValidators: ["disabled", "readOnly"]
    });
  }
  _initSelectionChangedAction() {
    this._selectionChangedAction = this._createActionByOption("onSelectionChanged", {
      excludeValidators: ["disabled", "readOnly"]
    });
  }
  _initItemClickAction() {
    this._itemClickAction = this._createActionByOption("onItemClick");
  }
  _initTemplates() {
    super._initTemplates(), this._templateManager.addDefaultTemplates({
      item: new T_("item")
    });
  }
  _isEditable() {
    const {
      searchEnabled: e
    } = this.option();
    return super._isEditable() || e;
  }
  _saveFocusOnWidget() {
    var e;
    (e = this._list) !== null && e !== void 0 && e.initialOption("focusStateEnabled") && this._focusInput();
  }
  _fitIntoRange(e, t, n) {
    return e > n ? t : e < t ? n : e;
  }
  _items() {
    const e = this._getPlainItems(!this._list && this._dataSource.items());
    return new un(e).filter("disabled", "<>", !0).toArray();
  }
  _calcNextItem(e) {
    const t = this._items(), n = this._fitIntoRange(this._getSelectedIndex() + e, 0, t.length - 1);
    return t[n];
  }
  _getSelectedIndex() {
    const e = this._items(), t = this.option("selectedItem");
    let n = -1;
    return y(e, (s, o) => {
      if (this._isValueEquals(o, t))
        return n = s, !1;
    }), n;
  }
  _createPopup() {
    super._createPopup(), this._updateCustomBoundaryContainer(), this._popup.$wrapper().addClass(this._popupWrapperClass());
    const e = this._popup.$content();
    _.off(e, "mouseup"), _.on(e, "mouseup", this._saveFocusOnWidget.bind(this));
  }
  _updateCustomBoundaryContainer() {
    const e = this.option("dropDownOptions.container"), t = e && p(e);
    if (t && t.length && !lt(t.get(0))) {
      const n = [].slice.call(t.parents());
      n.unshift(t.get(0)), y(n, (s, o) => {
        if (o === p("body").get(0))
          return !1;
        if (ww.getComputedStyle(o).overflowY === "hidden")
          return this._$customBoundaryContainer = p(o), !1;
      });
    }
  }
  _popupWrapperClass() {
    return "dx-dropdownlist-popup-wrapper";
  }
  _renderInputValue() {
    var e = this;
    let {
      value: t,
      renderOnly: n
    } = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    const s = t ?? this._getCurrentValue();
    return this._rejectValueLoading(), n ? super._renderInputValue(s) : this._loadInputValue(s, function() {
      e._setSelectedItem(...arguments);
    }).always(super._renderInputValue.bind(this, s));
  }
  _loadInputValue(e, t) {
    return this._loadItem(e).always(t);
  }
  _getItemFromPlain(e, t) {
    let n, s;
    return t && typeof e != "object" && (t.itemByValue || (t.itemByValue = {}, n = this._getPlainItems(), n.forEach(function(o) {
      t.itemByValue[this._valueGetter(o)] = o;
    }, this)), s = t.itemByValue[e]), s || (n = this._getPlainItems(), s = Wt(n, (o) => this._isValueEquals(this._valueGetter(o), e))[0]), s;
  }
  _resetInputText() {
    this._renderInputValue({
      renderOnly: !0
    });
  }
  _loadItem(e, t) {
    const n = this._getItemFromPlain(e, t);
    return n !== void 0 ? w().resolve(n).promise() : this._loadValue(e);
  }
  _getPlainItems(e) {
    let t = [];
    e = e || this.option("items") || this._dataSource.items() || [];
    for (let s = 0; s < e.length; s++) {
      var n;
      (n = e[s]) !== null && n !== void 0 && n.items ? t = t.concat(e[s].items) : t.push(e[s]);
    }
    return t;
  }
  _updateActiveDescendant(e) {
    var t;
    const n = this.option("opened"), s = (t = this._list) === null || t === void 0 ? void 0 : t.getFocusedItemId(), o = p(`#${s}`).length > 0, r = n && o && s;
    this.setAria({
      activedescendant: r || null
    }, e);
  }
  _setSelectedItem(e) {
    const t = this._displayValue(e);
    this.option("selectedItem", Qe(e, null)), this.option("displayValue", t);
  }
  _displayValue(e) {
    return this._displayGetter(e);
  }
  _refreshSelected() {
    const e = {};
    this._listItemElements().each((t, n) => {
      const s = p(n), o = this._valueGetter(s.data("dxListItemData"));
      this._isSelectedValue(o, e) ? this._list.selectItem(s) : this._list.unselectItem(s);
    });
  }
  _popupShownHandler() {
    super._popupShownHandler(), this._setFocusPolicy();
  }
  _setFocusPolicy() {
    !this.option("focusStateEnabled") || !this._list || this._list.option("focusedElement", null);
  }
  _isSelectedValue(e, t) {
    return this._isValueEquals(e, this.option("value"));
  }
  _validateSearchMode() {
    const e = this.option("searchMode"), t = e.toLowerCase();
    if (!c9.includes(t))
      throw _e.Error("E1019", e);
  }
  _clearSelectedItem() {
    this.option("selectedItem", null);
  }
  _processDataSourceChanging() {
    this._initDataController(), this._setListOption("_dataController", this._dataController), this._setListDataSource(), this._renderInputValue().fail(() => {
      this._isCustomValueAllowed() || this._clearSelectedItem();
    });
  }
  _isCustomValueAllowed() {
    return this.option("displayCustomValue");
  }
  clear() {
    super.clear(), this._clearFilter(), this._clearSelectedItem();
  }
  _listItemElements() {
    return this._$list ? this._$list.find(".dx-list-item") : p();
  }
  _popupConfig() {
    return I({}, super._popupConfig(), {
      templatesRenderAsynchronously: !1,
      autoResizeEnabled: !1,
      maxHeight: this._getMaxHeight.bind(this)
    });
  }
  _renderPopupContent() {
    super._renderPopupContent(), this._renderList();
  }
  _getKeyboardListeners() {
    const e = this._canListHaveFocus();
    return super._getKeyboardListeners().concat([!e && this._list]);
  }
  _renderList() {
    this._listId = `dx-${new Xe()._value}`;
    const e = p("<div>").attr("id", this._listId).appendTo(this._popup.$content());
    this._$list = e, this._list = this._createComponent(e, fa, this._listConfig()), this._refreshList(), this._renderPreventBlurOnListClick(), this._setListFocusedElementOptionChange();
  }
  _renderPreventBlurOnListClick() {
    const e = R("mousedown", "dxDropDownList");
    _.off(this._$list, e), _.on(this._$list, e, (t) => t.preventDefault());
  }
  _getControlsAria() {
    return this._list && this._listId;
  }
  _renderOpenedState() {
    super._renderOpenedState(), this._list && this._updateActiveDescendant(), this.setAria("owns", this._popup && this._popupContentId);
  }
  _getAriaHasPopup() {
    return "listbox";
  }
  _refreshList() {
    this._list && this._shouldRefreshDataSource() && this._setListDataSource();
  }
  _shouldRefreshDataSource() {
    return !!this._list.option("dataSource") !== this._needPassDataSourceToList();
  }
  _isDesktopDevice() {
    return z.real().deviceType === "desktop";
  }
  _listConfig() {
    const e = {
      selectionMode: "single",
      _templates: this.option("_templates"),
      templateProvider: this.option("templateProvider"),
      noDataText: this.option("noDataText"),
      encodeNoDataText: this.option("encodeNoDataText"),
      grouped: this.option("grouped"),
      wrapItemText: this.option("wrapItemText"),
      useItemTextAsTitle: this.option("useItemTextAsTitle"),
      onContentReady: this._listContentReadyHandler.bind(this),
      itemTemplate: this.option("itemTemplate"),
      indicateLoading: !1,
      keyExpr: this._getCollectionKeyExpr(),
      displayExpr: this._displayGetterExpr(),
      groupTemplate: this.option("groupTemplate"),
      onItemClick: this._listItemClickAction.bind(this),
      dataSource: this._getDataSource(),
      _dataController: this._dataController,
      hoverStateEnabled: this._isDesktopDevice() ? this.option("hoverStateEnabled") : !1,
      focusStateEnabled: this._isDesktopDevice() ? this.option("focusStateEnabled") : !1,
      _onItemsRendered: () => {
        this._popup.repaint();
      }
    };
    return this._canListHaveFocus() || (e.tabIndex = null), e;
  }
  _canListHaveFocus() {
    return !1;
  }
  _getDataSource() {
    return this._needPassDataSourceToList() ? this._dataSource : null;
  }
  _dataSourceOptions() {
    return {
      paginate: !1
    };
  }
  _getGroupedOption() {
    return this.option("grouped");
  }
  _dataSourceFromUrlLoadMode() {
    return "raw";
  }
  _listContentReadyHandler() {
    this._list = this._list || this._$list.dxList("instance"), this.option("deferRendering") || this._refreshSelected(), this._updatePopupWidth(), this._updateListDimensions(), this._contentReadyAction();
  }
  _setListOption(e, t) {
    this._setWidgetOption("_list", arguments);
  }
  _listItemClickAction(e) {
    this._listItemClickHandler(e), this._itemClickAction(e);
  }
  _listItemClickHandler(e) {
  }
  _setListDataSource() {
    this._list && (this._setListOption("dataSource", this._getDataSource()), this._needPassDataSourceToList() || this._setListOption("items", []));
  }
  _needPassDataSourceToList() {
    const {
      showDataBeforeSearch: e
    } = this.option();
    return e || this._isMinSearchLengthExceeded();
  }
  _isMinSearchLengthExceeded() {
    return this._searchValue().toString().length >= this.option("minSearchLength");
  }
  _needClearFilter() {
    return this._canKeepDataSource() ? !1 : this._needPassDataSourceToList();
  }
  _canKeepDataSource() {
    const e = this._isMinSearchLengthExceeded();
    return this._dataController.isLoaded() && this.option("showDataBeforeSearch") && this.option("minSearchLength") && !e && !this._isLastMinSearchLengthExceeded;
  }
  _searchValue() {
    return this._input().val() || "";
  }
  _getSearchEvent() {
    return R("input", `${this.NAME}Search`);
  }
  _getCompositionStartEvent() {
    return R("compositionstart", `${this.NAME}CompositionStart`);
  }
  _getCompositionEndEvent() {
    return R("compositionend", `${this.NAME}CompositionEnd`);
  }
  _getSetFocusPolicyEvent() {
    return R("input", `${this.NAME}FocusPolicy`);
  }
  _renderEvents() {
    super._renderEvents(), _.on(this._input(), this._getSetFocusPolicyEvent(), () => {
      this._setFocusPolicy();
    }), this._shouldRenderSearchEvent() && (_.on(this._input(), this._getSearchEvent(), (e) => {
      this._searchHandler(e);
    }), Sw && (_.on(this._input(), this._getCompositionStartEvent(), () => {
      this._isTextCompositionInProgress(!0);
    }), _.on(this._input(), this._getCompositionEndEvent(), (e) => {
      this._isTextCompositionInProgress(void 0), this._searchHandler(e, this._searchValue());
    })));
  }
  _shouldRenderSearchEvent() {
    return this.option("searchEnabled");
  }
  _refreshEvents() {
    _.off(this._input(), this._getSearchEvent()), _.off(this._input(), this._getSetFocusPolicyEvent()), Sw && (_.off(this._input(), this._getCompositionStartEvent()), _.off(this._input(), this._getCompositionEndEvent())), super._refreshEvents();
  }
  _isTextCompositionInProgress(e) {
    if (arguments.length)
      this._isTextComposition = e;
    else
      return this._isTextComposition;
  }
  _searchHandler(e, t) {
    if (this._isTextCompositionInProgress())
      return;
    if (!this._isMinSearchLengthExceeded()) {
      this._searchCanceled();
      return;
    }
    const {
      searchTimeout: n
    } = this.option();
    n ? (this._clearSearchTimer(), this._searchTimer = setTimeout(() => {
      this._searchDataSource(t);
    }, n)) : this._searchDataSource(t);
  }
  _searchCanceled() {
    this._clearSearchTimer(), this._needClearFilter() && this._filterDataSource(null), this._refreshList();
  }
  _searchDataSource() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : this._searchValue();
    this._filterDataSource(e);
  }
  _filterDataSource(e) {
    this._clearSearchTimer();
    const t = this._dataController;
    t.searchExpr(this.option("searchExpr") || this._displayGetterExpr()), t.searchOperation(this.option("searchMode")), t.searchValue(e), t.load().done(this._dataSourceFiltered.bind(this, e));
  }
  _clearFilter() {
    const e = this._dataController;
    e.searchValue() && e.searchValue(null);
  }
  _dataSourceFiltered(e) {
    this._isLastMinSearchLengthExceeded = this._isMinSearchLengthExceeded(), this._refreshList(), this._refreshPopupVisibility();
  }
  _shouldOpenPopup() {
    return this._hasItemsToShow();
  }
  _refreshPopupVisibility() {
    if (this.option("readOnly") || !this._searchValue())
      return;
    const e = this._shouldOpenPopup();
    e && !this._isFocused() || (this.option("opened", e), e && (this._updatePopupWidth(), this._updateListDimensions()));
  }
  _dataSourceChangedHandler(e) {
    this._dataController.pageIndex() === 0 ? this.option().items = e : this.option().items = this.option().items.concat(e);
  }
  _hasItemsToShow() {
    const n = (this._dataController.items() || []).length;
    return !!(this._needPassDataSourceToList() && n);
  }
  _clearSearchTimer() {
    clearTimeout(this._searchTimer), delete this._searchTimer;
  }
  _popupShowingHandler() {
    this._updatePopupWidth(), this._updateListDimensions();
  }
  _dimensionChanged() {
    super._dimensionChanged(), this._updateListDimensions();
  }
  _needPopupRepaint() {
    const e = this._dataController, t = e.pageIndex(), n = f(this._pageIndex) && t <= this._pageIndex || e.isLastPage() && !this._list._scrollViewIsFull();
    return this._pageIndex = t, n;
  }
  _updateListDimensions() {
    this._popup && (this._needPopupRepaint() && this._popup.repaint(), this._list && this._list.updateDimensions());
  }
  _getMaxHeight() {
    const e = this.$element(), t = this._$customBoundaryContainer, n = e.offset().top - (t ? t.offset().top : 0), s = he(ww), o = t ? Math.min(he(t), s) : s, r = Math.max(n, o - n - he(e));
    return Math.min(0.5 * o, r);
  }
  _clean() {
    this._list && delete this._list, delete this._isLastMinSearchLengthExceeded, super._clean();
  }
  _dispose() {
    this._clearSearchTimer(), super._dispose();
  }
  _setCollectionWidgetOption() {
    this._setListOption.apply(this, arguments);
  }
  _setSubmitValue() {
    const e = this.option("value"), t = this._shouldUseDisplayValue(e) ? this._displayGetter(e) : e;
    this._getSubmitElement().val(t);
  }
  _shouldUseDisplayValue(e) {
    return this.option("valueExpr") === "this" && X(e);
  }
  _optionChanged(e) {
    switch (this._dataExpressionOptionChanged(e), e.name) {
      case "hoverStateEnabled":
      case "focusStateEnabled":
        this._isDesktopDevice() && this._setListOption(e.name, e.value), super._optionChanged(e);
        break;
      case "items":
        this.option("dataSource") || this._processDataSourceChanging();
        break;
      case "dataSource":
        this._processDataSourceChanging();
        break;
      case "valueExpr":
        this._renderValue(), this._setListOption("keyExpr", this._getCollectionKeyExpr());
        break;
      case "displayExpr":
        this._renderValue(), this._setListOption("displayExpr", this._displayGetterExpr());
        break;
      case "searchMode":
        this._validateSearchMode();
        break;
      case "minSearchLength":
        this._refreshList();
        break;
      case "searchEnabled":
      case "showDataBeforeSearch":
      case "searchExpr":
        this._invalidate();
        break;
      case "onContentReady":
        this._initContentReadyAction();
        break;
      case "onSelectionChanged":
        this._initSelectionChangedAction();
        break;
      case "onItemClick":
        this._initItemClickAction();
        break;
      case "grouped":
      case "groupTemplate":
      case "wrapItemText":
      case "noDataText":
      case "encodeNoDataText":
      case "useItemTextAsTitle":
        this._setListOption(e.name);
        break;
      case "displayValue":
        this.option("text", e.value);
        break;
      case "itemTemplate":
      case "searchTimeout":
        break;
      case "selectedItem":
        e.previousValue !== e.value && this._selectionChangedAction({
          selectedItem: e.value
        });
        break;
      default:
        super._optionChanged(e);
    }
  }
}
gC.include(hC, iA);
xe("dxDropDownList", gC);
let mC = class extends gC {
  _supportedKeys() {
    const e = this, t = super._supportedKeys(), n = function(o) {
      this._isEditable() ? this._valueSubstituted() && (this._preventFiltering = !0) : this.option("showClearButton") && (o.preventDefault(), this.clear()), this._savedTextRemoveEvent = o, this._preventSubstitution = !0;
    }, s = function() {
      e.option("searchEnabled") && e._valueSubstituted() && e._searchHandler();
    };
    return I({}, t, {
      tab() {
        const {
          opened: o
        } = this.option(), r = o && !!this._popup.getFocusableElements().length;
        r || this._resetCaretPosition(!0), t.tab && t.tab.apply(this, arguments), r || this._cancelSearchIfNeed();
      },
      upArrow(o) {
        if (t.upArrow.apply(this, arguments))
          return this.option("opened") || this._setNextValue(o), !0;
      },
      downArrow(o) {
        if (t.downArrow.apply(this, arguments))
          return this.option("opened") || this._setNextValue(o), !0;
      },
      leftArrow() {
        var o;
        s(), (o = t.leftArrow) === null || o === void 0 || o.apply(this, arguments);
      },
      rightArrow() {
        var o;
        s(), (o = t.rightArrow) === null || o === void 0 || o.apply(this, arguments);
      },
      home() {
        var o;
        s(), (o = t.home) === null || o === void 0 || o.apply(this, arguments);
      },
      end() {
        var o;
        s(), (o = t.end) === null || o === void 0 || o.apply(this, arguments);
      },
      escape() {
        var o;
        const r = (o = t.escape) === null || o === void 0 ? void 0 : o.apply(this, arguments);
        return this._cancelEditing(), r ?? !0;
      },
      enter(o) {
        const r = this.option("opened"), a = this._input().val().trim(), l = a && this._list && !this._list.option("focusedElement");
        if (!a && f(this.option("value")) && this.option("allowClearing"))
          this._saveValueChangeEvent(o), this.option({
            selectedItem: null,
            value: null
          }), this.close();
        else {
          var d;
          if (this.option("acceptCustomValue"))
            return o.preventDefault(), l && (r && this._toggleOpenState(), this._valueChangeEventHandler(o)), r;
          if ((d = t.enter) !== null && d !== void 0 && d.apply(this, arguments))
            return r;
        }
      },
      space(o) {
        const r = this.option("opened"), a = this.option("searchEnabled"), l = this.option("acceptCustomValue");
        if (!(!r || a || l))
          return o.preventDefault(), this._valueChangeEventHandler(o), !0;
      },
      backspace: n,
      del: n
    });
  }
  _getDefaultOptions() {
    return I({}, super._getDefaultOptions(), {
      placeholder: S.format("Select"),
      fieldTemplate: null,
      customItemCreateEvent: "change",
      valueChangeEvent: "change",
      acceptCustomValue: !1,
      onCustomItemCreating(e) {
        f(e.customItem) || (e.customItem = e.text);
      },
      showSelectionControls: !1,
      allowClearing: !0,
      tooltipEnabled: !1,
      openOnFieldClick: !0,
      showDropDownButton: !0,
      displayCustomValue: !1,
      useHiddenSubmitElement: !0
    });
  }
  _init() {
    super._init(), this._initCustomItemCreatingAction();
  }
  _initMarkup() {
    this.$element().addClass("dx-selectbox"), this._renderTooltip(), super._initMarkup(), this._$container.addClass("dx-selectbox-container");
  }
  _createPopup() {
    var e, t;
    super._createPopup(), (e = this._popup) === null || e === void 0 || e.$element().addClass("dx-selectbox-popup"), (t = this._popup) === null || t === void 0 || t.$overlayContent().attr("tabindex", -1);
  }
  _popupWrapperClass() {
    return `${super._popupWrapperClass()} dx-selectbox-popup-wrapper`;
  }
  _setDeprecatedOptions() {
    super._setDeprecatedOptions(), x(this._deprecatedOptions, {
      valueChangeEvent: {
        since: "22.2",
        alias: "customItemCreateEvent"
      }
    });
  }
  _cancelEditing() {
    !this.option("searchEnabled") && this._list && (this._focusListElement(null), this._updateField(this.option("selectedItem")));
  }
  _renderOpenedState() {
    super._renderOpenedState(), this.option("opened") && (this._scrollToSelectedItem(), this._focusSelectedElement());
  }
  _focusSelectedElement() {
    if (!this._searchValue()) {
      this._focusListElement(null);
      return;
    }
    const {
      items: t,
      selectedItem: n
    } = this.option(), s = this._list._itemElements(), o = t?.indexOf(n) ?? -1, r = o !== -1 && !this._isCustomItemSelected() ? s.eq(o) : null;
    this._focusListElement(r);
  }
  _renderFocusedElement() {
    if (!this._list)
      return;
    if (!this._searchValue() || this.option("acceptCustomValue")) {
      this._focusListElement(null);
      return;
    }
    const n = this._list._itemElements().not(".dx-state-disabled").eq(0);
    this._focusListElement(n);
  }
  _focusListElement(e) {
    this._preventInputValueRender = !0, this._list.option("focusedElement", ee(e)), delete this._preventInputValueRender;
  }
  _scrollToSelectedItem() {
    var e;
    (e = this._list) === null || e === void 0 || e.scrollToItem(this._list.option("selectedItem"));
  }
  _listContentReadyHandler() {
    super._listContentReadyHandler(), !(this._dataController.paginate() && this._needPopupRepaint()) && this._scrollToSelectedItem();
  }
  _renderValue() {
    return this._renderInputValue(), this._setSubmitValue(), w().resolve();
  }
  _renderInputValue() {
    return super._renderInputValue(...arguments).always(() => {
      this._renderInputValueAsync();
    });
  }
  _renderInputValueAsync() {
    this._renderTooltip(), this._renderInputValueImpl().always(() => {
      this._refreshSelected();
    });
  }
  _renderInputValueImpl() {
    return this._renderField(), w().resolve();
  }
  _setNextItem(e) {
    const t = this._calcNextItem(e), n = this._valueGetter(t);
    this._setValue(n);
  }
  _setNextValue(e) {
    (this._dataController.isLoaded() ? w().resolve() : this._dataController.load()).done(() => {
      const n = this._getSelectedIndex(), s = this._dataController.pageSize(), o = this._dataController.isLastPage(), r = n === this._items().length - 1;
      this._saveValueChangeEvent(e);
      const a = Ye(e) === "downArrow" ? 1 : -1;
      s && !o && r && a > 0 ? (this._popup || this._createPopup(), this._dataController.isLoading() || this._list._loadNextPage().done(this._setNextItem.bind(this, a))) : this._setNextItem(a);
    });
  }
  _setSelectedItem(e) {
    const t = !this._isCustomValueAllowed() && e === void 0;
    super._setSelectedItem(t ? null : e), !t && (!this._isEditable() || this._isCustomItemSelected()) && this._setListOption("selectedItem", this.option("selectedItem"));
  }
  _isCustomValueAllowed() {
    return this.option("acceptCustomValue") || super._isCustomValueAllowed();
  }
  _displayValue(e) {
    return e = !f(e) && this._isCustomValueAllowed() ? this.option("value") : e, super._displayValue(e);
  }
  _listConfig() {
    const e = x(super._listConfig(), {
      pageLoadMode: "scrollBottom",
      onSelectionChanged: this._getSelectionChangeHandler(),
      selectedItem: this.option("selectedItem"),
      onFocusedItemChanged: this._listFocusedItemChangeHandler.bind(this),
      _onItemsRendered: () => {
        this._popup.repaint(), this.option("opened") && this._scrollToSelectedItem();
      }
    });
    return this.option("showSelectionControls") && x(e, {
      showSelectionControls: !0,
      selectByClick: !0
    }), e;
  }
  _listFocusedItemChangeHandler(e) {
    if (this._preventInputValueRender)
      return;
    const t = e.component, n = p(t.option("focusedElement")), s = t._getItemData(n);
    this._updateField(s);
  }
  _updateField(e) {
    if (!(this._getTemplateByOption("fieldTemplate") && this.option("fieldTemplate"))) {
      const n = this._displayGetter(e);
      this.option("text", n), this._renderDisplayText(n);
      return;
    }
    this._renderField();
  }
  _getSelectionChangeHandler() {
    return this.option("showSelectionControls") ? this._selectionChangeHandler.bind(this) : M;
  }
  _selectionChangeHandler(e) {
    y(e.addedItems || [], (t, n) => {
      this._setValue(this._valueGetter(n));
    });
  }
  _getActualSearchValue() {
    return this._dataController.searchValue();
  }
  _isInlineAutocompleteEnabled() {
    const {
      searchEnabled: e,
      acceptCustomValue: t,
      searchMode: n
    } = this.option();
    return e && !t && n === "startswith";
  }
  _getAriaAutocomplete() {
    const {
      disabled: e,
      readOnly: t,
      searchEnabled: n
    } = this.option();
    return n && !(t || e) ? this._isInlineAutocompleteEnabled() ? "both" : "list" : "none";
  }
  _toggleOpenState(e) {
    if (!this.option("disabled")) {
      if (e = arguments.length ? e : !this.option("opened"), !e && !this._shouldClearFilter() && this._restoreInputText(!0), this._wasSearch() && e)
        if (this._wasSearch(!1), (this.option("showDataBeforeSearch") || this._isMinSearchLengthExceeded()) && this._dataController.getDataSource()) {
          if (this._searchTimer)
            return;
          const n = this._getActualSearchValue();
          n && this._wasSearch(!0), this._filterDataSource(n || null);
        } else
          this._setListOption("items", []);
      e && this._scrollToSelectedItem(), super._toggleOpenState(e);
    }
  }
  _renderTooltip() {
    const {
      tooltipEnabled: e,
      displayValue: t
    } = this.option();
    e && this.$element().attr("title", t);
  }
  _renderDimensions() {
    super._renderDimensions(), this._updatePopupWidth(), this._updateListDimensions();
  }
  _isValueEqualInputText() {
    const e = this.option("selectedItem");
    if (e === null)
      return !1;
    const t = this._displayGetter(e), n = t ? String(t) : "", s = this._searchValue();
    return n === s;
  }
  _popupHidingHandler() {
    this._isValueEqualInputText() && this._cancelEditing(), super._popupHidingHandler();
  }
  _popupHiddenHandler() {
    super._popupHiddenHandler(), this._shouldCancelSearch() && (this._wasSearch(!1), this._searchCanceled(), this._shouldCancelSearch(!1));
  }
  _restoreInputText(e) {
    var t;
    this.option("readOnly") || (t = this._loadItemDeferred) === null || t === void 0 || t.always(() => {
      const {
        acceptCustomValue: n,
        text: s,
        selectedItem: o,
        customItemCreateEvent: r
      } = this.option();
      if (n) {
        if (!e && !this._isValueChanging) {
          let a = null;
          f(o) ? a = o : r !== "" && (a = this._createCustomItem(s)), this._updateField(a), this._clearFilter();
        }
        return;
      }
      if (this.option("searchEnabled") && !this._searchValue() && this.option("allowClearing")) {
        this._clearTextValue();
        return;
      }
      this._isValueEqualInputText() || this._renderInputValue().always((a) => {
        const l = Qe(a, o);
        this._setSelectedItem(l), this._updateField(l), this._clearFilter();
      });
    });
  }
  _valueChangeEventIncludesBlur() {
    return this.option(this._getValueChangeEventOptionName()).includes("blur");
  }
  _isPreventedFocusOutEvent(e) {
    return this._preventNestedFocusEvent(e) || this._valueChangeEventIncludesBlur();
  }
  _focusOutHandler(e) {
    this._isPreventedFocusOutEvent(e) || (this._isOverlayNestedTarget(e.relatedTarget) || (this._restoreInputText(), this._clearSearchTimer()), this._cancelSearchIfNeed(e)), e.target = this._input().get(0), super._focusOutHandler(e);
  }
  _cancelSearchIfNeed(e) {
    const {
      searchEnabled: t
    } = this.option(), n = this._isOverlayNestedTarget(e?.relatedTarget);
    if (this._wasSearch() && t && !n) {
      var o;
      const r = (o = this._popup) === null || o === void 0 ? void 0 : o._hideAnimationProcessing;
      this._clearSearchTimer(), r ? this._shouldCancelSearch(!0) : (this._wasSearch(!1), this._searchCanceled());
    }
  }
  _shouldCancelSearch(e) {
    if (!arguments.length)
      return this._shouldCancelSearchValue;
    this._shouldCancelSearchValue = e;
  }
  _isOverlayNestedTarget(e) {
    return !!p(e).closest(".dx-selectbox-popup-wrapper").length;
  }
  _clearTextValue() {
    const e = this.option("selectedItem"), t = this._displayGetter(e);
    e && t !== "" && (this._savedTextRemoveEvent && this._saveValueChangeEvent(this._savedTextRemoveEvent), this.option("value", null)), delete this._savedTextRemoveEvent;
  }
  _shouldOpenPopup() {
    return this._needPassDataSourceToList() && this._wasSearch();
  }
  _isFocused() {
    const e = O.getActiveElement(this.element());
    return super._isFocused() && p(e).closest(this._input()).length > 0;
  }
  _getValueChangeEventOptionName() {
    return "customItemCreateEvent";
  }
  _renderValueChangeEvent() {
    this._isEditable() && super._renderValueChangeEvent();
  }
  _fieldRenderData() {
    const {
      focusedElement: e
    } = this.option(), t = this._list && this.option("opened") && p(e);
    return t != null && t.length ? this._list._getItemData(t) : this.option("selectedItem");
  }
  _isSelectedValue(e, t) {
    return this._isValueEquals(e, this.option("value"));
  }
  _shouldCloseOnItemClick() {
    const {
      selectionMode: e
    } = this.option();
    return !(this.option("showSelectionControls") && e !== "single");
  }
  _listItemClickHandler(e) {
    const t = this._getCurrentValue();
    this._focusListElement(p(e.itemElement)), this._saveValueChangeEvent(e.event), this._completeSelection(this._valueGetter(e.itemData)), this._shouldCloseOnItemClick() && this.option("opened", !1), this.option("searchEnabled") && t === this._valueGetter(e.itemData) && this._updateField(e.itemData), this._shouldClearFilter() && this._cancelSearchIfNeed();
  }
  _shouldClearFilter() {
    return this._wasSearch();
  }
  _completeSelection(e) {
    this._setValue(e);
  }
  _loadItem(e, t) {
    const n = this, s = w();
    return super._loadItem(e, t).done((o) => {
      s.resolve(o);
    }).fail((o) => {
      if (o != null && o.shouldSkipCallback)
        return;
      const r = n.option("selectedItem");
      n.option("acceptCustomValue") && e === n._valueGetter(r) ? s.resolve(r) : s.reject();
    }), s.promise();
  }
  _loadInputValue(e, t) {
    return this._loadItemDeferred = this._loadItem(e).always(t), this._loadItemDeferred;
  }
  _isCustomItemSelected() {
    const e = this.option("selectedItem"), t = this._searchValue(), n = this._displayGetter(e);
    return !n || t !== n.toString();
  }
  _valueChangeEventHandler(e) {
    this.option("acceptCustomValue") && this._isCustomItemSelected() && !this._isValueChanging && (this._isValueChanging = !0, this._customItemAddedHandler(e));
  }
  _initCustomItemCreatingAction() {
    this._customItemCreatingAction = this._createActionByOption("onCustomItemCreating");
  }
  _createCustomItem(e) {
    const t = {
      text: e
    }, n = this._customItemCreatingAction(t), s = Qe(n, t.customItem);
    return f(n) && Ae.log("W0015", "onCustomItemCreating", "customItem"), s;
  }
  _customItemAddedHandler(e) {
    const t = this._searchValue(), n = this._createCustomItem(t);
    if (this._saveValueChangeEvent(e), n === void 0)
      throw this._renderValue(), Ae.Error("E0121");
    no(n) ? It(n).done(this._setCustomItem.bind(this)).fail(this._setCustomItem.bind(this, null)) : this._setCustomItem(n);
  }
  _setCustomItem(e) {
    this._disposed || (e = e || null, this.option("selectedItem", e), this._cancelSearchIfNeed(), this._setValue(this._valueGetter(e)), this._renderDisplayText(this._displayGetter(e)), this._isValueChanging = !1);
  }
  _clearValueHandler(e) {
    return this._preventFiltering = !0, super._clearValueHandler(e), this._searchCanceled(), !1;
  }
  _wasSearch(e) {
    if (!arguments.length)
      return !!this._wasSearchValue;
    this._wasSearchValue = e;
  }
  _searchHandler(e) {
    if (this._preventFiltering) {
      delete this._preventFiltering;
      return;
    }
    this._needPassDataSourceToList() && this._wasSearch(!0), super._searchHandler(arguments);
  }
  _dataSourceFiltered(e) {
    super._dataSourceFiltered(), e !== null && (this._renderInputSubstitution(), this._renderFocusedElement());
  }
  _valueSubstituted() {
    const e = this._input().get(0), t = this._searchValue().length, n = e.selectionStart === 0 && e.selectionEnd === t, s = e.selectionStart !== e.selectionEnd, o = t === e.selectionEnd;
    return this._wasSearch() && s && !n && o && this._shouldSubstitutionBeRendered();
  }
  _shouldSubstitutionBeRendered() {
    return !this._preventSubstitution && this._isInlineAutocompleteEnabled();
  }
  _renderInputSubstitution() {
    if (!this._shouldSubstitutionBeRendered()) {
      delete this._preventSubstitution;
      return;
    }
    const e = this._list && this._getPlainItems(this._list.option("items"))[0];
    if (!e)
      return;
    const t = this._input(), n = t.val().length;
    if (n === 0)
      return;
    const s = t.get(0), o = this._displayGetter(e).toString();
    s.value = o, this._caret({
      start: n,
      end: o.length
    });
  }
  _dispose() {
    this._renderInputValueAsync = M, delete this._loadItemDeferred, super._dispose();
  }
  _optionChanged(e) {
    switch (e.name) {
      case "customItemCreateEvent":
        this._refreshValueChangeEvent(), this._refreshFocusEvent(), this._refreshEvents();
        break;
      case "onCustomItemCreating":
        this._initCustomItemCreatingAction();
        break;
      case "tooltipEnabled":
        this._renderTooltip();
        break;
      case "readOnly":
      case "disabled":
      case "searchMode":
        super._optionChanged(e), this._setDefaultAria();
        break;
      case "displayCustomValue":
      case "acceptCustomValue":
      case "showSelectionControls":
        this._invalidate();
        break;
      case "allowClearing":
        break;
      default:
        super._optionChanged(e);
    }
  }
};
xe("dxSelectBox", mC);
const RA = "dxSwipeable", h9 = {
  onStart: ZO,
  onUpdated: QO,
  onEnd: iC,
  onCancel: "dxswipecancel"
};
class Ic extends ui {
  _getDefaultOptions() {
    return I({}, super._getDefaultOptions(), {
      elastic: !0,
      immediate: !1,
      immediateTimeout: 180,
      direction: "horizontal",
      itemSizeFunc: null,
      onStart: null,
      onUpdated: null,
      onEnd: null,
      onCancel: null
    });
  }
  _render() {
    super._render(), this.$element().addClass("dx-swipeable"), this._attachEventHandlers();
  }
  _attachEventHandlers() {
    if (this._detachEventHandlers(), this.option("disabled"))
      return;
    const {
      NAME: e
    } = this;
    this._createEventData(), y(h9, (t, n) => {
      const s = this._createActionByOption(t, {
        context: this
      });
      n = R(n, e), _.on(this.$element(), n, this._eventData, (o) => s({
        event: o
      }));
    });
  }
  _createEventData() {
    this._eventData = {
      elastic: this.option("elastic"),
      itemSizeFunc: this.option("itemSizeFunc"),
      direction: this.option("direction"),
      immediate: this.option("immediate"),
      immediateTimeout: this.option("immediateTimeout")
    };
  }
  _detachEventHandlers() {
    _.off(this.$element(), `.${RA}`);
  }
  _optionChanged(e) {
    switch (e.name) {
      case "disabled":
      case "onStart":
      case "onUpdated":
      case "onEnd":
      case "onCancel":
      case "elastic":
      case "immediate":
      case "itemSizeFunc":
      case "direction":
        this._detachEventHandlers(), this._attachEventHandlers();
        break;
      case "rtlEnabled":
        break;
      default:
        super._optionChanged(e);
    }
  }
  _useTemplates() {
    return !1;
  }
}
Wl(Ic, RA);
class fC {
  constructor(e) {
    this.calendar = e;
  }
  dateOption(e) {
    return this.calendar._dateOption(e);
  }
  dateValue(e, t) {
    this.calendar._dateValue(e, t);
  }
  skipNavigate() {
    this.calendar._skipNavigate = !0;
  }
  updateAriaSelected(e, t) {
    this.calendar._updateAriaSelected(e, t), e[0] && this.calendar.option("currentDate").getTime() === e[0].getTime() && this.calendar._updateAriaId(e[0]);
  }
  processValueChanged(e, t) {
    var n, s;
    f(e) && !Array.isArray(e) && (e = [e]), f(t) && !Array.isArray(t) && (t = [t]), e = ((n = e) === null || n === void 0 ? void 0 : n.map((o) => this._convertToDate(o))) || [], t = ((s = t) === null || s === void 0 ? void 0 : s.map((o) => this._convertToDate(o))) || [], this._updateViewsValue(e), this.updateAriaSelected(e, t), this._currentDateChanged || this.calendar._initCurrentDate(), this._currentDateChanged = !1;
  }
  _isDateDisabled(e) {
    const t = this.calendar._dateOption("min"), n = this.calendar._dateOption("max"), s = f(t) && e < t && !j.sameDate(t, e), o = f(n) && e > n && !j.sameDate(n, e);
    return this.calendar._view.isDateDisabled(e) || s || o;
  }
  _getLowestDateInArray(e) {
    if (e.length)
      return new Date(Math.min(...e));
  }
  _convertToDate(e) {
    return this.calendar._convertToDate(e);
  }
  _isMaxZoomLevel() {
    return this.calendar._isMaxZoomLevel();
  }
  _updateViewsOption(e, t) {
    this.calendar._updateViewsOption(e, t);
  }
  _updateViewsValue(e) {
    this._updateViewsOption("value", e);
  }
  _updateCurrentDate(e) {
    this.calendar.option("currentDate", e ?? /* @__PURE__ */ new Date());
  }
  _shouldHandleWeekNumberClick() {
    const {
      selectionMode: e,
      selectWeekOnClick: t
    } = this.calendar.option();
    return t && e !== "single";
  }
}
class p9 extends fC {
  constructor(e) {
    super(e), this.NAME = "MultiSelection";
  }
  getViewOptions() {
    return {
      value: this.dateOption("value"),
      range: [],
      selectionMode: "multiple",
      onWeekNumberClick: this._shouldHandleWeekNumberClick() ? this._weekNumberClickHandler.bind(this) : null
    };
  }
  selectValue(e, t) {
    const n = [...this.dateOption("value")], s = n.findIndex((o) => o?.toDateString() === e.toDateString());
    s > -1 ? n.splice(s, 1) : n.push(e), this.skipNavigate(), this._updateCurrentDate(e), this._currentDateChanged = !0, this.dateValue(n, t);
  }
  updateAriaSelected(e, t) {
    e ?? (e = this.dateOption("value")), t ?? (t = []), super.updateAriaSelected(e, t);
  }
  getDefaultCurrentDate() {
    const e = this.dateOption("value").filter(Boolean);
    return this._getLowestDateInArray(e);
  }
  restoreValue() {
    this.calendar.option("value", []);
  }
  _weekNumberClickHandler(e) {
    let {
      rowDates: t,
      event: n
    } = e;
    const s = t.filter((o) => !this._isDateDisabled(o));
    this.dateValue(s, n);
  }
}
class g9 extends Rt {
  _getDefaultOptions() {
    return I({}, super._getDefaultOptions(), {
      onClick: void 0,
      onCaptionClick: void 0,
      type: "normal",
      stylingMode: "outlined",
      text: ""
    });
  }
  _defaultOptionsRules() {
    return super._defaultOptionsRules().concat([{
      device: () => Zt(),
      options: {
        type: "default",
        stylingMode: "text"
      }
    }, {
      device: () => nn(),
      options: {
        type: "normal",
        stylingMode: "text"
      }
    }]);
  }
  _init() {
    super._init(), this._initActions();
  }
  _initActions() {
    this._clickAction = this._createActionByOption("onClick"), this._captionClickAction = this._createActionByOption("onCaptionClick");
  }
  _initMarkup() {
    super._initMarkup(), p(this.element()).addClass("dx-calendar-navigator"), this._renderButtons(), this._renderCaption();
  }
  _renderButtons() {
    const {
      rtlEnabled: e,
      type: t,
      stylingMode: n,
      focusStateEnabled: s
    } = this.option();
    this._prevButton = this._createComponent(p("<div>"), wt, {
      focusStateEnabled: s,
      icon: e ? "chevronright" : "chevronleft",
      onClick: (l) => {
        var d;
        (d = this._clickAction) === null || d === void 0 || d.call(this, {
          direction: -1,
          event: l
        });
      },
      type: t,
      stylingMode: n,
      integrationOptions: {}
    });
    const o = p(this._prevButton.element()).addClass("dx-calendar-navigator-previous-view").addClass("dx-calendar-navigator-previous-month");
    this._nextButton = this._createComponent(p("<div>"), wt, {
      focusStateEnabled: s,
      icon: e ? "chevronleft" : "chevronright",
      onClick: (l) => {
        var d;
        (d = this._clickAction) === null || d === void 0 || d.call(this, {
          direction: 1,
          event: l
        });
      },
      type: t,
      stylingMode: n,
      integrationOptions: {}
    });
    const r = p(this._nextButton.element()).addClass("dx-calendar-navigator-next-view").addClass("dx-calendar-navigator-next-month");
    this._caption = this._createComponent(p("<div>").addClass("dx-calendar-caption-button"), wt, {
      focusStateEnabled: s,
      onClick: (l) => {
        var d;
        (d = this._captionClickAction) === null || d === void 0 || d.call(this, {
          event: l
        });
      },
      type: t,
      stylingMode: n,
      template: (l, d) => {
        const {
          text: u
        } = this.option();
        u.split(" - ").forEach((h) => {
          p(d).append(p("<span>").addClass("dx-button-text").text(h));
        });
      },
      integrationOptions: {}
    });
    const a = this._caption.$element();
    this.$element().append(o).append(a).append(r);
  }
  _renderCaption() {
    var e;
    const {
      text: t
    } = this.option();
    (e = this._caption) === null || e === void 0 || e.option("text", t);
  }
  toggleButton(e, t) {
    const n = `_${e}Button`, s = this[n];
    s && (s.option("disabled", t), s.$element().toggleClass("dx-calendar-disabled-navigator-link", t));
  }
  _optionChanged(e) {
    e.name === "text" ? this._renderCaption() : super._optionChanged(e);
  }
}
class m9 extends fC {
  constructor(e) {
    super(e), this.NAME = "RangeSelection";
  }
  getViewOptions() {
    const e = this._getValue(), t = this._getDaysInRange(e[0], e[1]);
    return {
      value: e,
      range: t,
      selectionMode: "range",
      onCellHover: this._cellHoverHandler.bind(this),
      onWeekNumberClick: this._shouldHandleWeekNumberClick() ? this._weekNumberClickHandler.bind(this) : null
    };
  }
  selectValue(e, t) {
    const [n, s] = this._getValue();
    this.skipNavigate(), this._updateCurrentDate(e), this._currentDateChanged = !0, this.calendar.option("_allowChangeSelectionOrder") === !0 ? (this.calendar._valueSelected = !0, this.calendar.option("_currentSelection") === "startDate" ? this.calendar._convertToDate(e) > this.calendar._convertToDate(s) ? this.dateValue([e, null], t) : this.dateValue([e, s], t) : this.calendar._convertToDate(e) >= this.calendar._convertToDate(n) ? this.dateValue([n, e], t) : this.dateValue([e, null], t)) : !n || s ? this.dateValue([e, null], t) : this.dateValue(n < e ? [n, e] : [e, n], t);
  }
  updateAriaSelected(e, t) {
    e ?? (e = this._getValue()), t ?? (t = []), super.updateAriaSelected(e, t);
  }
  processValueChanged(e, t) {
    super.processValueChanged(e, t);
    const n = this._getRange();
    this._updateViewsOption("range", n);
  }
  getDefaultCurrentDate() {
    const {
      _allowChangeSelectionOrder: e,
      _currentSelection: t
    } = this.calendar.option(), n = this.dateOption("value");
    if (e) {
      if (t === "startDate" && n[0])
        return n[0];
      if (t === "endDate" && n[1])
        return n[1];
    }
    const s = n.filter((o) => o);
    return this._getLowestDateInArray(s);
  }
  restoreValue() {
    this.calendar.option("value", [null, null]);
  }
  _getValue() {
    const e = this.dateOption("value");
    if (!e.length)
      return e;
    let [t, n] = e;
    return t && n && t > n && ([t, n] = [n, t]), [t, n];
  }
  _getRange() {
    const [e, t] = this._getValue();
    return this._getDaysInRange(e, t);
  }
  _getDaysInRange(e, t) {
    if (!e || !t)
      return [];
    const {
      currentDate: n,
      viewsCount: s
    } = this.calendar.option(), o = this.calendar._isAdditionalViewDate(n), r = j.getFirstMonthDate(n, o ? -2 : -1), a = j.getLastMonthDate(n, o ? 1 : s), l = new Date(Math.max(r, e)), d = new Date(Math.min(a, t));
    return [...j.getDatesOfInterval(l, d, 864e5), d];
  }
  _cellHoverHandler(e) {
    const t = this._isMaxZoomLevel(), [n, s] = this._getValue(), {
      _allowChangeSelectionOrder: o,
      _currentSelection: r
    } = this.calendar.option();
    if (t) {
      if (n && !s && !(o && r === "startDate")) {
        if (e.value > n) {
          this._updateViewsOption("hoveredRange", this._getDaysInRange(n, e.value));
          return;
        }
      } else if (!n && s && !(o && r === "endDate")) {
        if (e.value < s) {
          this._updateViewsOption("hoveredRange", this._getDaysInRange(e.value, s));
          return;
        }
      } else if (n && s) {
        if (r === "startDate" && e.value < n) {
          this._updateViewsOption("hoveredRange", this._getDaysInRange(e.value, n));
          return;
        }
        if (r === "endDate" && e.value > s) {
          this._updateViewsOption("hoveredRange", this._getDaysInRange(s, e.value));
          return;
        }
      }
      this._updateViewsOption("hoveredRange", []);
    }
  }
  _weekNumberClickHandler(e) {
    let {
      rowDates: t,
      event: n
    } = e;
    const s = t.filter((r) => !this._isDateDisabled(r)), o = s.length ? [s[0], s[s.length - 1]] : [null, null];
    this.dateValue(o, n);
  }
}
class f9 extends fC {
  constructor(e) {
    super(e), this.NAME = "SingleSelection";
  }
  getViewOptions() {
    return {
      value: this.dateOption("value"),
      range: [],
      selectionMode: "single"
    };
  }
  selectValue(e, t) {
    this.skipNavigate(), this.dateValue(e, t);
  }
  updateAriaSelected(e, t) {
    e ?? (e = [this.dateOption("value")]), t ?? (t = []), super.updateAriaSelected(e, t);
  }
  getDefaultCurrentDate() {
    const e = this.dateOption("value");
    return e === "" ? /* @__PURE__ */ new Date() : e;
  }
  restoreValue() {
    this.calendar.option("value", null);
  }
  _updateViewsValue(e) {
    this._updateViewsOption("value", e[0]);
  }
}
const Ew = "td:not(.dx-calendar-week-number-cell)", zp = R(Te, "dxCalendar"), Iw = R(rd, "dxCalendar"), _9 = {
  month: S.format("dxCalendar-currentDay"),
  year: S.format("dxCalendar-currentMonth"),
  decade: S.format("dxCalendar-currentYear"),
  century: S.format("dxCalendar-currentYearRange")
}, _o = {
  single: "single",
  multiple: "multiple",
  range: "range"
};
class xh extends Rt {
  _getViewName() {
    return "base";
  }
  _getDefaultOptions() {
    return I({}, super._getDefaultOptions(), {
      date: /* @__PURE__ */ new Date(),
      focusStateEnabled: !1,
      cellTemplate: null,
      disabledDates: null,
      onCellClick: null,
      onCellHover: null,
      onWeekNumberClick: null,
      rowCount: 3,
      colCount: 4,
      allowValueSelection: !0,
      _todayDate: () => /* @__PURE__ */ new Date()
    });
  }
  _initMarkup() {
    super._initMarkup(), this._renderImpl();
  }
  _renderImpl() {
    this.$element().append(this._createTable()), this._createDisabledDatesHandler(), this._renderBody(), this._renderContouredDate(), this._renderValue(), this._renderRange(), this._renderEvents(), this._updateTableAriaLabel();
  }
  _getLocalizedWidgetName() {
    return S.format("dxCalendar-ariaWidgetName");
  }
  _getSingleModeAriaLabel() {
    const {
      value: e
    } = this.option(), t = this._getLocalizedWidgetName(), n = ue.format(e, "date"), s = S.format("dxCalendar-selectedDate", n);
    return `${t}. ${s}`;
  }
  _getRangeModeAriaLabel() {
    const {
      value: e
    } = this.option(), t = this._getLocalizedWidgetName(), [n, s] = e, o = ue.format(n, "date"), r = ue.format(s, "date"), a = n && s ? S.format("dxCalendar-selectedDateRange", o, r) : S.format("dxCalendar-selectedDate", o ?? r);
    return `${t}. ${a}`;
  }
  _getMultipleModeAriaLabel() {
    const e = this._getLocalizedWidgetName(), t = this._getMultipleRangesText();
    return `${e}. ${t}`;
  }
  _getMultipleRangesText() {
    const {
      value: e
    } = this.option(), t = j.getRangesByDates(e.map((r) => new Date(r)));
    if (t.length > 2)
      return S.format("dxCalendar-selectedDateRangeCount", t.length);
    const n = S.format("dxCalendar-selectedDates"), s = t.map((r) => this._getRangeText(r)).join(", ");
    return `${n}: ${s}`;
  }
  _getRangeText(e) {
    const [t, n] = e, s = ue.format(t, "date"), o = ue.format(n, "date");
    return t && n ? S.format("dxCalendar-selectedMultipleDateRange", s, o) : s;
  }
  _getTableAriaLabel() {
    const {
      value: e,
      selectionMode: t
    } = this.option();
    if (!e || Array.isArray(e) && !e.filter(Boolean).length)
      return this._getLocalizedWidgetName();
    switch (t) {
      case _o.single:
        return this._getSingleModeAriaLabel();
      case _o.range:
        return this._getRangeModeAriaLabel();
      case _o.multiple:
        return this._getMultipleModeAriaLabel();
    }
  }
  _updateTableAriaLabel() {
    const e = this._getTableAriaLabel();
    this.setAria({
      label: e
    }, this._$table);
  }
  _createTable() {
    return this._$table = p("<table>"), this.setAria({
      role: "grid"
    }, this._$table), this._$table;
  }
  _renderBody() {
    this.$body = p("<tbody>").appendTo(this._$table);
    const e = {
      cellDate: this._getFirstCellData(),
      prevCellDate: null
    }, {
      rowCount: t,
      colCount: n
    } = this.option();
    for (let s = 0, o = t; s < o; s++) {
      e.row = this._createRow();
      for (let r = 0, a = n; r < a; r++)
        this._renderCell(e, r);
      this._renderWeekNumberCell(e);
    }
  }
  _renderWeekNumberCell(e) {
  }
  _createRow() {
    const e = O.createElement("tr");
    return this.setAria("role", "row", p(e)), this.$body.get(0).appendChild(e), e;
  }
  _createCell(e, t) {
    const n = O.createElement("td"), s = p(n);
    return n.className = this._getClassNameByDate(e, t), n.setAttribute("data-value", pt.serializeDate(e, j.getShortDateFormat())), tt(n, "dxDateValueKey", e), this.setAria({
      role: "gridcell",
      selected: !1,
      label: this.getCellAriaLabel(e)
    }, s), {
      cell: n,
      $cell: s
    };
  }
  _renderCell(e, t) {
    const {
      cellDate: n,
      prevCellDate: s,
      row: o
    } = e;
    s && j.fixTimezoneGap(s, n), e.prevCellDate = n;
    const {
      cell: r,
      $cell: a
    } = this._createCell(n, t), l = this.option("cellTemplate");
    p(o).append(r), l ? l.render(this._prepareCellTemplateData(n, t, a)) : r.innerHTML = this._getCellText(n), e.cellDate = this._getNextCellData(n);
  }
  _getClassNameByDate(e, t) {
    let n = "dx-calendar-cell";
    this._isTodayCell(e) && (n += " dx-calendar-today"), (this._isDateOutOfRange(e) || this.isDateDisabled(e)) && (n += " dx-calendar-empty-cell"), this._isOtherView(e) && (n += " dx-calendar-other-view");
    const {
      selectionMode: s
    } = this.option();
    if (s === _o.range) {
      t === 0 && (n += " dx-calendar-cell-start-in-row");
      const {
        colCount: o
      } = this.option();
      t === o - 1 && (n += " dx-calendar-cell-end-in-row"), this._isStartDayOfMonth(e) && (n += " dx-calendar-cell-start"), this._isEndDayOfMonth(e) && (n += " dx-calendar-cell-end");
    }
    return n;
  }
  _prepareCellTemplateData(e, t, n) {
    const s = e instanceof Date, o = s ? this._getCellText(e) : e, r = s ? e : void 0, a = this._getViewName();
    return {
      model: {
        text: o,
        date: r,
        view: a
      },
      container: ee(n),
      index: t
    };
  }
  _renderEvents() {
    this._createCellClickAction(), _.off(this._$table, zp), _.on(this._$table, zp, Ew, (t) => {
      p(t.currentTarget).hasClass("dx-calendar-empty-cell") || this._cellClickAction({
        event: t,
        value: p(t.currentTarget).data("dxDateValueKey")
      });
    });
    const {
      selectionMode: e
    } = this.option();
    _.off(this._$table, Iw), e === _o.range && (this._createCellHoverAction(), _.on(this._$table, Iw, Ew, (t) => {
      p(t.currentTarget).hasClass("dx-calendar-empty-cell") || this._cellHoverAction({
        event: t,
        value: p(t.currentTarget).data("dxDateValueKey")
      });
    })), e !== _o.single && (this._createWeekNumberCellClickAction(), _.on(this._$table, zp, ".dx-calendar-week-number-cell", (t) => {
      const n = p(t.currentTarget).closest("tr"), s = n.find(".dx-calendar-cell").first().data("dxDateValueKey"), o = n.find(".dx-calendar-cell").last().data("dxDateValueKey"), r = [...j.getDatesOfInterval(s, o, 864e5), o];
      this._weekNumberCellClickAction({
        event: t,
        rowDates: r
      });
    }));
  }
  _createCellClickAction() {
    this._cellClickAction = this._createActionByOption("onCellClick");
  }
  _createCellHoverAction() {
    this._cellHoverAction = this._createActionByOption("onCellHover");
  }
  _createWeekNumberCellClickAction() {
    this._weekNumberCellClickAction = this._createActionByOption("onWeekNumberClick");
  }
  _createDisabledDatesHandler() {
    const {
      disabledDates: e
    } = this.option();
    this._disabledDatesHandler = Array.isArray(e) ? this._getDefaultDisabledDatesHandler(e) : e || M;
  }
  _getDefaultDisabledDatesHandler(e) {
    return M;
  }
  _isTodayCell(e) {
    se.abstract();
  }
  _isDateOutOfRange(e) {
    se.abstract();
  }
  isDateDisabled(e) {
    const t = {
      date: e,
      view: this._getViewName()
    };
    return this._disabledDatesHandler(t);
  }
  _isOtherView(e) {
    se.abstract();
  }
  _isStartDayOfMonth(e) {
    se.abstract();
  }
  _isEndDayOfMonth(e) {
    se.abstract();
  }
  _getCellText(e) {
    se.abstract();
  }
  _getFirstCellData() {
    se.abstract();
  }
  _getNextCellData(e) {
    se.abstract();
  }
  _renderContouredDate(e) {
    if (!this.option("focusStateEnabled"))
      return;
    e = e || this.option("contouredDate");
    const t = this._getContouredCell(), n = this._getCellByDate(e);
    t.removeClass("dx-calendar-contoured-date"), e && n.addClass("dx-calendar-contoured-date");
  }
  _getContouredCell() {
    return this._$table.find(".dx-calendar-contoured-date");
  }
  _renderValue() {
    if (!this.option("allowValueSelection"))
      return;
    let e = this.option("value");
    Array.isArray(e) || (e = [e]), this._updateSelectedClass(e);
  }
  _updateSelectedClass(e) {
    var t;
    this._isRangeMode() && !this._isMonthView() || ((t = this._$selectedCells) === null || t === void 0 || t.forEach((n) => {
      n.removeClass("dx-calendar-selected-date");
    }), this._$selectedCells = e.map((n) => this._getCellByDate(n)), this._$selectedCells.forEach((n) => {
      n.addClass("dx-calendar-selected-date");
    }));
  }
  _renderRange() {
    var e, t, n, s, o, r, a, l;
    const {
      allowValueSelection: d,
      value: u,
      range: c
    } = this.option();
    !d || !this._isRangeMode() || !this._isMonthView() || ((e = this._$rangeCells) === null || e === void 0 || e.forEach((h) => {
      h.removeClass("dx-calendar-cell-in-range");
    }), (t = this._$hoveredRangeCells) === null || t === void 0 || t.forEach((h) => {
      h.removeClass("dx-calendar-cell-range-hover");
    }), (n = this._$rangeStartHoverCell) === null || n === void 0 || n.removeClass("dx-calendar-cell-range-hover-start"), (s = this._$rangeEndHoverCell) === null || s === void 0 || s.removeClass("dx-calendar-cell-range-hover-end"), (o = this._$rangeStartDateCell) === null || o === void 0 || o.removeClass("dx-calendar-range-start-date"), (r = this._$rangeEndDateCell) === null || r === void 0 || r.removeClass("dx-calendar-range-end-date"), this._$rangeCells = c.map((h) => this._getCellByDate(h)), this._$rangeStartDateCell = this._getCellByDate(u[0]), this._$rangeEndDateCell = this._getCellByDate(u[1]), this._$rangeCells.forEach((h) => {
      h.addClass("dx-calendar-cell-in-range");
    }), (a = this._$rangeStartDateCell) === null || a === void 0 || a.addClass("dx-calendar-range-start-date"), (l = this._$rangeEndDateCell) === null || l === void 0 || l.addClass("dx-calendar-range-end-date"));
  }
  _renderHoveredRange() {
    var e, t, n, s, o;
    const {
      allowValueSelection: r,
      hoveredRange: a
    } = this.option();
    !r || !this._isRangeMode() || !this._isMonthView() || ((e = this._$hoveredRangeCells) === null || e === void 0 || e.forEach((l) => {
      l.removeClass("dx-calendar-cell-range-hover");
    }), (t = this._$rangeStartHoverCell) === null || t === void 0 || t.removeClass("dx-calendar-cell-range-hover-start"), (n = this._$rangeEndHoverCell) === null || n === void 0 || n.removeClass("dx-calendar-cell-range-hover-end"), this._$hoveredRangeCells = a.map((l) => this._getCellByDate(l)), this._$rangeStartHoverCell = this._getCellByDate(a[0]), this._$rangeEndHoverCell = this._getCellByDate(a[a.length - 1]), this._$hoveredRangeCells.forEach((l) => {
      l.addClass("dx-calendar-cell-range-hover");
    }), (s = this._$rangeStartHoverCell) === null || s === void 0 || s.addClass("dx-calendar-cell-range-hover-start"), (o = this._$rangeEndHoverCell) === null || o === void 0 || o.addClass("dx-calendar-cell-range-hover-end"));
  }
  _isMonthView() {
    const {
      zoomLevel: e
    } = this.option();
    return e === "month";
  }
  _isRangeMode() {
    const {
      selectionMode: e
    } = this.option();
    return e === _o.range;
  }
  _getCurrentDateFormat() {
    return null;
  }
  getCellAriaLabel(e) {
    const t = this._getViewName(), n = this._isTodayCell(e), s = this._getCurrentDateFormat(), o = s ? ue.format(e, s) : this._getCellText(e);
    return n ? `${o}. ${_9[t]}` : o;
  }
  _getFirstAvailableDate() {
    let e = this.option("date");
    const t = this.option("min");
    return e = j.getViewFirstCellDate(this._getViewName(), e), new Date(t && e < t ? t : e);
  }
  _getCellByDate(e) {
    se.abstract();
  }
  isBoundary(e) {
    se.abstract();
  }
  _optionChanged(e) {
    const {
      name: t,
      value: n
    } = e;
    switch (t) {
      case "value":
        this._renderValue(), this._updateTableAriaLabel();
        break;
      case "range":
        this._renderRange();
        break;
      case "hoveredRange":
        this._renderHoveredRange();
        break;
      case "contouredDate":
        this._renderContouredDate(n);
        break;
      case "onCellClick":
        this._createCellClickAction();
        break;
      case "onCellHover":
        this._createCellHoverAction();
        break;
      case "min":
      case "max":
      case "disabledDates":
      case "cellTemplate":
      case "selectionMode":
        this._invalidate();
        break;
      case "_todayDate":
        this._renderBody();
        break;
      default:
        super._optionChanged(e);
    }
  }
}
class C9 extends xh {
  _getViewName() {
    return "month";
  }
  _getCurrentDateFormat() {
    return "longdate";
  }
  _getDefaultOptions() {
    return I({}, super._getDefaultOptions(), {
      firstDayOfWeek: 0,
      rowCount: 6,
      colCount: 7
    });
  }
  _renderImpl() {
    super._renderImpl(), this._renderHeader();
  }
  _renderBody() {
    super._renderBody(), this._$table.find(".dx-calendar-other-view").addClass("dx-calendar-other-month");
  }
  _renderFocusTarget() {
  }
  _renderHeader() {
    const e = p("<tr>"), t = p("<thead>").append(e);
    this._$table.prepend(t);
    const {
      colCount: n,
      showWeekNumbers: s
    } = this.option();
    for (let o = 0, r = n; o < r; o++)
      this._renderHeaderCell(o, e);
    s && this._renderWeekHeaderCell(e);
  }
  _renderHeaderCell(e, t) {
    const {
      firstDayOfWeek: n
    } = this.option(), {
      full: s,
      abbreviated: o
    } = this._getDayCaption(n + e), r = p("<th>").attr({
      scope: "col",
      abbr: s
    }).text(o);
    t.append(r);
  }
  _renderWeekHeaderCell(e) {
    const t = p("<th>").attr({
      scope: "col",
      abbr: "WeekNumber",
      class: "dx-week-number-header"
    });
    e.prepend(t);
  }
  _renderWeekNumberCell(e) {
    const {
      showWeekNumbers: t,
      cellTemplate: n,
      selectionMode: s,
      selectWeekOnClick: o
    } = this.option();
    if (!t)
      return;
    const r = this._getWeekNumber(e.prevCellDate), a = O.createElement("td"), l = p(a);
    a.className = "dx-calendar-week-number-cell", s !== "single" && o && l.addClass("dx-calendar-week-selection"), n ? n.render(this._prepareCellTemplateData(r, -1, l)) : a.innerHTML = r, e.row.prepend(a), this.setAria({
      role: "gridcell",
      label: `Week ${r}`
    }, l);
  }
  _getWeekNumber(e) {
    const {
      weekNumberRule: t,
      firstDayOfWeek: n
    } = this.option();
    return t === "auto" ? j.getWeekNumber(e, n, n === 1 ? "firstFourDays" : "firstDay") : j.getWeekNumber(e, n, t);
  }
  getNavigatorCaption() {
    const {
      date: e
    } = this.option();
    return ue.format(e, "monthandyear");
  }
  _isTodayCell(e) {
    const {
      _todayDate: t
    } = this.option();
    return j.sameDate(e, t());
  }
  _isDateOutOfRange(e) {
    const t = this.option("min"), n = this.option("max");
    return !j.dateInRange(e, t, n, "date");
  }
  _isOtherView(e) {
    const {
      date: t
    } = this.option();
    return e.getMonth() !== t.getMonth();
  }
  _isStartDayOfMonth(e) {
    return j.sameDate(e, j.getFirstMonthDate(this.option("date")));
  }
  _isEndDayOfMonth(e) {
    return j.sameDate(e, j.getLastMonthDate(this.option("date")));
  }
  _getCellText(e) {
    return ue.format(e, "d");
  }
  _getDayCaption(e) {
    const {
      colCount: t
    } = this.option(), n = e % t;
    return {
      full: ue.getDayNames()[n],
      abbreviated: ue.getDayNames("abbreviated")[n]
    };
  }
  _getFirstCellData() {
    const {
      firstDayOfWeek: e
    } = this.option(), t = j.getFirstMonthDate(this.option("date"));
    let n = e - t.getDay();
    const {
      colCount: s
    } = this.option();
    return n >= 0 && (n -= s), t.setDate(t.getDate() + n), t;
  }
  _getNextCellData(e) {
    return e = new Date(e), e.setDate(e.getDate() + 1), e;
  }
  _getCellByDate(e) {
    return this._$table.find(`td[data-value='${pt.serializeDate(e, j.getShortDateFormat())}']`);
  }
  isBoundary(e) {
    return j.sameMonthAndYear(e, this.option("min")) || j.sameMonthAndYear(e, this.option("max"));
  }
  _getDefaultDisabledDatesHandler(e) {
    return function(t) {
      if (e.some((s) => j.sameDate(s, t.date)))
        return !0;
    };
  }
}
class v9 extends xh {
  _getViewName() {
    return "year";
  }
  _getCurrentDateFormat() {
    return "monthandyear";
  }
  _isTodayCell(e) {
    const {
      _todayDate: t
    } = this.option();
    return j.sameMonthAndYear(e, t());
  }
  _isDateOutOfRange(e) {
    return !j.dateInRange(e, j.getFirstMonthDate(this.option("min")), j.getLastMonthDate(this.option("max")));
  }
  _isOtherView() {
    return !1;
  }
  _isStartDayOfMonth() {
    return !1;
  }
  _isEndDayOfMonth() {
    return !1;
  }
  _getCellText(e) {
    return ue.getMonthNames("abbreviated")[e.getMonth()];
  }
  _getFirstCellData() {
    const {
      date: e
    } = this.option(), t = new Date(e);
    return t.setDate(1), t.setMonth(0), t;
  }
  _getNextCellData(e) {
    return e = new Date(e), e.setMonth(e.getMonth() + 1), e;
  }
  _getCellByDate(e) {
    const t = new Date(e);
    return t.setDate(1), this._$table.find(`td[data-value='${pt.serializeDate(t, j.getShortDateFormat())}']`);
  }
  getNavigatorCaption() {
    const {
      date: e
    } = this.option();
    return ue.format(e, "yyyy");
  }
  isBoundary(e) {
    return j.sameYear(e, this.option("min")) || j.sameYear(e, this.option("max"));
  }
  _renderWeekNumberCell() {
  }
}
class x9 extends xh {
  _getViewName() {
    return "decade";
  }
  _isTodayCell(e) {
    const {
      _todayDate: t
    } = this.option();
    return j.sameYear(e, t());
  }
  _isDateOutOfRange(e) {
    const t = this.option("min"), n = this.option("max");
    return !j.dateInRange(e.getFullYear(), t?.getFullYear(), n?.getFullYear());
  }
  _isOtherView(e) {
    const t = new Date(e);
    return t.setMonth(1), !j.sameDecade(t, this.option("date"));
  }
  _isStartDayOfMonth() {
    return !1;
  }
  _isEndDayOfMonth() {
    return !1;
  }
  _getCellText(e) {
    return ue.format(e, "yyyy");
  }
  _getFirstCellData() {
    const e = j.getFirstYearInDecade(this.option("date")) - 1;
    return j.createDateWithFullYear(e, 0, 1);
  }
  _getNextCellData(e) {
    return e = new Date(e), e.setFullYear(e.getFullYear() + 1), e;
  }
  getNavigatorCaption() {
    const {
      date: e
    } = this.option(), t = j.getFirstYearInDecade(e), n = new Date(e), s = new Date(e);
    return n.setFullYear(t), s.setFullYear(t + 9), `${ue.format(n, "yyyy")}-${ue.format(s, "yyyy")}`;
  }
  _isValueOnCurrentView(e, t) {
    return j.sameDecade(e, t);
  }
  _getCellByDate(e) {
    const t = new Date(e);
    return t.setDate(1), t.setMonth(0), this._$table.find(`td[data-value='${pt.serializeDate(t, j.getShortDateFormat())}']`);
  }
  isBoundary(e) {
    return j.sameDecade(e, this.option("min")) || j.sameDecade(e, this.option("max"));
  }
  _renderWeekNumberCell() {
  }
}
class y9 extends xh {
  _getViewName() {
    return "century";
  }
  _isTodayCell(e) {
    const {
      _todayDate: t
    } = this.option();
    return j.sameDecade(e, t());
  }
  _isDateOutOfRange(e) {
    const t = j.getFirstYearInDecade(e), n = j.getFirstYearInDecade(this.option("min")), s = j.getFirstYearInDecade(this.option("max"));
    return !j.dateInRange(t, n, s);
  }
  _isOtherView(e) {
    const t = new Date(e);
    return t.setMonth(1), !j.sameCentury(t, this.option("date"));
  }
  _isStartDayOfMonth() {
    return !1;
  }
  _isEndDayOfMonth() {
    return !1;
  }
  _getCellText(e) {
    const t = ue.format(e, "yyyy"), n = new Date(e);
    return n.setFullYear(n.getFullYear() + 9), `${t} - ${ue.format(n, "yyyy")}`;
  }
  _getFirstCellData() {
    const e = j.getFirstDecadeInCentury(this.option("date")) - 10;
    return j.createDateWithFullYear(e, 0, 1);
  }
  _getNextCellData(e) {
    return e = new Date(e), e.setFullYear(e.getFullYear() + 10), e;
  }
  _getCellByDate(e) {
    const t = new Date(e);
    return t.setDate(1), t.setMonth(0), t.setFullYear(j.getFirstYearInDecade(t)), this._$table.find(`td[data-value='${pt.serializeDate(t, j.getShortDateFormat())}']`);
  }
  getNavigatorCaption() {
    const {
      date: e
    } = this.option(), t = j.getFirstDecadeInCentury(e), n = new Date(e), s = new Date(e);
    return n.setFullYear(t), s.setFullYear(t + 99), `${ue.format(n, "yyyy")}-${ue.format(s, "yyyy")}`;
  }
  isBoundary(e) {
    return j.sameCentury(e, this.option("min")) || j.sameCentury(e, this.option("max"));
  }
  _renderWeekNumberCell() {
  }
}
const b9 = {
  month: C9,
  year: v9,
  decade: x9,
  century: y9
}, Dw = R(ad, "dxCalendar"), yr = {
  month: 3,
  year: 2,
  decade: 1,
  century: 0
}, Pt = {
  MONTH: "month",
  YEAR: "year",
  DECADE: "decade",
  CENTURY: "century"
}, w9 = {
  SingleSelection: f9,
  MultipleSelection: p9,
  RangeSelection: m9
};
class FA extends ci {
  _getDefaultOptions() {
    return I({}, super._getDefaultOptions(), {
      hoverStateEnabled: !0,
      activeStateEnabled: !0,
      currentDate: /* @__PURE__ */ new Date(),
      value: null,
      min: new Date(1e3, 0),
      max: new Date(3e3, 0),
      viewsCount: 1,
      zoomLevel: Pt.MONTH,
      maxZoomLevel: Pt.MONTH,
      minZoomLevel: Pt.CENTURY,
      selectionMode: "single",
      selectWeekOnClick: !0,
      showTodayButton: !1,
      showWeekNumbers: !1,
      weekNumberRule: "auto",
      cellTemplate: "cell",
      disabledDates: null,
      onCellClick: null,
      onContouredChanged: null,
      skipFocusCheck: !1,
      _todayDate: () => /* @__PURE__ */ new Date()
    });
  }
  _defaultOptionsRules() {
    return super._defaultOptionsRules().concat([{
      device: () => z.real().deviceType === "desktop" && !z.isSimulator(),
      options: {
        focusStateEnabled: !0
      }
    }]);
  }
  _supportedKeys() {
    return I({}, super._supportedKeys(), {
      rightArrow(e) {
        e.preventDefault(), bt(e) ? this._waitRenderView(1) : this._moveCurrentDateByOffset(1 * this._getRtlCorrection());
      },
      leftArrow(e) {
        e.preventDefault(), bt(e) ? this._waitRenderView(-1) : this._moveCurrentDateByOffset(-1 * this._getRtlCorrection());
      },
      upArrow(e) {
        if (e.preventDefault(), bt(e))
          this._navigateUp();
        else {
          if (Le.isAnimating(this._view.$element()))
            return;
          this._moveCurrentDateByOffset(-1 * this._view.option("colCount"));
        }
      },
      downArrow(e) {
        if (e.preventDefault(), bt(e))
          this._navigateDown();
        else {
          if (Le.isAnimating(this._view.$element()))
            return;
          this._moveCurrentDateByOffset(1 * this._view.option("colCount"));
        }
      },
      home(e) {
        e.preventDefault();
        const t = this.option("zoomLevel"), n = this.option("currentDate"), s = this._dateOption("min");
        if (this._view.isDateDisabled(n))
          return;
        const o = j.sameView(t, n, s) ? s : j.getViewFirstCellDate(t, n);
        this._moveToClosestAvailableDate(o);
      },
      end(e) {
        e.preventDefault();
        const t = this.option("zoomLevel"), n = this.option("currentDate"), s = this._dateOption("max");
        if (this._view.isDateDisabled(n))
          return;
        const o = j.sameView(t, n, s) ? s : j.getViewLastCellDate(t, n);
        this._moveToClosestAvailableDate(o);
      },
      pageUp(e) {
        e.preventDefault(), this._waitRenderView(-1 * this._getRtlCorrection());
      },
      pageDown(e) {
        e.preventDefault(), this._waitRenderView(1 * this._getRtlCorrection());
      },
      tab() {
      },
      enter: this._enterKeyHandler
    });
  }
  _enterKeyHandler(e) {
    if (!this._isMaxZoomLevel())
      this._navigateDown();
    else if (!this._view.isDateDisabled(this.option("currentDate"))) {
      const t = this._updateTimeComponent(this.option("currentDate"));
      this._selectionStrategy.selectValue(t, e);
    }
  }
  _getSerializationFormat(e) {
    const t = this.option(e || "value");
    if (this.option("dateSerializationFormat"))
      return this.option("dateSerializationFormat");
    if ($e(t))
      return "number";
    if (te(t))
      return pt.getDateSerializationFormat(t);
  }
  _convertToDate(e) {
    return pt.deserializeDate(e);
  }
  _dateValue(e, t) {
    if (t) {
      if (t.type === "keydown") {
        const n = this._view._getContouredCell().get(0);
        t.target = n;
      }
      this._saveValueChangeEvent(t);
    }
    this._dateOption("value", e);
  }
  _dateOption(e, t) {
    const n = e === "value" && !this._isSingleMode(), s = this.option("value");
    if (arguments.length === 1)
      return n ? (s ?? []).map((a) => this._convertToDate(a)) : this._convertToDate(this.option(e));
    const o = this._getSerializationFormat(e), r = n ? t?.map((a) => pt.serializeDate(a, o)) || [] : pt.serializeDate(t, o);
    this.option(e, r);
  }
  _isSingleMode() {
    const {
      selectionMode: e
    } = this.option();
    return e === "single";
  }
  _shiftDate(e, t, n, s) {
    switch (e) {
      case Pt.MONTH:
        t.setDate(t.getDate() + n * s);
        break;
      case Pt.YEAR:
        t.setMonth(t.getMonth() + n * s);
        break;
      case Pt.DECADE:
        t.setFullYear(t.getFullYear() + n * s);
        break;
      case Pt.CENTURY:
        t.setFullYear(t.getFullYear() + 10 * n * s);
    }
  }
  _moveCurrentDateByOffset(e) {
    const t = this.option("currentDate");
    let n = new Date(t);
    const s = this.option("zoomLevel");
    this._shiftDate(s, n, e, 1);
    const o = this._getMaxDate(), r = this._getMinDate();
    let a = this._areDatesInNeighborView(s, n, t), l = ss(n, r, o) && a;
    const d = new Date(n);
    for (; l; ) {
      if (!this._view.isDateDisabled(d)) {
        n = d;
        break;
      }
      this._shiftDate(s, d, e, 1), a = this._areDatesInNeighborView(s, d, t), l = ss(d, r, o) && a;
    }
    if (this._view.isDateDisabled(t) || this._view.isDateDisabled(n)) {
      const u = e > 0 ? 1 : -1;
      (u === 1 ? this._isNextViewDisabled() : this._isPrevViewDisabled()) ? this._moveToClosestAvailableDate(n) : this._waitRenderView(u);
    } else
      this._skipNavigate = !0, this.option("currentDate", n);
  }
  _isNextViewDisabled() {
    return this._navigator._nextButton.option("disabled");
  }
  _isPrevViewDisabled() {
    return this._navigator._prevButton.option("disabled");
  }
  _areDatesInSameView(e, t, n) {
    switch (e) {
      case Pt.MONTH:
        return t.getMonth() === n.getMonth();
      case Pt.YEAR:
        return t.getYear() === n.getYear();
      case Pt.DECADE:
        return parseInt(t.getYear() / 10) === parseInt(n.getYear() / 10);
      case Pt.CENTURY:
        return parseInt(t.getYear() / 100) === parseInt(n.getYear() / 100);
    }
  }
  _areDatesInNeighborView(e, t, n) {
    switch (e) {
      case Pt.MONTH:
        return ((s, o) => {
          const r = Math.abs(s - o);
          return Math.min(r, 12 - r);
        })(t.getMonth(), n.getMonth()) <= 1;
      case Pt.YEAR:
        return Math.abs(t.getYear() - n.getYear()) <= 1;
      case Pt.DECADE:
        return Math.abs(t.getYear() - n.getYear()) <= 10;
      case Pt.CENTURY:
        return Math.abs(t.getYear() - n.getYear()) <= 100;
    }
  }
  _moveToClosestAvailableDate() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : this.option("currentDate"), t = new Date(e);
    const n = this.option("zoomLevel"), s = !this._isDateNotAvailable(t);
    let o = s, r = s, a, l;
    const d = new Date(t), u = new Date(t);
    do {
      if (o) {
        t = d;
        break;
      }
      if (r) {
        t = u;
        break;
      }
      this._shiftDate(n, d, 1, 1), this._shiftDate(n, u, 1, -1), a = this._areDatesInSameView(n, d, e), l = this._areDatesInSameView(n, u, e), o = a && !this._isDateNotAvailable(d), r = l && !this._isDateNotAvailable(u);
    } while (a || l);
    this.option("currentDate", t);
  }
  _isDateNotAvailable(e) {
    const t = this._getMaxDate(), n = this._getMinDate();
    return !ss(e, n, t) || this._view.isDateDisabled(e);
  }
  _init() {
    super._init(), this._activeStateUnit = ".dx-calendar-cell", this._initSelectionStrategy(), this._correctZoomLevel(), this._initCurrentDate(), this._initActions();
  }
  _initSelectionStrategy() {
    const e = this._getSelectionStrategyName(), t = w9[e];
    (!this._selectionStrategy || this._selectionStrategy.NAME !== e) && (this._selectionStrategy = new t(this));
  }
  _refreshSelectionStrategy() {
    this._initSelectionStrategy(), this._selectionStrategy.restoreValue(), this._refresh();
  }
  _getSelectionStrategyName() {
    const {
      selectionMode: e
    } = this.option();
    switch (e) {
      case "multiple":
        return "MultipleSelection";
      case "range":
        return "RangeSelection";
      default:
        return "SingleSelection";
    }
  }
  _correctZoomLevel() {
    const {
      minZoomLevel: e,
      maxZoomLevel: t,
      zoomLevel: n
    } = this.option();
    yr[t] < yr[e] || (yr[n] > yr[t] ? this.option("zoomLevel", t) : yr[n] < yr[e] && this.option("zoomLevel", e));
  }
  _initCurrentDate() {
    const e = this._getNormalizedDate(this._selectionStrategy.getDefaultCurrentDate()) ?? this._getNormalizedDate(this.option("currentDate"));
    this.option("currentDate", e);
  }
  _getNormalizedDate(e) {
    return e = j.normalizeDate(e, this._getMinDate(), this._getMaxDate()), f(e) ? this._getDate(e) : e;
  }
  _initActions() {
    this._cellClickAction = this._createActionByOption("onCellClick"), this._onContouredChanged = this._createActionByOption("onContouredChanged");
  }
  _initTemplates() {
    this._templateManager.addDefaultTemplates({
      cell: new sa((e) => {
        const t = e.model;
        p(e.container).append(p("<span>").text(t && t.text || String(t)));
      })
    }), super._initTemplates();
  }
  _updateCurrentDate(e) {
    Le.isAnimating(this._$viewsWrapper) && Le.stop(this._$viewsWrapper, !0);
    const t = this._getMinDate(), n = this._getMaxDate();
    if (t > n) {
      this.option("currentDate", /* @__PURE__ */ new Date());
      return;
    }
    const s = this._getNormalizedDate(e);
    if (e.getTime() !== s.getTime()) {
      this.option("currentDate", new Date(s));
      return;
    }
    let o = this._getViewsOffset(this._view.option("date"), s);
    o !== 0 && !this._isMaxZoomLevel() && this._isOtherViewCellClicked && (o = 0), this._view && o !== 0 && !this._suppressNavigation ? this._additionalView ? o > 2 || o < -1 ? (this._refreshViews(), this._setViewContoured(s), this._updateAriaId(s), this._renderNavigator()) : o === 1 && this._skipNavigate ? (this._setViewContoured(s), this._updateAriaId(s)) : this._navigate(o, s) : this._navigate(o, s) : (this._renderNavigator(), this._setViewContoured(s), this._updateAriaId(s)), this._skipNavigate = !1;
  }
  _isAdditionalViewDate(e) {
    return this._additionalView ? e >= this._additionalView._getFirstAvailableDate() : !1;
  }
  _getActiveView(e) {
    return this._isAdditionalViewDate(e) ? this._additionalView : this._view;
  }
  _setViewContoured(e) {
    if (this.option("skipFocusCheck") || p(this._$viewsWrapper).is(":focus")) {
      var t;
      this._view.option("contouredDate", null), (t = this._additionalView) === null || t === void 0 || t.option("contouredDate", null), (this._isAdditionalViewDate(e) ? this._additionalView : this._view).option("contouredDate", e);
    }
  }
  _getMinDate() {
    const e = this.option("_rangeMin");
    return e || (this.min ? this.min : (this.min = this._dateOption("min") || new Date(1e3, 0), this.min));
  }
  _getMaxDate() {
    const e = this.option("_rangeMax");
    return e || (this.max ? this.max : (this.max = this._dateOption("max") || new Date(3e3, 0), this.max));
  }
  _getViewsOffset(e, t) {
    const {
      zoomLevel: n
    } = this.option();
    if (n === Pt.MONTH)
      return this._getMonthsOffset(e, t);
    let s;
    switch (n) {
      case Pt.CENTURY:
        s = 100;
        break;
      case Pt.DECADE:
        s = 10;
        break;
      default:
        s = 1;
    }
    return parseInt(t.getFullYear() / s) - parseInt(e.getFullYear() / s);
  }
  _getMonthsOffset(e, t) {
    const n = t.getFullYear() - e.getFullYear(), s = t.getMonth() - e.getMonth();
    return 12 * n + s;
  }
  _waitRenderView(e) {
    if (this._alreadyViewRender)
      return;
    this._alreadyViewRender = !0;
    const t = this._getDateByOffset(e * this._getRtlCorrection());
    this._moveToClosestAvailableDate(t), this._waitRenderViewTimeout = setTimeout(() => {
      this._alreadyViewRender = !1;
    });
  }
  _getRtlCorrection() {
    return this.option("rtlEnabled") ? -1 : 1;
  }
  _getDateByOffset(e, t) {
    t = this._getDate(t ?? this.option("currentDate"));
    const n = t.getDate(), s = j.getDifferenceInMonth(this.option("zoomLevel")) * e;
    t.setDate(1), t.setMonth(t.getMonth() + s);
    const o = j.getLastMonthDate(t).getDate();
    return t.setDate(n > o ? o : n), t;
  }
  _focusTarget() {
    return this._$viewsWrapper;
  }
  _focusEventTarget() {
    return this.$element();
  }
  _initMarkup() {
    this._renderSubmitElement();
    const e = this.$element();
    e.addClass("dx-calendar");
    const {
      selectionMode: t
    } = this.option();
    e.toggleClass("dx-calendar-range", t === "range"), this._renderBody(), e.append(this.$body), this._renderViews(), this._renderNavigator(), super._initMarkup(), this._renderEvents(), e.prepend(this._navigator.$element()), this._renderSwipeable(), this._renderFooter(), this._selectionStrategy.updateAriaSelected(), this._updateAriaId(), this._updateNavigatorLabels(), this.setAria("role", "application"), this._updateAriaLabelAndRole(), this._moveToClosestAvailableDate();
  }
  _render() {
    super._render(), this._setViewContoured(this.option("currentDate"));
  }
  _renderBody() {
    this._$viewsWrapper || (this.$body = p("<div>").addClass("dx-calendar-body"), this._$viewsWrapper = p("<div>").addClass("dx-calendar-views-wrapper"), this.$body.append(this._$viewsWrapper));
  }
  _updateAriaLabelAndRole() {
    const e = this.option("readOnly"), t = this.$element(), n = {
      role: e ? "group" : void 0,
      label: e ? S.format("dxCalendar-readOnlyLabel") : void 0
    };
    this.setAria(n, t);
  }
  _setAriaReadonly() {
  }
  _getKeyboardListeners() {
    return super._getKeyboardListeners().concat([this._view]);
  }
  _renderViews() {
    const {
      zoomLevel: e
    } = this.option();
    this.$element().addClass(`dx-calendar-view-${e}`);
    const {
      currentDate: t,
      viewsCount: n
    } = this.option();
    if (this.$element().toggleClass("dx-calendar-multiview", n > 1), this._view = this._renderSpecificView(t), ae()) {
      const s = this._getDateByOffset(-1, t);
      this._beforeView = this._isViewAvailable(s) ? this._renderSpecificView(s) : null;
      const o = this._getDateByOffset(n, t);
      o.setDate(1), this._afterView = this._isViewAvailable(o) ? this._renderSpecificView(o) : null;
    }
    n > 1 && (this._additionalView = this._renderSpecificView(this._getDateByOffset(1, t))), this._translateViews();
  }
  _renderSpecificView(e) {
    const {
      zoomLevel: t
    } = this.option(), n = b9[t], s = p("<div>").appendTo(this._$viewsWrapper), o = this._viewConfig(e);
    return this._createComponent(s, n, o);
  }
  _viewConfig(e) {
    let t = this.option("disabledDates");
    return t = B(t) ? this._injectComponent(t.bind(this)) : t, I({}, this._selectionStrategy.getViewOptions(), {
      date: e,
      min: this._getMinDate(),
      max: this._getMaxDate(),
      firstDayOfWeek: this.option("firstDayOfWeek") ?? ue.firstDayOfWeekIndex(),
      showWeekNumbers: this.option("showWeekNumbers"),
      selectWeekOnClick: this.option("selectWeekOnClick"),
      weekNumberRule: this.option("weekNumberRule"),
      zoomLevel: this.option("zoomLevel"),
      tabIndex: void 0,
      focusStateEnabled: this.option("focusStateEnabled"),
      hoverStateEnabled: this.option("hoverStateEnabled"),
      disabledDates: t,
      onCellClick: this._cellClickHandler.bind(this),
      cellTemplate: this._getTemplateByOption("cellTemplate"),
      allowValueSelection: this._isMaxZoomLevel(),
      _todayDate: this.option("_todayDate")
    });
  }
  _renderEvents() {
    _.off(this._$viewsWrapper, Dw);
    const {
      selectionMode: e
    } = this.option();
    e === "range" && _.on(this._$viewsWrapper, Dw, null, () => {
      this._updateViewsOption("hoveredRange", []);
    });
  }
  _injectComponent(e) {
    const t = this;
    return function(n) {
      return x(n, {
        component: t
      }), e(n);
    };
  }
  _isViewAvailable(e) {
    const t = this.option("zoomLevel"), n = j.getViewMinBoundaryDate(t, this._getMinDate()), s = j.getViewMaxBoundaryDate(t, this._getMaxDate());
    return j.dateInRange(e, n, s);
  }
  _translateViews() {
    const {
      viewsCount: e
    } = this.option();
    Ot(this._view.$element(), {
      left: 0,
      top: 0
    }), this._moveViewElement(this._beforeView, -1), this._moveViewElement(this._afterView, e), this._moveViewElement(this._additionalView, 1);
  }
  _moveViewElement(e, t) {
    e && Ot(e.$element(), {
      left: this._getViewPosition(t),
      top: 0
    });
  }
  _getViewPosition(e) {
    const t = this.option("rtlEnabled") ? -1 : 1;
    return 100 * e * t + "%";
  }
  _cellClickHandler(e) {
    const t = this.option("zoomLevel"), n = j.getViewDown(t), s = this._isMaxZoomLevel();
    if (n && !s)
      this._navigateDown(e.event.currentTarget);
    else {
      var o;
      const r = this._updateTimeComponent(e.value);
      this._selectionStrategy.selectValue(r, e.event), (o = this._cellClickAction) === null || o === void 0 || o.call(this, e);
    }
  }
  _updateTimeComponent(e) {
    const t = new Date(e), n = this._dateOption("value");
    return n && this._isSingleMode() && (t.setHours(n.getHours()), t.setMinutes(n.getMinutes()), t.setSeconds(n.getSeconds()), t.setMilliseconds(n.getMilliseconds())), t;
  }
  _isMaxZoomLevel() {
    return this.option("zoomLevel") === this.option("maxZoomLevel");
  }
  _navigateDown(e) {
    const t = this.option("zoomLevel");
    if (this._isMaxZoomLevel())
      return;
    const n = j.getViewDown(t);
    if (!n)
      return;
    let s = this._view.option("contouredDate") || this._view.option("date");
    e && (s = p(e).data("dxDateValueKey")), this._isOtherViewCellClicked = !0, this.option("currentDate", s), this.option("zoomLevel", n), this._isOtherViewCellClicked = !1, this._renderNavigator(), this._animateShowView(), this._moveToClosestAvailableDate(), this._setViewContoured(this._getNormalizedDate(this.option("currentDate")));
  }
  _renderNavigator() {
    this._navigator || (this._navigator = new g9(p("<div>"), this._navigatorConfig())), this._navigator.option("text", this._getViewsCaption(this._view, this._additionalView)), this._updateButtonsVisibility();
  }
  _navigatorConfig() {
    const {
      focusStateEnabled: e,
      rtlEnabled: t
    } = this.option();
    return {
      text: this._getViewsCaption(this._view, this._additionalView),
      onClick: this._navigatorClickHandler.bind(this),
      onCaptionClick: this._navigateUp.bind(this),
      focusStateEnabled: e,
      rtlEnabled: t,
      tabIndex: void 0
    };
  }
  _navigatorClickHandler(e) {
    const {
      currentDate: t,
      viewsCount: n
    } = this.option();
    let s = e.direction;
    if (n > 1) {
      const r = this._isAdditionalViewDate(t);
      (r && s < 0 || !r && s > 0) && (s *= 2);
    }
    const o = this._getDateByOffset(s, t);
    this._moveToClosestAvailableDate(o);
  }
  _navigateUp() {
    const e = this.option("zoomLevel"), t = j.getViewUp(e);
    !t || this._isMinZoomLevel(e) || (this.option("zoomLevel", t), this._renderNavigator(), this._animateShowView(), this._moveToClosestAvailableDate(), this._setViewContoured(this._getNormalizedDate(this.option("currentDate"))));
  }
  _isMinZoomLevel(e) {
    const t = this._getMinDate(), n = this._getMaxDate();
    return j.sameView(e, t, n) || this.option("minZoomLevel") === e;
  }
  _updateButtonsVisibility() {
    this._navigator.toggleButton("next", !f(this._afterView)), this._navigator.toggleButton("prev", !f(this._beforeView));
  }
  _renderSwipeable() {
    this._swipeable || (this._swipeable = this._createComponent(this.$element(), Ic, {
      onStart: this._swipeStartHandler.bind(this),
      onUpdated: this._swipeUpdateHandler.bind(this),
      onEnd: this._swipeEndHandler.bind(this),
      itemSizeFunc: this._viewWidth.bind(this)
    }));
  }
  _swipeStartHandler(e) {
    Le.stop(this._$viewsWrapper, !0);
    const {
      viewsCount: t
    } = this.option();
    this._toggleGestureCoverCursor("grabbing"), e.event.maxLeftOffset = this._getRequiredView("next") ? 1 / t : 0, e.event.maxRightOffset = this._getRequiredView("prev") ? 1 / t : 0;
  }
  _toggleGestureCoverCursor(e) {
    p(".dx-gesture-cover").css("cursor", e);
  }
  _getRequiredView(e) {
    let t;
    const n = this.option("rtlEnabled");
    return e === "next" ? t = n ? this._beforeView : this._afterView : e === "prev" && (t = n ? this._afterView : this._beforeView), t;
  }
  _swipeUpdateHandler(e) {
    const {
      offset: t
    } = e.event;
    Ot(this._$viewsWrapper, {
      left: t * this._viewWidth(),
      top: 0
    }), this._updateNavigatorCaption(t);
  }
  _swipeEndHandler(e) {
    this._toggleGestureCoverCursor("auto");
    const {
      currentDate: t,
      rtlEnabled: n
    } = this.option(), {
      targetOffset: s
    } = e.event, o = s ? s / Math.abs(s) : 0, a = this._isAdditionalViewDate(t) && (n ? o === -1 : o === 1);
    if (o === 0) {
      this._animateWrapper(0, 250);
      return;
    }
    const l = -o * this._getRtlCorrection() * (a ? 2 : 1);
    let d = this._getDateByOffset(l);
    this._isDateInInvalidRange(d) && (o >= 0 ? d = new Date(this._getMinDate()) : d = new Date(this._getMaxDate())), this.option("currentDate", d);
  }
  _viewWidth() {
    if (!this._viewWidthValue) {
      const {
        viewsCount: e
      } = this.option();
      this._viewWidthValue = ne(this.$element()) / e;
    }
    return this._viewWidthValue;
  }
  _updateNavigatorCaption(e) {
    e *= this._getRtlCorrection();
    const {
      viewsCount: t
    } = this.option(), n = t > 1;
    let s, o;
    e > 0.5 && this._beforeView ? (s = this._beforeView, o = n && this._view) : e < -0.5 && this._afterView ? (s = n ? this._additionalView : this._afterView, o = n ? this._afterView : null) : (s = this._view, o = n ? this._additionalView : null), this._navigator.option("text", this._getViewsCaption(s, o));
  }
  _getViewsCaption(e, t) {
    let n = e.getNavigatorCaption();
    const {
      viewsCount: s
    } = this.option();
    if (s > 1 && t) {
      const o = t.getNavigatorCaption();
      n = `${n} - ${o}`;
    }
    return n;
  }
  _isDateInInvalidRange(e) {
    if (this._view.isBoundary(e))
      return;
    const t = this._getMinDate(), n = this._getMaxDate(), s = j.normalizeDate(e, t, n);
    return s === t || s === n;
  }
  _renderFooter() {
    const e = this.option("showTodayButton");
    if (e) {
      const t = this._createComponent(p("<div>"), wt, {
        focusStateEnabled: this.option("focusStateEnabled"),
        text: S.format("dxCalendar-todayButtonText"),
        onClick: (n) => {
          this._toTodayView(n);
        },
        type: nn() ? "normal" : "default",
        stylingMode: nn() ? "outlined" : "text",
        integrationOptions: {}
      }).$element().addClass("dx-calendar-today-button");
      this._$footer = p("<div>").addClass("dx-calendar-footer").append(t), this.$element().append(this._$footer);
    }
    this.$element().toggleClass("dx-calendar-with-footer", e);
  }
  _renderSubmitElement() {
    this._$submitElement = p("<input>").attr("type", "hidden").appendTo(this.$element()), this._setSubmitValue(this.option("value"));
  }
  _setSubmitValue(e) {
    const t = this._convertToDate(e);
    this._getSubmitElement().val(pt.serializeDate(t, "yyyy-MM-dd"));
  }
  _getSubmitElement() {
    return this._$submitElement;
  }
  _animateShowView() {
    Le.stop(this._view.$element(), !0), this._popAnimationView(this._view, 0.6, 1, 250);
    const {
      viewsCount: e
    } = this.option();
    e > 1 && (Le.stop(this._additionalView.$element(), !0), this._popAnimationView(this._additionalView, 0.6, 1, 250));
  }
  _popAnimationView(e, t, n, s) {
    return Le.animate(e.$element(), {
      type: "pop",
      from: {
        scale: t,
        opacity: t
      },
      to: {
        scale: n,
        opacity: n
      },
      duration: s
    });
  }
  _navigate(e, t) {
    if (e !== 0 && Math.abs(e) !== 1 && this._isViewAvailable(t)) {
      const a = this._renderSpecificView(t);
      e > 0 ? (this._afterView && this._afterView.$element().remove(), this._afterView = a) : (this._beforeView && this._beforeView.$element().remove(), this._beforeView = a), this._translateViews();
    }
    const n = this._getRtlCorrection(), s = e > 0 ? 1 : e < 0 ? -1 : 0, o = -n * s * this._viewWidth();
    this._$viewsWrapper.position().left !== o && (this._preventViewChangeAnimation ? this._wrapperAnimationEndHandler(e, t) : this._animateWrapper(o, 250).done(this._wrapperAnimationEndHandler.bind(this, e, t)));
  }
  _animateWrapper(e, t) {
    return Le.animate(this._$viewsWrapper, {
      type: "slide",
      from: {
        left: this._$viewsWrapper.position().left
      },
      to: {
        left: e
      },
      duration: t
    });
  }
  _getDate(e) {
    return new Date(e);
  }
  _toTodayView(e) {
    const t = /* @__PURE__ */ new Date();
    if (this._isMaxZoomLevel()) {
      this._selectionStrategy.selectValue(t, e.event);
      return;
    }
    this._preventViewChangeAnimation = !0, this.option("zoomLevel", this.option("maxZoomLevel")), this._selectionStrategy.selectValue(t, e.event), this._animateShowView(), this._preventViewChangeAnimation = !1;
  }
  _wrapperAnimationEndHandler(e, t) {
    this._rearrangeViews(e), this._translateViews(), this._resetLocation(), this._renderNavigator(), this._setViewContoured(t), this._updateAriaId(t), this._selectionStrategy.updateAriaSelected();
  }
  _rearrangeViews(e) {
    var t;
    if (e === 0)
      return;
    const {
      viewsCount: n
    } = this.option();
    let s, o, r, a, l;
    if (e < 0 ? (s = 1, o = "_beforeView", r = "_afterView", a = "_view", l = n === 1 ? "_view" : "_additionalView") : (s = -1, o = "_afterView", r = "_beforeView", a = n === 1 ? "_view" : "_additionalView", l = "_view"), !this[o])
      return;
    const d = this[o].option("date");
    (t = this[r]) === null || t === void 0 || t.$element().remove(), this[r] = this._renderSpecificView(this._getDateByOffset(s * n, d)), this[l].$element().remove(), n === 1 ? this[l] = this[o] : (this[l] = this[a], this[a] = this[o]);
    const u = this._getDateByOffset(-s, d);
    this[o] = this._isViewAvailable(u) ? this._renderSpecificView(u) : null;
  }
  _resetLocation() {
    Ot(this._$viewsWrapper, {
      left: 0,
      top: 0
    });
  }
  _clean() {
    super._clean(), this._clearViewWidthCache(), delete this._$viewsWrapper, delete this._navigator, delete this._$footer;
  }
  _clearViewWidthCache() {
    delete this._viewWidthValue;
  }
  _disposeViews() {
    var e, t, n;
    this._view.$element().remove(), (e = this._beforeView) === null || e === void 0 || e.$element().remove(), (t = this._additionalView) === null || t === void 0 || t.$element().remove(), (n = this._afterView) === null || n === void 0 || n.$element().remove(), delete this._view, delete this._additionalView, delete this._beforeView, delete this._afterView, delete this._skipNavigate;
  }
  _dispose() {
    clearTimeout(this._waitRenderViewTimeout), super._dispose();
  }
  _refreshViews() {
    this._resetActiveState(), this._disposeViews(), this._renderViews();
  }
  _visibilityChanged() {
    this._translateViews();
  }
  _shouldSkipFocusEvent(e) {
    const {
      target: t,
      relatedTarget: n
    } = e;
    return p(t).parents(".dx-calendar").length && p(n).parents(".dx-calendar").length;
  }
  _focusInHandler(e) {
    p(e.target).is(this._$viewsWrapper) && this._setViewContoured(this.option("currentDate")), !this._shouldSkipFocusEvent(e) && (super._focusInHandler.apply(this, arguments), this._toggleFocusClass(!0, this.$element()));
  }
  _focusOutHandler(e) {
    if (p(e.target).is(this._$viewsWrapper)) {
      var t;
      this._view.option("contouredDate", null), (t = this._additionalView) === null || t === void 0 || t.option("contouredDate", null);
    }
    this._shouldSkipFocusEvent(e) || (super._focusOutHandler.apply(this, arguments), this._toggleFocusClass(!1, this.$element()));
  }
  _updateViewsOption(e, t) {
    var n, s, o;
    this._view.option(e, t), (n = this._additionalView) === null || n === void 0 || n.option(e, t), (s = this._beforeView) === null || s === void 0 || s.option(e, t), (o = this._afterView) === null || o === void 0 || o.option(e, t);
  }
  _setViewsMinOption(e) {
    this._restoreViewsMinMaxOptions(), this.option("_rangeMin", this._convertToDate(e)), this._updateViewsOption("min", this._getMinDate());
  }
  _setViewsMaxOption(e) {
    this._restoreViewsMinMaxOptions(), this.option("_rangeMax", this._convertToDate(e)), this._updateViewsOption("max", this._getMaxDate());
  }
  _restoreViewsMinMaxOptions() {
    this._resetActiveState(), this.option({
      _rangeMin: null,
      _rangeMax: null
    }), this._updateViewsOption("min", this._getMinDate()), this._updateViewsOption("max", this._getMaxDate());
  }
  _updateNavigatorLabels() {
    let {
      zoomLevel: e
    } = this.option();
    e = e.charAt(0).toUpperCase() + e.slice(1);
    const t = this._navigator._caption.option("text"), n = S.format(`dxCalendar-previous${e}ButtonLabel`), s = S.format(`dxCalendar-caption${e}Label`), o = S.format(`dxCalendar-next${e}ButtonLabel`);
    this.setAria("label", n, this._navigator._prevButton.$element()), this.setAria("label", `${t}. ${s}`, this._navigator._caption.$element()), this.setAria("label", o, this._navigator._nextButton.$element());
  }
  _updateAriaSelected(e, t) {
    t.forEach((s) => {
      this.setAria("selected", !1, this._view._getCellByDate(s));
    }), e.forEach((s) => {
      this.setAria("selected", !0, this._view._getCellByDate(s));
    });
    const {
      viewsCount: n
    } = this.option();
    n > 1 && (t.forEach((s) => {
      this.setAria("selected", !1, this._additionalView._getCellByDate(s));
    }), e.forEach((s) => {
      this.setAria("selected", !0, this._additionalView._getCellByDate(s));
    }));
  }
  _updateAriaId(e) {
    var t;
    e = e ?? this.option("currentDate");
    const n = `dx-${new Xe()}`, o = this._getActiveView(e)._getCellByDate(e);
    this.setAria("id", n, o), this.setAria("activedescendant", n), (t = this._onContouredChanged) === null || t === void 0 || t.call(this, n);
  }
  _suppressingNavigation(e, t) {
    this._suppressNavigation = !0, e.apply(this, t), delete this._suppressNavigation;
  }
  _optionChanged(e) {
    const {
      value: t,
      previousValue: n
    } = e;
    switch (e.name) {
      case "width":
        super._optionChanged(e), this._clearViewWidthCache();
        break;
      case "min":
      case "max":
        this.min = void 0, this.max = void 0, this._suppressingNavigation(this._updateCurrentDate, [this.option("currentDate")]), this._refreshViews(), this._renderNavigator();
        break;
      case "selectionMode":
        this._refreshSelectionStrategy(), this._initCurrentDate();
        break;
      case "selectWeekOnClick":
      case "_todayDate":
      case "showWeekNumbers":
      case "weekNumberRule":
        this._refreshViews();
        break;
      case "firstDayOfWeek":
        this._refreshViews(), this._updateButtonsVisibility();
        break;
      case "focusStateEnabled":
      case "disabledDates":
      case "dateSerializationFormat":
      case "cellTemplate":
      case "showTodayButton":
        this._invalidate();
        break;
      case "currentDate":
        this.setAria("id", void 0, this._view._getCellByDate(n)), this._updateCurrentDate(t);
        break;
      case "zoomLevel":
        this.$element().removeClass(`dx-calendar-view-${n}`), this._correctZoomLevel(), this._refreshViews(), this._renderNavigator(), this._updateAriaId(), this._updateNavigatorLabels();
        break;
      case "minZoomLevel":
      case "maxZoomLevel":
        this._correctZoomLevel(), this._updateButtonsVisibility();
        break;
      case "value": {
        j.sameDatesArrays(t, n) || this._selectionStrategy.processValueChanged(t, n), this._setSubmitValue(t), super._optionChanged(e);
        break;
      }
      case "viewsCount":
        this._refreshViews(), this._renderNavigator();
        break;
      case "onCellClick":
        this._view.option("onCellClick", t);
        break;
      case "onContouredChanged":
        this._onContouredChanged = this._createActionByOption("onContouredChanged");
        break;
      case "readOnly":
        super._optionChanged(e), this._updateAriaLabelAndRole();
        break;
      case "skipFocusCheck":
        break;
      default:
        super._optionChanged(e);
    }
  }
  getContouredDate() {
    const {
      contouredDate: e
    } = this._view.option();
    return e;
  }
}
xe("dxCalendar", FA);
class yh extends se.inherit({}) {
  ctor(e) {
    this.dateBox = e;
  }
  widgetOption(e) {
    var t;
    return (t = this._widget) === null || t === void 0 ? void 0 : t.option.apply(this._widget, arguments);
  }
  _renderWidget(e) {
    e = e || p("<div>"), this._widget = this._createWidget(e), this._widget.$element().appendTo(this._getWidgetContainer());
  }
  _createWidget(e) {
    const t = this._getWidgetName(), n = this._getWidgetOptions();
    return this.dateBox._createComponent(e, t, n);
  }
  _getWidgetOptions() {
    se.abstract();
  }
  _getWidgetName() {
    se.abstract();
  }
  getDefaultOptions() {
    return {
      mode: "text"
    };
  }
  getDisplayFormat(e) {
    se.abstract();
  }
  supportedKeys() {
  }
  getKeyboardListener() {
  }
  customizeButtons() {
  }
  getParsedText(e, t) {
    return ue.parse(e, t) || ue.parse(e);
  }
  renderInputMinMax() {
  }
  renderOpenedState() {
    this._updateValue();
  }
  popupConfig(e) {
    se.abstract();
  }
  _dimensionChanged() {
    var e;
    (e = this._getPopup()) === null || e === void 0 || e.repaint();
  }
  renderPopupContent() {
    const e = this._getPopup();
    this._renderWidget();
    const t = e.$content().parent();
    _.off(t, "mousedown"), _.on(t, "mousedown", this._preventFocusOnPopup.bind(this));
  }
  _preventFocusOnPopup(e) {
    e.preventDefault();
  }
  _getWidgetContainer() {
    return this._getPopup().$content();
  }
  _getPopup() {
    return this.dateBox._popup;
  }
  popupShowingHandler() {
  }
  popupHiddenHandler() {
  }
  _updateValue(e) {
    var t;
    (t = this._widget) === null || t === void 0 || t.option("value", this.dateBoxValue());
  }
  useCurrentDateByDefault() {
  }
  getDefaultDate() {
    return /* @__PURE__ */ new Date();
  }
  textChangedHandler() {
  }
  renderValue() {
    this.dateBox.option("opened") && this._updateValue();
  }
  getValue() {
    return this._widget.option("value");
  }
  isAdaptivityChanged() {
    return !1;
  }
  dispose() {
    const e = this._getPopup();
    e && e.$content().empty();
  }
  dateBoxValue(e, t) {
    return arguments.length ? this.dateBox.dateValue.apply(this.dateBox, arguments) : this.dateBox.dateOption.apply(this.dateBox, ["value"]);
  }
}
class kA extends yh {
  ctor(e) {
    super.ctor(e), this.NAME = "Calendar";
  }
  getDefaultOptions() {
    return I({}, super.getDefaultOptions(), {
      todayButtonText: S.format("dxCalendar-todayButtonText")
    });
  }
  supportedKeys() {
    const e = function(t) {
      return this.option("opened") ? (t.preventDefault(), !0) : !1;
    };
    return {
      rightArrow() {
        if (this.option("opened"))
          return !0;
      },
      leftArrow() {
        if (this.option("opened"))
          return !0;
      },
      enter: function(t) {
        if (this.dateBox.option("opened")) {
          if (t.preventDefault(), this._widget.option("zoomLevel") === this._widget.option("maxZoomLevel")) {
            const n = this._getContouredValue(), s = this._lastActionElement, o = this._closeDropDownByEnter();
            return o && n && s === "calendar" && this.dateBoxValue(n, t), o && this.dateBox.close(), this.dateBox._valueChangeEventHandler(t), !o;
          }
          return !0;
        }
        this.dateBox._valueChangeEventHandler(t);
      }.bind(this),
      home: e,
      end: e
    };
  }
  getDisplayFormat(e) {
    return e || "shortdate";
  }
  _closeDropDownByEnter() {
    return !0;
  }
  _getWidgetName() {
    return FA;
  }
  _getContouredValue() {
    return this._widget._view.option("contouredDate");
  }
  getKeyboardListener() {
    return this._widget;
  }
  _getWidgetOptions() {
    const e = this.dateBox.option("disabledDates");
    return x(this.dateBox.option("calendarOptions"), {
      value: this.dateBoxValue() || null,
      selectionMode: "single",
      dateSerializationFormat: null,
      min: this.dateBox.dateOption("min"),
      max: this.dateBox.dateOption("max"),
      onValueChanged: this._valueChangedHandler.bind(this),
      onCellClick: this._cellClickHandler.bind(this),
      disabledDates: B(e) ? this._injectComponent(e.bind(this.dateBox)) : e,
      onContouredChanged: this._refreshActiveDescendant.bind(this),
      skipFocusCheck: !0
    });
  }
  _injectComponent(e) {
    const t = this;
    return function(n) {
      return x(n, {
        component: t.dateBox
      }), e(n);
    };
  }
  _refreshActiveDescendant(e) {
    this._lastActionElement = "calendar", this.dateBox.setAria("activedescendant", e.actionValue);
  }
  _getTodayButtonConfig() {
    const e = this.dateBox.option("buttonsLocation"), n = e === "default" ? ["bottom", "center"] : er(e), s = Zt() ? "text" : "outlined";
    return {
      widget: "dxButton",
      toolbar: n[0],
      location: n[1] === "after" ? "before" : n[1],
      options: {
        onClick: (o) => {
          this._widget._toTodayView(o);
        },
        text: this.dateBox.option("todayButtonText"),
        elementAttr: {
          class: "dx-button-today"
        },
        stylingMode: s
      }
    };
  }
  _isCalendarVisible() {
    const {
      calendarOptions: e
    } = this.dateBox.option();
    return en(e) || e.visible !== !1;
  }
  _getPopupToolbarItems(e) {
    return this.dateBox.option("applyValueMode") === "useButtons" && this._isCalendarVisible() ? [this._getTodayButtonConfig(), ...e] : e;
  }
  popupConfig(e) {
    return x(!0, e, {
      position: {
        collision: "flipfit flip"
      },
      width: "auto"
    });
  }
  _valueChangedHandler(e) {
    const {
      value: t
    } = e, n = e.previousValue;
    j.sameDate(t, n) && j.sameHoursAndMinutes(t, n) || this.dateBox.option("applyValueMode") === "instantly" && this.dateBoxValue(this.getValue(), e.event);
  }
  _updateValue(e) {
    this._widget && this._widget.option("value", this.dateBoxValue());
  }
  textChangedHandler() {
    this._lastActionElement = "input", this.dateBox.option("opened") && this._widget && this._updateValue(!0);
  }
  _cellClickHandler(e) {
    const {
      dateBox: t
    } = this;
    t.option("applyValueMode") === "instantly" && (t.option("opened", !1), this.dateBoxValue(this.getValue(), e.event));
  }
}
const S9 = {
  row: "minWidth",
  col: "minHeight"
}, E9 = {
  row: "maxWidth",
  col: "maxHeight"
}, Tw = {
  start: "flex-start",
  end: "flex-end",
  center: "center",
  "space-between": "space-between",
  "space-around": "space-around"
}, Ow = {
  start: "flex-start",
  end: "flex-end",
  center: "center",
  stretch: "stretch"
}, I9 = {
  row: "row",
  col: "column"
}, br = (i, e, t) => {
  if (t = yl(e, t), i.style[tr(e)] = t, !ae()) {
    if (t === "" || !f(t))
      return;
    const s = `${Hl(e)}: ${t};`;
    JE(i, s, !1);
  }
};
class D9 extends ga {
  _renderVisible(e, t) {
    super._renderVisible(e), f(t) && this._options.fireItemStateChangedAction({
      name: "visible",
      state: e,
      oldState: t
    });
  }
}
class T9 {
  constructor(e, t) {
    this._$element = e, this._option = t;
  }
  renderBox() {
    this._$element.css({
      display: `${wu("flexDirection")}flex`
    }), br(this._$element.get(0), "flexDirection", I9[this._option("direction")]);
  }
  renderAlign() {
    this._$element.css({
      justifyContent: this._normalizedAlign()
    });
  }
  _normalizedAlign() {
    const e = this._option("align");
    return e in Tw ? Tw[e] : e;
  }
  renderCrossAlign() {
    this._$element.css({
      alignItems: this._normalizedCrossAlign()
    });
  }
  _normalizedCrossAlign() {
    const e = this._option("crossAlign");
    return e in Ow ? Ow[e] : e;
  }
  renderItems(e) {
    const t = wu("flexDirection"), n = this._option("direction");
    y(e, function() {
      const s = p(this), o = s.data("dxBoxItemData");
      s.css({
        display: `${t}flex`
      }).css(E9[n], o.maxSize || "none").css(S9[n], o.minSize || "0"), br(s.get(0), "flexBasis", o.baseSize || 0), br(s.get(0), "flexGrow", o.ratio), br(s.get(0), "flexShrink", f(o.shrink) ? o.shrink : 1), s.children().each((r, a) => {
        p(a).css({
          width: "auto",
          height: "auto",
          display: `${wu("flexDirection")}flex`,
          flexBasis: 0
        }), br(a, "flexGrow", 1), br(a, "flexDirection", p(a)[0].style.flexDirection || "column");
      });
    });
  }
}
class Js extends vd {
  _getDefaultOptions() {
    return x(super._getDefaultOptions(), {
      direction: "row",
      align: "start",
      crossAlign: "stretch",
      activeStateEnabled: !1,
      focusStateEnabled: !1,
      onItemStateChanged: void 0,
      _queue: void 0
    });
  }
  _itemClass() {
    return "dx-box-item";
  }
  _itemDataKey() {
    return "dxBoxItemData";
  }
  _itemElements() {
    return this._itemContainer().children(this._itemSelector());
  }
  _init() {
    super._init(), this.$element().addClass("dx-box-flex"), this._initLayout(), this._initBoxQueue();
  }
  _initLayout() {
    this._layout = new T9(this.$element(), this.option.bind(this));
  }
  _initBoxQueue() {
    this._queue = this.option("_queue") || [];
  }
  _queueIsNotEmpty() {
    return this.option("_queue") ? !1 : !!this._queue.length;
  }
  _pushItemToQueue(e, t) {
    this._queue.push({
      $item: e,
      config: t
    });
  }
  _shiftItemFromQueue() {
    return this._queue.shift();
  }
  _initMarkup() {
    this.$element().addClass("dx-box"), this._layout.renderBox(), super._initMarkup(), this._renderAlign(), this._renderActions();
  }
  _renderActions() {
    this._onItemStateChanged = this._createActionByOption("onItemStateChanged");
  }
  _renderAlign() {
    this._layout.renderAlign(), this._layout.renderCrossAlign();
  }
  _renderItems(e) {
    for (super._renderItems(e); this._queueIsNotEmpty(); ) {
      const t = this._shiftItemFromQueue();
      this._createComponent(t.$item, Js, x({
        itemTemplate: this.option("itemTemplate"),
        itemHoldTimeout: this.option("itemHoldTimeout"),
        onItemHold: this.option("onItemHold"),
        onItemClick: this.option("onItemClick"),
        onItemContextMenu: this.option("onItemContextMenu"),
        onItemRendered: this.option("onItemRendered"),
        _queue: this._queue
      }, t.config));
    }
    this._layout.renderItems(this._itemElements());
  }
  _renderItemContent(e) {
    const t = e.itemData && e.itemData.node;
    return t ? this._renderItemContentByNode(e, t) : super._renderItemContent(e);
  }
  _postprocessRenderItem(e) {
    const t = e.itemData.box;
    t && this._pushItemToQueue(e.itemContent, t);
  }
  _createItemByTemplate(e, t) {
    return t.itemData.box ? e.source ? e.source() : p() : super._createItemByTemplate(e, t);
  }
  _itemOptionChanged(e, t, n, s) {
    t === "visible" && this._onItemStateChanged({
      name: t,
      state: n,
      oldState: s !== !1
    }), super._itemOptionChanged(e, t, n);
  }
  _optionChanged(e) {
    switch (e.name) {
      case "_queue":
      case "direction":
        this._invalidate();
        break;
      case "align":
        this._layout.renderAlign();
        break;
      case "crossAlign":
        this._layout.renderCrossAlign();
        break;
      default:
        super._optionChanged(e);
    }
  }
  _itemOptions() {
    const e = super._itemOptions();
    return e.fireItemStateChangedAction = (t) => {
      this._onItemStateChanged(t);
    }, e;
  }
}
Js.ItemClass = D9;
xe("dxBox", Js);
const Kp = ["year", "day", "month", "day"], Aw = ["hours", "minutes", "seconds", "milliseconds"], O9 = 864e5, A9 = 31536e6, R9 = function(i) {
  const e = typeof i;
  return e === "string" ? "format" : e === "object" && i.type !== void 0 ? i.type : null;
}, Oe = {
  SUPPORTED_FORMATS: ["date", "time", "datetime"],
  ONE_MINUTE: 6e4,
  ONE_DAY: O9,
  ONE_YEAR: A9,
  MIN_DATEVIEW_DEFAULT_DATE: new Date(1900, 0, 1),
  MAX_DATEVIEW_DEFAULT_DATE: function() {
    const i = /* @__PURE__ */ new Date();
    return new Date(i.getFullYear() + 50, i.getMonth(), i.getDate(), 23, 59, 59);
  }(),
  FORMATS_INFO: {
    date: {
      getStandardPattern: () => "yyyy-MM-dd",
      components: Kp
    },
    time: {
      getStandardPattern: () => "HH:mm",
      components: Aw
    },
    datetime: {
      getStandardPattern() {
        let i;
        return function() {
          const e = p("<input>").attr("type", "datetime");
          e.val("2000-01-01T01:01Z"), e.val() && (i = "yyyy-MM-ddTHH:mmZ");
        }(), i || (i = "yyyy-MM-ddTHH:mm:ssZ"), Oe.FORMATS_INFO.datetime.getStandardPattern = function() {
          return i;
        }, i;
      },
      components: [...Kp, ...Aw]
    },
    "datetime-local": {
      getStandardPattern: () => "yyyy-MM-ddTHH:mm:ss",
      components: [...Kp, "hours", "minutes", "seconds"]
    }
  },
  FORMATS_MAP: {
    date: "shortdate",
    time: "shorttime",
    datetime: "shortdateshorttime"
  },
  SUBMIT_FORMATS_MAP: {
    date: "date",
    time: "time",
    datetime: "datetime-local"
  },
  toStandardDateFormat(i, e) {
    const t = Oe.FORMATS_INFO[e].getStandardPattern();
    return pt.serializeDate(i, t);
  },
  fromStandardDateFormat(i) {
    const e = pt.dateParser(i);
    return cn(e) ? e : void 0;
  },
  getMaxMonthDay: (i, e) => new Date(i, e + 1, 0).getDate(),
  mergeDates(i, e, t) {
    if (!e)
      return e || null;
    if (!i || isNaN(i.getTime())) {
      const o = /* @__PURE__ */ new Date(null);
      i = new Date(o.getFullYear(), o.getMonth(), o.getDate());
    }
    const n = new Date(i.valueOf()), s = Oe.FORMATS_INFO[t];
    return y(s.components, function() {
      const o = Oe.DATE_COMPONENTS_INFO[this];
      n[o.setter](e[o.getter]());
    }), n;
  },
  getLongestCaptionIndex(i) {
    let e = 0, t = 0, n;
    for (n = 0; n < i.length; ++n)
      i[n].length > t && (e = n, t = i[n].length);
    return e;
  },
  formatUsesMonthName: (i) => ue.formatUsesMonthName(i),
  formatUsesDayName: (i) => ue.formatUsesDayName(i),
  getLongestDate(i, e, t) {
    const n = R9(i);
    let s = 9;
    (!n || Oe.formatUsesMonthName(n)) && (s = Oe.getLongestCaptionIndex(e));
    const o = new Date(1888, s, 21, 23, 59, 59, 999);
    if (!n || Oe.formatUsesDayName(n)) {
      const r = o.getDate() - o.getDay() + Oe.getLongestCaptionIndex(t);
      o.setDate(r);
    }
    return o;
  },
  normalizeTime(i) {
    i.setSeconds(0), i.setMilliseconds(0);
  }
};
Oe.DATE_COMPONENTS_INFO = {
  year: {
    getter: "getFullYear",
    setter: "setFullYear",
    formatter(i, e) {
      const t = new Date(e.getTime());
      return t.setFullYear(i), ue.format(t, "yyyy");
    },
    startValue: void 0,
    endValue: void 0
  },
  day: {
    getter: "getDate",
    setter: "setDate",
    formatter(i, e) {
      const t = new Date(e.getTime());
      return t.setDate(i), ue.format(t, "d");
    },
    startValue: 1,
    endValue: void 0
  },
  month: {
    getter: "getMonth",
    setter: "setMonth",
    formatter: (i) => ue.getMonthNames()[i],
    startValue: 0,
    endValue: 11
  },
  hours: {
    getter: "getHours",
    setter: "setHours",
    formatter: (i) => ue.format(new Date(0, 0, 0, i), "hour"),
    startValue: 0,
    endValue: 23
  },
  minutes: {
    getter: "getMinutes",
    setter: "setMinutes",
    formatter: (i) => ue.format(new Date(0, 0, 0, 0, i), "minute"),
    startValue: 0,
    endValue: 59
  },
  seconds: {
    getter: "getSeconds",
    setter: "setSeconds",
    formatter: (i) => ue.format(new Date(0, 0, 0, 0, 0, i), "second"),
    startValue: 0,
    endValue: 59
  },
  milliseconds: {
    getter: "getMilliseconds",
    setter: "setMilliseconds",
    formatter: (i) => ue.format(new Date(0, 0, 0, 0, 0, 0, i), "millisecond"),
    startValue: 0,
    endValue: 999
  }
};
const Rw = function(i, e, t) {
  F9(i, e, t);
}, F9 = function(i, e, t) {
  i.css("transform", `rotate(${e}deg) translate(0,${t}px)`);
};
class VA extends ci {
  _getDefaultOptions() {
    return I({}, super._getDefaultOptions(), {
      value: new Date(Date.now()),
      use24HourFormat: !0,
      _showClock: !0,
      _arrowOffset: 5
    });
  }
  _getValue() {
    const {
      value: e
    } = this.option();
    return e || /* @__PURE__ */ new Date();
  }
  _init() {
    super._init(), this.$element().addClass("dx-timeview");
  }
  _render() {
    super._render(), this._renderBox(), this._updateTime();
  }
  _renderBox() {
    const e = p("<div>").appendTo(this.$element()), t = [];
    this.option("_showClock") && t.push({
      ratio: 1,
      shrink: 0,
      baseSize: "auto",
      template: this._renderClock.bind(this)
    }), t.push({
      ratio: 0,
      shrink: 0,
      baseSize: "auto",
      template: this._renderField.bind(this)
    }), this._createComponent(e, Js, {
      height: "100%",
      width: "100%",
      direction: "col",
      items: t
    });
  }
  _renderClock(e, t, n) {
    this._$hourArrow = p("<div>").addClass("dx-timeview-hourarrow"), this._$minuteArrow = p("<div>").addClass("dx-timeview-minutearrow");
    const s = p(n);
    s.addClass("dx-timeview-clock").append(this._$hourArrow).append(this._$minuteArrow), this.setAria("role", "presentation", s);
  }
  _updateClock() {
    const e = this._getValue(), t = e.getHours() / 12 * 360 + e.getMinutes() / 60 * 30, n = e.getMinutes() / 60 * 360;
    Rw(this._$hourArrow, t, this.option("_arrowOffset")), Rw(this._$minuteArrow, n, this.option("_arrowOffset"));
  }
  _getBoxItems(e) {
    const t = [{
      ratio: 0,
      shrink: 0,
      baseSize: "auto",
      template: () => this._hourBox.$element()
    }, {
      ratio: 0,
      shrink: 0,
      baseSize: "auto",
      template: p("<div>").addClass("dx-timeview-time-separator").text(ue.getTimeSeparator())
    }, {
      ratio: 0,
      shrink: 0,
      baseSize: "auto",
      template: () => this._minuteBox.$element()
    }];
    return e && t.push({
      ratio: 0,
      shrink: 0,
      baseSize: "auto",
      template: () => this._format12.$element()
    }), t;
  }
  _renderField() {
    const e = !this.option("use24HourFormat");
    return this._createHourBox(e), this._createMinuteBox(), e && this._createFormat12Box(), this._createComponent(p("<div>").addClass("dx-timeview-field"), Js, {
      direction: "row",
      align: "center",
      crossAlign: "center",
      items: this._getBoxItems(e)
    }).$element();
  }
  _createHourBox(e) {
    this._hourBox = this._createComponent(p("<div>"), Sc, I({
      min: -1,
      max: e ? 13 : 24,
      value: this._getValue().getHours(),
      onValueChanged: this._onHourBoxValueChanged.bind(this),
      onKeyboardHandled: (t) => this._keyboardHandler(t)
    }, this._getNumberBoxConfig())), this._hourBox.setAria("label", "hours");
  }
  _isPM() {
    return !this.option("use24HourFormat") && this._format12.option("value") === 1;
  }
  _onHourBoxValueChanged(e) {
    let {
      value: t,
      component: n
    } = e;
    const s = this._getValue(), o = new Date(s);
    let r = this._convertMaxHourToMin(t);
    n.option("value", r), this._isPM() && (r += 12), o.setHours(r), Oe.normalizeTime(o), this.option("value", o);
  }
  _convertMaxHourToMin(e) {
    const t = this.option("use24HourFormat") ? 24 : 12;
    return (t + e) % t;
  }
  _createMinuteBox() {
    this._minuteBox = this._createComponent(p("<div>"), Sc, I({
      min: -1,
      max: 60,
      value: this._getValue().getMinutes(),
      onKeyboardHandled: (e) => this._keyboardHandler(e),
      onValueChanged: (e) => {
        let {
          value: t,
          component: n
        } = e;
        const s = (60 + t) % 60;
        n.option("value", s);
        const o = new Date(this._getValue());
        o.setMinutes(s), Oe.normalizeTime(o), this.option("value", o);
      }
    }, this._getNumberBoxConfig())), this._minuteBox.setAria("label", "minutes");
  }
  _createFormat12Box() {
    const e = ue.getPeriodNames();
    this._format12 = this._createComponent(p("<div>").addClass("dx-timeview-format12"), mC, {
      items: [{
        value: -1,
        text: e[0]
      }, {
        value: 1,
        text: e[1]
      }],
      valueExpr: "value",
      displayExpr: "text",
      onKeyboardHandled: (t) => this._keyboardHandler(t),
      onValueChanged: (t) => {
        let {
          value: n
        } = t;
        const s = this._getValue().getHours(), o = new Date(this._getValue()), r = (s + 12 * n) % 24;
        o.setHours(r), this.option("value", o);
      },
      value: this._getValue().getHours() >= 12 ? 1 : -1,
      stylingMode: this.option("stylingMode")
    }), this._format12.setAria("label", "type");
  }
  _refreshFormat12() {
    if (this.option("use24HourFormat"))
      return;
    const s = this._getValue().getHours() >= 12 ? 1 : -1;
    this._silentEditorValueUpdate(this._format12, s);
  }
  _silentEditorValueUpdate(e, t) {
    e && (e._suppressValueChangeAction(), e.option("value", t), e._resumeValueChangeAction());
  }
  _getNumberBoxConfig() {
    const {
      stylingMode: e
    } = this.option();
    return {
      showSpinButtons: !0,
      displayValueFormatter: (t) => (t < 10 ? "0" : "") + t,
      stylingMode: e
    };
  }
  _normalizeHours(e) {
    return this.option("use24HourFormat") ? e : e % 12 || 12;
  }
  _updateField() {
    const e = this._normalizeHours(this._getValue().getHours());
    this._silentEditorValueUpdate(this._hourBox, e), this._silentEditorValueUpdate(this._minuteBox, this._getValue().getMinutes()), this._refreshFormat12();
  }
  _updateTime() {
    this.option("_showClock") && this._updateClock(), this._updateField();
  }
  _visibilityChanged(e) {
    e && this._updateTime();
  }
  _optionChanged(e) {
    switch (e.name) {
      case "value":
        this._updateTime(), super._optionChanged(e);
        break;
      case "_arrowOffset":
        break;
      case "use24HourFormat":
      case "_showClock":
      case "stylingMode":
        this._invalidate();
        break;
      default:
        super._optionChanged(e);
    }
  }
}
xe("dxTimeView", VA);
const k9 = fe(), Fw = "dx-datebox-datetime-time-side";
class V9 extends kA {
  ctor(e) {
    super.ctor(e), this.NAME = "CalendarWithTime";
  }
  getDefaultOptions() {
    return I({}, super.getDefaultOptions(), {
      applyValueMode: "useButtons",
      buttonsLocation: "bottom after",
      "dropDownOptions.showTitle": !1
    });
  }
  _closeDropDownByEnter() {
    return j.sameDate(this._getContouredValue(), this.widgetOption("value"));
  }
  getDisplayFormat(e) {
    return e || "shortdateshorttime";
  }
  _is24HourFormat() {
    return ue.is24HourFormat(this.getDisplayFormat(this.dateBox.option("displayFormat")));
  }
  _getContouredValue() {
    const e = super._getContouredValue();
    return this._updateDateTime(e);
  }
  _renderWidget() {
    super._renderWidget(), this._timeView = this.dateBox._createComponent(p("<div>"), VA, {
      value: this.dateBoxValue(),
      _showClock: !this._isShrinkView(),
      use24HourFormat: this._is24HourFormat(),
      onValueChanged: this._valueChangedHandler.bind(this),
      stylingMode: this.dateBox.option("stylingMode")
    });
  }
  renderOpenedState() {
    super.renderOpenedState();
    const e = this._getPopup();
    e && e.$wrapper().toggleClass("dx-datebox-adaptivity-mode", this._isSmallScreen()), clearTimeout(this._repaintTimer), this._repaintTimer = setTimeout(() => {
      var t;
      (t = this._getPopup()) === null || t === void 0 || t.repaint();
    }, 0);
  }
  isAdaptivityChanged() {
    const e = this._isShrinkView(), t = this._currentAdaptiveMode;
    return e !== t ? (this._currentAdaptiveMode = e, t !== void 0) : super.isAdaptivityChanged();
  }
  _updateValue(e) {
    let t = this.dateBoxValue();
    !t && !e && (t = /* @__PURE__ */ new Date(), Oe.normalizeTime(t)), super._updateValue(), this._timeView && (t && this._timeView.option("value", t), this._timeView.option("use24HourFormat", this._is24HourFormat()));
  }
  _isSmallScreen() {
    return ne(k9) <= 573;
  }
  _isShrinkView() {
    return !this.dateBox.option("showAnalogClock") || this.dateBox.option("adaptivityEnabled") && this._isSmallScreen();
  }
  _getBoxItems() {
    const e = [{
      ratio: 0,
      shrink: 0,
      baseSize: "auto",
      name: "calendar"
    }];
    return this._isShrinkView() || e.push({
      ratio: 0,
      shrink: 0,
      baseSize: "auto",
      name: "time"
    }), e;
  }
  renderPopupContent() {
    super.renderPopupContent(), this._currentAdaptiveMode = this._isShrinkView();
    const e = this._getPopup().$content();
    this._box = this.dateBox._createComponent(p("<div>").appendTo(e), Js, {
      direction: "row",
      crossAlign: "stretch",
      items: this._getBoxItems(),
      itemTemplate: function(t, n, s) {
        const o = p("<div>");
        switch (t.name) {
          case "calendar":
            o.append(this._widget.$element()), this._isShrinkView() && (this._timeView.$element().addClass(Fw), o.append(this._timeView.$element()));
            break;
          case "time":
            o.append(this._timeView.$element()), p(s).addClass(Fw);
        }
        return o;
      }.bind(this)
    });
  }
  popupConfig(e) {
    const t = super.popupConfig(e);
    return x(t, {
      width: "auto"
    });
  }
  _preventFocusOnPopup(e) {
    p(e.target).hasClass("dx-texteditor-input") || (super._preventFocusOnPopup.apply(this, arguments), this.dateBox._hasFocusClass() || this.dateBox.focus());
  }
  _updateDateTime(e) {
    const {
      value: t
    } = this._timeView.option();
    return e.setHours(t.getHours(), t.getMinutes(), t.getSeconds(), t.getMilliseconds()), e;
  }
  getValue() {
    let e = this._widget.option("value") ?? this._widget.getContouredDate();
    return e = e ? new Date(e) : /* @__PURE__ */ new Date(), this._updateDateTime(e);
  }
  dispose() {
    clearTimeout(this._removeMinWidthTimer), clearTimeout(this._repaintTimer), super.dispose();
  }
}
class P9 {
  constructor(e) {
    this.DIRECTION_HORIZONTAL = "horizontal", this.DIRECTION_VERTICAL = "vertical", this.DIRECTION_BOTH = "both", this.direction = e ?? xc;
  }
  get isHorizontal() {
    return this.direction === IO || this.direction === Ap;
  }
  get isVertical() {
    return this.direction === xc || this.direction === Ap;
  }
  get isBoth() {
    return this.direction === Ap;
  }
}
function M9(i, e) {
  if (pe(i)) {
    const s = Qe(i.left, i.x), o = Qe(i.top, i.y);
    return {
      left: f(s) ? s : void 0,
      top: f(o) ? o : void 0
    };
  }
  const {
    isVertical: t,
    isHorizontal: n
  } = new P9(e);
  return {
    left: n && f(i) ? i : void 0,
    top: t && f(i) ? i : void 0
  };
}
class PA extends Qt {
  _getDefaultOptions() {
    return I({}, super._getDefaultOptions(), {
      showScrollbar: "never",
      useNative: !1,
      selectedIndex: 0,
      bounceEnabled: !1,
      items: [],
      showOnClick: !1,
      onClick: null,
      onSelectedIndexChanged: null,
      scrollByContent: !0
    });
  }
  _init() {
    super._init(), this.option("onVisibilityChange", this._visibilityChangedHandler.bind(this)), this.option("onEnd", this._endActionHandler.bind(this));
  }
  _render() {
    super._render(), this._renderSelectedItemFrame(), this.$element().addClass("dx-dateviewroller"), this._renderContainerClick(), this._renderItems(), this._renderSelectedValue(), this._renderItemsClick(), this._renderWheelEvent(), this._renderSelectedIndexChanged();
  }
  _renderSelectedIndexChanged() {
    this._selectedIndexChanged = this._createActionByOption("onSelectedIndexChanged");
  }
  _renderWheelEvent() {
    _.on(p(this.container()), "dxmousewheel", (e) => {
      this._isWheelScrolled = !0;
    });
  }
  _renderContainerClick() {
    if (!this.option("showOnClick"))
      return;
    const e = R(Te, this.NAME), t = this._createActionByOption("onClick");
    _.off(p(this.container()), e), _.on(p(this.container()), e, (n) => {
      t({
        event: n
      });
    });
  }
  _renderItems() {
    const e = this.option("items") || [];
    let t = p();
    p(this.content()).empty(), e.forEach((n) => {
      t = t.add(p("<div>").addClass("dx-dateview-item").append(n));
    }), p(this.content()).append(t), this._$items = t, this.update();
  }
  _renderSelectedItemFrame() {
    p("<div>").addClass("dx-dateview-item-selected-frame").append(p("<div>").addClass("dx-dateview-item-selected-border")).appendTo(p(this.container()));
  }
  _renderSelectedValue(e) {
    const t = this._fitIndex(e ?? this.option("selectedIndex"));
    this._moveTo({
      top: this._getItemPosition(t)
    }), this._renderActiveStateItem();
  }
  _fitIndex(e) {
    const n = (this.option("items") || []).length;
    return e >= n ? n - 1 : e < 0 ? 0 : e;
  }
  _getItemPosition(e) {
    return Math.round(this._itemHeight() * e);
  }
  _renderItemsClick() {
    const e = this._getItemSelector(), t = R(Te, this.NAME);
    _.off(this.$element(), t, e), _.on(this.$element(), t, e, this._itemClickHandler.bind(this));
  }
  _getItemSelector() {
    return ".dx-dateview-item";
  }
  _itemClickHandler(e) {
    this.option("selectedIndex", this._itemElementIndex(e.currentTarget));
  }
  _itemElementIndex(e) {
    return this._itemElements().index(e);
  }
  _itemElements() {
    return this.$element().find(this._getItemSelector());
  }
  _renderActiveStateItem() {
    const e = this.option("selectedIndex");
    y(this._$items, function(t) {
      p(this).toggleClass("dx-dateview-item-selected", e === t);
    });
  }
  _shouldScrollToNeighborItem() {
    return z.real().deviceType === "desktop" && this._isWheelScrolled;
  }
  _moveTo(e) {
    const {
      top: t,
      left: n
    } = M9(e), s = this.scrollOffset(), o = {
      x: s.left - n,
      y: s.top - t
    };
    if (this._isVisible() && (o.x || o.y))
      if (this._prepareDirections(!0), this._animation && !this._shouldScrollToNeighborItem()) {
        const r = this;
        Le.stop(p(this.content())), Le.animate(p(this.content()), {
          duration: 200,
          type: "slide",
          to: {
            top: Math.floor(o.y)
          },
          complete() {
            id(p(r.content())), r.handleMove({
              delta: o
            });
          }
        }), delete this._animation;
      } else
        this.handleMove({
          delta: o
        });
  }
  _validate(e) {
    return this._moveIsAllowed(e);
  }
  _fitSelectedIndexInRange(e) {
    const t = this.option("items").length;
    return Math.max(Math.min(e, t - 1), 0);
  }
  _isInNullNeighborhood(e) {
    return -0.1 <= e && e <= 0.1;
  }
  _getSelectedIndexAfterScroll(e) {
    const t = this.scrollOffset().top, n = e * this._itemHeight(), s = t - n;
    if (this._isInNullNeighborhood(s))
      return e;
    const o = s > 0 ? 1 : -1;
    return this._fitSelectedIndexInRange(e + o);
  }
  _getNewSelectedIndex(e) {
    if (this._shouldScrollToNeighborItem())
      return this._getSelectedIndexAfterScroll(e);
    this._animation = !0;
    const t = this.scrollOffset().top / this._itemHeight();
    return Math.round(t);
  }
  _endActionHandler() {
    const e = this.option("selectedIndex"), t = this._getNewSelectedIndex(e);
    t === e ? this._renderSelectedValue(t) : this.option("selectedIndex", t), this._isWheelScrolled = !1;
  }
  _itemHeight() {
    const e = this._$items.first();
    return le(e);
  }
  _toggleActive(e) {
    this.$element().toggleClass("dx-state-active", e);
  }
  _isVisible() {
    return p(this.container()).is(":visible");
  }
  _fireSelectedIndexChanged(e, t) {
    var n;
    (n = this._selectedIndexChanged) === null || n === void 0 || n.call(this, {
      value: e,
      previousValue: t,
      event: void 0
    });
  }
  _visibilityChanged(e) {
    super._visibilityChanged(e), this._visibilityChangedHandler(e);
  }
  _visibilityChangedHandler(e) {
    e && (this._visibilityTimer = setTimeout(() => {
      this._renderSelectedValue(this.option("selectedIndex"));
    })), this.toggleActiveState(!1);
  }
  toggleActiveState(e) {
    this.$element().toggleClass("dx-dateviewroller-current", e);
  }
  _refreshSelectedIndex() {
    const e = this.option("selectedIndex"), t = this._fitIndex(e);
    t === e ? this._renderActiveStateItem() : this.option("selectedIndex", t);
  }
  _optionChanged(e) {
    switch (e.name) {
      case "selectedIndex":
        this._fireSelectedIndexChanged(e.value, e.previousValue), this._renderSelectedValue(e.value);
        break;
      case "items":
        this._renderItems(), this._refreshSelectedIndex();
        break;
      case "onClick":
      case "showOnClick":
        this._renderContainerClick();
        break;
      case "onSelectedIndexChanged":
        this._renderSelectedIndexChanged();
        break;
      default:
        super._optionChanged(e);
    }
  }
  _dispose() {
    clearTimeout(this._visibilityTimer), super._dispose();
  }
}
xe("dxDateViewRoller", PA);
const kw = {
  date: "date",
  datetime: "datetime",
  time: "time"
}, mn = {
  year: "year",
  month: "month",
  day: "day",
  hours: "hours"
};
class MA extends ci {
  _valueOption() {
    const {
      value: e
    } = this.option(), t = new Date(e);
    return !e || isNaN(t) ? this._getDefaultDate() : t;
  }
  _getDefaultDate() {
    const e = /* @__PURE__ */ new Date(), {
      type: t
    } = this.option();
    return t === kw.date ? new Date(e.getFullYear(), e.getMonth(), e.getDate()) : e;
  }
  _getDefaultOptions() {
    return I({}, super._getDefaultOptions(), {
      minDate: Oe.MIN_DATEVIEW_DEFAULT_DATE,
      maxDate: Oe.MAX_DATEVIEW_DEFAULT_DATE,
      type: kw.date,
      value: /* @__PURE__ */ new Date(),
      applyCompactClass: !1
    });
  }
  _defaultOptionsRules() {
    return super._defaultOptionsRules().concat([{
      device: (e) => e.deviceType !== "desktop",
      options: {
        applyCompactClass: !0
      }
    }]);
  }
  _render() {
    super._render(), this.$element().addClass("dx-dateview");
    const {
      type: e
    } = this.option();
    this._toggleFormatClasses(e), this._toggleCompactClass();
  }
  _toggleFormatClasses(e, t) {
    this.$element().addClass(`dx-dateview-${e}`), t && this.$element().removeClass(`dx-dateview-${t}`);
  }
  _toggleCompactClass() {
    const {
      applyCompactClass: e
    } = this.option();
    this.$element().toggleClass("dx-dateview-compact", e);
  }
  _wrapper() {
    return this._$wrapper;
  }
  _renderContentImpl() {
    this._$wrapper = p("<div>").addClass("dx-dateview-wrapper"), this._renderRollers(), this._$wrapper.appendTo(this.$element());
  }
  _renderRollers() {
    this._$rollersContainer || (this._$rollersContainer = p("<div>").addClass("dx-dateview-rollers")), this._$rollersContainer.empty(), this._createRollerConfigs(), this._rollers = {};
    const e = this;
    y(e._rollerConfigs, (t) => {
      const n = p("<div>").appendTo(e._$rollersContainer).addClass(`dx-dateviewroller-${e._rollerConfigs[t].type}`);
      e._rollers[e._rollerConfigs[t].type] = e._createComponent(n, PA, {
        items: e._rollerConfigs[t].displayItems,
        selectedIndex: e._rollerConfigs[t].selectedIndex,
        showScrollbar: "never",
        scrollByContent: !0,
        onStart(s) {
          s.component._toggleActive(!0), e._setActiveRoller(e._rollerConfigs[t]);
        },
        onEnd(s) {
          s.component._toggleActive(!1);
        },
        onClick(s) {
          const o = s.component;
          o._toggleActive(!0), e._setActiveRoller(e._rollerConfigs[t]), e._setRollerState(e._rollerConfigs[t], o.option("selectedIndex")), o._toggleActive(!1);
        },
        onSelectedIndexChanged(s) {
          const o = s.component;
          e._setRollerState(e._rollerConfigs[t], o.option("selectedIndex"));
        }
      });
    }), e._$rollersContainer.appendTo(e._wrapper());
  }
  _createRollerConfigs(e) {
    const t = this;
    e = e || t.option("type"), t._rollerConfigs = {}, ue.getFormatParts(Oe.FORMATS_MAP[e]).forEach((n) => {
      t._createRollerConfig(n);
    });
  }
  _createRollerConfig(e) {
    const t = Oe.DATE_COMPONENTS_INFO[e], n = this._calculateRollerConfigValueRange(e), {
      startValue: s
    } = n, {
      endValue: o
    } = n, {
      formatter: r
    } = t, a = this._getCurrentDate(), l = {
      type: e,
      setValue: t.setter,
      valueItems: [],
      displayItems: [],
      getIndex: (d) => d[t.getter]() - s
    };
    for (let d = s; d <= o; d++)
      l.valueItems.push(d), l.displayItems.push(r(d, a));
    l.selectedIndex = l.getIndex(a), this._rollerConfigs[e] = l;
  }
  _setActiveRoller(e) {
    const t = e && this._rollers[e.type];
    y(this._rollers, function() {
      this.toggleActiveState(this === t);
    });
  }
  _updateRollersPosition() {
    const e = this;
    y(this._rollers, function(t) {
      const n = e._rollerConfigs[t].getIndex(e._getCurrentDate());
      this.option("selectedIndex", n);
    });
  }
  _setRollerState(e, t) {
    if (t !== e.selectedIndex) {
      const n = e.valueItems[t], {
        setValue: s
      } = e;
      let o = new Date(this._getCurrentDate()), r = o.getDate();
      const a = this.option("minDate"), l = this.option("maxDate");
      e.type === mn.month ? r = Math.min(r, Oe.getMaxMonthDay(o.getFullYear(), n)) : e.type === mn.year && (r = Math.min(r, Oe.getMaxMonthDay(n, o.getMonth()))), o.setDate(r), o[s](n);
      const d = j.normalizeDate(o, a, l);
      o = Oe.mergeDates(d, o, "time"), o = j.normalizeDate(o, a, l), this.option("value", o), e.selectedIndex = t;
    }
    e.type === mn.year && this._refreshRollers(), e.type === mn.month && (this._refreshRoller(mn.day), this._refreshRoller(mn.hours));
  }
  _refreshRoller(e) {
    const t = this._rollers[e];
    if (t) {
      this._createRollerConfig(e);
      const n = this._rollerConfigs[e];
      (e === mn.day || n.displayItems.toString() !== t.option("items").toString()) && t.option({
        items: n.displayItems,
        selectedIndex: n.selectedIndex
      });
    }
  }
  _getCurrentDate() {
    const e = this._valueOption(), t = this.option("minDate"), n = this.option("maxDate");
    return j.normalizeDate(e, t, n);
  }
  _calculateRollerConfigValueRange(e) {
    const t = this._getCurrentDate(), {
      minDate: n,
      maxDate: s
    } = this.option(), o = j.sameYear(t, n), r = o && t.getMonth() === n.getMonth(), a = j.sameYear(t, s), l = a && t.getMonth() === s.getMonth(), d = r && t.getDate() === n.getDate(), u = l && t.getDate() === s.getDate(), c = Oe.DATE_COMPONENTS_INFO[e];
    let {
      startValue: h
    } = c, {
      endValue: g
    } = c;
    return e === mn.year && (h = n.getFullYear(), g = s.getFullYear()), e === mn.month && (o && (h = n.getMonth()), a && (g = s.getMonth())), e === mn.day && (g = Oe.getMaxMonthDay(t.getFullYear(), t.getMonth()), o && r && (h = n.getDate()), a && l && (g = s.getDate())), e === mn.hours && (h = d ? n.getHours() : h, g = u ? s.getHours() : g), {
      startValue: h,
      endValue: g
    };
  }
  _refreshRollers() {
    this._refreshRoller(mn.month), this._refreshRoller(mn.day), this._refreshRoller(mn.hours);
  }
  _optionChanged(e) {
    switch (e.name) {
      case "minDate":
      case "maxDate":
      case "type":
        this._renderRollers(), this._toggleFormatClasses(e.value, e.previousValue);
        break;
      case "visible":
        super._optionChanged(e), e.value && this._renderRollers();
        break;
      case "value":
        this.option("value", this._valueOption()), this._refreshRollers(), this._updateRollersPosition();
        break;
      default:
        super._optionChanged(e);
    }
  }
  _clean() {
    super._clean(), delete this._$rollersContainer;
  }
}
xe("dxDateView", MA);
const B9 = fe();
class $9 extends yh {
  ctor(e) {
    super.ctor(e), this.NAME = "DateView";
  }
  getDefaultOptions() {
    return I({}, super.getDefaultOptions(), {
      openOnFieldClick: !0,
      applyButtonText: S.format("OK"),
      "dropDownOptions.showTitle": !0
    });
  }
  getDisplayFormat(e) {
    return e || Oe.FORMATS_MAP[this.dateBox.option("type")];
  }
  popupConfig(e) {
    return {
      toolbarItems: this.dateBox._popupToolbarItemsConfig(),
      onInitialized: e.onInitialized,
      defaultOptionsRules: [{
        device: {
          platform: "android"
        },
        options: {
          width: 333,
          height: 331
        }
      }, {
        device(t) {
          const {
            platform: n
          } = t;
          return n === "generic" || n === "ios";
        },
        options: {
          width: "auto",
          height: "auto"
        }
      }, {
        device(t) {
          const {
            platform: n
          } = t, {
            phone: s
          } = t;
          return n === "generic" && s;
        },
        options: {
          width: 333,
          maxWidth: "100%",
          maxHeight: "100%",
          height: "auto",
          position: {
            collision: "flipfit flip"
          }
        }
      }, {
        device: {
          platform: "ios",
          phone: !0
        },
        options: {
          width: "100%",
          position: {
            my: "bottom",
            at: "bottom",
            of: B9
          }
        }
      }]
    };
  }
  _renderWidget() {
    if (th(this.dateBox.option("mode")) && this.dateBox._isNativeType() || this.dateBox.option("readOnly")) {
      this._widget && (this._widget.$element().remove(), this._widget = null);
      return;
    }
    const e = this._getPopup();
    if (this._widget)
      this._widget.option(this._getWidgetOptions());
    else {
      const t = p("<div>").appendTo(e.$content());
      this._widget = this._createWidget(t);
    }
    this._widget.$element().appendTo(this._getWidgetContainer());
  }
  _getWidgetName() {
    return MA;
  }
  renderOpenedState() {
    super.renderOpenedState(), this._widget && this._widget.option("value", this._widget._getCurrentDate());
  }
  _getWidgetOptions() {
    return {
      value: this.dateBoxValue() || /* @__PURE__ */ new Date(),
      type: this.dateBox.option("type"),
      minDate: this.dateBox.dateOption("min") || new Date(1900, 0, 1),
      maxDate: this.dateBox.dateOption("max") || new Date(Date.now() + 50 * Oe.ONE_YEAR),
      onDisposing: function() {
        this._widget = null;
      }.bind(this)
    };
  }
}
const N9 = fe(), L9 = {
  min: new Date(0, 0, 0, 0, 0),
  max: new Date(0, 0, 0, 23, 59)
};
class H9 extends yh {
  ctor(e) {
    super.ctor(e), this.NAME = "List";
  }
  supportedKeys() {
    return {
      space: M,
      home: M,
      end: M
    };
  }
  getDefaultOptions() {
    return I({}, super.getDefaultOptions(), {
      applyValueMode: "instantly"
    });
  }
  getDisplayFormat(e) {
    return e || "shorttime";
  }
  popupConfig(e) {
    return e;
  }
  getValue() {
    const e = this._widget.option("selectedIndex");
    if (e === -1)
      return this.dateBox.option("value");
    const t = this._widgetItems[e];
    return this._getDateByItemData(t);
  }
  useCurrentDateByDefault() {
    return !0;
  }
  getDefaultDate() {
    return /* @__PURE__ */ new Date(null);
  }
  popupShowingHandler() {
    this.dateBox._dimensionChanged();
  }
  _renderWidget() {
    super._renderWidget(), this._refreshItems();
  }
  _getWidgetName() {
    return fa;
  }
  _getWidgetOptions() {
    return {
      itemTemplate: this._timeListItemTemplate.bind(this),
      onItemClick: this._listItemClickHandler.bind(this),
      tabIndex: -1,
      onFocusedItemChanged: this._refreshActiveDescendant.bind(this),
      selectionMode: "single"
    };
  }
  _refreshActiveDescendant(e) {
    this.dateBox.setAria("activedescendant", ""), this.dateBox.setAria("activedescendant", e.actionValue);
  }
  _refreshItems() {
    this._widgetItems = this._getTimeListItems(), this._widget.option("items", this._widgetItems);
  }
  renderOpenedState() {
    this._widget && (this._widget.option("focusedElement", null), this._setSelectedItemsByValue(), this._widget.option("templatesRenderAsynchronously") ? this._asyncScrollTimeout = setTimeout(this._scrollToSelectedItem.bind(this)) : this._scrollToSelectedItem());
  }
  dispose() {
    super.dispose(), clearTimeout(this._asyncScrollTimeout);
  }
  _updateValue() {
    this._widget && (this._refreshItems(), this._setSelectedItemsByValue(), this._scrollToSelectedItem());
  }
  _setSelectedItemsByValue() {
    const e = this.dateBoxValue(), t = this._getDateIndex(e);
    t === -1 ? this._widget.option("selectedItems", []) : this._widget.option("selectedIndex", t);
  }
  _scrollToSelectedItem() {
    this._widget.scrollToItem(this._widget.option("selectedIndex"));
  }
  _getDateIndex(e) {
    let t = -1;
    for (let n = 0, s = this._widgetItems.length; n < s; n++)
      if (this._areDatesEqual(e, this._widgetItems[n])) {
        t = n;
        break;
      }
    return t;
  }
  _areDatesEqual(e, t) {
    return cn(e) && cn(t) && e.getHours() === t.getHours() && e.getMinutes() === t.getMinutes();
  }
  _getTimeListItems() {
    let e = this.dateBox.dateOption("min") || this._getBoundaryDate("min");
    const t = this.dateBox.dateOption("max") || this._getBoundaryDate("max"), n = this.dateBox.dateOption("value") || null;
    let s = t - e;
    const o = e.getMinutes() % this.dateBox.option("interval");
    return s < 0 ? [] : (s > Oe.ONE_DAY && (s = Oe.ONE_DAY), n - e < Oe.ONE_DAY ? this._getRangeItems(e, new Date(e), s) : (e = this._getBoundaryDate("min"), e.setMinutes(o), n && Math.abs(n - t) < Oe.ONE_DAY && (s = (60 * t.getHours() + Math.abs(t.getMinutes() - o)) * Oe.ONE_MINUTE), this._getRangeItems(e, new Date(e), s)));
  }
  _getRangeItems(e, t, n) {
    const s = [], o = this.dateBox.option("interval");
    for (; t - e <= n; )
      s.push(new Date(t)), t.setMinutes(t.getMinutes() + o);
    return s;
  }
  _getBoundaryDate(e) {
    const t = L9[e], n = new Date(Qe(this.dateBox.dateOption("value"), 0));
    return new Date(n.getFullYear(), n.getMonth(), n.getDate(), t.getHours(), t.getMinutes());
  }
  _timeListItemTemplate(e) {
    const t = this.dateBox.option("displayFormat");
    return ue.format(e, this.getDisplayFormat(t));
  }
  _listItemClickHandler(e) {
    if (this.dateBox.option("applyValueMode") === "useButtons")
      return;
    const t = this._getDateByItemData(e.itemData);
    this.dateBox.option("opened", !1), this.dateBoxValue(t, e.event);
  }
  _getDateByItemData(e) {
    let t = this.dateBox.option("value");
    const n = e.getHours(), s = e.getMinutes(), o = e.getSeconds(), r = e.getFullYear(), a = e.getMonth(), l = e.getDate();
    return t ? (this.dateBox.option("dateSerializationFormat") ? t = pt.deserializeDate(t) : t = new Date(t), t.setHours(n), t.setMinutes(s), t.setSeconds(o), t.setFullYear(r), t.setMonth(a), t.setDate(l)) : t = new Date(r, a, l, n, s, 0, 0), t;
  }
  getKeyboardListener() {
    return this._widget;
  }
  _updatePopupHeight() {
    var e;
    const t = pC(this.dateBox.option("dropDownOptions.height"));
    if (t === void 0 || t === "auto") {
      this.dateBox._setPopupOption("height", "auto");
      const n = he(this._widget.$element()), s = 0.45 * le(N9);
      this.dateBox._setPopupOption("height", Math.min(n, s));
    }
    (e = this.dateBox._timeList) === null || e === void 0 || e.updateDimensions();
  }
  getParsedText(e, t) {
    let n = super.getParsedText(e, t);
    return n && (n = Oe.mergeDates(n, /* @__PURE__ */ new Date(null), "date")), n;
  }
}
class W9 extends yh {
  ctor(e) {
    super.ctor(e), this.NAME = "Native";
  }
  popupConfig(e) {
    return I({}, e, {
      width: "auto"
    });
  }
  getParsedText(e) {
    return e ? this.dateBox.option("type") === "datetime" ? new Date(e.replace(/-/g, "/").replace("T", " ").split(".")[0]) : Oe.fromStandardDateFormat(e) : null;
  }
  renderPopupContent() {
  }
  _getWidgetName() {
  }
  _getWidgetOptions() {
  }
  _getDateBoxType() {
    let {
      type: e
    } = this.dateBox.option();
    return Oe.SUPPORTED_FORMATS.includes(e) ? e === "datetime" && !th(e) && (e = "datetime-local") : e = "date", e;
  }
  customizeButtons() {
    const e = this.dateBox.getButton("dropDown");
    z.real().android && e && e.on("click", () => {
      this.dateBox._input().get(0).click();
    });
  }
  getDefaultOptions() {
    return {
      mode: this._getDateBoxType()
    };
  }
  getDisplayFormat(e) {
    const t = this._getDateBoxType();
    return e || Oe.FORMATS_MAP[t];
  }
  renderInputMinMax(e) {
    const t = this.dateBox.option("type"), n = {
      datetime: "yyyy-MM-ddTHH:mm:ss",
      date: "yyyy-MM-dd",
      time: "HH:mm:ss"
    }[t] ?? "yyyy-MM-dd";
    e.attr({
      min: pt.serializeDate(this.dateBox.dateOption("min"), n),
      max: pt.serializeDate(this.dateBox.dateOption("max"), n)
    });
  }
}
const Ba = fe(), z9 = "dx-show-invalid-badge", K9 = "dx-clear-button-area", kn = {
  calendar: "calendar",
  rollers: "rollers",
  list: "list",
  native: "native"
}, Vn = {
  date: "date",
  datetime: "datetime",
  time: "time"
}, $a = {
  calendar: "Calendar",
  dateView: "DateView",
  native: "Native",
  calendarWithTime: "CalendarWithTime",
  list: "List"
}, G9 = {
  Calendar: kA,
  DateView: $9,
  Native: W9,
  CalendarWithTime: V9,
  List: H9
};
class U9 extends vh {
  _supportedKeys() {
    return I({}, super._supportedKeys(), this._strategy.supportedKeys());
  }
  _renderButtonContainers() {
    super._renderButtonContainers.apply(this, arguments), this._strategy.customizeButtons();
  }
  _getDefaultOptions() {
    return I({}, super._getDefaultOptions(), {
      type: "date",
      showAnalogClock: !0,
      value: null,
      displayFormat: null,
      interval: 30,
      disabledDates: null,
      pickerType: kn.calendar,
      invalidDateMessage: S.format("dxDateBox-validation-datetime"),
      dateOutOfRangeMessage: S.format("validation-range"),
      applyButtonText: S.format("OK"),
      adaptivityEnabled: !1,
      calendarOptions: {},
      useHiddenSubmitElement: !0,
      _showValidationIcon: !0
    });
  }
  _defaultOptionsRules() {
    return super._defaultOptionsRules().concat([{
      device: {
        platform: "ios"
      },
      options: {
        "dropDownOptions.showTitle": !0
      }
    }, {
      device: {
        platform: "android"
      },
      options: {
        buttonsLocation: "bottom after"
      }
    }, {
      device() {
        const e = z.real(), {
          platform: t
        } = e;
        return t === "ios" || t === "android";
      },
      options: {
        pickerType: kn.native
      }
    }, {
      device: {
        platform: "generic",
        deviceType: "desktop"
      },
      options: {
        buttonsLocation: "bottom after"
      }
    }]);
  }
  _initOptions(e) {
    this._userOptions = x({}, e), super._initOptions(e), this._updatePickerOptions();
  }
  _updatePickerOptions() {
    let {
      pickerType: e
    } = this.option();
    const {
      type: t
    } = this.option();
    e === kn.list && (t === Vn.datetime || t === Vn.date) && (e = kn.calendar), t === Vn.time && e === kn.calendar && (e = kn.list), this._pickerType = e, this._setShowDropDownButtonOption();
  }
  _setShowDropDownButtonOption() {
    const {
      platform: e
    } = z.real(), t = e === "android" && ze.mozilla, n = this._isNativeType();
    let s = e !== "generic" || !n;
    n && t && (s = !1), this.option({
      showDropDownButton: s
    });
  }
  _init() {
    this._initStrategy(), this.option(x({}, this._strategy.getDefaultOptions(), this._userOptions)), delete this._userOptions, super._init();
  }
  _toLowerCaseFirstLetter(e) {
    return e.charAt(0).toLowerCase() + e.substr(1);
  }
  _initStrategy() {
    const e = this._getStrategyName(this._getFormatType()), t = G9[e];
    this._strategy && this._strategy.NAME === e || (this._strategy = new t(this));
  }
  _getFormatType() {
    const e = this.option("type"), t = /h|m|s/g.test(e), n = /d|M|Y/g.test(e);
    let s = "";
    return n && (s += Vn.date), t && (s += Vn.time), s;
  }
  _getStrategyName(e) {
    const t = this._pickerType;
    return t === kn.rollers ? $a.dateView : t === kn.native ? $a.native : e === Vn.date ? $a.calendar : e === Vn.datetime ? $a.calendarWithTime : $a.list;
  }
  _initMarkup() {
    this.$element().addClass("dx-datebox"), super._initMarkup(), this._refreshFormatClass(), this._refreshPickerTypeClass(), this._strategy.renderInputMinMax(this._input());
  }
  _render() {
    super._render(), this._formatValidationIcon();
  }
  _renderDimensions() {
    super._renderDimensions(), this.$element().toggleClass("dx-auto-width", !this.option("width")), this._updatePopupWidth(), this._updatePopupHeight();
  }
  _dimensionChanged() {
    super._dimensionChanged(), this._updatePopupHeight();
  }
  _updatePopupHeight() {
    if (this._popup) {
      var e, t;
      (e = (t = this._strategy)._updatePopupHeight) === null || e === void 0 || e.call(t);
    }
  }
  _refreshFormatClass() {
    const e = this.$element();
    y(Vn, (n, s) => {
      e.removeClass(`dx-datebox-${s}`);
    });
    const {
      type: t
    } = this.option();
    e.addClass(`dx-datebox-${t}`);
  }
  _refreshPickerTypeClass() {
    const e = this.$element();
    y(kn, (t, n) => {
      e.removeClass(`dx-datebox-${n}`);
    }), e.addClass(`dx-datebox-${this._pickerType}`);
  }
  _formatValidationIcon() {
    if (!ae())
      return;
    const e = this._input().get(0), t = this.option("rtlEnabled"), n = this._getClearButtonWidth(), s = this._getLongestElementDimensions(), o = parseFloat(Ba.getComputedStyle(e).width) - n, r = s.width > o, {
      style: a
    } = e, {
      _showValidationIcon: l
    } = this.option();
    this.$element().toggleClass(z9, !r && l), r ? (this._storedPadding === void 0 && (this._storedPadding = t ? s.leftPadding : s.rightPadding), t ? a.paddingLeft = 0 : a.paddingRight = 0) : t ? a.paddingLeft = `${this._storedPadding}px` : a.paddingRight = `${this._storedPadding}px`;
  }
  _getClearButtonWidth() {
    let e = 0;
    if (this._isClearButtonVisible() && this._input().val() === "") {
      const t = this.$element().find(`.${K9}`).get(0);
      e = parseFloat(Ba.getComputedStyle(t).width);
    }
    return e;
  }
  _getLongestElementDimensions() {
    const e = this._strategy.getDisplayFormat(this.option("displayFormat")), t = ue.format(Oe.getLongestDate(e, ue.getMonthNames(), ue.getDayNames()), e), n = this._input(), s = n.get(0), o = HD(n, t), a = this._storedPadding !== void 0 ? this._storedPadding : 0;
    o.appendTo(this.$element());
    const l = parseFloat(Ba.getComputedStyle(o.get(0)).width), d = parseFloat(Ba.getComputedStyle(s).paddingRight), u = parseFloat(Ba.getComputedStyle(s).paddingLeft), c = l + u + d + a;
    return o.remove(), {
      width: c,
      leftPadding: u,
      rightPadding: d
    };
  }
  _getKeyboardListeners() {
    var e;
    return super._getKeyboardListeners().concat([(e = this._strategy) === null || e === void 0 ? void 0 : e.getKeyboardListener()]);
  }
  _renderPopup() {
    var e;
    super._renderPopup(), (e = this._popup) === null || e === void 0 || e.$wrapper().addClass("dx-datebox-wrapper"), this._renderPopupWrapper();
  }
  _getPopupToolbarItems() {
    var e, t;
    const n = super._getPopupToolbarItems();
    return ((e = (t = this._strategy)._getPopupToolbarItems) === null || e === void 0 ? void 0 : e.call(t, n)) ?? n;
  }
  _popupConfig() {
    const e = super._popupConfig();
    return I({}, this._strategy.popupConfig(e), {
      title: this._getPopupTitle(),
      dragEnabled: !1
    });
  }
  _renderPopupWrapper() {
    if (!this._popup)
      return;
    const e = this.$element(), t = x({}, Vn, kn);
    y(t, (s, o) => {
      e.removeClass(`dx-datebox-wrapper-${o}`);
    });
    const {
      type: n
    } = this.option();
    this._popup.$wrapper().addClass(`dx-datebox-wrapper-${n}`).addClass(`dx-datebox-wrapper-${this._pickerType}`).addClass("dx-dropdowneditor-overlay");
  }
  _renderPopupContent() {
    super._renderPopupContent(), this._strategy.renderPopupContent();
  }
  _popupShowingHandler() {
    super._popupShowingHandler(), this._strategy.popupShowingHandler();
  }
  _popupShownHandler() {
    super._popupShownHandler(), this._strategy.renderOpenedState();
  }
  _popupHiddenHandler() {
    super._popupHiddenHandler(), this._strategy.renderOpenedState(), this._strategy.popupHiddenHandler();
  }
  _visibilityChanged(e) {
    e && this._formatValidationIcon();
  }
  _clearValueHandler(e) {
    this.option("text", ""), super._clearValueHandler(e);
  }
  _readOnlyPropValue() {
    if (this._pickerType === kn.rollers)
      return !0;
    const {
      platform: e
    } = z.real();
    if (this._isNativeType() && (e === "ios" || e === "android")) {
      const {
        readOnly: n
      } = this.option();
      return n;
    }
    return super._readOnlyPropValue();
  }
  _isClearButtonVisible() {
    return super._isClearButtonVisible() && !this._isNativeType();
  }
  _renderValue() {
    const e = this.dateOption("value");
    return this.option("text", this._getDisplayedText(e)), this._strategy.renderValue(), super._renderValue();
  }
  _setSubmitValue() {
    const e = this.dateOption("value"), {
      type: t,
      dateSerializationFormat: n
    } = this.option(), s = Oe.SUBMIT_FORMATS_MAP[t], o = n ? pt.serializeDate(e, n) : Oe.toStandardDateFormat(e, s);
    this._getSubmitElement().val(o);
  }
  _getDisplayedText(e) {
    const {
      mode: t
    } = this.option();
    let n;
    if (t === "text") {
      const s = this._strategy.getDisplayFormat(this.option("displayFormat"));
      n = ue.format(e, s);
    } else {
      const s = this._getFormatByMode(t);
      s ? n = ue.format(e, s) : n = Oe.toStandardDateFormat(e, t);
    }
    return n;
  }
  _getFormatByMode(e) {
    return th(e) ? null : Oe.FORMATS_MAP[e];
  }
  _valueChangeEventHandler(e) {
    const {
      text: t,
      type: n,
      validationError: s
    } = this.option(), o = this.dateOption("value");
    if (t === this._getDisplayedText(o)) {
      this._recallInternalValidation(o, s);
      return;
    }
    const r = this._getParsedDate(t), a = o ?? this._getDateByDefault(), l = Oe.mergeDates(a, r, n), d = r && n === "time" ? l : r;
    if (this._applyInternalValidation(d).isValid) {
      const u = this._getDisplayedText(l);
      a && l && a.getTime() === l.getTime() && u !== t ? this._renderValue() : this.dateValue(l, e);
    }
  }
  _recallInternalValidation(e, t) {
    (!t || t.editorSpecific) && (this._applyInternalValidation(e), this._applyCustomValidation(e));
  }
  _getDateByDefault() {
    return this._strategy.useCurrentDateByDefault() && this._strategy.getDefaultDate();
  }
  _getParsedDate(e) {
    const t = this._strategy.getDisplayFormat(this.option("displayFormat"));
    return this._strategy.getParsedText(e, t) ?? void 0;
  }
  _applyInternalValidation(e) {
    const n = !!this.option("text") && e !== null, s = !!e && cn(e) && !isNaN(e.getTime()), o = s && j.dateInRange(e, this.dateOption("min"), this.dateOption("max"), this.option("type")), r = !n && !e || o;
    let a = "";
    const {
      invalidDateMessage: l,
      dateOutOfRangeMessage: d
    } = this.option();
    return s ? o || (a = d) : a = l, this._updateInternalValidationState(r, a), {
      isValid: r,
      isDate: s
    };
  }
  _updateInternalValidationState(e, t) {
    this.option({
      isValid: e,
      validationError: e ? null : {
        editorSpecific: !0,
        message: t
      }
    });
  }
  _applyCustomValidation(e) {
    this.validationRequest.fire({
      editor: this,
      value: this._serializeDate(e)
    });
  }
  _isValueChanged(e) {
    const t = this.dateOption("value"), n = t && t.getTime(), s = e && e.getTime();
    return n !== s;
  }
  _isTextChanged(e) {
    const t = this.option("text"), n = e && this._getDisplayedText(e) || "";
    return t !== n;
  }
  _renderProps() {
    super._renderProps(), this._input().attr("autocomplete", "off");
  }
  _renderOpenedState() {
    this._isNativeType() || super._renderOpenedState(), this._strategy.isAdaptivityChanged() && this._refreshStrategy();
  }
  _getPopupTitle() {
    const {
      placeholder: e
    } = this.option();
    if (e)
      return e;
    const {
      type: t
    } = this.option();
    return t === Vn.time ? S.format("dxDateBox-simulatedDataPickerTitleTime") : t === Vn.date || t === Vn.datetime ? S.format("dxDateBox-simulatedDataPickerTitleDate") : "";
  }
  _refreshStrategy() {
    this._strategy.dispose(), this._initStrategy(), this.option(this._strategy.getDefaultOptions()), this._refresh();
  }
  _applyButtonHandler(e) {
    const t = this._strategy.getValue();
    this.dateValue(t, e.event), super._applyButtonHandler();
  }
  _dispose() {
    var e;
    super._dispose(), (e = this._strategy) === null || e === void 0 || e.dispose();
  }
  _isNativeType() {
    return this._pickerType === kn.native;
  }
  _updatePopupTitle() {
    var e;
    (e = this._popup) === null || e === void 0 || e.option("title", this._getPopupTitle());
  }
  _optionChanged(e) {
    switch (e.name) {
      case "showClearButton":
      case "buttons":
      case "isValid":
      case "readOnly":
        super._optionChanged.apply(this, arguments), this._formatValidationIcon();
        break;
      case "pickerType":
        this._updatePickerOptions(), this._refreshStrategy(), this._refreshPickerTypeClass(), this._invalidate();
        break;
      case "type":
        this._updatePickerOptions(), this._refreshStrategy(), this._refreshFormatClass(), this._renderPopupWrapper(), this._formatValidationIcon(), this._updateValue();
        break;
      case "placeholder":
        super._optionChanged.apply(this, arguments), this._updatePopupTitle();
        break;
      case "min":
      case "max": {
        const t = this.option("isValid");
        this._applyInternalValidation(this.dateOption("value")), t || this._applyCustomValidation(this.dateOption("value")), this._invalidate();
        break;
      }
      case "dateSerializationFormat":
      case "interval":
      case "disabledDates":
      case "calendarOptions":
        this._invalidate();
        break;
      case "displayFormat":
        this.option("text", this._getDisplayedText(this.dateOption("value"))), this._renderInputValue();
        break;
      case "text":
        this._strategy.textChangedHandler(e.value), super._optionChanged.apply(this, arguments);
        break;
      case "showDropDownButton":
        this._formatValidationIcon(), super._optionChanged.apply(this, arguments);
        break;
      case "todayButtonText":
        this._setPopupOption("toolbarItems", this._getPopupToolbarItems());
        break;
      case "invalidDateMessage":
      case "dateOutOfRangeMessage":
      case "adaptivityEnabled":
      case "showAnalogClock":
      case "_showValidationIcon":
        break;
      default:
        super._optionChanged.apply(this, arguments);
    }
  }
  _getSerializationFormat() {
    const e = this.option("value");
    if (this.option("dateSerializationFormat") && Pe().forceIsoDateParsing)
      return this.option("dateSerializationFormat");
    if ($e(e))
      return "number";
    if (te(e))
      return pt.getDateSerializationFormat(e);
  }
  _updateValue(e) {
    super._updateValue(), this._applyInternalValidation(e ?? this.dateOption("value"));
  }
  dateValue(e, t) {
    const n = this._isValueChanged(e);
    if (n && t && this._saveValueChangeEvent(t), !n) {
      const {
        text: s
      } = this.option();
      this._isTextChanged(e) ? this._updateValue(e) : s === "" && this._applyCustomValidation(e);
    }
    return this.dateOption("value", e);
  }
  dateOption(e, t) {
    if (arguments.length === 1)
      return pt.deserializeDate(this.option(e));
    this.option(e, this._serializeDate(t));
  }
  _serializeDate(e) {
    const t = this._getSerializationFormat();
    return pt.serializeDate(e, t);
  }
  _clearValue() {
    const e = this.option("value");
    super._clearValue(), e === null && this._applyCustomValidation(null);
  }
  clear() {
    const e = this.option("value");
    super.clear(), e === null && this._applyInternalValidation(null);
  }
}
const Vw = (i) => i.getMonth() + 1, Pw = (i, e) => {
  const t = i.getDate(), n = kl("M", i), s = Lt(parseInt(e), n.min, n.max);
  i.setMonth(s - 1, 1);
  const {
    min: o,
    max: r
  } = kl("dM", i), a = Lt(t, o, r);
  i.setDate(a);
}, j9 = {
  a: (i) => i.getHours() < 12 ? 0 : 1,
  E: "getDay",
  y: "getFullYear",
  M: Vw,
  L: Vw,
  d: "getDate",
  H: "getHours",
  h: "getHours",
  m: "getMinutes",
  s: "getSeconds",
  S: "getMilliseconds",
  x: "getTimezoneOffset"
}, q9 = x({}, U2(), {
  a: (i, e) => {
    const t = i.getHours();
    t >= 12 !== !!parseInt(e) && i.setHours((t + 12) % 24);
  },
  d: (i, e) => {
    const t = kl("dM", i).max;
    e > t && i.setMonth(i.getMonth() + 1), i.setDate(e);
  },
  h: (i, e) => {
    const t = i.getHours() >= 12;
    i.setHours(+e % 12 + (t ? 12 : 0));
  },
  M: Pw,
  L: Pw,
  E: (i, e) => {
    e < 0 || i.setDate(i.getDate() - i.getDay() + parseInt(e));
  },
  y: (i, e) => {
    const t = i.getFullYear(), n = String(e).length, s = String(kl("y", i).max).length, o = parseInt(String(t).substr(0, s - n) + e);
    i.setFullYear(o);
  },
  x: (i) => i
}), Y9 = (i) => j9[i] || (() => i), X9 = (i, e) => {
  const t = e.regexp.exec(i);
  let n = 0, s = 0;
  const o = [];
  for (let r = 1; r < t.length; r++) {
    n = s, s = n + t[r].length;
    const a = e.patterns[r - 1].replace(/^'|'$/g, ""), l = Y9(a[0]);
    o.push({
      index: r - 1,
      isStub: a === t[r],
      caret: {
        start: n,
        end: s
      },
      pattern: a,
      text: t[r],
      limits: function() {
        for (var d = arguments.length, u = new Array(d), c = 0; c < d; c++)
          u[c] = arguments[c];
        return kl(a[0], ...u);
      },
      setter: q9[a[0]] || M,
      getter: l
    });
  }
  return o;
}, kl = (i, e, t) => {
  const n = {
    y: {
      min: 0,
      max: 9999
    },
    M: {
      min: 1,
      max: 12
    },
    L: {
      min: 1,
      max: 12
    },
    d: {
      min: 1,
      max: 31
    },
    dM: {
      min: 1,
      max: new Date(e.getFullYear(), e.getMonth() + 1, 0).getDate()
    },
    E: {
      min: 0,
      max: 6
    },
    H: {
      min: 0,
      max: 23
    },
    h: {
      min: 1,
      max: 12
    },
    m: {
      min: 0,
      max: 59
    },
    s: {
      min: 0,
      max: 59
    },
    S: {
      min: 0,
      max: 999
    },
    a: {
      min: 0,
      max: 1
    },
    x: {
      min: 0,
      max: 0
    }
  };
  return n[t || i] || n.getAmPm;
}, Z9 = (i, e) => {
  for (let t = 0; t < i.length; t++) {
    const n = i[t].caret.end >= e;
    if (!i[t].isStub && n)
      return t;
  }
  return null;
};
class Q9 extends U9 {
  _supportedKeys() {
    const e = super._supportedKeys(), t = (s) => {
      const o = e[Ye(s)];
      return o?.apply(this, [s]);
    }, n = (s, o) => this._shouldUseOriginalHandler(s) ? t.apply(this, [s]) : o.apply(this, [s]);
    return I({}, e, {
      del: (s) => n(s, (o) => {
        this._revertPart(1), this._isAllSelected() || o.preventDefault();
      }),
      backspace: (s) => n(s, (o) => {
        this._revertPart(-1), this._isAllSelected() || o.preventDefault();
      }),
      home: (s) => n(s, (o) => {
        this._selectFirstPart(), o.preventDefault();
      }),
      end: (s) => n(s, (o) => {
        this._selectLastPart(), o.preventDefault();
      }),
      escape: (s) => n(s, () => {
        this._revertChanges();
      }),
      enter: (s) => n(s, () => {
        this._enterHandler();
      }),
      leftArrow: (s) => n(s, (o) => {
        this._selectNextPart(-1), o.preventDefault();
      }),
      rightArrow: (s) => n(s, (o) => {
        this._selectNextPart(1), o.preventDefault();
      }),
      upArrow: (s) => n(s, (o) => {
        this._upDownArrowHandler(1), o.preventDefault();
      }),
      downArrow: (s) => n(s, (o) => {
        this._upDownArrowHandler(-1), o.preventDefault();
      })
    });
  }
  _shouldUseOriginalHandler(e) {
    const t = this.option("opened") && e && !["backspace", "del"].includes(Ye(e));
    return !this._useMaskBehavior() || t || e && e.altKey;
  }
  _upDownArrowHandler(e) {
    this._setNewDateIfEmpty();
    const t = this._getActivePartValue(this._initialMaskValue), s = this._getActivePartValue() - t;
    this._loadMaskValue(this._initialMaskValue), this._changePartValue(s + e, !0);
  }
  _changePartValue(e, t) {
    const n = this._getActivePartProp("pattern");
    /^a{1,5}$/.test(n) ? this._toggleAmPm() : this._partIncrease(e, t);
  }
  _toggleAmPm() {
    const e = this._getActivePartProp("text"), n = 1 ^ Mr.getPeriodNames().indexOf(e);
    this._setActivePartValue(n);
  }
  _getDefaultOptions() {
    return I({}, super._getDefaultOptions(), {
      useMaskBehavior: !1,
      emptyDateValue: new Date(2e3, 0, 1, 0, 0, 0)
    });
  }
  _isSingleCharKey(e) {
    let {
      originalEvent: t,
      alt: n
    } = e;
    const s = t.data || t.key;
    return typeof s == "string" && s.length === 1 && !n && !bt(t);
  }
  _isSingleDigitKey(e) {
    var t;
    const n = (t = e.originalEvent) === null || t === void 0 ? void 0 : t.data;
    return n?.length === 1 && parseInt(n, 10);
  }
  _useBeforeInputEvent() {
    return z.real().android;
  }
  _keyInputHandler(e, t) {
    const n = this._input().val();
    this._processInputKey(t), e.preventDefault(), n !== this._input().val() && _.trigger(this._input(), "input");
  }
  _keyboardHandler(e) {
    let {
      key: t
    } = e.originalEvent;
    const n = super._keyboardHandler(e);
    return !this._useMaskBehavior() || this._useBeforeInputEvent() || (ze.chrome && e.key === "Process" && e.code.indexOf("Digit") === 0 ? (t = e.code.replace("Digit", ""), this._processInputKey(t), this._maskInputHandler = () => {
      this._renderSelectedPart();
    }) : this._isSingleCharKey(e) && this._keyInputHandler(e.originalEvent, t)), n;
  }
  _maskBeforeInputHandler(e) {
    this._maskInputHandler = null;
    const {
      inputType: t
    } = e.originalEvent;
    t === "insertCompositionText" && (this._maskInputHandler = () => {
      this._renderSelectedPart();
    });
    const n = t === "deleteContentBackward";
    if (n || t === "deleteContentForward") {
      const r = n ? -1 : 1;
      this._maskInputHandler = () => {
        this._revertPart(), this._selectNextPart(r);
      };
    }
    if (!this._useMaskBehavior() || !this._isSingleCharKey(e))
      return;
    const o = e.originalEvent.data;
    return this._keyInputHandler(e, o), !0;
  }
  _keyPressHandler(e) {
    const {
      originalEvent: t
    } = e;
    t?.inputType === "insertCompositionText" && this._isSingleDigitKey(e) && (this._processInputKey(t.data), this._renderDisplayText(this._getDisplayedText(this._maskValue)), this._selectNextPart()), super._keyPressHandler(e), this._maskInputHandler && (this._maskInputHandler(), this._maskInputHandler = null);
  }
  _processInputKey(e) {
    this._isAllSelected() && (this._activePartIndex = 0), this._setNewDateIfEmpty(), isNaN(parseInt(e)) ? this._searchString(e) : this._searchNumber(e);
  }
  _isAllSelected() {
    const e = this._caret(), {
      text: t
    } = this.option();
    return e.end - e.start === t.length;
  }
  _getFormatPattern() {
    if (this._formatPattern)
      return this._formatPattern;
    const e = this._strategy.getDisplayFormat(this.option("displayFormat"));
    return te(e) && !ue._getPatternByFormat(e) ? this._formatPattern = e : this._formatPattern = GT((n) => ue.format(n, e)), this._formatPattern;
  }
  _setNewDateIfEmpty() {
    if (!this._maskValue) {
      const {
        type: e
      } = this.option(), t = e === "time" ? /* @__PURE__ */ new Date(null) : /* @__PURE__ */ new Date();
      this._maskValue = t, this._initialMaskValue = t, this._renderDateParts();
    }
  }
  _partLimitsReached(e) {
    const t = String(e).length, n = this._getActivePartProp("pattern").length, o = n === 1 ? t : Math.min(n, t), r = this._searchValue.length === o, a = parseInt(`${this._searchValue}0`) > e;
    return r || a;
  }
  _searchNumber(e) {
    const {
      max: t
    } = this._getActivePartLimits(), n = String(t).length;
    this._searchValue = (this._searchValue + e).substr(-n), isNaN(this._searchValue) && (this._searchValue = e), this._setActivePartValue(this._searchValue), this._partLimitsReached(t) && this._selectNextPart(1);
  }
  _searchString(e) {
    if (!isNaN(parseInt(this._getActivePartProp("text"))))
      return;
    const t = this._getActivePartProp("limits")(this._maskValue), n = this._searchValue + e.toLowerCase(), s = t.max - t.min;
    for (let o = 0; o <= s; o++)
      if (this._loadMaskValue(this._initialMaskValue), this._changePartValue(o + 1), this._getActivePartProp("text").toLowerCase().indexOf(n) === 0) {
        this._searchValue = n;
        return;
      }
    this._setNewDateIfEmpty(), this._searchValue && (this._clearSearchValue(), this._searchString(e));
  }
  _clearSearchValue() {
    this._searchValue = "";
  }
  _revertPart(e) {
    if (!this._isAllSelected()) {
      const t = this._getActivePartValue(this.option("emptyDateValue"));
      this._setActivePartValue(t), this._selectNextPart(e);
    }
    this._clearSearchValue();
  }
  _useMaskBehavior() {
    const {
      mode: e
    } = this.option();
    return this.option("useMaskBehavior") && e === "text";
  }
  _prepareRegExpInfo() {
    this._regExpInfo = UT(this._getFormatPattern(), ue);
    const {
      regexp: e
    } = this._regExpInfo, {
      source: t
    } = e, {
      flags: n
    } = e, s = new RegExp(/(\{[0-9]+,?[0-9]*\})/), o = t.split(s).map((r) => s.test(r) ? r : We.convertDigits(r, !1)).join("");
    this._regExpInfo.regexp = new RegExp(o, n);
  }
  _initMaskState() {
    this._activePartIndex = 0, this._formatPattern = null, this._prepareRegExpInfo(), this._loadMaskValue();
  }
  _renderMask() {
    super._renderMask(), this._detachMaskEvents(), this._clearMaskState(), this._useMaskBehavior() && (this._attachMaskEvents(), this._initMaskState(), this._renderDateParts());
  }
  _renderDateParts() {
    if (!this._useMaskBehavior())
      return;
    const e = this.option("text") || this._getDisplayedText(this._maskValue);
    e && (this._dateParts = X9(e, this._regExpInfo), this._input().is(":hidden") || this._selectNextPart());
  }
  _detachMaskEvents() {
    _.off(this._input(), ".dateBoxMask");
  }
  _attachMaskEvents() {
    _.on(this._input(), R("dxclick", "dateBoxMask"), this._maskClickHandler.bind(this)), _.on(this._input(), R("paste", "dateBoxMask"), this._maskPasteHandler.bind(this)), _.on(this._input(), R("drop", "dateBoxMask"), () => {
      this._renderSelectedPart();
    }), _.on(this._input(), R("compositionend", "dateBoxMask"), this._maskCompositionEndHandler.bind(this)), this._useBeforeInputEvent() && _.on(this._input(), R("beforeinput", "dateBoxMask"), this._maskBeforeInputHandler.bind(this));
  }
  _renderSelectedPart() {
    this._renderDisplayText(this._getDisplayedText(this._maskValue)), this._selectNextPart();
  }
  _selectLastPart() {
    this.option("text") && (this._activePartIndex = this._dateParts.length, this._selectNextPart(-1));
  }
  _selectFirstPart() {
    this.option("text") && this._dateParts && (this._activePartIndex = -1, this._selectNextPart(1));
  }
  _onMouseWheel(e) {
    this._useMaskBehavior() && this._partIncrease(e.delta > 0 ? 1 : -1, e);
  }
  _selectNextPart() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 0;
    if (!this.option("text") || this._disposed)
      return;
    e && (this._initialMaskValue = new Date(this._maskValue));
    let t = Lt(this._activePartIndex + e, 0, this._dateParts.length - 1);
    if (this._dateParts[t].isStub) {
      if (!(t === 0 && e < 0 || t === this._dateParts.length - 1 && e > 0)) {
        this._selectNextPart(e >= 0 ? e + 1 : e - 1);
        return;
      }
      t = this._activePartIndex;
    }
    this._activePartIndex !== t && this._clearSearchValue(), this._activePartIndex = t, this._caret(this._getActivePartProp("caret"));
  }
  _getRealLimitsPattern() {
    if (this._getActivePartProp("pattern")[0] === "d")
      return "dM";
  }
  _getActivePartLimits(e) {
    return this._getActivePartProp("limits")(this._maskValue, e && this._getRealLimitsPattern());
  }
  _getActivePartValue(e) {
    e = e || this._maskValue;
    const t = this._getActivePartProp("getter");
    return B(t) ? t(e) : e[t]();
  }
  _addLeadingZeroes(e) {
    const t = /^0+/.exec(this._searchValue), n = this._getActivePartLimits(), s = String(n.max).length;
    return ((t && t[0] || "") + String(e)).substr(-s);
  }
  _setActivePartValue(e, t) {
    t = t || this._maskValue;
    const n = this._getActivePartProp("setter"), s = this._getActivePartLimits();
    e = ss(e, s.min, s.max) ? e : e % 10, e = this._addLeadingZeroes(Lt(e, s.min, s.max)), B(n) ? n(t, e) : t[n](e), this._renderDisplayText(this._getDisplayedText(t)), this._renderDateParts();
  }
  _getActivePartProp(e) {
    if (!(!this._dateParts || !this._dateParts[this._activePartIndex]))
      return this._dateParts[this._activePartIndex][e];
  }
  _loadMaskValue() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : this.dateOption("value");
    this._maskValue = e && new Date(e), this._initialMaskValue = e && new Date(e);
  }
  _saveMaskValue() {
    const e = this._maskValue && new Date(this._maskValue), {
      type: t
    } = this.option();
    e && t === "date" && e.setHours(0, 0, 0, 0), this._initialMaskValue = new Date(e), this.dateOption("value", e);
  }
  _revertChanges() {
    this._loadMaskValue(), this._renderDisplayText(this._getDisplayedText(this._maskValue)), this._renderDateParts();
  }
  _renderDisplayText(e) {
    super._renderDisplayText(e), this._useMaskBehavior() && this.option("text", e);
  }
  _partIncrease(e, t) {
    this._setNewDateIfEmpty();
    const {
      max: n,
      min: s
    } = this._getActivePartLimits(t);
    let o = e + this._getActivePartValue();
    o > n ? o = this._applyLimits(o, {
      limitBase: s,
      limitClosest: n,
      max: n
    }) : o < s && (o = this._applyLimits(o, {
      limitBase: n,
      limitClosest: s,
      max: n
    })), this._setActivePartValue(o);
  }
  _applyLimits(e, t) {
    let {
      limitBase: n,
      limitClosest: s,
      max: o
    } = t;
    const r = (e - s) % o;
    return r ? n + r - 1 * na(r) : s;
  }
  _maskClickHandler() {
    this._loadMaskValue(this._maskValue), this.option("text") && (this._activePartIndex = Z9(this._dateParts, this._caret().start), this._isAllSelected() || (this._clearSearchValue(), f(this._activePartIndex) ? this._caret(this._getActivePartProp("caret")) : this._selectLastPart()));
  }
  _maskCompositionEndHandler(e) {
    this._input().val(this._getDisplayedText(this._maskValue)), this._selectNextPart(), this._maskInputHandler = () => {
      this._renderSelectedPart();
    };
  }
  _maskPasteHandler(e) {
    const t = this._replaceSelectedText(this.option("text"), this._caret(), cc(e)), n = ue.parse(t, this._getFormatPattern());
    n && this._isDateValid(n) && (this._maskValue = n, this._renderDisplayText(this._getDisplayedText(this._maskValue)), this._renderDateParts(), this._selectNextPart()), e.preventDefault();
  }
  _isDateValid(e) {
    return cn(e) && !isNaN(e);
  }
  _isValueDirty() {
    const e = this.dateOption("value");
    return (this._maskValue && this._maskValue.getTime()) !== (e && e.getTime());
  }
  _fireChangeEvent() {
    this._clearSearchValue(), this._isValueDirty() && _.trigger(this._input(), "change");
  }
  _enterHandler() {
    this._fireChangeEvent(), this._selectNextPart(1);
  }
  _focusOutHandler(e) {
    this._useMaskBehavior() && !e.isDefaultPrevented() ? (this._fireChangeEvent(), super._focusOutHandler(e), this._selectFirstPart()) : super._focusOutHandler(e);
  }
  _valueChangeEventHandler(e) {
    const t = this.option("text");
    this._useMaskBehavior() ? (this._saveValueChangeEvent(e), t ? this._maskValue === null && this._loadMaskValue(t) : this._maskValue = null, this._saveMaskValue()) : super._valueChangeEventHandler(e);
  }
  _optionChanged(e) {
    switch (e.name) {
      case "useMaskBehavior":
        this._renderMask();
        break;
      case "displayFormat":
      case "mode":
        super._optionChanged(e), this._renderMask();
        break;
      case "value":
        this._loadMaskValue(), super._optionChanged(e), this._renderDateParts();
        break;
      case "emptyDateValue":
        break;
      default:
        super._optionChanged(e);
    }
  }
  _clearMaskState() {
    this._clearSearchValue(), delete this._dateParts, delete this._activePartIndex, delete this._maskValue;
  }
  clear() {
    this._clearMaskState(), this._activePartIndex = 0, super.clear();
  }
  _clean() {
    super._clean(), this._detachMaskEvents(), this._clearMaskState();
  }
}
xe("dxDateBox", Q9);
const {
  isWrapped: J9
} = Bt, eX = "dx-editor-inline-block", yd = function(i, e) {
  return x(i, {
    readOnly: e.readOnly,
    placeholder: e.placeholder,
    inputAttr: {
      id: e.id,
      "aria-labelledby": e["aria-labelledby"]
    },
    tabIndex: e.tabIndex
  }, e.editorOptions);
}, BA = function() {
  return ze.mozilla || z.real().ios;
}, $A = function(i) {
  const e = {}, t = BA(), n = i.sharedData || e;
  return yd({
    placeholder: i.placeholder,
    width: i.width,
    value: i.value,
    onValueChanged: function(s) {
      const o = i.parentType === "filterRow" || i.parentType === "searchPanel", r = s.event && (s.event.type === "input" || s.event.type === "keyup"), a = function(l, d) {
        i && i.setValue(l.value, d);
      };
      clearTimeout(e.valueChangeTimeout), r && o ? n.valueChangeTimeout = e.valueChangeTimeout = setTimeout(function() {
        a(s, e.valueChangeTimeout !== n.valueChangeTimeout);
      }, f(i.updateValueTimeout) ? i.updateValueTimeout : 0) : a(s);
    },
    onKeyDown: function(s) {
      t && Ye(s.event) === "enter" && _.trigger(p(s.component._input()), "change");
    },
    valueChangeEvent: "change" + (i.parentType === "filterRow" ? " keyup input" : "")
  }, i);
}, Mw = function(i) {
  i.editorName = "dxDateBox", i.editorOptions = yd({
    value: i.value,
    onValueChanged: function(e) {
      i.setValue(e.value);
    },
    onKeyDown: function(e) {
      let {
        component: t,
        event: n
      } = e;
      const s = t.option("useMaskBehavior");
      (BA() || s) && Ye(n) === "enter" && (t.blur(), t.focus());
    },
    displayFormat: i.format,
    type: i.dataType,
    dateSerializationFormat: null,
    width: i.parentType === "filterBuilder" ? void 0 : "auto"
  }, i);
}, Bw = function(i) {
  const e = $A(i), t = i.parentType === "searchPanel";
  i.editorType && i.editorType !== "dxTextBox" ? e.value = i.value : e.value = (n = i.value, f(n) ? n.toString() : "");
  var n;
  e.valueChangeEvent += t ? " keyup input search" : "", e.mode = e.mode || (t ? "search" : "text"), i.editorName = "dxTextBox", i.editorOptions = e;
}, $w = function(i) {
  const e = $A(i);
  e.value = f(i.value) ? i.value : null, i.editorName = "dxNumberBox", i.editorOptions = e;
}, tX = function(i) {
  i.parentType === "filterRow" || i.parentType === "filterBuilder" ? NA(x(i, {
    lookup: {
      displayExpr: function(e) {
        if (e === !0)
          return i.trueText || "true";
        if (e === !1)
          return i.falseText || "false";
      },
      dataSource: [!0, !1]
    }
  })) : LA(i);
};
function nX(i) {
  if (i.row && i.row.watch && i.parentType === "dataRow") {
    const e = i.editorOptions || {};
    i.editorOptions = e;
    let t;
    const n = e.onInitialized;
    e.onInitialized = function(r) {
      n && n.apply(this, arguments), t = r.component, t.on("disposing", o);
    };
    let s;
    const o = i.row.watch(() => (s = i.lookup.dataSource(i.row), s && s.filter), () => {
      t.option("dataSource", s);
    }, (r) => {
      i.row = r;
    });
  }
}
function NA(i) {
  const e = i.lookup;
  let t, n, s;
  const o = i.parentType === "filterRow";
  if (e) {
    t = Be(e.displayExpr), n = e.dataSource, B(n) && !J9(n) && (n = n(i.row || {}), nX(i)), (X(n) || Array.isArray(n)) && (n = lo(n), o && (s = n.postProcess, n.postProcess = function(a) {
      return this.pageIndex() === 0 && (a = a.slice(0), a.unshift(null)), s ? s.call(this, a) : a;
    }));
    const r = !!(e.allowClearing && !o);
    i.editorName = i.editorType ?? "dxSelectBox", i.editorOptions = yd({
      searchEnabled: !0,
      value: i.value,
      valueExpr: i.lookup.valueExpr,
      searchExpr: i.lookup.searchExpr || i.lookup.displayExpr,
      allowClearing: r,
      showClearButton: r,
      displayExpr: function(a) {
        return a === null ? i.showAllText : t(a);
      },
      dataSource: n,
      onValueChanged: function(a) {
        const l = [a.value];
        !o && l.push(a.component.option("text")), i.setValue.apply(this, l);
      }
    }, i);
  }
}
function LA(i) {
  i.editorName = "dxCheckBox", i.editorOptions = yd({
    elementAttr: {
      id: i.id
    },
    value: f(i.value) ? i.value : void 0,
    hoverStateEnabled: !i.readOnly,
    focusStateEnabled: !i.readOnly,
    activeStateEnabled: !1,
    onValueChanged: function(e) {
      i.setValue && i.setValue(e.value, e);
    }
  }, i);
}
const iX = function(i, e) {
  const t = p(e.editorElement);
  if (e.editorName && e.editorOptions && t[e.editorName]) {
    if ((e.editorName === "dxCheckBox" || e.editorName === "dxSwitch") && (e.isOnForm || (t.addClass(i.addWidgetPrefix("checkbox-size")), t.parent().addClass(eX))), i._createComponent(t, e.editorName, e.editorOptions), e.editorName === "dxDateBox") {
      const n = t.dxDateBox("instance"), s = n._supportedKeys().enter;
      n.registerKeyHandler("enter", (o) => (n.option("opened") && s(o), !0));
    }
    e.editorName === "dxTextArea" && t.dxTextArea("instance").registerKeyHandler("enter", function(n) {
      Ye(n) === "enter" && !n.ctrlKey && !n.shiftKey && n.stopPropagation();
    });
  }
}, sX = (i) => {
  i.editorName = i.editorType, i.editorOptions = yd({
    value: i.value,
    onValueChanged: function(e) {
      i.setValue(e.value);
    }
  }, i);
}, oX = (i) => {
  const e = {
    dxDateBox: Mw,
    dxCheckBox: LA,
    dxNumberBox: $w,
    dxTextBox: Bw
  };
  if (i.lookup)
    NA(i);
  else if (i.editorType)
    (e[i.editorType] ?? sX)(i);
  else
    switch (i.dataType) {
      case "date":
      case "datetime":
        Mw(i);
        break;
      case "boolean":
        tX(i);
        break;
      case "number":
        $w(i);
        break;
      default:
        Bw(i);
    }
}, HA = (i) => class extends i {
  createEditor(e, t) {
    t.cancel = !1, t.editorElement = ee(e), f(t.tabIndex) || (t.tabIndex = this.option("tabIndex")), oX(t), this.executeAction("onEditorPreparing", t), !t.cancel && (t.parentType === "dataRow" && !t.isOnForm && !f(t.editorOptions.showValidationMark) && (t.editorOptions.showValidationMark = !1), iX(this, t), this.executeAction("onEditorPrepared", t));
  }
}, rX = "dx-editor-inline-block", WA = "dxDataGridEditorFactory", Nw = R([ye.down, "focusin", Te].join(" "), WA), eu = "dx-hidden", aX = HA(Ue.ViewController);
let lX = class extends aX {
  init() {
    this.createAction("onEditorPreparing", {
      excludeValidators: ["disabled", "readOnly"],
      category: "rendering"
    }), this.createAction("onEditorPrepared", {
      excludeValidators: ["disabled", "readOnly"],
      category: "rendering"
    }), this._columnsResizerController = this.getController("columnsResizer"), this._editingController = this.getController("editing"), this._keyboardNavigationController = this.getController("keyboardNavigation"), this._columnsController = this.getController("columns"), this._validatingController = this.getController("validating"), this._rowsView = this.getView("rowsView"), this._updateFocusHandler = this._updateFocusHandler || this.createAction(this._updateFocus.bind(this)), this._subscribedContainerRoot = this._getContainerRoot(), _.on(this._subscribedContainerRoot, Nw, this._updateFocusHandler), this._attachContainerEventHandlers();
  }
  dispose() {
    clearTimeout(this._focusTimeoutID), clearTimeout(this._updateFocusTimeoutID), _.off(this._subscribedContainerRoot, Nw, this._updateFocusHandler);
  }
  _getFocusedElement(e) {
    const n = ["td[tabindex]:focus", `${this.option("focusedRowEnabled") ? "tr[tabindex]:focus" : "tr[tabindex]:not(.dx-data-row):focus"}`, "input:focus", "button:focus", "textarea:focus", "div[tabindex]:focus", ".dx-lookup-field:focus", ".dx-checkbox:focus", ".dx-switch:focus", ".dx-dropdownbutton .dx-buttongroup:focus", ".dx-adaptive-item-text:focus"].join(","), s = e.find(n);
    return this.elementIsInsideGrid(s) && s;
  }
  _getFocusCellSelector() {
    return ".dx-row > td";
  }
  _updateFocusCore() {
    const e = this.component && this.component.$element();
    if (e) {
      let t = this._getFocusedElement(e);
      if (t && t.length) {
        let n;
        if (!t.hasClass("dx-cell-focus-disabled") && !t.hasClass("dx-row")) {
          const s = t.closest(`${this._getFocusCellSelector()}, .dx-cell-focus-disabled`);
          s.get(0) !== t.get(0) && (n = this._needHideBorder(s), t = s);
        }
        if (t.length && !t.hasClass("dx-cell-focus-disabled")) {
          this.focus(t, n);
          return;
        }
      }
    }
    this.loseFocus();
  }
  _needHideBorder(e) {
    const t = this._rowsView.element(), n = e.closest(t).length > 0, s = this._editingController.isEditing();
    return e.hasClass(rX) || n && !s;
  }
  _updateFocus(e) {
    const t = this, n = e && e.event && p(e.event.target).hasClass(t.addWidgetPrefix("focus-overlay"));
    t._isFocusOverlay = t._isFocusOverlay || n, clearTimeout(t._updateFocusTimeoutID), t._updateFocusTimeoutID = setTimeout(() => {
      delete t._updateFocusTimeoutID, t._isFocusOverlay || t._updateFocusCore(), t._isFocusOverlay = !1;
    });
  }
  updateFocusOverlaySize(e, t) {
    e.hide();
    const n = Un.calculate(e, x({
      collision: "fit"
    }, t));
    n.h.oversize > 0 && mx(e, Ee(e) - n.h.oversize), n.v.oversize > 0 && fx(e, he(e) - n.v.oversize), e.show();
  }
  callbackNames() {
    return ["focused"];
  }
  getFocusOverlayContainer(e) {
    return e.closest(`.${this.addWidgetPrefix("content")}`);
  }
  getFocusOverlaySize(e) {
    const t = Ge(e.get(0));
    return {
      width: t.right - t.left + 1,
      height: t.bottom - t.top + 1
    };
  }
  updateFocusOverlay(e) {
    if (arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !1)
      this._$focusOverlay.addClass(eu);
    else if (e.length) {
      const n = ze.mozilla ? "right bottom" : "left top", s = e.hasClass(this.addWidgetPrefix("invalid")), o = e.hasClass("dx-cell-modified") && !s, r = this.getFocusOverlayContainer(e), a = this.getFocusOverlaySize(e);
      this._$focusOverlay.removeClass(eu).toggleClass("dx-focused-cell-invalid", s).toggleClass("dx-focused-cell-modified", o).appendTo(r), fx(this._$focusOverlay, a.height), mx(this._$focusOverlay, a.width);
      const l = {
        precise: !0,
        my: n,
        at: n,
        of: e,
        boundary: r.length && r
      };
      this.updateFocusOverlaySize(this._$focusOverlay, l), Un.setup(this._$focusOverlay, l), this._$focusOverlay.css("visibility", "visible");
    }
  }
  renderFocusOverlay(e, t) {
    F.isElementInCurrentGrid(this, e) && (this._$focusOverlay || (this._$focusOverlay = p("<div>").addClass(this.addWidgetPrefix("focus-overlay"))), this.updateFocusOverlay(e, t));
  }
  focus(e, t) {
    const n = this;
    if (e === void 0)
      return n._$focusedElement;
    e && (e.is(n._$focusedElement) || n._$focusedElement && n._$focusedElement.removeClass("dx-focused"), n._$focusedElement = e, clearTimeout(n._focusTimeoutID), n._focusTimeoutID = setTimeout(() => {
      delete n._focusTimeoutID, n.renderFocusOverlay(e, t), e.addClass("dx-focused"), n.focused.fire(e);
    }));
  }
  refocus() {
    const e = this.focus();
    this.focus(e);
  }
  resize() {
    const e = this._$focusedElement;
    e && this.focus(e);
  }
  loseFocus(e) {
    this._$focusedElement && this._$focusedElement.removeClass("dx-focused"), this._$focusedElement = null, this._$focusOverlay && this._$focusOverlay.addClass(eu);
  }
  _getContainerRoot() {
    var e;
    const t = (e = this.component) === null || e === void 0 ? void 0 : e.$element(), n = O.getRootNode(t?.get(0));
    return n.nodeType === Node.DOCUMENT_FRAGMENT_NODE && !n.host ? O.getDocument() : n;
  }
  _attachContainerEventHandlers() {
    const e = this, t = e.component && e.component.$element();
    t && _.on(t, R("keydown", WA), (n) => {
      Ye(n) === "tab" && e._updateFocusHandler(n);
    });
  }
  getFocusOverlay() {
    return this._$focusOverlay;
  }
  hasOverlayElements() {
    var e;
    return !!((e = this._$focusOverlay) !== null && e !== void 0 && e.length) && !this._$focusOverlay.hasClass(eu);
  }
};
const dX = {
  defaultOptions: () => ({}),
  controllers: {
    editorFactory: lX
  }
};
J.registerModule("editorFactory", dX);
const tu = fe(), uX = {
  text: "OK",
  onClick: () => !0
}, cX = () => nn() ? {
  stylingMode: "contained",
  type: "default"
} : {}, hX = () => nn() ? {
  stylingMode: "outlined",
  type: "default"
} : {}, pX = function(i) {
  const e = w();
  i = i || {};
  const t = p("<div>").addClass("dx-dialog").appendTo(Ys()), n = "message" in i, s = "messageHtml" in i;
  n && _e.log("W1013");
  const o = String(s ? i.messageHtml : i.message), r = i.title ? null : new Xe(), a = p("<div>").addClass("dx-dialog-message").html(o).attr("id", r), l = [], d = new pi(t, x({
    title: i.title ?? "",
    showTitle: Qe(i.showTitle, !0),
    dragEnabled: Qe(i.dragEnabled, !0),
    height: "auto",
    width: i.width,
    showCloseButton: i.showCloseButton || !1,
    ignoreChildEvents: !1,
    container: t,
    visualContainer: tu,
    dragAndResizeArea: tu,
    onContentReady(h) {
      h.component.$content().addClass("dx-dialog-content").append(a), r && h.component.$overlayContent().attr("aria-labelledby", r);
    },
    onShowing(h) {
      h.component.bottomToolbar().addClass("dx-dialog-buttons").find(".dx-button").addClass("dx-dialog-button"), li.resetActiveElement();
    },
    onShown(h) {
      const g = h.component.bottomToolbar().find(".dx-button").first();
      _.trigger(g, "focus");
    },
    onHiding() {
      e.reject();
    },
    onHidden(h) {
      let {
        element: g
      } = h;
      p(g).remove();
    },
    animation: {
      show: {
        type: "pop",
        duration: 400
      },
      hide: {
        type: "pop",
        duration: 400,
        to: {
          opacity: 0,
          scale: 0
        },
        from: {
          opacity: 1,
          scale: 1
        }
      }
    },
    rtlEnabled: Pe().rtlEnabled,
    position: {
      boundaryOffset: {
        h: 10,
        v: 0
      }
    }
  }, i.popupOptions));
  (i.buttons || [uX]).forEach((h) => {
    const g = new vn(h.onClick, {
      context: d
    });
    l.push({
      toolbar: "bottom",
      location: z.current().android ? "after" : "center",
      widget: "dxButton",
      options: I({}, h, {
        onClick() {
          const m = g.execute(...arguments);
          c(m);
        }
      })
    });
  }), d.option("toolbarItems", l), d.$wrapper().addClass("dx-dialog-wrapper"), i.position && d.option("position", i.position), d.$wrapper().addClass("dx-dialog-root");
  function c(h) {
    e.resolve(h), d.hide();
  }
  return {
    show: function() {
      if (z.real().deviceType === "phone") {
        const g = le(tu) > ne(tu) ? "90%" : "60%";
        d.option({
          width: g
        });
      }
      return d.show(), e.promise();
    },
    hide: c
  };
}, gX = function(i) {
  let e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "", t = arguments.length > 2 ? arguments[2] : void 0;
  const n = pe(i) ? i : {
    title: e,
    messageHtml: i,
    showTitle: t,
    buttons: [I({
      text: S.format("Yes"),
      onClick: () => !0
    }, cX()), I({
      text: S.format("No"),
      onClick: () => !1
    }, hX())],
    dragEnabled: t
  };
  return pX(n).show();
}, bh = "dx-editor-cell", Fs = "dx-row", mX = "dx-cell-modified", Lw = "dx-selection", _C = "edit-form", Jn = "insert", qi = "remove", Pu = "editing.popup", Gp = "editing.form", Sn = "editing.editRowKey", Do = "editing.editColumnName", zA = "targetComponent", CC = "input:not([type='hidden'])", vC = `[tabindex]:not([disabled]), ${CC}:not([disabled])`, Hm = "batch", ul = "row", Wm = "cell", xC = "form", fX = "popup", Hw = "first", nu = "last", Ww = "pageBottom", Up = "pageTop", zw = "viewportBottom", KA = "viewportTop", _X = ["batch", "row", "cell", "form", "popup"], CX = ["row", "form", "popup"], vX = ["batch", "cell"], xX = ["batch", "row", "cell"], yX = ["row", "form"], bX = "readonly", wX = "dx-link", SX = "dx-link-icon", EX = "dx-selection", IX = "dx-edit-button", DX = "dx-command-edit", Kw = "dx-command-edit-with-icons", Is = "__DX_INSERT_INDEX__", TX = "dx-row-inserted", OX = "dx-row-modified", Gw = "dx-cell-modified", AX = "dxDataGridEditing", RX = "dx-cell-focus-disabled", Na = "update", FX = "click", kX = {
  save: "dx-link-save",
  cancel: "dx-link-cancel",
  edit: "dx-link-edit",
  undelete: "dx-link-undelete",
  delete: "dx-link-delete",
  add: "dx-link-add"
}, VX = {
  save: "save",
  cancel: "revert",
  edit: "edit",
  undelete: "revert",
  delete: "trash",
  add: "add"
}, PX = {
  edit: "editRow",
  delete: "deleteRow",
  undelete: "undeleteRow",
  save: "saveEditData",
  cancel: "cancelEditData",
  add: "addRowByRowIndex"
}, MX = {
  add: "allowAdding",
  edit: "allowUpdating",
  delete: "allowDeleting"
}, BX = ["edit", "save", "cancel", "delete", "undelete"], Yi = "editing.changes", $X = "focus-overlay", NX = "addrow-button", LX = "dx-dropdowneditor-overlay", HX = "dx-data-row", WX = "dx-row-removed", zX = "filter-row", KX = !!Qt.IS_RENOVATED_WIDGET, GA = "edit-form-item", GX = "edit-popup", UX = "edit-popup-form", jX = KX ? "dx-scrollable" : "dx-scrollable-container", qX = "dx-button", YX = "form-buttons-container", Uw = "dx-edit-row", iu = function(i) {
  return function(e) {
    const t = e instanceof Error ? e : new Error(e && String(e) || "Unknown error");
    i.reject(t);
  };
}, UA = function(i, e) {
  return e.isEditing || i && e.column.allowEditing;
}, jw = function(i, e) {
  const t = !!e.column.command, n = UA(i, e), s = !t && (n || e.column.showEditorAlways);
  return e.rowType === "data" && s;
}, XX = (i) => {
  const e = i.component.option("editing.texts") || {};
  return {
    save: e.saveRowChanges,
    cancel: e.cancelRowChanges,
    edit: e.editRow,
    undelete: e.undeleteRow,
    delete: e.deleteRow,
    add: e.addRowToNode
  };
}, ZX = () => `_DX_KEY_${new Xe()}`, QX = (i) => typeof i == "string" && i.startsWith("_DX_KEY_") && i.length === 44, wr = (i, e) => {
  let t = -1;
  return i.some((n, s) => {
    if (jA(n) === e)
      return t = s, !0;
  }), t;
};
function jA(i) {
  return X(i) ? i.name : i;
}
function JX(i) {
  return i && (i.is("input") || i.is("textarea"));
}
const e8 = (i) => {
  var e;
  const {
    column: t
  } = i;
  return i.isCustomEditorType ? i.editorType : (e = t.formItem) === null || e === void 0 ? void 0 : e.editorType;
}, qA = (i, e) => {
  i.forEach((t) => {
    t.items || t.tabs ? qA(t.items || t.tabs, e) : e(t);
  });
};
class t8 extends Ue.ViewController {
  init() {
    this._columnsController = this.getController("columns"), this._dataController = this.getController("data"), this._adaptiveColumnsController = this.getController("adaptiveColumns"), this._validatingController = this.getController("validating"), this._editorFactoryController = this.getController("editorFactory"), this._focusController = this.getController("focus"), this._keyboardNavigationController = this.getController("keyboardNavigation"), this._columnsResizerController = this.getController("columnsResizer"), this._errorHandlingController = this.getController("errorHandling"), this._rowsView = this.getView("rowsView"), this._headerPanelView = this.getView("headerPanel"), this._lastOperation = null, this._changes = [], this._deferreds && this._deferreds.forEach((e) => {
      e.reject("cancel");
    }), this._deferreds = [], this._dataChangedHandler || (this._dataChangedHandler = this._handleDataChanged.bind(this), this._dataController.changed.add(this._dataChangedHandler)), this._saveEditorHandler || (this.createAction("onInitNewRow", {
      excludeValidators: ["disabled", "readOnly"]
    }), this.createAction("onRowInserting", {
      excludeValidators: ["disabled", "readOnly"]
    }), this.createAction("onRowInserted", {
      excludeValidators: ["disabled", "readOnly"]
    }), this.createAction("onEditingStart", {
      excludeValidators: ["disabled", "readOnly"]
    }), this.createAction("onRowUpdating", {
      excludeValidators: ["disabled", "readOnly"]
    }), this.createAction("onRowUpdated", {
      excludeValidators: ["disabled", "readOnly"]
    }), this.createAction("onRowRemoving", {
      excludeValidators: ["disabled", "readOnly"]
    }), this.createAction("onRowRemoved", {
      excludeValidators: ["disabled", "readOnly"]
    }), this.createAction("onSaved", {
      excludeValidators: ["disabled", "readOnly"]
    }), this.createAction("onSaving", {
      excludeValidators: ["disabled", "readOnly"]
    }), this.createAction("onEditCanceling", {
      excludeValidators: ["disabled", "readOnly"]
    }), this.createAction("onEditCanceled", {
      excludeValidators: ["disabled", "readOnly"]
    })), this._updateEditColumn(), this._updateEditButtons(), this._internalState || (this._internalState = /* @__PURE__ */ new Map()), this.component._optionsByReference[Sn] = !0, this.component._optionsByReference[Yi] = !0;
  }
  getEditMode() {
    const e = this.option("editing.mode") ?? ul;
    return _X.includes(e) ? e : ul;
  }
  isCellBasedEditMode() {
    const e = this.getEditMode();
    return vX.includes(e);
  }
  _getDefaultEditorTemplate() {
    return (e, t) => {
      const n = p("<div>").appendTo(e), s = x({}, t.column, {
        value: t.value,
        setValue: t.setValue,
        row: t.row,
        parentType: "dataRow",
        width: null,
        readOnly: !t.setValue,
        isOnForm: t.isOnForm,
        id: t.id
      });
      xX.includes(this.getEditMode()) && (s["aria-labelledby"] = t.column.headerId), this._editorFactoryController.createEditor(n, s);
    };
  }
  _getNewRowPosition() {
    const e = this.option("editing.newRowPosition");
    if (this.option("scrolling.mode") === "virtual")
      switch (e) {
        case Up:
          return KA;
        case Ww:
          return zw;
        default:
          return e;
      }
    return e;
  }
  getChanges() {
    return this.option(Yi);
  }
  getInsertRowCount() {
    return this.option(Yi).filter((t) => t.type === "insert").length;
  }
  resetChanges() {
    const e = this.getChanges();
    e?.length && (this._silentOption(Yi, []), this._internalState.clear());
  }
  _getInternalData(e) {
    return this._internalState.get(xn(e));
  }
  _addInternalData(e) {
    const t = this._getInternalData(e.key);
    return t ? x(t, e) : (this._internalState.set(xn(e.key), e), e);
  }
  _getOldData(e) {
    var t;
    return (t = this._getInternalData(e)) === null || t === void 0 ? void 0 : t.oldData;
  }
  getUpdatedData(e) {
    const t = this._dataController.keyOf(e), n = this.getChanges(), s = F.getIndexByKey(t, n);
    return n[s] ? Ns(e, n[s].data) : e;
  }
  getInsertedData() {
    return this.getChanges().filter((e) => e.data && e.type === Jn).map((e) => e.data);
  }
  getRemovedData() {
    return this.getChanges().filter((e) => this._getOldData(e.key) && e.type === qi).map((e) => this._getOldData(e.key));
  }
  _fireDataErrorOccurred(e) {
    if (e === "cancel")
      return;
    const t = this.getPopupContent();
    this._dataController.dataErrorOccurred.fire(e, t);
  }
  _needToCloseEditableCell(e) {
  }
  _closeEditItem(e) {
  }
  _handleDataChanged(e) {
  }
  _isDefaultButtonVisible(e, t) {
    let n = !0;
    switch (e.name) {
      case "delete":
        n = this.allowDeleting(t);
        break;
      case "undelete":
        n = !1;
    }
    return n;
  }
  isPopupEditMode() {
    return this.option("editing.mode") === fX;
  }
  _isButtonVisible(e, t) {
    const {
      visible: n
    } = e;
    return f(n) ? B(n) ? n.call(e, {
      component: t.component,
      row: t.row,
      column: t.column
    }) : n : this._isDefaultButtonVisible(e, t);
  }
  _isButtonDisabled(e, t) {
    const {
      disabled: n
    } = e;
    return B(n) ? n.call(e, {
      component: t.component,
      row: t.row,
      column: t.column
    }) : !!n;
  }
  _getButtonConfig(e, t) {
    const n = X(e) ? e : {}, s = jA(e), o = XX(t), r = PX[s], a = this.option("editing"), l = MX[s], d = l ? a[l] : !0;
    return x({
      name: s,
      text: o[s],
      cssClass: kX[s]
    }, {
      onClick: r && ((u) => {
        const {
          event: c
        } = u;
        c.stopPropagation(), c.preventDefault(), setTimeout(() => {
          t.row && d && this[r] && this[r](t.row.rowIndex);
        });
      })
    }, n);
  }
  _getEditingButtons(e) {
    let t;
    const n = !!e.column.buttons;
    let s = (e.column.buttons || []).slice();
    return n ? (t = wr(s, "edit"), t >= 0 && (wr(s, "save") < 0 && s.splice(t + 1, 0, "save"), wr(s, "cancel") < 0 && s.splice(wr(s, "save") + 1, 0, "cancel")), t = wr(s, "delete"), t >= 0 && wr(s, "undelete") < 0 && s.splice(t + 1, 0, "undelete")) : s = BX.slice(), s.map((o) => this._getButtonConfig(o, e));
  }
  _renderEditingButtons(e, t, n, s) {
    t.forEach((o) => {
      this._isButtonVisible(o, n) && this._createButton(e, o, n, s);
    });
  }
  _getEditCommandCellTemplate() {
    return (e, t, n) => {
      const s = p(e);
      if (t.rowType === "data") {
        const o = this._getEditingButtons(t);
        if (this._renderEditingButtons(s, o, t, n), t.watch) {
          const r = t.watch(() => o.map((a) => ({
            visible: this._isButtonVisible(a, t),
            disabled: this._isButtonDisabled(a, t)
          })), () => {
            s.empty(), this._renderEditingButtons(s, o, t);
          });
          _.on(s, On, r);
        }
      } else
        F.setEmptyText(s);
    };
  }
  isRowBasedEditMode() {
    const e = this.getEditMode();
    return CX.includes(e);
  }
  getFirstEditableColumnIndex() {
    let e;
    const t = this._columnsController.getVisibleColumns();
    return y(t, (n, s) => {
      if (s.allowEditing)
        return e = n, !1;
    }), e;
  }
  getFirstEditableCellInRow(e) {
    var t;
    const n = this.getFirstEditableColumnIndex();
    return (t = this._rowsView) === null || t === void 0 ? void 0 : t._getCellElement(e || 0, n);
  }
  getFocusedCellInRow(e) {
    return this.getFirstEditableCellInRow(e);
  }
  getIndexByKey(e, t) {
    return F.getIndexByKey(e, t);
  }
  hasChanges(e) {
    const t = this.getChanges();
    let n = !1;
    for (let s = 0; s < t?.length; s++)
      if (t[s].type && (!f(e) || this._dataController.getRowIndexByKey(t[s].key) === e)) {
        n = !0;
        break;
      }
    return n;
  }
  dispose() {
    super.dispose(), clearTimeout(this._inputFocusTimeoutID), _.off(O.getDocument(), ye.up, this._pointerUpEditorHandler), _.off(O.getDocument(), ye.down, this._pointerDownEditorHandler), _.off(O.getDocument(), Te, this._saveEditorHandler);
  }
  _silentOption(e, t) {
    e === "editing.changes" && (this._changes = an([], t)), super._silentOption(e, t);
  }
  optionChanged(e) {
    if (e.name === "editing") {
      const {
        fullName: t
      } = e;
      t === Sn ? this._handleEditRowKeyChange(e) : t === Yi ? He(e.value, this._changes, {
        maxDepth: 4
      }) || (this._changes = an([], e.value), this._handleChangesChange(e)) : e.handled || (this._columnsController.reinit(), this.init(), this.resetChanges(), this._resetEditColumnName(), this._resetEditRowKey()), e.handled = !0;
    } else
      super.optionChanged(e);
  }
  _handleEditRowKeyChange(e) {
    const t = this._dataController.getRowIndexByKey(e.value), n = this._getEditRowIndexCorrection(), s = this._dataController.getRowIndexByKey(e.previousValue) + n;
    f(e.value) ? e.value !== e.previousValue && this._editRowFromOptionChanged(t, s) : this.cancelEditData();
  }
  _handleChangesChange(e) {
    const t = this._dataController, n = e.value;
    !e.value.length && !e.previousValue.length || (n.forEach((s) => {
      if (s.type === "insert")
        this._addInsertInfo(s);
      else {
        var o;
        const r = t.getCachedStoreData() || ((o = t.items()) === null || o === void 0 ? void 0 : o.map((l) => l.data)), a = F.getIndexByKey(s.key, r, t.key());
        this._addInternalData({
          key: s.key,
          oldData: r[a]
        });
      }
    }), t.updateItems({
      repaintChangesOnly: !0,
      isLiveUpdate: !1,
      isOptionChanged: !0
    }));
  }
  publicMethods() {
    return ["addRow", "deleteRow", "undeleteRow", "editRow", "saveEditData", "cancelEditData", "hasEditData"];
  }
  refresh() {
    f(this._pageIndex) && this._refreshCore.apply(this, arguments);
  }
  _refreshCore(e) {
  }
  isEditing() {
    return f(this.option(Sn));
  }
  isEditRow(e) {
    return !1;
  }
  _setEditRowKey(e, t) {
    t ? this._silentOption(Sn, e) : this.option(Sn, e), this._refocusEditCell && (this._refocusEditCell = !1, this._focusEditingCell());
  }
  _setEditRowKeyByIndex(e, t) {
    const n = this._dataController.getKeyByRowIndex(e);
    if (n === void 0) {
      this._dataController.fireError("E1043");
      return;
    }
    this._setEditRowKey(n, t);
  }
  getEditRowIndex() {
    return this._getVisibleEditRowIndex();
  }
  getEditFormRowIndex() {
    return -1;
  }
  isEditRowByIndex(e) {
    const t = this._dataController.getKeyByRowIndex(e), n = f(t) && He(this.option(Sn), t);
    return n && this._getVisibleEditRowIndex() === e;
  }
  isEditCell(e, t) {
    return this.isEditRowByIndex(e) && this._getVisibleEditColumnIndex() === t;
  }
  getPopupContent() {
  }
  _isProcessedItem(e) {
    return !1;
  }
  _getInsertRowIndex(e, t, n) {
    let s = -1;
    const o = this._dataController, r = this._getInsertAfterOrBeforeKey(t);
    return !f(r) && e.length === 0 ? s = 0 : f(r) && e.some((a, l) => {
      const d = n || this._isProcessedItem(a);
      if (X(a) && (d || f(a[Is]) ? He(a.key, r) && (s = l) : He(o.keyOf(a), r) && (s = l)), s >= 0) {
        const u = e[s + 1];
        return u && (u.rowType === "detail" || u.rowType === "detailAdaptive") && f(t.insertAfterKey) ? void 0 : (f(t.insertAfterKey) && (s += 1), !0);
      }
    }), s;
  }
  _generateNewItem(e) {
    var t;
    const n = {
      key: e
    }, s = (t = this._getInternalData(e)) === null || t === void 0 ? void 0 : t.insertInfo;
    return s != null && s[Is] && (n[Is] = s[Is]), n;
  }
  _getLoadedRowIndex(e, t, n) {
    let s = this._getInsertRowIndex(e, t, n);
    const o = this._dataController;
    if (s < 0) {
      const r = this._getNewRowPosition(), a = o.pageIndex(), l = this._getInsertAfterOrBeforeKey(t);
      r !== nu && a === 0 && !f(l) ? s = 0 : r === nu && o.isLastPageLoaded() && (s = e.length);
    }
    return s;
  }
  processItems(e, t) {
    const {
      changeType: n
    } = t;
    return this.update(n), this.getChanges().forEach((o) => {
      var r;
      if (!(o.type === Jn))
        return;
      let {
        key: l
      } = o, d = (r = this._getInternalData(l)) === null || r === void 0 ? void 0 : r.insertInfo;
      (!f(l) || !f(d)) && (d = this._addInsertInfo(o), l = d.key);
      const u = this._getLoadedRowIndex(e, o), c = this._generateNewItem(l);
      u >= 0 && e.splice(u, 0, c);
    }), e;
  }
  processDataItem(e, t, n) {
    const s = t.visibleColumns, o = e.data[Is] ? e.data.key : e.key, r = this.getChanges(), a = F.getIndexByKey(o, r);
    e.isEditing = !1, a >= 0 && this._processDataItemCore(e, r[a], o, s, n);
  }
  _processDataItemCore(e, t, n, s, o) {
    const {
      data: r,
      type: a
    } = t;
    switch (a) {
      case Jn:
        e.isNewRow = !0, e.key = n, e.data = r;
        break;
      case Na:
        e.modified = !0, e.oldData = e.data, e.data = Ns(e.data, r), e.modifiedValues = o(r, s, !0);
        break;
      case qi:
        e.removed = !0;
    }
  }
  _initNewRow(e) {
    if (this.executeAction("onInitNewRow", e), e.promise) {
      const t = new w();
      return W(It(e.promise)).done(t.resolve).fail(iu(t)).fail((n) => this._fireDataErrorOccurred(n)), t;
    }
  }
  _createInsertInfo() {
    const e = {};
    return e[Is] = this._getInsertIndex(), e;
  }
  _addInsertInfo(e, t) {
    var n;
    let s;
    e.key = this.getChangeKeyValue(e);
    const {
      key: o
    } = e;
    if (s = (n = this._getInternalData(o)) === null || n === void 0 ? void 0 : n.insertInfo, !f(s)) {
      const r = this._getInsertAfterOrBeforeKey(e);
      s = this._createInsertInfo(), f(r) || this._setInsertAfterOrBeforeKey(e, t);
    }
    return this._addInternalData({
      insertInfo: s,
      key: o
    }), {
      insertInfo: s,
      key: o
    };
  }
  getChangeKeyValue(e) {
    if (f(e.key))
      return e.key;
    const t = this._dataController.key();
    let n;
    return e.data && t && !Array.isArray(t) && (n = e.data[t]), f(n) || (n = ZX()), n;
  }
  _setInsertAfterOrBeforeKey(e, t) {
    const n = this.getView("rowsView"), s = this._dataController, o = s.items(!0), r = this._getNewRowPosition();
    switch (r) {
      case Hw:
      case nu:
        break;
      case Up:
      case Ww:
        if (o.length) {
          const a = r === Up ? 0 : o.length - 1;
          e[a === 0 ? "insertBeforeKey" : "insertAfterKey"] = o[a].key;
        }
        break;
      default: {
        let l = r === zw ? n?.getBottomVisibleItemIndex() : n?.getTopVisibleItemIndex();
        const d = s.getVisibleRows()[l];
        d && (!d.isEditing && d.rowType === "detail" || d.rowType === "detailAdaptive") && l++;
        const u = s.getKeyByRowIndex(l);
        f(u) && (e.insertBeforeKey = u);
      }
    }
  }
  _getInsertIndex() {
    let e = 0;
    return this.getChanges().forEach((t) => {
      var n;
      const s = (n = this._getInternalData(t.key)) === null || n === void 0 ? void 0 : n.insertInfo;
      f(s) && t.type === Jn && s[Is] > e && (e = s[Is]);
    }), e + 1;
  }
  _getInsertAfterOrBeforeKey(e) {
    return e.insertAfterKey ?? e.insertBeforeKey;
  }
  _getPageIndexToInsertRow() {
    const e = this._getNewRowPosition(), t = this._dataController, n = t.pageIndex(), s = t.pageCount() - 1;
    return e === Hw && n !== 0 ? 0 : e === nu && n !== s ? s : -1;
  }
  addRow(e) {
    const t = this._dataController;
    return t.store() ? this._addRow(e) : (t.fireError("E1052", this.component.NAME), new w().reject());
  }
  _addRow(e) {
    const n = this._dataController.store(), s = n && n.key(), o = {
      data: {}
    }, r = this._getVisibleEditRowIndex(), a = new w();
    return this.refresh({
      allowCancelEditing: !0
    }), this._allowRowAdding() ? (s || (o.data.__KEY__ = String(new Xe())), W(this._initNewRow(o, e)).done(() => {
      this._allowRowAdding() ? W(this._addRowCore(o.data, e, r)).done(a.resolve).fail(a.reject) : a.reject("cancel");
    }).fail(a.reject), a.promise()) : (W(this._navigateToNewRow(r)).done(a.resolve).fail(a.reject), a.promise());
  }
  _allowRowAdding(e) {
    return !(this._getInsertIndex() > 1);
  }
  _addRowCore(e, t, n) {
    const s = {
      data: e,
      type: Jn
    }, o = this._getVisibleEditRowIndex(), r = this._addInsertInfo(s, t), {
      key: a
    } = r;
    return this._setEditRowKey(a, !0), this._addChange(s), this._navigateToNewRow(n, s, o);
  }
  _navigateToNewRow(e, t, n) {
    const s = new w(), o = this._dataController;
    if (n = n ?? -1, t = t ?? this.getChanges().filter((u) => u.type === Jn)[0], !t)
      return s.reject("cancel").promise();
    const r = this._getPageIndexToInsertRow();
    let a = this._getLoadedRowIndex(o.items(), t, !0);
    const l = (u) => {
      var c;
      W((c = this._focusController) === null || c === void 0 ? void 0 : c.navigateToRow(u)).done(() => {
        a = o.getRowIndexByKey(t.key), s.resolve();
      });
    }, d = this._getInsertAfterOrBeforeKey(t);
    return r >= 0 ? o.pageIndex(r).done(() => {
      l(t.key);
    }).fail(s.reject) : a < 0 && f(d) ? l(d) : (o.updateItems({
      changeType: "update",
      rowIndices: [e, n, a]
    }), a = o.getRowIndexByKey(t.key), a < 0 ? l(t.key) : s.resolve()), s.done(() => {
      var u;
      (u = this._rowsView) === null || u === void 0 || u.waitAsyncTemplates(!0).done(() => {
        this._showAddedRow(a), this._afterInsertRow(t.key);
      });
    }), s.promise();
  }
  _showAddedRow(e) {
    this._focusFirstEditableCellInRow(e);
  }
  _beforeFocusElementInRow(e) {
  }
  _focusFirstEditableCellInRow(e) {
    var t;
    const n = this._dataController, s = n.getKeyByRowIndex(e), o = this.getFirstEditableCellInRow(e);
    (t = this._keyboardNavigationController) === null || t === void 0 || t.focus(o), this.option("focusedRowKey", s), this._editCellInProgress = !0, this._delayedInputFocus(o, () => {
      e = n.getRowIndexByKey(s), this._editCellInProgress = !1, this._beforeFocusElementInRow(e);
    });
  }
  _isEditingStart(e) {
    return this.executeAction("onEditingStart", e), e.cancel;
  }
  _beforeUpdateItems(e, t) {
  }
  _getVisibleEditColumnIndex() {
    const e = this.option(Do);
    return f(e) ? this._columnsController.getVisibleColumnIndex(e) : -1;
  }
  _setEditColumnNameByIndex(e, t) {
    var n;
    const s = this._columnsController.getVisibleColumns();
    this._setEditColumnName((n = s[e]) === null || n === void 0 ? void 0 : n.name, t);
  }
  _setEditColumnName(e, t) {
    t ? this._silentOption(Do, e) : this.option(Do, e);
  }
  _resetEditColumnName() {
    this._setEditColumnName(null, !0);
  }
  _getEditColumn() {
    const e = this.option(Do);
    return this._getColumnByName(e);
  }
  _getColumnByName(e) {
    const t = this._columnsController.getVisibleColumns();
    let n;
    return f(e) && t.some((s) => {
      if (s.name === e)
        return n = s, !0;
    }), n;
  }
  _getVisibleEditRowIndex(e) {
    const t = this._dataController, n = this.option(Sn), s = t.getRowIndexByKey(n);
    return s === -1 ? s : s + this._getEditRowIndexCorrection(e);
  }
  _getEditRowIndexCorrection(e) {
    const t = e ? this._getColumnByName(e) : this._getEditColumn();
    return t?.visibleWidth === "adaptiveHidden" ? 1 : 0;
  }
  _resetEditRowKey() {
    this._refocusEditCell = !1, this._setEditRowKey(null, !0);
  }
  _resetEditIndices() {
    this._resetEditColumnName(), this._resetEditRowKey();
  }
  editRow(e) {
    const t = this._dataController, s = t.items()[e], o = {
      data: s && s.data,
      cancel: !1
    }, r = this._getVisibleEditRowIndex();
    if (s) {
      if (e === r)
        return !0;
      if (s.key === void 0) {
        this._dataController.fireError("E1043");
        return;
      }
      s.isNewRow || (o.key = s.key), !this._isEditingStart(o) && (this.resetChanges(), this.init(), this._resetEditColumnName(), this._pageIndex = t.pageIndex(), this._addInternalData({
        key: s.key,
        oldData: s.oldData ?? s.data
      }), this._setEditRowKey(s.key));
    }
  }
  _editRowFromOptionChanged(e, t) {
    const n = [t, e];
    this._beforeUpdateItems(n, e, t), this._editRowFromOptionChangedCore(n, e);
  }
  _editRowFromOptionChangedCore(e, t, n) {
    this._needFocusEditor = !0, this._dataController.updateItems({
      changeType: "update",
      rowIndices: e,
      cancel: n
    });
  }
  _focusEditorIfNeed() {
  }
  _showEditPopup(e, t) {
  }
  _repaintEditPopup() {
  }
  _getEditPopupHiddenHandler() {
    return (e) => {
      this.isEditing() && this.cancelEditData();
    };
  }
  _getPopupEditFormTemplate(e) {
  }
  _getSaveButtonConfig() {
    const e = {
      text: this.option("editing.texts.saveRowChanges"),
      onClick: this.saveEditData.bind(this)
    };
    return nn(pn()) && (e.stylingMode = "contained", e.type = "default"), e;
  }
  _getCancelButtonConfig() {
    const e = {
      text: this.option("editing.texts.cancelRowChanges"),
      onClick: this.cancelEditData.bind(this)
    };
    return nn(pn()) && (e.stylingMode = "outlined"), e;
  }
  _removeInternalData(e) {
    this._internalState.delete(xn(e));
  }
  _updateInsertAfterOrBeforeKeys(e, t) {
    const n = e[t];
    e.forEach((s) => {
      if (s.type === Jn) {
        const o = this._getInsertAfterOrBeforeKey(s);
        He(o, n.key) && (s[f(s.insertAfterKey) ? "insertAfterKey" : "insertBeforeKey"] = this._getInsertAfterOrBeforeKey(n));
      }
    });
  }
  _removeChange(e) {
    if (e >= 0) {
      const t = [...this.getChanges()], {
        key: n
      } = t[e];
      this._removeInternalData(n), this._updateInsertAfterOrBeforeKeys(t, e), t.splice(e, 1), this._silentOption(Yi, t), He(this.option(Sn), n) && this._resetEditIndices();
    }
  }
  executeOperation(e, t) {
    this._lastOperation && this._lastOperation.reject(), this._lastOperation = e, this.waitForDeferredOperations().done(() => {
      e.state() !== "rejected" && (t(), this._lastOperation = null);
    }).fail(() => {
      e.reject(), this._lastOperation = null;
    });
  }
  waitForDeferredOperations() {
    return W(...this._deferreds);
  }
  _processCanceledEditingCell() {
  }
  _repaintEditCell(e, t, n) {
    !e || !e.showEditorAlways || t && !t.showEditorAlways ? (this._editCellInProgress = !0, this._needFocusEditor = !0, this._editorFactoryController.loseFocus(), this._dataController.updateItems({
      changeType: "update",
      rowIndices: [n, this._getVisibleEditRowIndex()]
    })) : e !== t && (this._needFocusEditor = !0, this._dataController.updateItems({
      changeType: "update",
      rowIndices: []
    }));
  }
  _delayedInputFocus(e, t, n) {
    const s = () => {
      if (t && t(), e) {
        const o = e.find(vC).first();
        F.focusAndSelectElement(this, o);
      }
      this._beforeFocusCallback = null;
    };
    z.real().ios || z.real().android ? s() : (this._beforeFocusCallback && this._beforeFocusCallback(), clearTimeout(this._inputFocusTimeoutID), n && (this._beforeFocusCallback = t), this._inputFocusTimeoutID = setTimeout(s));
  }
  _focusEditingCell(e, t, n) {
    const s = this._getVisibleEditColumnIndex();
    t = t || this._rowsView && this._rowsView._getCellElement(this._getVisibleEditRowIndex(), s), t && this._delayedInputFocus(t, e, n);
  }
  deleteRow(e) {
    this._checkAndDeleteRow(e);
  }
  _checkAndDeleteRow(e) {
    const t = this.option("editing"), n = t?.texts, s = t?.confirmDelete, o = n?.confirmDeleteMessage, r = this._dataController.items()[e], a = !this.isEditing() || r.isNewRow;
    if (r && a)
      if (!s || !o)
        this._deleteRowCore(e);
      else {
        const l = n && n.confirmDeleteTitle, d = f(l) && l.length > 0;
        gX(o, l, d).done((u) => {
          u && this._deleteRowCore(e);
        });
      }
  }
  _deleteRowCore(e) {
    const n = this._dataController.items()[e], s = n && n.key, o = this._getVisibleEditRowIndex();
    this.refresh();
    const r = this.getChanges(), a = F.getIndexByKey(s, r);
    return a >= 0 ? r[a].type === Jn ? this._removeChange(a) : this._addChange({
      key: s,
      type: qi
    }) : this._addChange({
      key: s,
      oldData: n.data,
      type: qi
    }), this._afterDeleteRow(e, o);
  }
  _afterDeleteRow(e, t) {
    return this.saveEditData();
  }
  undeleteRow(e) {
    const t = this._dataController, n = t.items()[e], s = this._getVisibleEditRowIndex(), o = n && n.key, r = this.getChanges();
    if (n) {
      const a = F.getIndexByKey(o, r);
      if (a >= 0) {
        const {
          data: l
        } = r[a];
        en(l) ? this._removeChange(a) : this._addChange({
          key: o,
          type: Na
        }), t.updateItems({
          changeType: "update",
          rowIndices: [s, e]
        });
      }
    }
  }
  _fireOnSaving() {
    const e = {
      cancel: !1,
      promise: null,
      changes: [...this.getChanges()]
    };
    this.executeAction("onSaving", e);
    const t = new w();
    return W(It(e.promise)).done(() => {
      t.resolve(e);
    }).fail((n) => {
      this._fireDataErrorOccurred(n), t.resolve({
        cancel: !0
      });
    }), t;
  }
  _executeEditingAction(e, t, n) {
    if (this.component._disposed)
      return null;
    const s = new w();
    return this.executeAction(e, t), W(It(t.cancel)).done((o) => {
      o ? setTimeout(() => {
        s.resolve("cancel");
      }) : n(t).done(s.resolve).fail(iu(s));
    }).fail(iu(s)), s;
  }
  _processChanges(e, t, n, s) {
    const o = this._dataController.store();
    y(s, (r, a) => {
      const l = this._getOldData(a.key), {
        data: d,
        type: u
      } = a, c = I({}, a);
      let h, g;
      if (!this._beforeSaveEditData(a, r)) {
        switch (u) {
          case qi:
            g = {
              data: l,
              key: a.key,
              cancel: !1
            }, h = this._executeEditingAction("onRowRemoving", g, () => o.remove(a.key).done((m) => {
              n.push({
                type: "remove",
                key: m
              });
            }));
            break;
          case Jn:
            g = {
              data: d,
              cancel: !1
            }, h = this._executeEditingAction("onRowInserting", g, () => o.insert(g.data).done((m, C) => {
              f(C) && (c.key = C), m && X(m) && m !== g.data && (c.data = m), n.push({
                type: "insert",
                data: m,
                index: 0
              });
            }));
            break;
          case Na:
            g = {
              newData: d,
              oldData: l,
              key: a.key,
              cancel: !1
            }, h = this._executeEditingAction("onRowUpdating", g, () => o.update(a.key, g.newData).done((m, C) => {
              m && X(m) && m !== g.newData && (c.data = m), n.push({
                type: "update",
                key: C,
                data: m
              });
            }));
        }
        if (s[r] = c, h) {
          const m = new w();
          h.always((C) => {
            t.push({
              key: a.key,
              result: C
            });
          }).always(m.resolve), e.push(m.promise());
        }
      }
    });
  }
  _processRemoveIfError(e, t) {
    const n = e[t];
    return n?.type === qi && t >= 0 && e.splice(t, 1), !0;
  }
  _processRemove(e, t, n) {
    const s = e[t];
    if (!n || !s || s.type === qi)
      return this._processRemoveCore(e, t, !n || !s);
  }
  _processRemoveCore(e, t, n) {
    return t >= 0 && e.splice(t, 1), !0;
  }
  _processSaveEditDataResult(e) {
    let t = !1;
    const n = this.getChanges(), s = [...n], o = s.length;
    for (let r = 0; r < e.length; r++) {
      const a = e[r].result, l = a === "cancel", d = F.getIndexByKey(e[r].key, s), u = s[d];
      if (a && a instanceof Error) {
        if (u && this._addInternalData({
          key: u.key,
          error: a
        }), this._fireDataErrorOccurred(a), this._processRemoveIfError(s, d))
          break;
      } else if (this._processRemove(s, d, l)) {
        t = !l;
        const h = F.getIndexByKey(e[r].key, n);
        this._updateInsertAfterOrBeforeKeys(n, h);
      }
    }
    return s.length < o && this._silentOption(Yi, s), t;
  }
  _fireSaveEditDataEvents(e) {
    y(e, (t, n) => {
      let {
        data: s,
        key: o,
        type: r
      } = n;
      const a = this._addInternalData({
        key: o
      }), l = {
        key: o,
        data: s
      };
      switch (a.error && (l.error = a.error), r) {
        case qi:
          this.executeAction("onRowRemoved", x({}, l, {
            data: a.oldData
          }));
          break;
        case Jn:
          this.executeAction("onRowInserted", l);
          break;
        case Na:
          this.executeAction("onRowUpdated", l);
      }
    }), this.executeAction("onSaved", {
      changes: e
    });
  }
  saveEditData() {
    const e = new w();
    return this.waitForDeferredOperations().done(() => {
      if (this.isSaving()) {
        this._resolveAfterSave(e);
        return;
      }
      W(this._beforeSaveEditData()).done((t) => {
        if (t) {
          this._resolveAfterSave(e, {
            cancel: t
          });
          return;
        }
        this._saving = !0, this._saveEditDataInner().always(() => {
          this._saving = !1, this._refocusEditCell && this._focusEditingCell();
        }).done(e.resolve).fail(e.reject);
      }).fail(e.reject);
    }).fail(e.reject), e.promise();
  }
  _resolveAfterSave(e) {
    let {
      cancel: t,
      error: n
    } = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    W(this._afterSaveEditData(t)).done(() => {
      e.resolve(n);
    }).fail(e.reject);
  }
  _saveEditDataInner() {
    const e = new w(), t = [], n = [], s = [], o = this._dataController.dataSource();
    return W(this._fireOnSaving()).done((r) => {
      let {
        cancel: a,
        changes: l
      } = r;
      if (a)
        return e.resolve().promise();
      if (this._processChanges(n, t, s, l), n.length)
        return this._refocusEditCell = !0, o?.beginLoading(), W(...n).done(() => {
          this._processSaveEditDataResult(t) ? this._endSaving(s, l, e) : (o?.endLoading(), e.resolve());
        }).fail((d) => {
          o?.endLoading(), e.resolve(d);
        }), e.always(() => {
          this._refocusEditCell = !0;
        }).promise();
      this._cancelSaving(e);
    }).fail(e.reject), e.promise();
  }
  _beforeEndSaving(e) {
    this._resetEditIndices();
  }
  _endSaving(e, t, n) {
    const s = this._dataController.dataSource();
    this._beforeEndSaving(t), s?.endLoading(), this._refreshDataAfterSave(e, t, n);
  }
  _cancelSaving(e) {
    this.executeAction("onSaved", {
      changes: []
    }), this._resolveAfterSave(e);
  }
  _refreshDataAfterSave(e, t, n) {
    const s = this._dataController, o = this.option("editing.refreshMode"), r = o !== "reshape" && o !== "repaint";
    r || s.push(e), W(s.refresh({
      selection: r,
      reload: r,
      load: o === "reshape",
      changesOnly: this.option("repaintChangesOnly")
    })).always(() => {
      this._fireSaveEditDataEvents(t);
    }).done(() => {
      this._resolveAfterSave(n);
    }).fail((a) => {
      this._resolveAfterSave(n, {
        error: a
      });
    });
  }
  isSaving() {
    return this._saving;
  }
  _updateEditColumn() {
    const e = this._isEditColumnVisible(), t = this.option("editing.useIcons"), n = DX + (t ? ` ${Kw}` : "");
    this._columnsController.addCommandColumn({
      type: "buttons",
      command: "edit",
      visible: e,
      cssClass: n,
      width: "auto",
      alignment: "center",
      cellTemplate: this._getEditCommandCellTemplate(),
      fixedPosition: "right"
    }), this._columnsController.columnOption("command:edit", {
      visible: e,
      cssClass: n
    });
  }
  _isEditColumnVisible() {
    return this.option("editing").allowDeleting;
  }
  _isEditButtonDisabled() {
    const e = this.hasChanges();
    return !(f(this.option("editing.editRowKey")) || e);
  }
  _updateEditButtons() {
    const e = this._isEditButtonDisabled();
    this._headerPanelView && (this._headerPanelView.setToolbarItemDisabled("saveButton", e), this._headerPanelView.setToolbarItemDisabled("revertButton", e));
  }
  _applyModified(e, t) {
    e && e.addClass(Gw);
  }
  _beforeCloseEditCellInBatchMode(e) {
  }
  cancelEditData() {
    const e = this.getChanges(), t = {
      cancel: !1,
      changes: e
    };
    this.executeAction("onEditCanceling", t), t.cancel || (this._cancelEditDataCore(), this.executeAction("onEditCanceled", {
      changes: e
    }));
  }
  _cancelEditDataCore() {
    const e = this._getVisibleEditRowIndex();
    this._beforeCancelEditData(), this.init(), this.resetChanges(), this._resetEditColumnName(), this._resetEditRowKey(), this._afterCancelEditData(e);
  }
  _afterCancelEditData(e) {
    this._dataController.updateItems({
      repaintChangesOnly: this.option("repaintChangesOnly")
    });
  }
  _hideEditPopup() {
  }
  hasEditData() {
    return this.hasChanges();
  }
  update(e) {
    const t = this._dataController;
    t && this._pageIndex !== t.pageIndex() && (e === "refresh" && this.refresh({
      isPageChanged: !0
    }), this._pageIndex = t.pageIndex()), this._updateEditButtons();
  }
  _getRowIndicesForCascadeUpdating(e, t) {
    return t ? [] : [e.rowIndex];
  }
  addDeferred(e) {
    this._deferreds.includes(e) || (this._deferreds.push(e), e.always(() => {
      const t = this._deferreds.indexOf(e);
      t >= 0 && this._deferreds.splice(t, 1);
    }));
  }
  _prepareChange(e, t, n) {
    var s;
    const o = {}, r = (s = e.row) === null || s === void 0 ? void 0 : s.data, a = e.key, l = new w();
    return a !== void 0 && (e.value = t, It(e.column.setCellValue(o, t, x(!0, {}, r), n)).done(() => {
      l.resolve({
        data: o,
        key: a,
        oldData: r,
        type: Na
      });
    }).fail(iu(l)).fail((u) => this._fireDataErrorOccurred(u)), f(n) && e.column.displayValueMap && (e.column.displayValueMap[t] = n), this._updateRowValues(e), this.addDeferred(l)), l;
  }
  _updateRowValues(e) {
    if (e.values) {
      const t = this._dataController, n = t.getRowIndexByKey(e.key), s = t.getVisibleRows()[n];
      s && (e.row.values = s.values, e.values = s.values), e.values[e.columnIndex] = e.value;
    }
  }
  updateFieldValue(e, t, n, s) {
    const o = e.key, r = new w();
    return o === void 0 && this._dataController.fireError("E1043"), e.column.setCellValue ? this._prepareChange(e, t, n).done((a) => {
      W(this._applyChange(e, a, s)).always(() => {
        r.resolve();
      });
    }) : r.resolve(), r.promise();
  }
  _focusPreviousEditingCellIfNeed(e) {
    if (this.hasEditData() && !this.isEditCell(e.rowIndex, e.columnIndex))
      return this._focusEditingCell(), this._updateEditRow(e.row, !0), !0;
  }
  _needUpdateRow(e) {
    const t = this._columnsController.getVisibleColumns();
    e || (e = this._getEditColumn());
    const n = e && e.setCellValue !== e.defaultSetCellValue, s = t.some((o) => o.calculateCellValue !== o.defaultCalculateCellValue);
    return n || s;
  }
  _applyChange(e, t, n) {
    const s = I({}, e, {
      forceUpdateRow: n
    });
    return this._addChange(t, s), this._updateEditButtons(), this._applyChangeCore(e, s.forceUpdateRow);
  }
  _applyChangeCore(e, t) {
    const n = e.column.setCellValue !== e.column.defaultSetCellValue, {
      row: s
    } = e;
    s && (t || n ? this._updateEditRow(s, t, n) : s.update && s.update());
  }
  _updateEditRowCore(e, t, n) {
    this._dataController.updateItems({
      changeType: "update",
      rowIndices: this._getRowIndicesForCascadeUpdating(e, t)
    });
  }
  _updateEditRow(e, t, n) {
    t ? this._updateRowImmediately(e, t, n) : this._updateRowWithDelay(e, n);
  }
  _updateRowImmediately(e, t, n) {
    this._updateEditRowCore(e, !t, n), this._validateEditFormAfterUpdate(e, n), t || this._focusEditingCell();
  }
  _updateRowWithDelay(e, t) {
    const n = new w();
    this.addDeferred(n), setTimeout(() => {
      var s;
      const o = ((s = this._editForm) === null || s === void 0 ? void 0 : s.element()) || this.component.$element().get(0), r = p(O.getActiveElement(o)), a = this._rowsView.getCellIndex(r, e.rowIndex);
      let l = r.get(0);
      const d = F.getSelectionRange(l);
      if (this._updateEditRowCore(e, !1, t), this._validateEditFormAfterUpdate(e, t), a >= 0) {
        const u = this._rowsView._getCellElement(e.rowIndex, a);
        this._delayedInputFocus(u, () => {
          setTimeout(() => {
            var c;
            l = O.getActiveElement((c = this.component.$element()) === null || c === void 0 ? void 0 : c.get(0)), d.selectionStart >= 0 && F.setSelectionRange(l, d);
          });
        });
      }
      n.resolve();
    });
  }
  _validateEditFormAfterUpdate() {
  }
  _addChange(e, t) {
    var n;
    const s = t?.row, o = [...this.getChanges()];
    let r = F.getIndexByKey(e.key, o);
    r < 0 && (r = o.length, this._addInternalData({
      key: e.key,
      oldData: e.oldData
    }), delete e.oldData, o.push(e));
    const a = I({}, o[r]);
    return a && (e.data && (a.data = Ns(a.data, e.data)), (!a.type || !e.data) && e.type && (a.type = e.type), s && (s.oldData = this._getOldData(s.key), s.data = Ns(s.data, e.data))), o[r] = a, this._silentOption(Yi, o), t && a !== ((n = this.getChanges()) === null || n === void 0 ? void 0 : n[r]) && (t.forceUpdateRow = !0), a;
  }
  _getFormEditItemTemplate(e, t) {
    return t.editCellTemplate || this._getDefaultEditorTemplate();
  }
  getColumnTemplate(e) {
    const {
      column: t
    } = e, n = e.row && e.row.rowIndex;
    let s;
    const o = this.isRowBasedEditMode(), r = this.isEditRow(n), a = this.isEditCell(n, e.columnIndex);
    let l;
    return (t.showEditorAlways || t.setCellValue && (r && t.allowEditing || a)) && (e.rowType === "data" || e.rowType === "detailAdaptive") && !t.command ? (((this.allowUpdating(e) || r) && t.allowEditing || a) && (r || !o) && (t.showEditorAlways && !o && (l = {
      cancel: !1,
      key: e.row.isNewRow ? void 0 : e.row.key,
      data: e.row.data,
      column: t
    }, this._isEditingStart(l)), (!l || !l.cancel) && (e.setValue = (u, c) => {
      this.updateFieldValue(e, u, c);
    })), s = t.editCellTemplate || this._getDefaultEditorTemplate()) : t.command === "detail" && e.rowType === "detail" && r && (s = this === null || this === void 0 ? void 0 : this.getEditFormTemplate(e)), s;
  }
  _createButton(e, t, n, s) {
    let o = VX[t.name];
    const r = this.option("editing.useIcons"), a = this.option("useLegacyColumnButtonTemplate");
    let l = p("<a>").attr("href", "#").addClass(wX).addClass(t.cssClass);
    if (t.template && a)
      this._rowsView.renderTemplate(e, t.template, n, !0);
    else {
      if (t.template)
        l = p("<span>").addClass(t.cssClass);
      else if (r && o || t.icon) {
        o = t.icon || o;
        const d = td(o);
        d === "image" || d === "svg" ? l = cs(o).addClass(t.cssClass) : l.addClass(`dx-icon${d === "dxIcon" ? "-" : " "}${o}`).attr("title", t.text), l.addClass(SX), e.addClass(Kw);
        const u = this.getButtonLocalizationNames()[t.name];
        u && l.attr("aria-label", S.format(u));
      } else
        l.text(t.text);
      f(t.hint) && l.attr("title", t.hint), this._isButtonDisabled(t, n) ? l.addClass("dx-state-disabled") : (!t.template || t.onClick) && _.on(l, R("click", AX), this.createAction((d) => {
        var u;
        (u = t.onClick) === null || u === void 0 || u.call(t, x({}, d, {
          row: n.row,
          column: n.column
        })), d.event.preventDefault(), d.event.stopPropagation();
      })), e.append(l), t.template && (n.renderAsync = !1, this._rowsView.renderTemplate(l, t.template, n, !0, s));
    }
  }
  getButtonLocalizationNames() {
    return {
      edit: "dxDataGrid-editingEditRow",
      save: "dxDataGrid-editingSaveRowChanges",
      delete: "dxDataGrid-editingDeleteRow",
      undelete: "dxDataGrid-editingUndeleteRow",
      cancel: "dxDataGrid-editingCancelRowChanges"
    };
  }
  prepareButtonItem(e, t, n, s) {
    const o = this.option("editing.texts") ?? {}, r = {
      revert: o.cancelAllChanges,
      save: o.saveAllChanges,
      addRow: o.addRow
    }, a = {
      revert: "cancel",
      save: "save",
      addRow: "addrow"
    }[t], l = r[t], d = (a === "save" || a === "cancel") && this._isEditButtonDisabled();
    return {
      widget: "dxButton",
      options: {
        onInitialized: (u) => {
          p(u.element).addClass(e._getToolbarButtonClass(`${IX} ${this.addWidgetPrefix(a)}-button`));
        },
        icon: `edit-button-${a}`,
        disabled: d,
        onClick: () => {
          setTimeout(() => {
            this[n]();
          });
        },
        text: l,
        hint: l
      },
      showText: "inMenu",
      name: `${t}Button`,
      location: "after",
      locateInMenu: "auto",
      sortIndex: s
    };
  }
  prepareEditButtons(e) {
    const t = this.option("editing") ?? {}, n = [];
    return t.allowAdding && n.push(this.prepareButtonItem(e, "addRow", "addRow", 20)), n;
  }
  highlightDataCell(e, t) {
    this.shouldHighlightCell(t) && e.addClass(Gw);
  }
  _afterInsertRow(e) {
  }
  _beforeSaveEditData(e) {
    if (e && !f(e.key) && f(e.type))
      return !0;
  }
  _afterSaveEditData() {
  }
  _beforeCancelEditData() {
  }
  _allowEditAction(e, t) {
    let n = this.option(`editing.${e}`);
    return B(n) && (n = n({
      component: this.component,
      row: t.row
    })), n;
  }
  allowUpdating(e, t) {
    const n = this.option("editing.startEditAction") ?? FX;
    return (arguments.length > 1 ? n === t || t === "down" : !0) && this._allowEditAction("allowUpdating", e);
  }
  allowDeleting(e) {
    return this._allowEditAction("allowDeleting", e);
  }
  isCellModified(e) {
    var t, n;
    const {
      columnIndex: s
    } = e;
    let o = e == null || (t = e.row) === null || t === void 0 || (t = t.modifiedValues) === null || t === void 0 ? void 0 : t[s];
    return e != null && (n = e.row) !== null && n !== void 0 && n.isNewRow && (o = e.value), o !== void 0;
  }
  isNewRowInEditMode() {
    const e = this._getVisibleEditRowIndex(), t = this._dataController.items();
    return e >= 0 ? t[e].isNewRow : !1;
  }
  _isRowDeleteAllowed() {
  }
  shouldHighlightCell(e) {
    return this.isCellModified(e) && e.column.setCellValue && (this.getEditMode() !== ul || !e.row.isEditing);
  }
}
const YA = (i) => class extends i {
  reload(e, t) {
    return !t && this._editingController.refresh(), super.reload.apply(this, arguments);
  }
  repaintRows() {
    if (!this._editingController.isSaving())
      return super.repaintRows.apply(this, arguments);
  }
  _updateEditRow(e) {
    const t = this.option(Sn), n = F.getIndexByKey(t, e), s = e[n];
    if (s) {
      var o;
      s.isEditing = !0, (o = this._updateEditItem) === null || o === void 0 || o.call(this, s);
    }
  }
  _updateItemsCore(e) {
    super._updateItemsCore(e), this._updateEditRow(this.items(!0));
  }
  _applyChangeUpdate(e) {
    this._updateEditRow(e.items), super._applyChangeUpdate(e);
  }
  _applyChangesOnly(e) {
    this._updateEditRow(e.items), super._applyChangesOnly(e);
  }
  _processItems(e, t) {
    return e = this._editingController.processItems(e, t), super._processItems(e, t);
  }
  _processDataItem(e, t) {
    return this._editingController.processDataItem(e, t, this.generateDataValues), super._processDataItem(e, t);
  }
  _processItem(e, t) {
    return e = super._processItem(e, t), e.isNewRow && (t.dataIndex--, delete e.dataIndex), e;
  }
  _getChangedColumnIndices(e, t, n, s) {
    if (!(e.isNewRow !== t.isNewRow || e.removed !== t.removed))
      return super._getChangedColumnIndices.apply(this, arguments);
  }
  _isCellChanged(e, t, n, s, o) {
    const r = e.cells && e.cells[s], a = this._editingController && this._editingController.isEditCell(n, s);
    return o && a ? !1 : r && r.column && !r.column.showEditorAlways && r.isEditing !== a ? !0 : super._isCellChanged.apply(this, arguments);
  }
  needToRefreshOnDataSourceChange(e) {
    return !(Array.isArray(e.value) && e.value === e.previousValue && this._editingController.isSaving());
  }
  _handleDataSourceChange(e) {
    const t = super._handleDataSourceChange(e), n = this.option("editing.changes"), s = e.value;
    if (Array.isArray(s) && n.length) {
      const o = s.map((d) => this.keyOf(d)), r = n.filter((d) => d.type === "insert" || o.some((u) => He(d.key, u)));
      r.length !== n.length && this.option("editing.changes", r);
      const a = this.option("editing.editRowKey");
      !r.some((d) => d.type === "insert" && He(a, d.key)) && o.every((d) => !He(a, d)) && this.option("editing.editRowKey", null);
    }
    return t;
  }
}, n8 = (i) => class extends i {
  getCellIndex(e, t) {
    if (!e.is("td") && t >= 0) {
      const n = this.getCellElements(t);
      let s = -1;
      return y(n, (o, r) => {
        p(r).find(e).length && (s = o);
      }), s;
    }
    return super.getCellIndex.apply(this, arguments);
  }
  publicMethods() {
    return super.publicMethods().concat(["cellValue"]);
  }
  _getCellTemplate(e) {
    return this._editingController.getColumnTemplate(e) || super._getCellTemplate(e);
  }
  _createRow(e) {
    const t = super._createRow.apply(this, arguments);
    if (e) {
      const n = !!e.removed, s = !!e.isNewRow, o = !!e.modified;
      s && t.addClass(TX), o && t.addClass(OX), (s || n) && t.removeClass(EX);
    }
    return t;
  }
  _getColumnIndexByElement(e) {
    let t = e.closest("table");
    const n = this.getTableElements();
    for (; t.length && !n.filter(t).length; )
      e = t.closest("td"), t = e.closest("table");
    return this._getColumnIndexByElementCore(e);
  }
  _getColumnIndexByElementCore(e) {
    const t = e.closest(`.${Fs}> td:not(.dx-master-detail-cell)`);
    return this.getCellIndex(t);
  }
  _editCellByClick(e, t) {
    const n = this._editingController, s = p(e.event.target), o = this._getColumnIndexByElement(s), r = this._dataController.items()[e.rowIndex], a = n.allowUpdating({
      row: r
    }, t) || r && r.isNewRow, l = this._columnsController.getVisibleColumns()[o], d = n.isEditCell(e.rowIndex, o), u = a && l && (l.allowEditing || d), c = this.option("editing.startEditAction") || "click", h = l && l.showEditorAlways;
    if (d)
      return !0;
    if (t === "down")
      return (z.real().ios || z.real().android) && li.resetActiveElement(), h && u && n.editCell(e.rowIndex, o);
    if (t === "click" && c === "dblClick" && this._pointerDownTarget === s.get(0)) {
      const m = r?.isNewRow;
      n.closeEditCell(!1, m);
    }
    if (u && t === c)
      return n.editCell(e.rowIndex, o) || n.isEditRow(e.rowIndex);
  }
  _rowPointerDown(e) {
    this._pointerDownTarget = e.event.target, this._pointerDownTimeout = setTimeout(() => {
      this._editCellByClick(e, "down");
    });
  }
  _rowClickTreeListHack(e) {
    super._rowClick.apply(this, arguments);
  }
  _rowClick(e) {
    const t = p(e.rowElement).hasClass(this.addWidgetPrefix(_C));
    e.event[zA] = this.component, !this._editCellByClick(e, "click") && !t && super._rowClick.apply(this, arguments);
  }
  _rowDblClickTreeListHack(e) {
    super._rowDblClick.apply(this, arguments);
  }
  _rowDblClick(e) {
    this._editCellByClick(e, "dblClick") || super._rowDblClick.apply(this, arguments);
  }
  _cellPrepared(e, t) {
    var n;
    const s = this._editingController, o = !!t.column.command, r = t.setValue, a = s.isEditRow(t.rowIndex), l = UA(a, t);
    if (jw(a, t)) {
      const {
        alignment: u
      } = t.column;
      e.toggleClass(this.addWidgetPrefix(bX), !r).toggleClass(RX, !r), u && e.find(CC).first().css("textAlign", u);
    }
    l && this._editCellPrepared(e);
    const d = !!((n = t.column) !== null && n !== void 0 && n.cellTemplate);
    t.column && !o && (!d || s.shouldHighlightCell(t)) && s.highlightDataCell(e, t), super._cellPrepared.apply(this, arguments);
  }
  _getCellOptions(e) {
    const t = super._getCellOptions(e), {
      columnIndex: n,
      row: s
    } = e;
    return t.isEditing = this._editingController.isEditCell(t.rowIndex, t.columnIndex), t.removed = s.removed, s.modified && (t.modified = s.modifiedValues[n] !== void 0), t;
  }
  _setCellAriaAttributes(e, t, n) {
    super._setCellAriaAttributes(e, t, n), t.removed && this.setAria("roledescription", S.format("dxDataGrid-ariaDeletedCell"), e), t.modified && this.setAria("roledescription", S.format("dxDataGrid-ariaModifiedCell"), e), t.column.allowEditing && !t.removed && !t.modified && t.rowType === "data" && t.column.calculateCellValue === t.column.defaultCalculateCellValue && this._editingController.isCellBasedEditMode() && this.setAria("roledescription", S.format("dxDataGrid-ariaEditableCell"), e);
  }
  _createCell(e) {
    const t = super._createCell(e), n = this._editingController.isEditRow(e.rowIndex);
    return jw(n, e) && t.addClass(bh), t;
  }
  cellValue(e, t, n, s) {
    const o = this.getCellOptions(e, t);
    if (o) {
      if (n === void 0)
        return o.value;
      this._editingController.updateFieldValue(o, n, s, !0);
    }
  }
  dispose() {
    super.dispose.apply(this, arguments), clearTimeout(this._pointerDownTimeout);
  }
  _renderCore() {
    return super._renderCore.apply(this, arguments), this.waitAsyncTemplates(!0).done(() => {
      this._editingController._focusEditorIfNeed();
    });
  }
  _editCellPrepared() {
  }
  _formItemPrepared() {
  }
}, i8 = (i) => class extends i {
  optionChanged(e) {
    const {
      fullName: t
    } = e;
    switch (e.name) {
      case "editing": {
        t && ![Pu, Yi, Do, Sn].some((o) => o === t) && this._invalidate(), super.optionChanged(e);
        break;
      }
      case "useLegacyColumnButtonTemplate":
        e.handled = !0;
        break;
      default:
        super.optionChanged(e);
    }
  }
  _getToolbarItems() {
    const e = super._getToolbarItems();
    return this._editingController.prepareEditButtons(this).concat(e);
  }
}, jp = {
  defaultOptions: () => ({
    editing: {
      mode: "row",
      refreshMode: "full",
      newRowPosition: KA,
      allowAdding: !1,
      allowUpdating: !1,
      allowDeleting: !1,
      useIcons: !1,
      selectTextOnEditStart: !1,
      confirmDelete: !0,
      texts: {
        editRow: S.format("dxDataGrid-editingEditRow"),
        saveAllChanges: S.format("dxDataGrid-editingSaveAllChanges"),
        saveRowChanges: S.format("dxDataGrid-editingSaveRowChanges"),
        cancelAllChanges: S.format("dxDataGrid-editingCancelAllChanges"),
        cancelRowChanges: S.format("dxDataGrid-editingCancelRowChanges"),
        addRow: S.format("dxDataGrid-editingAddRow"),
        deleteRow: S.format("dxDataGrid-editingDeleteRow"),
        undeleteRow: S.format("dxDataGrid-editingUndeleteRow"),
        confirmDeleteMessage: S.format("dxDataGrid-editingConfirmDeleteMessage"),
        confirmDeleteTitle: ""
      },
      form: {
        colCount: 2
      },
      popup: {},
      startEditAction: "click",
      editRowKey: null,
      editColumnName: null,
      changes: []
    },
    useLegacyColumnButtonTemplate: !1
  }),
  controllers: {
    editing: t8
  },
  extenders: {
    controllers: {
      data: YA
    },
    views: {
      rowsView: n8,
      headerPanel: i8
    }
  }
}, s8 = (i) => class extends YA(i) {
  _changeRowExpandCore(e) {
    const t = this._editingController;
    return Array.isArray(e) && t && t.refresh(), super._changeRowExpandCore.apply(this, arguments);
  }
};
J.registerModule("editing", I({}, jp, {
  extenders: I({}, jp.extenders, {
    controllers: I({}, jp.extenders.controllers, {
      data: s8
    })
  })
}));
const o8 = (i) => class extends i {
  isRowEditMode() {
    return this.getEditMode() === ul;
  }
  _afterCancelEditData(e) {
    const t = this._dataController;
    this.isRowBasedEditMode() && e >= 0 ? t.updateItems({
      changeType: "update",
      rowIndices: [e, e + 1]
    }) : super._afterCancelEditData(e);
  }
  _isDefaultButtonVisible(e, t) {
    const n = this.isRowBasedEditMode(), o = !this.isPopupEditMode() && t.row && He(t.row.key, this.option(Sn));
    if (n)
      switch (e.name) {
        case "edit":
          return !o && this.allowUpdating(t);
        case "delete":
          return super._isDefaultButtonVisible(e, t) && !o;
        case "save":
        case "cancel":
          return o;
        default:
          return super._isDefaultButtonVisible(e, t);
      }
    return super._isDefaultButtonVisible(e, t);
  }
  isEditRow(e) {
    return this.isRowBasedEditMode() && this.isEditRowByIndex(e);
  }
  _cancelSaving(e) {
    this.isRowBasedEditMode() && (this.hasChanges() || this._cancelEditDataCore()), super._cancelSaving(e);
  }
  _refreshCore(e) {
    const {
      allowCancelEditing: t
    } = e ?? {};
    if (this.isRowBasedEditMode()) {
      const n = this.getChanges().filter((s) => s.type === "update").length > 0;
      this.init(), t && n && this._cancelEditDataCore();
    }
    super._refreshCore(e);
  }
  _isEditColumnVisible() {
    const e = super._isEditColumnVisible(), t = this.option("editing"), n = this.isRowEditMode(), s = t.allowUpdating || t.allowAdding;
    return e || n && s;
  }
  _focusEditorIfNeed() {
    const e = this.getEditMode();
    if (this._needFocusEditor) {
      if (yX.includes(e)) {
        const t = this.getFocusedCellInRow(this._getVisibleEditRowIndex());
        this._delayedInputFocus(t, () => {
          t && this.component.focus(t);
        });
      }
      this._needFocusEditor = !1;
    }
  }
}, r8 = (i) => class extends i {
  _getChangedColumnIndices(e, t, n, s) {
    if (!(this._editingController.isRowBasedEditMode() && e.isEditing !== t.isEditing))
      return super._getChangedColumnIndices.apply(this, arguments);
  }
}, a8 = (i) => class extends i {
  _createRow(e) {
    const t = super._createRow.apply(this, arguments);
    return e && this._editingController.isEditRow(e.rowIndex) && (t.addClass(Uw), t.removeClass(Lw), e.rowType === "detail" && t.addClass(this.addWidgetPrefix(_C))), t;
  }
  _update(e) {
    super._update(e), e.changeType === "updateSelection" && this.getTableElements().children("tbody").children(`.${Uw}`).removeClass(Lw);
  }
}, l8 = {
  extenders: {
    controllers: {
      editing: o8,
      data: r8
    },
    views: {
      rowsView: a8
    }
  }
};
J.registerModule("editingRowBased", l8);
const d8 = "dx-validationsummary-item", u8 = "dx-validationsummary-item-data";
class XA extends vd {
  _getDefaultOptions() {
    return I({}, super._getDefaultOptions(), {
      focusStateEnabled: !1,
      noDataText: null
    });
  }
  _setOptionsByReference() {
    super._setOptionsByReference(), x(this._optionsByReference, {
      validationGroup: !0
    });
  }
  _init() {
    super._init(), this._initGroupRegistration();
  }
  _initGroupRegistration() {
    const e = this.$element(), {
      validationGroup: t
    } = this.option(), n = t || Ve.findGroup(e, this._modelByElement(e)), s = Ve.addGroup(n, !0);
    this._unsubscribeGroup(), this._groupWasInit = !0, this._validationGroup = n, this.groupSubscription = this._groupValidationHandler.bind(this), s.on("validated", this.groupSubscription);
  }
  _unsubscribeGroup() {
    const e = Ve.getGroupConfig(this._validationGroup);
    e?.off("validated", this.groupSubscription);
  }
  _getOrderedItems(e, t) {
    let n = [];
    return y(e, (s, o) => {
      const r = Wt(t, (a) => {
        if (a.validator === o)
          return !0;
      });
      r.length && (n = n.concat(r));
    }), n;
  }
  _groupValidationHandler(e) {
    const t = this._getOrderedItems(e.validators, mt(e.brokenRules, (n) => ({
      text: n.message,
      validator: n.validator,
      index: n.index
    })));
    this.validators = e.validators, y(this.validators, (n, s) => {
      if (s._validationSummary !== this) {
        let o = this._itemValidationHandler.bind(this);
        const r = function() {
          s.off("validated", o), s._validationSummary = null, o = null;
        };
        s.on("validated", o), s.on("disposing", r), s._validationSummary = this;
      }
    }), this.option("items", t);
  }
  _itemValidationHandler(e) {
    let {
      isValid: t,
      validator: n,
      brokenRules: s
    } = e, {
      items: o
    } = this.option(), r = !1, a = 0;
    for (; a < o.length; ) {
      const l = o[a];
      if (l.validator === n) {
        const d = Wt(s || [], (u) => u.index === l.index)[0];
        if (t || !d) {
          o.splice(a, 1), r = !0;
          continue;
        }
        d.message !== l.text && (l.text = d.message, r = !0);
      }
      a++;
    }
    y(s, (l, d) => {
      Wt(o, (c) => c.validator === n && c.index === d.index)[0] || (o.push({
        text: d.message,
        validator: n,
        index: d.index
      }), r = !0);
    }), r && (o = this._getOrderedItems(this.validators, o), this.option("items", o));
  }
  _initMarkup() {
    this.$element().addClass("dx-validationsummary"), super._initMarkup();
  }
  _optionChanged(e) {
    e.name === "validationGroup" ? this._initGroupRegistration() : super._optionChanged(e);
  }
  _itemClass() {
    return d8;
  }
  _itemDataKey() {
    return u8;
  }
  _postprocessRenderItem(e) {
    _.on(e.itemElement, "click", () => {
      var t, n;
      (t = e.itemData.validator) === null || t === void 0 || (n = t.focus) === null || n === void 0 || n.call(t);
    });
  }
  _dispose() {
    super._dispose(), this._unsubscribeGroup();
  }
  refreshValidationGroup() {
    this._initGroupRegistration();
  }
}
xe("dxValidationSummary", XA);
class c8 extends se.inherit({}) {
  ctor(e, t) {
    this.editor = e, this.validator = t, this.validationRequestsCallbacks = [];
    const n = (s) => {
      this.validationRequestsCallbacks.forEach((o) => o(s));
    };
    e.validationRequest.add(n), e.on("disposing", () => {
      e.validationRequest.remove(n);
    });
  }
  getValue() {
    return this.editor.option("value");
  }
  getCurrentValidationError() {
    return this.editor.option("validationError");
  }
  bypass() {
    return this.editor.option("disabled");
  }
  applyValidationResults(e) {
    this.editor.option({
      validationErrors: e.brokenRules,
      validationStatus: e.status
    });
  }
  reset() {
    this.editor.clear();
  }
  focus() {
    this.editor.focus();
  }
}
class wh extends ui {
  _initOptions(e) {
    super._initOptions.apply(this, arguments), this.option(Ve.initValidationOptions(e));
  }
  _getDefaultOptions() {
    return I({}, super._getDefaultOptions(), {
      validationRules: []
    });
  }
  _init() {
    super._init(), this._initGroupRegistration(), this.focused = Ie(), this._initAdapter(), this._validationInfo = {
      result: null,
      deferred: null,
      skipValidation: !1
    };
  }
  _initGroupRegistration() {
    const e = this._findGroup();
    this._groupWasInit || this.on("disposing", (t) => {
      Ve.removeRegisteredValidator(t.component._validationGroup, t.component);
    }), (!this._groupWasInit || this._validationGroup !== e) && (Ve.removeRegisteredValidator(this._validationGroup, this), this._groupWasInit = !0, this._validationGroup = e, Ve.registerValidatorInGroup(e, this));
  }
  _setOptionsByReference() {
    super._setOptionsByReference(), x(this._optionsByReference, {
      validationGroup: !0
    });
  }
  _getEditor() {
    const e = this.$element()[0];
    return tt(e, "dx-validation-target");
  }
  _initAdapter() {
    const e = this._getEditor();
    let {
      adapter: t
    } = this.option();
    if (!t) {
      if (e) {
        var n;
        t = new c8(e, this), (n = t) === null || n === void 0 || (n = n.validationRequestsCallbacks) === null || n === void 0 || n.push((o) => {
          var r;
          (r = this._validationInfo) !== null && r !== void 0 && r.skipValidation || this.validate(o);
        }), this.option("adapter", t);
        return;
      }
      throw _e.Error("E0120");
    }
    const s = t.validationRequestsCallbacks;
    s && s.push((o) => {
      this.validate(o);
    });
  }
  _toggleRTLDirection(e) {
    var t;
    const {
      adapter: n
    } = this.option(), s = (n == null || (t = n.editor) === null || t === void 0 ? void 0 : t.option("rtlEnabled")) ?? e;
    super._toggleRTLDirection(s);
  }
  _initMarkup() {
    this.$element().addClass("dx-validator"), super._initMarkup();
  }
  _render() {
    super._render(), this._toggleAccessibilityAttributes();
  }
  _toggleAccessibilityAttributes() {
    const e = this._getEditor();
    if (e) {
      const n = (this.option("validationRules") || []).some((s) => {
        let {
          type: o
        } = s;
        return o === "required";
      }) || null;
      e.isInitialized() && e.setAria("required", n), e.option("_onMarkupRendered", () => {
        e.setAria("required", n);
      });
    }
  }
  _visibilityChanged(e) {
    e && this._initGroupRegistration();
  }
  _optionChanged(e) {
    switch (e.name) {
      case "validationGroup":
        this._initGroupRegistration();
        return;
      case "validationRules":
        this._resetValidationRules(), this._toggleAccessibilityAttributes(), this.option("isValid") !== void 0 && this.validate();
        return;
      case "adapter":
        this._initAdapter();
        break;
      case "isValid":
      case "validationStatus":
        this.option(Ve.synchronizeValidationOptions(e, this.option()));
        break;
      default:
        super._optionChanged(e);
    }
  }
  _getValidationRules() {
    return this._validationRules || (this._validationRules = mt(this.option("validationRules"), (e, t) => x({}, e, {
      validator: this,
      index: t
    }))), this._validationRules;
  }
  _findGroup() {
    const e = this.$element(), {
      validationGroup: t
    } = this.option();
    return t || Ve.findGroup(e, this._modelByElement(e));
  }
  _resetValidationRules() {
    delete this._validationRules;
  }
  validate(e) {
    var t, n, s, o, r;
    const {
      adapter: a,
      name: l
    } = this.option(), d = a == null || (t = a.bypass) === null || t === void 0 ? void 0 : t.call(a), u = e && e.value !== void 0 ? e.value : a == null || (n = a.getValue) === null || n === void 0 ? void 0 : n.call(a), c = a == null || (s = a.getCurrentValidationError) === null || s === void 0 ? void 0 : s.call(a), h = this._getValidationRules(), g = (o = this._validationInfo) === null || o === void 0 ? void 0 : o.result;
    if (g && g.status === "pending" && g.value === u)
      return x({}, g);
    let m;
    return d ? m = {
      isValid: !0,
      status: "valid"
    } : c != null && c.editorSpecific ? (c.validator = this, m = {
      isValid: !1,
      status: "invalid",
      brokenRule: c,
      brokenRules: [c]
    }) : m = Ve.validate(u, h, l), m.id = new Xe().toString(), this._applyValidationResult(m, a), (r = m.complete) === null || r === void 0 || r.then((C) => {
      C.id === this._validationInfo.result.id && this._applyValidationResult(C, a);
    }), x({}, this._validationInfo.result);
  }
  reset() {
    const {
      adapter: e
    } = this.option(), t = {
      id: null,
      isValid: !0,
      brokenRule: null,
      brokenRules: null,
      pendingRules: null,
      status: "valid",
      complete: null
    };
    this._validationInfo.skipValidation = !0, e.reset(), this._validationInfo.skipValidation = !1, this._resetValidationRules(), this._applyValidationResult(t, e);
  }
  _updateValidationResult(e) {
    if (!this._validationInfo.result || this._validationInfo.result.id !== e.id) {
      const t = this._validationInfo.deferred && this._validationInfo.result.complete;
      this._validationInfo.result = x({}, e, {
        complete: t
      });
    } else
      for (const t in e)
        t !== "id" && t !== "complete" && (this._validationInfo.result[t] = e[t]);
  }
  _applyValidationResult(e, t) {
    const n = this._createActionByOption("onValidated", {
      excludeValidators: ["readOnly"]
    });
    if (e.validator = this, this._updateValidationResult(e), t.applyValidationResults && t.applyValidationResults(this._validationInfo.result), this.option({
      validationStatus: this._validationInfo.result.status
    }), this._validationInfo.result.status === "pending") {
      this._validationInfo.deferred || (this._validationInfo.deferred = w(), this._validationInfo.result.complete = this._validationInfo.deferred.promise()), this._eventsStrategy.fireEvent("validating", [this._validationInfo.result]);
      return;
    }
    this._validationInfo.result.status !== "pending" && (n(e), this._validationInfo.deferred && (this._validationInfo.deferred.resolve(e), this._validationInfo.deferred = null));
  }
  focus() {
    const {
      adapter: e
    } = this.option();
    e && e.focus && e.focus();
  }
  _useTemplates() {
    return !1;
  }
}
xe("dxValidator", wh);
class h8 extends ui {
  _getDefaultOptions() {
    return super._getDefaultOptions();
  }
  _init() {
    super._init(), Ve.addGroup(this, !1);
  }
  _initMarkup() {
    const e = this.$element();
    e.addClass("dx-validationgroup"), e.find(".dx-validator").each((t, n) => {
      wh.getInstance(p(n))._initGroupRegistration();
    }), e.find(".dx-validationsummary").each((t, n) => {
      XA.getInstance(p(n)).refreshValidationGroup();
    }), super._initMarkup();
  }
  validate() {
    return Ve.validateGroup(this);
  }
  reset() {
    return Ve.resetGroup(this);
  }
  _dispose() {
    Ve.removeGroup(this), this.$element().removeClass("dx-validationgroup"), super._dispose();
  }
  _useTemplates() {
    return !1;
  }
}
xe("dxValidationGroup", h8);
const qw = "dx-responsivebox-screen-";
class ZA extends vd {
  _getDefaultOptions() {
    return I({}, super._getDefaultOptions(), {
      rows: [],
      cols: [],
      screenByWidth: null,
      singleColumnScreen: "",
      height: "100%",
      width: "100%",
      activeStateEnabled: !1,
      focusStateEnabled: !1,
      onLayoutChanged: null
    });
  }
  _init() {
    this.option("screenByWidth") || this._options.silent("screenByWidth", jc), super._init(), this._initLayoutChangedAction();
  }
  _initLayoutChangedAction() {
    this._layoutChangedAction = this._createActionByOption("onLayoutChanged", {
      excludeValidators: ["disabled", "readOnly"]
    });
  }
  _itemClass() {
    return "dx-box-item";
  }
  _itemDataKey() {
    return "dxBoxItemData";
  }
  _initMarkup() {
    super._initMarkup(), this.$element().addClass("dx-responsivebox");
  }
  _renderItems() {
    this._setScreenSize(), this._screenItems = this._itemsByScreen(), this._prepareGrid(), this._spreadItems(), this._layoutItems(), this._linkNodeToItem();
  }
  _itemOptionChanged(e) {
    const t = this._findItemElementByItem(e);
    t.length && (this._refreshItem(t, e), this._clearItemNodeTemplates(), this._update(!0));
  }
  _setScreenSize() {
    const e = this._getCurrentScreen();
    this._removeScreenSizeClass(), this.$element().addClass(qw + e), this.option("currentScreenFactor", e);
  }
  _removeScreenSizeClass() {
    const {
      currentScreenFactor: e
    } = this.option();
    e && this.$element().removeClass(qw + e);
  }
  _prepareGrid() {
    const e = this._grid = [];
    this._prepareRowsAndCols(), y(this._rows, () => {
      const t = [];
      e.push(t), y(this._cols, () => {
        t.push(this._createEmptyCell());
      });
    });
  }
  getSingleColumnRows() {
    const {
      rows: e
    } = this.option(), t = this._screenItems.length;
    if (e != null && e.length) {
      const n = this._filterByScreen(e), s = [];
      for (let o = 0; o < t; o++) {
        const r = this._defaultSizeConfig();
        o < n.length && f(n[o].shrink) && (r.shrink = n[o].shrink), s.push(r);
      }
      return s;
    }
    return this._defaultSizeConfig(t);
  }
  _prepareRowsAndCols() {
    this._isSingleColumnScreen() ? (this._prepareSingleColumnScreenItems(), this._rows = this.getSingleColumnRows(), this._cols = this._defaultSizeConfig(1)) : (this._rows = this._sizesByScreen(this.option("rows")), this._cols = this._sizesByScreen(this.option("cols")));
  }
  _isSingleColumnScreen() {
    const {
      singleColumnScreen: e,
      rows: t,
      cols: n
    } = this.option();
    return this._screenRegExp().test(e) || !(t != null && t.length) || !(n != null && n.length);
  }
  _prepareSingleColumnScreenItems() {
    this._screenItems.sort((e, t) => e.location.row - t.location.row || e.location.col - t.location.col), y(this._screenItems, (e, t) => {
      x(t.location, {
        row: e,
        col: 0,
        rowspan: 1,
        colspan: 1
      });
    });
  }
  _sizesByScreen(e) {
    return mt(this._filterByScreen(e), (t) => x(this._defaultSizeConfig(), t));
  }
  _createDefaultSizeConfig() {
    return {
      ratio: 1,
      baseSize: 0,
      minSize: 0,
      maxSize: 0
    };
  }
  _defaultSizeConfig(e) {
    const t = this._createDefaultSizeConfig();
    if (!arguments.length)
      return t;
    const n = [];
    for (let s = 0; s < e; s++)
      n.push(t);
    return n;
  }
  _filterByScreen(e) {
    const t = this._screenRegExp();
    return Wt(e, (n) => !n.screen || t.test(n.screen));
  }
  _screenRegExp() {
    const e = this._getCurrentScreen();
    return new RegExp(`(^|\\s)${e}($|\\s)`, "i");
  }
  _getCurrentScreen() {
    const e = this._screenWidth(), {
      screenByWidth: t
    } = this.option();
    return t?.(e);
  }
  _screenWidth() {
    return ae() ? ne(fe()) : 1920;
  }
  _createEmptyCell() {
    return {
      item: {},
      location: {
        colspan: 1,
        rowspan: 1
      }
    };
  }
  _spreadItems() {
    y(this._screenItems, (e, t) => {
      const n = t.location || {}, s = n.col, o = n.row, r = this._grid[o], a = r?.[s];
      this._occupyCells(a, t);
    });
  }
  _itemsByScreen() {
    const {
      items: e
    } = this.option();
    return e?.reduce((t, n) => {
      let s = n.location || {};
      return s = pe(s) ? [s] : s, this._filterByScreen(s).forEach((o) => {
        t.push({
          item: n,
          location: x({
            rowspan: 1,
            colspan: 1
          }, o)
        });
      }), t;
    }, []);
  }
  _occupyCells(e, t) {
    !e || this._isItemCellOccupied(e, t) || (x(e, t), this._markSpanningCell(e));
  }
  _isItemCellOccupied(e, t) {
    if (!en(e.item))
      return !0;
    let n = !1;
    return this._loopOverSpanning(t.location, (s) => {
      n = n || !en(s.item);
    }), n;
  }
  _loopOverSpanning(e, t) {
    const n = e.row + e.rowspan - 1, s = e.col + e.colspan - 1, o = Math.min(n, this._rows.length - 1), r = Math.min(s, this._cols.length - 1);
    e.rowspan -= n - o, e.colspan -= s - r;
    for (let a = e.row; a <= o; a++)
      for (let l = e.col; l <= r; l++)
        (a !== e.row || l !== e.col) && t(this._grid[a][l]);
  }
  _markSpanningCell(e) {
    this._loopOverSpanning(e.location, (t) => {
      x(t, {
        item: e.item,
        spanningCell: e
      });
    });
  }
  _linkNodeToItem() {
    y(this._itemElements(), (e, t) => {
      const n = p(t), s = n.data("dxBoxItemData");
      s.box || (s.node = n.children());
    });
  }
  _layoutItems() {
    const e = this._grid.length, t = e && this._grid[0].length;
    if (!e && !t)
      return;
    const n = this._layoutBlock({
      direction: "col",
      row: {
        start: 0,
        end: e - 1
      },
      col: {
        start: 0,
        end: t - 1
      }
    }), s = this._prepareBoxConfig(n.box || {
      direction: "row",
      items: [x(n, {
        ratio: 1
      })]
    });
    x(s, this._rootBoxConfig(s.items)), this._$root = p("<div>").appendTo(this._itemContainer()), this._createComponent(this._$root, Js, s);
  }
  _rootBoxConfig(e) {
    const t = y(e, (s, o) => {
      this._needApplyAutoBaseSize(o) && x(o, {
        baseSize: "auto"
      });
    }), {
      itemHoldTimeout: n
    } = this.option();
    return {
      width: "100%",
      height: "100%",
      items: t,
      itemTemplate: this._getTemplateByOption("itemTemplate"),
      itemHoldTimeout: n,
      onItemHold: this._createActionByOption("onItemHold"),
      onItemClick: this._createActionByOption("onItemClick"),
      onItemContextMenu: this._createActionByOption("onItemContextMenu"),
      onItemRendered: this._createActionByOption("onItemRendered")
    };
  }
  _needApplyAutoBaseSize(e) {
    return !e.baseSize && (!e.minSize || e.minSize === "auto") && (!e.maxSize || e.maxSize === "auto");
  }
  _prepareBoxConfig(e) {
    return x(e || {}, {
      crossAlign: "stretch",
      onItemStateChanged: this.option("onItemStateChanged")
    });
  }
  _layoutBlock(e) {
    return this._isSingleItem(e) ? this._itemByCell(e.row.start, e.col.start) : this._layoutDirection(e);
  }
  _isSingleItem(e) {
    const t = this._grid[e.row.start][e.col.start].location, n = e.row.end - e.row.start === t.rowspan - 1, s = e.col.end - e.col.start === t.colspan - 1;
    return n && s;
  }
  _itemByCell(e, t) {
    const n = this._grid[e][t];
    return n.spanningCell ? null : n.item;
  }
  _layoutDirection(e) {
    const t = [], {
      direction: n
    } = e, s = this._crossDirection(n);
    let o;
    for (; o = this._nextBlock(e); ) {
      if (this._isBlockIndivisible(e.prevBlockOptions, o))
        throw _e.Error("E1025");
      const r = this._layoutBlock({
        direction: s,
        row: o.row,
        col: o.col,
        prevBlockOptions: e
      });
      r && (x(r, this._blockSize(o, s)), t.push(r)), e[s].start = o[s].end + 1;
    }
    return {
      box: this._prepareBoxConfig({
        direction: n,
        items: t
      })
    };
  }
  _isBlockIndivisible(e, t) {
    return e && e.col.start === t.col.start && e.col.end === t.col.end && e.row.start === t.row.start && e.row.end === t.row.end;
  }
  _crossDirection(e) {
    return e === "col" ? "row" : "col";
  }
  _nextBlock(e) {
    const {
      direction: t
    } = e, n = this._crossDirection(t), s = e[t].start, o = e[t].end, r = e[n].start;
    if (r > e[n].end)
      return null;
    let a = 1;
    for (let d = r; d < r + a; d++) {
      let u = 1;
      for (let g = s; g <= o; g++) {
        const m = this._cellByDirection(t, g, d);
        u = Math.max(u, m.location[`${n}span`]);
      }
      const c = d + u, h = r + a;
      c > h && (a += c - h);
    }
    const l = {};
    return l[t] = {
      start: s,
      end: o
    }, l[n] = {
      start: r,
      end: r + a - 1
    }, l;
  }
  _cellByDirection(e, t, n) {
    return e === "col" ? this._grid[n][t] : this._grid[t][n];
  }
  _blockSize(e, t) {
    const n = t === "row" ? "auto" : 0, s = t === "row" ? this._rows : this._cols, o = x(this._createDefaultSizeConfig(), {
      ratio: 0
    });
    for (let r = e[t].start; r <= e[t].end; r++) {
      const a = s[r];
      o.ratio += a.ratio, o.baseSize += a.baseSize, o.minSize += a.minSize, o.maxSize += a.maxSize, f(a.shrink) && (o.shrink = a.shrink);
    }
    return o.minSize = o.minSize ? o.minSize : n, o.maxSize = o.maxSize ? o.maxSize : "auto", this._isSingleColumnScreen() && (o.baseSize = "auto"), o;
  }
  _update(e) {
    var t;
    const n = this._$root;
    this._renderItems(), n && (e ? n.remove() : (n.detach(), this._saveAssistantRoot(n))), (t = this._layoutChangedAction) === null || t === void 0 || t.call(this);
  }
  _saveAssistantRoot(e) {
    this._assistantRoots = this._assistantRoots || [], this._assistantRoots.push(e);
  }
  _dispose() {
    this._clearItemNodeTemplates(), this._cleanUnusedRoots(), super._dispose.apply(this, arguments);
  }
  _cleanUnusedRoots() {
    this._assistantRoots && y(this._assistantRoots, (e, t) => {
      p(t).remove();
    });
  }
  _clearItemNodeTemplates() {
    y(this.option("items"), function() {
      delete this.node;
    });
  }
  _attachClickEvent() {
  }
  _optionChanged(e) {
    switch (e.name) {
      case "rows":
      case "cols":
      case "screenByWidth":
      case "singleColumnScreen":
        this._clearItemNodeTemplates(), this._invalidate();
        break;
      case "width":
      case "height":
        super._optionChanged(e), this._update();
        break;
      case "onLayoutChanged":
        this._initLayoutChangedAction();
        break;
      case "itemTemplate":
        this._clearItemNodeTemplates(), super._optionChanged(e);
        break;
      case "currentScreenFactor":
        break;
      default:
        super._optionChanged(e);
    }
  }
  _dimensionChanged() {
    this._getCurrentScreen() !== this.option("currentScreenFactor") && this._update();
  }
  repaint() {
    this._update();
  }
}
xe("dxResponsiveBox", ZA);
function p8(i) {
  let {
    item: e,
    $parent: t,
    rootElementCssClassList: n,
    validationGroup: s,
    createComponentCallback: o
  } = i;
  const r = p("<div>").appendTo(t).addClass(n.join(" ")).addClass("dx-field-button-item").css("textAlign", g8(e.horizontalAlignment));
  t.css("justifyContent", m8(e.verticalAlignment));
  const a = p("<div>").appendTo(r);
  return {
    $rootElement: r,
    buttonInstance: o(a, "dxButton", x({
      validationGroup: s
    }, e.buttonOptions))
  };
}
function g8(i) {
  return f(i) ? i : "right";
}
function m8(i) {
  switch (i) {
    case "center":
      return "center";
    case "bottom":
      return "flex-end";
    default:
      return "flex-start";
  }
}
function Yw(i) {
  let {
    $parent: e,
    rootElementCssClassList: t
  } = i;
  return p("<div>").addClass("dx-field-empty-item").html("&nbsp;").addClass(t.join(" ")).appendTo(e);
}
const f8 = "dx-form", qp = "dx-form-group", _8 = "dx-form-group-caption", C8 = "dx-form-group-custom-caption", Xw = "dx-col-", QA = "dx-field-item", Zw = "dx-layout-manager-one-col", JA = "dx-field-item-label-content", v8 = "dx-layout-manager", eR = "dx-field-item-label", zm = "dx-field-item-content", x8 = "dx-single-column-item-content", tR = "dx-root-simple-item", y8 = "dx-form-group-content", b8 = "dx-field-item-has-group", w8 = "dx-field-item-has-tabs", S8 = "dx-form-group-with-caption", Qw = "dx-field-item-tab", Jw = "dx-group-colcount-", e0 = "group-col-count", E8 = "dx-form-validation-summary", I8 = "dx-form-styling-mode-underlined", Km = "simple", D8 = ["dxTagBox", "dxRangeSlider", "dxDateRangeBox"], T8 = ["dxRangeSlider", "dxDateRangeBox"], O8 = ["dxRangeSlider", "dxSlider"], A8 = ["dxCalendar", "dxCheckBox", "dxHtmlEditor", "dxRadioGroup", "dxRangeSlider", "dxSlider", "dxSwitch"], R8 = ["dxSelectBox", "dxDropDownBox", "dxTagBox", "dxLookup", "dxAutocomplete", "dxColorBox", "dxDateBox", "dxDateRangeBox"];
function F8(i) {
  let {
    $parent: e,
    rootElementCssClassList: t,
    formOrLayoutManager: n,
    createComponentCallback: s,
    item: o,
    template: r,
    labelTemplate: a,
    name: l,
    formLabelLocation: d,
    requiredMessageTemplate: u,
    validationGroup: c,
    editorValue: h,
    canAssignUndefinedValueToEditor: g,
    editorValidationBoundary: m,
    editorStylingMode: C,
    showColonAfterLabel: v,
    managerLabelLocation: E,
    itemId: T,
    managerMarkOptions: V,
    labelMode: $,
    onLabelTemplateRendered: G
  } = i;
  const H = f(o.isRequired) ? o.isRequired : !!M8(o.validationRules), ce = o.itemType === Km, re = o.helpText ? `dx-${new Xe()}` : null, me = B8({
    item: o,
    id: T,
    isRequired: H,
    managerMarkOptions: V,
    showColonAfterLabel: v,
    labelLocation: E,
    formLabelMode: $,
    labelTemplate: a,
    onLabelTemplateRendered: G
  }), dt = me.visible && (me.text || me.labelTemplate && ce), {
    location: Ke,
    labelID: ut
  } = me, gn = Ke !== "top" && ["dxTextArea", "dxRadioGroup", "dxCalendar", "dxHtmlEditor"].includes(o.editorType), kt = P8({
    $parent: e,
    editorType: o.editorType,
    editorValue: h,
    defaultEditorName: o.dataField,
    canAssignUndefinedValueToEditor: g,
    externalEditorOptions: o.editorOptions,
    editorInputId: T,
    editorValidationBoundary: m,
    editorStylingMode: C,
    formLabelMode: $,
    labelText: me.textWithoutColon,
    labelMark: me.markOptions.showRequiredMark ? String.fromCharCode(160) + me.markOptions.requiredMark : ""
  }), Et = me.markOptions.showOptionalMark && !me.visible && kt.labelMode !== "hidden" && !f(o.helpText) ? me.markOptions.optionalMark : o.helpText;
  return {
    $parent: e,
    rootElementCssClassList: t,
    formOrLayoutManager: n,
    createComponentCallback: s,
    labelOptions: me,
    labelNeedBaselineAlign: gn,
    labelLocation: Ke,
    needRenderLabel: dt,
    item: o,
    isSimpleItem: ce,
    isRequired: H,
    template: r,
    helpID: re,
    labelID: ut,
    name: l,
    helpText: Et,
    formLabelLocation: d,
    requiredMessageTemplate: u,
    validationGroup: c,
    editorOptions: kt
  };
}
function k8(i) {
  let {
    showRequiredMark: e,
    requiredMark: t,
    showOptionalMark: n,
    optionalMark: s
  } = i;
  return !e && !n ? "" : String.fromCharCode(160) + (e ? t : s);
}
function nR(i, e) {
  let {
    showRequiredMark: t,
    requiredMark: n,
    showOptionalMark: s,
    optionalMark: o
  } = i;
  return {
    showRequiredMark: t && e,
    requiredMark: n,
    showOptionalMark: s && !e,
    optionalMark: o
  };
}
function V8(i, e, t) {
  return R8.includes(e) ? {
    onPopupInitialized: (s) => {
      let {
        component: o,
        popup: r
      } = s;
      const a = o.option("openOnFieldClick"), l = r.option("hideOnOutsideClick");
      if (a && B(l)) {
        const d = (u) => {
          const c = p(u.target), h = i.find(`label[for="${t}"]`);
          return !!!c.closest(h).length && l(u);
        };
        o.option("dropDownOptions", {
          hideOnOutsideClick: d
        }), r.option({
          hideOnOutsideClick: d
        });
      }
    }
  } : {};
}
function P8(i) {
  let {
    $parent: e,
    editorType: t,
    defaultEditorName: n,
    editorValue: s,
    canAssignUndefinedValueToEditor: o,
    externalEditorOptions: r,
    editorInputId: a,
    editorValidationBoundary: l,
    editorStylingMode: d,
    formLabelMode: u,
    labelText: c,
    labelMark: h
  } = i;
  const g = {};
  (s !== void 0 || o) && (g.value = s), D8.includes(t) && (g.value = g.value || []);
  let m = r?.labelMode;
  f(m) || (m = u === "outside" ? "hidden" : u);
  const C = r?.stylingMode || d, v = O8.includes(t), E = V8(e, t, a), T = x(!0, g, r, E, {
    inputAttr: {
      id: a
    },
    validationBoundary: l,
    stylingMode: C,
    label: v ? r?.label : c,
    labelMode: m,
    labelMark: h
  });
  if (r && (T.dataSource && (T.dataSource = r.dataSource), T.items && (T.items = r.items)), n) {
    if (T8.includes(t))
      return t === "dxRangeSlider" && (T.startName || (T.startName = `${n}Start`), T.endName || (T.endName = `${n}End`)), t === "dxDateRangeBox" && (T.startDateName || (T.startDateName = `${n}Start`), T.endDateName || (T.endDateName = `${n}End`)), T;
    T.name || (T.name = n);
  }
  return T;
}
function M8(i) {
  let e;
  return i != null && i.length && y(i, (t, n) => {
    if (n.type === "required")
      return e = !0, !1;
  }), e;
}
function B8(i) {
  let {
    item: e,
    id: t,
    isRequired: n,
    managerMarkOptions: s,
    showColonAfterLabel: o,
    labelLocation: r,
    labelTemplate: a,
    formLabelMode: l,
    onLabelTemplateRendered: d
  } = i;
  const u = A8.includes(e.editorType), c = x({
    showColon: o,
    location: r,
    id: t,
    visible: l === "outside" || u && l !== "hidden",
    isRequired: n
  }, e ? e.label : {}, {
    markOptions: nR(s, n),
    labelTemplate: a,
    onLabelTemplateRendered: d
  });
  return ["dxRadioGroup", "dxCheckBox", "dxLookup", "dxSlider", "dxRangeSlider", "dxSwitch", "dxHtmlEditor", "dxDateRangeBox"].includes(e.editorType) && (c.labelID = `dx-label-${new Xe()}`), !c.text && e.dataField && (c.text = ta(e.dataField)), c.text && (c.textWithoutColon = c.text, c.text += c.showColon ? ":" : ""), c;
}
function $8(i) {
  let {
    text: e,
    id: t,
    location: n,
    alignment: s,
    labelID: o = null,
    markOptions: r = {},
    labelTemplate: a,
    labelTemplateData: l,
    onLabelTemplateRendered: d
  } = i;
  if ((!f(e) || e.length <= 0) && !f(a))
    return null;
  const u = p("<label>").addClass(`${eR} dx-field-item-label-location-${n}`).attr("for", t).attr("id", o).css("textAlign", s), c = p("<span>").addClass(JA);
  let h = p("<span>").addClass("dx-field-item-label-text").text(e);
  return a && (h = p("<div>").addClass("dx-field-item-custom-label-content"), l.text = e, a.render({
    container: ee(h),
    model: l,
    onRendered() {
      d?.();
    }
  })), u.append(c.append(h, N8(r)));
}
function N8(i) {
  const e = k8(i);
  return e === "" ? null : p("<span>").addClass(i.showRequiredMark ? "dx-field-item-required-mark" : "dx-field-item-optional-mark").text(e);
}
function L8(i, e, t) {
  const n = `${e} > .${eR}:not(.dx-field-item-label-location-top) > .${JA}`, s = i.find(n), o = s.length;
  let r, a, l = 0;
  for (a = 0; a < o; a++)
    r = H8(s[a]), r > l && (l = r);
  for (a = 0; a < o; a++)
    s[a].style.width = `${l}px`;
}
function H8(i) {
  let e = 0;
  const t = i.children.length;
  for (let n = 0; n < t; n++) {
    const s = i.children[n];
    e += s.offsetWidth;
  }
  return e;
}
function W8(i) {
  let {
    $parent: e,
    rootElementCssClassList: t,
    formOrLayoutManager: n,
    createComponentCallback: s,
    labelOptions: o,
    labelNeedBaselineAlign: r,
    labelLocation: a,
    needRenderLabel: l,
    formLabelLocation: d,
    item: u,
    editorOptions: c,
    isSimpleItem: h,
    isRequired: g,
    template: m,
    helpID: C,
    labelID: v,
    name: E,
    helpText: T,
    requiredMessageTemplate: V,
    validationGroup: $
  } = i;
  const G = p("<div>").addClass(t.join(" ")).appendTo(e);
  G.addClass(g ? "dx-field-item-required" : "dx-field-item-optional"), h && G.addClass("dx-flex-layout"), h && r && G.addClass("dx-field-item-label-align");
  const H = p("<div>");
  H.data("dx-form-item", u), H.addClass(zm).addClass("dx-field-item-content-location-" + {
    right: "left",
    left: "right",
    top: "bottom"
  }[d]);
  let ce = null;
  if (l && (o.labelTemplate && (o.labelTemplateData = i0(u, c, n)), ce = $8(o)), ce) {
    const {
      editorType: Ke
    } = u;
    G.append(ce), (a === "top" || a === "left") && G.append(H), a === "right" && G.prepend(H), a === "top" ? G.addClass("dx-label-v-align") : G.addClass("dx-label-h-align"), (Ke === "dxCheckBox" || Ke === "dxSwitch") && _.on(ce, Te, () => {
      _.trigger(H.children(), Te);
    });
    const gn = ["dxCheckBox", "dxSwitch", "dxRadioGroup"].includes(Ke), kt = o.alignment;
    !m && gn && a === "top" && (kt === "left" || !kt) && H.addClass("dx-toggle-controls-paddings");
  } else
    G.append(H);
  let re;
  if (m)
    m.render({
      container: ee(H),
      model: i0(u, c, n),
      onRendered() {
        const Ke = t0(H), ut = z8(Ke);
        n0(ut);
      }
    });
  else {
    const Ke = p("<div>").appendTo(H);
    try {
      re = s(Ke, u.editorType, c), re.setAria("describedby", C), v && re.setAria("labelledby", v), re.setAria("required", g);
    } catch (ut) {
      _e.log("E1035", ut.message);
    }
  }
  const me = t0(H), dt = me && me.data("dx-validation-target");
  if (dt) {
    const Ke = u.label && u.label.text, ut = Ke ? null : E, gn = Ke ? u.label.text : ut && ta(ut);
    let kt;
    if (h)
      if (u.validationRules)
        kt = u.validationRules;
      else {
        const Kt = Fi(V, gn || "");
        kt = u.isRequired ? [{
          type: "required",
          message: Kt
        }] : null;
      }
    Array.isArray(kt) && kt.length && s(me, wh, {
      validationRules: kt,
      validationGroup: $,
      dataGetter: () => ({
        formItem: u
      })
    }), n0(dt);
  }
  return T && h && H.parent().append(p("<div>").addClass("dx-field-item-content-wrapper").append(H).append(p("<div>").addClass("dx-field-item-help-text").attr("id", C).text(T))), {
    $fieldEditorContainer: H,
    $rootElement: G,
    widgetInstance: re
  };
}
function t0(i) {
  const e = i.children().first();
  return e.hasClass("dx-template-wrapper") ? e.children().first() : e;
}
function z8(i) {
  var e;
  return i?.data("dx-validation-target") || (i == null || (e = i.parent) === null || e === void 0 || (e = e.call(i)) === null || e === void 0 ? void 0 : e.data("dx-validation-target"));
}
function n0(i) {
  if (i && Gn()) {
    const e = ".dx-field-item-content-wrapper", t = (n) => {
      let {
        element: s,
        component: o
      } = n;
      const {
        isValid: r,
        validationMessageMode: a
      } = o.option();
      p(s).parents(e).toggleClass("dx-invalid", r === !1 && (o._isFocused() || a === "always"));
    };
    i.on("optionChanged", (n) => {
      n.name === "isValid" && t(n);
    }), i.on("focusIn", t).on("focusOut", t).on("enterKey", t);
  }
}
function i0(i, e, t) {
  return {
    dataField: i.dataField,
    editorType: i.editorType,
    editorOptions: e,
    component: t,
    name: i.name
  };
}
class iR {
  constructor() {
    this._map = {};
  }
  _findWidgetInstance(e) {
    let t;
    return y(this._map, (n, s) => {
      let {
        widgetInstance: o,
        item: r
      } = s;
      if (e(r))
        return t = o, !1;
    }), t;
  }
  _findFieldByCondition(e, t) {
    let n;
    return y(this._map, (s, o) => {
      if (e(o))
        return n = t === "guid" ? s : o[t], !1;
    }), n;
  }
  clear() {
    this._map = {};
  }
  removeItemsByItems(e) {
    y(e.getItems(), (t) => this.removeItemByKey(t));
  }
  removeItemByKey(e) {
    delete this._map[e];
  }
  add(e) {
    const t = e.guid || new Xe();
    return this._map[t] = e, t;
  }
  addItemsOrExtendFrom(e) {
    e.each((t, n) => {
      this._map[t] ? (n.widgetInstance && (this._map[t].widgetInstance = n.widgetInstance), this._map[t].$itemContainer = n.$itemContainer) : this.add({
        item: n.item,
        widgetInstance: n.widgetInstance,
        guid: t,
        $itemContainer: n.$itemContainer
      });
    });
  }
  extendRunTimeItemInfoByKey(e, t) {
    this._map[e] && (this._map[e] = x(this._map[e], t));
  }
  findWidgetInstanceByItem(e) {
    return this._findWidgetInstance((t) => t === e);
  }
  findGroupOrTabLayoutManagerByPath(e) {
    return this._findFieldByCondition((t) => {
      let {
        path: n
      } = t;
      return n === e;
    }, "layoutManager");
  }
  findKeyByPath(e) {
    return this._findFieldByCondition((t) => {
      let {
        path: n
      } = t;
      return n === e;
    }, "guid");
  }
  findWidgetInstanceByName(e) {
    return this._findWidgetInstance((t) => e === t.name);
  }
  findWidgetInstanceByDataField(e) {
    return this._findWidgetInstance((t) => e === (te(t) ? t : t.dataField));
  }
  findItemContainerByItem(e) {
    for (const t in this._map)
      if (this._map[t].item === e)
        return this._map[t].$itemContainer;
    return null;
  }
  findItemIndexByItem(e) {
    return this._findFieldByCondition((t) => {
      let {
        item: n
      } = t;
      return n === e;
    }, "itemIndex");
  }
  findPreparedItemByItem(e) {
    return this._findFieldByCondition((t) => {
      let {
        item: n
      } = t;
      return n === e;
    }, "preparedItem");
  }
  getItems() {
    return this._map;
  }
  each(e) {
    y(this._map, (t, n) => {
      e(t, n);
    });
  }
  removeItemsByPathStartWith(e) {
    Object.keys(this._map).filter((s) => this._map[s].path ? this._map[s].path.indexOf(e, 0) > -1 : !1).forEach((s) => this.removeItemByKey(s));
  }
}
class K8 extends Rt {
  _getDefaultOptions() {
    return I({}, super._getDefaultOptions(), {
      layoutData: {},
      readOnly: !1,
      colCount: 1,
      labelLocation: "left",
      onFieldDataChanged: null,
      onEditorEnterKey: null,
      customizeItem: null,
      alignItemLabels: !0,
      minColWidth: 200,
      showRequiredMark: !0,
      screenByWidth: null,
      showOptionalMark: !1,
      requiredMark: "*",
      labelMode: "outside",
      optionalMark: S.format("dxForm-optionalMark"),
      requiredMessage: S.getFormatter("dxForm-requiredMessage")
    });
  }
  _setOptionsByReference() {
    super._setOptionsByReference(), x(this._optionsByReference, {
      layoutData: !0,
      validationGroup: !0
    });
  }
  _init() {
    const e = this.option("layoutData");
    super._init(), this._itemWatchers = [], this._itemsRunTimeInfo = new iR(), this._updateReferencedOptions(e), this._initDataAndItems(e);
  }
  _dispose() {
    super._dispose(), this._cleanItemWatchers();
  }
  _initDataAndItems(e) {
    this._syncDataWithItems(), this._updateItems(e);
  }
  _syncDataWithItems() {
    const e = this.option("layoutData"), t = this.option("items");
    f(t) && t.forEach((n) => {
      if (n.dataField && this._getDataByField(n.dataField) === void 0) {
        let s;
        n.editorOptions && (s = n.editorOptions.value), (f(s) || n.dataField in e) && this._updateFieldValue(n.dataField, s);
      }
    });
  }
  _getDataByField(e) {
    return e ? this.option(`layoutData.${e}`) : null;
  }
  _isCheckboxUndefinedStateEnabled(e) {
    let {
      allowIndeterminateState: t,
      editorType: n,
      dataField: s
    } = e;
    if (t === !0 && n === "dxCheckBox") {
      const o = ["layoutData", ...s.split(".")], r = o.pop(), a = this.option(o.join("."));
      return a && r in a;
    }
    return !1;
  }
  _updateFieldValue(e, t) {
    const n = this.option("layoutData");
    let s = t;
    !Bt.isWrapped(n[e]) && f(e) ? this.option(`layoutData.${e}`, s) : Bt.isWritableWrapped(n[e]) && (s = B(s) ? s() : s, n[e](s)), this._triggerOnFieldDataChanged({
      dataField: e,
      value: s
    });
  }
  _triggerOnFieldDataChanged(e) {
    this._createActionByOption("onFieldDataChanged")(e);
  }
  _updateItems(e) {
    const t = this, n = this.option("items"), s = f(n), {
      customizeItem: o
    } = this.option(), r = s ? n : this._generateItemsByData(e);
    if (f(r)) {
      const a = [];
      y(r, (l, d) => {
        t._isAcceptableItem(d) && (d = t._processItem(d), o && o(d), X(d) && Bt.unwrap(d.visible) !== !1 && a.push(d));
      }), (!t._itemWatchers.length || !s) && t._updateItemWatchers(r), this._setItems(a), this._sortItems();
    }
  }
  _cleanItemWatchers() {
    this._itemWatchers.forEach((e) => {
      e();
    }), this._itemWatchers = [];
  }
  _updateItemWatchers(e) {
    const t = this, n = t._getWatch();
    e.forEach((s) => {
      X(s) && f(s.visible) && B(n) && t._itemWatchers.push(n(() => Bt.unwrap(s.visible), () => {
        t._updateItems(t.option("layoutData")), t.repaint();
      }, {
        skipImmediate: !0
      }));
    });
  }
  _generateItemsByData(e) {
    const t = [];
    return f(e) && y(e, (n) => {
      t.push({
        dataField: n
      });
    }), t;
  }
  _isAcceptableItem(e) {
    const t = e.dataField || e, n = this._getDataByField(t);
    return !(B(n) && !Bt.isWrapped(n));
  }
  _processItem(e) {
    if (typeof e == "string" && (e = {
      dataField: e
    }), typeof e == "object" && !e.itemType && (e.itemType = Km), !f(e.editorType) && f(e.dataField)) {
      const t = this._getDataByField(e.dataField);
      e.editorType = f(t) ? this._getEditorTypeByDataType(yn(t)) : "dxTextBox";
    }
    return e.editorType === "dxCheckBox" && (e.allowIndeterminateState = e.allowIndeterminateState ?? !0), e;
  }
  _getEditorTypeByDataType(e) {
    switch (e) {
      case "number":
        return "dxNumberBox";
      case "date":
        return "dxDateBox";
      case "boolean":
        return "dxCheckBox";
      default:
        return "dxTextBox";
    }
  }
  _sortItems() {
    Al(this._items, "visibleIndex"), this._sortIndexes();
  }
  _sortIndexes() {
    this._items.sort((e, t) => {
      const n = e.visibleIndex, s = t.visibleIndex;
      let o;
      return n > s ? o = 1 : n < s ? o = -1 : o = 0, o;
    });
  }
  _initMarkup() {
    this._itemsRunTimeInfo.clear(), this.$element().addClass(v8), super._initMarkup(), this._renderResponsiveBox();
  }
  _renderResponsiveBox() {
    const e = this, t = [];
    if (e._items && e._items.length) {
      const n = e._getColCount(), s = p("<div>").appendTo(e.$element());
      e._prepareItemsWithMerging(n);
      const o = e._generateLayoutItems();
      e._responsiveBox = e._createComponent(s, ZA, e._getResponsiveBoxConfig(o, n, t)), ae() || e._renderTemplates(t);
    }
  }
  _itemStateChangedHandler(e) {
    this._refresh();
  }
  _renderTemplates(e) {
    const t = this;
    let n = 0;
    e.forEach((s) => {
      var o;
      let {
        item: r
      } = s;
      r != null && (o = r.label) !== null && o !== void 0 && o.template && n++;
    }), y(e, (s, o) => {
      switch (o.itemType) {
        case "empty":
          Yw(o);
          break;
        case "button":
          t._renderButtonItem(o);
          break;
        default:
          t._renderFieldItem(o, n);
      }
    });
  }
  _getResponsiveBoxConfig(e, t, n) {
    const s = this, o = s.option("colCountByScreen"), r = o && o.xs;
    return {
      onItemStateChanged: this._itemStateChangedHandler.bind(this),
      onLayoutChanged() {
        const {
          onLayoutChanged: a
        } = s.option(), l = s.isSingleColumnMode();
        a && (s.$element().toggleClass(Zw, l), a(l));
      },
      onContentReady(a) {
        ae() && s._renderTemplates(n), s.option("onLayoutChanged") && s.$element().toggleClass(Zw, s.isSingleColumnMode(a.component));
      },
      itemTemplate(a, l, d) {
        if (!a.location)
          return;
        const u = p(d), c = a.location.row * t, h = s._items[a.location.col + c];
        if (!h)
          return;
        const g = [h.cssClass];
        u.toggleClass(x8, s.isSingleColumnMode(this)), a.location.row === 0 && g.push("dx-first-row"), a.location.col === 0 && g.push("dx-first-col"), h.itemType === Km && s.option("isRoot") && u.addClass(tR);
        const m = a.location.col === t - 1 || a.location.col + a.location.colspan === t, C = s._getRowsCount(), v = a.location.row === C - 1;
        m && g.push("dx-last-col"), v && g.push("dx-last-row"), h.itemType !== "empty" && (g.push(QA), g.push(s.option("cssItemClass")), f(h.col) && g.push(`dx-col-${h.col}`)), n.push({
          itemType: h.itemType,
          item: h,
          $parent: u,
          rootElementCssClassList: g
        });
      },
      cols: s._generateRatio(t),
      rows: s._generateRatio(s._getRowsCount(), !0),
      dataSource: e,
      screenByWidth: s.option("screenByWidth"),
      singleColumnScreen: r ? !1 : "xs"
    };
  }
  _getColCount() {
    let {
      colCount: e
    } = this.option();
    const t = this.option("colCountByScreen");
    if (t) {
      const {
        form: n
      } = this.option();
      let s = n?.getTargetScreenFactor();
      s || (s = ae() ? Kf(this.option("screenByWidth")) : "lg"), e = t[s] || e;
    }
    if (e === "auto") {
      if (this._cashedColCount)
        return this._cashedColCount;
      this._cashedColCount = e = this._getMaxColCount();
    }
    return e < 1 ? 1 : e;
  }
  _getMaxColCount() {
    if (!ae())
      return 1;
    const e = this.option("minColWidth"), t = ne(this.$element()), n = this._items.length, s = Math.floor(t / e) || 1;
    return n < s ? n : s;
  }
  isCachedColCountObsolete() {
    return this._cashedColCount && this._getMaxColCount() !== this._cashedColCount;
  }
  _prepareItemsWithMerging(e) {
    const t = this._items.slice(0);
    let n, s, o = [], r, a;
    for (a = 0; a < t.length; a++)
      if (n = t[a], o.push(n), (this.option("alignItemLabels") || n.alignItemLabels || n.colSpan) && (n.col = this._getColByIndex(o.length - 1, e)), n.colSpan > 1 && n.col + n.colSpan <= e) {
        for (s = [], r = 0; r < n.colSpan - 1; r++)
          s.push({
            merged: !0
          });
        o = o.concat(s);
      } else
        delete n.colSpan;
    this._setItems(o);
  }
  _getColByIndex(e, t) {
    return e % t;
  }
  _setItems(e) {
    this._items = e, this._cashedColCount = null;
  }
  _generateLayoutItems() {
    const e = this._items, t = this._getColCount(), n = [];
    let s, o;
    for (o = 0; o < e.length; o++)
      if (s = e[o], !s.merged) {
        const r = {
          location: {
            row: parseInt(o / t),
            col: this._getColByIndex(o, t)
          }
        };
        f(s.disabled) && (r.disabled = s.disabled), f(s.visible) && (r.visible = s.visible), f(s.colSpan) && (r.location.colspan = s.colSpan), f(s.rowSpan) && (r.location.rowspan = s.rowSpan), n.push(r);
      }
    return n;
  }
  _renderEmptyItem(e) {
    Yw({
      $container: e
    });
  }
  _renderButtonItem(e) {
    let {
      item: t,
      $parent: n,
      rootElementCssClassList: s
    } = e;
    const {
      $rootElement: o,
      buttonInstance: r
    } = p8({
      item: t,
      $parent: n,
      rootElementCssClassList: s,
      validationGroup: this.option("validationGroup"),
      createComponentCallback: this._createComponent.bind(this)
    });
    this._itemsRunTimeInfo.add({
      item: t,
      widgetInstance: r,
      guid: t.guid,
      $itemContainer: o
    });
  }
  _renderFieldItem(e, t) {
    var n;
    let {
      item: s,
      $parent: o,
      rootElementCssClassList: r
    } = e;
    const a = this._getDataByField(s.dataField);
    let l = !1;
    if (a === void 0) {
      const {
        allowIndeterminateState: v,
        editorType: E,
        dataField: T
      } = s;
      l = this._isCheckboxUndefinedStateEnabled({
        allowIndeterminateState: v,
        editorType: E,
        dataField: T
      });
    }
    const d = s.dataField || s.name, u = this._getFormOrThis(), {
      form: c
    } = this.option(), {
      $fieldEditorContainer: h,
      widgetInstance: g,
      $rootElement: m
    } = W8(F8({
      $parent: o,
      rootElementCssClassList: r,
      item: s,
      name: d,
      editorValue: a,
      canAssignUndefinedValueToEditor: l,
      formOrLayoutManager: this._getFormOrThis(),
      createComponentCallback: this._createComponent.bind(this),
      formLabelLocation: this.option("labelLocation"),
      requiredMessageTemplate: this.option("requiredMessage"),
      validationGroup: this.option("validationGroup"),
      editorValidationBoundary: this.option("validationBoundary"),
      editorStylingMode: c?.option("stylingMode"),
      showColonAfterLabel: this.option("showColonAfterLabel"),
      managerLabelLocation: this.option("labelLocation"),
      template: s.template ? this._getTemplate(s.template) : null,
      labelTemplate: (n = s.label) !== null && n !== void 0 && n.template ? this._getTemplate(s.label.template) : null,
      itemId: c?.getItemID(d),
      managerMarkOptions: this._getMarkOptions(),
      labelMode: this.option("labelMode"),
      onLabelTemplateRendered: () => {
        this._incTemplateRenderedCallCount(), this._shouldAlignLabelsOnTemplateRendered(u, t) && u._alignLabels(this, this.isSingleColumnMode(u));
      }
    })), {
      onFieldItemRendered: C
    } = this.option();
    C?.(), g && s.dataField && this._bindDataField(g, s.dataField, s.editorType, h), this._itemsRunTimeInfo.add({
      item: s,
      widgetInstance: g,
      guid: s.guid,
      $itemContainer: m
    });
  }
  _incTemplateRenderedCallCount() {
    this._labelTemplateRenderedCallCount = (this._labelTemplateRenderedCallCount ?? 0) + 1;
  }
  _shouldAlignLabelsOnTemplateRendered(e, t) {
    return e.option("templatesRenderAsynchronously") && this._labelTemplateRenderedCallCount === t;
  }
  _getMarkOptions() {
    return {
      showRequiredMark: this.option("showRequiredMark"),
      requiredMark: this.option("requiredMark"),
      showOptionalMark: this.option("showOptionalMark"),
      optionalMark: this.option("optionalMark")
    };
  }
  _getFormOrThis() {
    const {
      form: e
    } = this.option();
    return e || this;
  }
  _bindDataField(e, t, n, s) {
    const o = this._getFormOrThis();
    e.on("enterKey", (r) => {
      o._createActionByOption("onEditorEnterKey")(x(r, {
        dataField: t
      }));
    }), this._createWatcher(e, s, t), this.linkEditorToDataField(e, t);
  }
  _createWatcher(e, t, n) {
    const s = this, o = s._getWatch();
    if (!B(o))
      return;
    const r = o(() => s._getDataByField(n), () => {
      const a = s._getDataByField(n);
      if (e.NAME === "dxTagBox") {
        const l = e.option("value");
        if (a !== l && function(d, u) {
          if (!Array.isArray(d) || !Array.isArray(u) || d.length !== u.length)
            return !1;
          for (let c = 0; c < d.length; c++)
            if (d[c] !== u[c])
              return !1;
          return !0;
        }(a, l))
          return;
      }
      e.option("value", a);
    }, {
      deep: !0,
      skipImmediate: !0
    }, {
      createWatcherDataField: n
    });
    _.on(t, On, r);
  }
  _getWatch() {
    if (!f(this._watch)) {
      const {
        form: e
      } = this.option();
      this._watch = e && e.option("integrationOptions.watchMethod");
    }
    return this._watch;
  }
  _createComponent(e, t, n) {
    const s = this.option("readOnly");
    let o = Object.hasOwn(n, "readOnly");
    const r = super._createComponent(e, t, I({}, n, {
      readOnly: o ? n.readOnly : s
    }));
    let a = !1;
    return r.on("optionChanged", (l) => {
      l.name === "readOnly" && !a && (o = !0);
    }), this.on("optionChanged", (l) => {
      l.name === "readOnly" && !o && (a = !0, r.option(l.name, l.value), a = !1);
    }), r;
  }
  _generateRatio(e, t) {
    const n = [];
    let s, o;
    for (o = 0; o < e; o++)
      s = {
        ratio: 1
      }, t && (s.baseSize = "auto"), n.push(s);
    return n;
  }
  _getRowsCount() {
    return Math.ceil(this._items.length / this._getColCount());
  }
  _updateReferencedOptions(e) {
    const t = this.option("layoutData");
    X(t) && Object.getOwnPropertyNames(t).forEach((n) => delete this._optionsByReference[`layoutData.${n}`]), X(e) && Object.getOwnPropertyNames(e).forEach((n) => this._optionsByReference[`layoutData.${n}`] = !0);
  }
  _clearWidget(e) {
    this._disableEditorValueChangedHandler = !0, e.clear(), this._disableEditorValueChangedHandler = !1, e.option("isValid", !0);
  }
  _optionChanged(e) {
    if (e.fullName.search("layoutData.") !== 0)
      switch (e.name) {
        case "showRequiredMark":
        case "showOptionalMark":
        case "requiredMark":
        case "optionalMark":
        case "alignItemLabels":
        case "labelLocation":
        case "labelMode":
        case "requiredMessage":
          this._invalidate();
          break;
        case "layoutData":
          this._updateReferencedOptions(e.value), this.option("items") ? en(e.value) || this._itemsRunTimeInfo.each((t, n) => {
            if (f(n.item)) {
              const {
                dataField: s
              } = n.item;
              if (s && f(n.widgetInstance)) {
                const r = Be(s)(e.value), {
                  allowIndeterminateState: a,
                  editorType: l
                } = n.item;
                r !== void 0 || this._isCheckboxUndefinedStateEnabled({
                  allowIndeterminateState: a,
                  editorType: l,
                  dataField: s
                }) ? n.widgetInstance.option("value", r) : this._clearWidget(n.widgetInstance);
              }
            }
          }) : (this._initDataAndItems(e.value), this._invalidate());
          break;
        case "items":
          this._cleanItemWatchers(), this._initDataAndItems(e.value), this._invalidate();
          break;
        case "customizeItem":
          this._updateItems(this.option("layoutData")), this._invalidate();
          break;
        case "colCount":
        case "colCountByScreen":
          this._resetColCount();
          break;
        case "minColWidth": {
          const {
            colCount: t
          } = this.option();
          t === "auto" && this._resetColCount();
          break;
        }
        case "readOnly":
        case "onFieldDataChanged":
          break;
        case "width": {
          super._optionChanged(e);
          const {
            colCount: t
          } = this.option();
          t === "auto" && this._resetColCount();
          break;
        }
        default:
          super._optionChanged(e);
      }
  }
  _resetColCount() {
    this._cashedColCount = null, this._invalidate();
  }
  linkEditorToDataField(e, t) {
    this.on("optionChanged", (n) => {
      n.fullName === `layoutData.${t}` && e._setOptionWithoutOptionChange("value", n.value);
    }), e.on("valueChanged", (n) => {
      const s = X(n.value) || Array.isArray(n.value);
      !this._disableEditorValueChangedHandler && !(s && n.value === n.previousValue) && this._updateFieldValue(t, n.value);
    });
  }
  _dimensionChanged() {
    const {
      colCount: e
    } = this.option();
    e === "auto" && this.isCachedColCountObsolete() && this._eventsStrategy.fireEvent("autoColCountChanged");
  }
  updateData(e, t) {
    const n = this;
    X(e) ? y(e, (s, o) => {
      n._updateFieldValue(s, o);
    }) : typeof e == "string" && n._updateFieldValue(e, t);
  }
  getEditor(e) {
    return this._itemsRunTimeInfo.findWidgetInstanceByDataField(e) || this._itemsRunTimeInfo.findWidgetInstanceByName(e);
  }
  isSingleColumnMode(e) {
    const t = this._responsiveBox || e;
    if (t)
      return t.option("currentScreenFactor") === t.option("singleColumnScreen");
  }
  getItemsRunTimeInfo() {
    return this._itemsRunTimeInfo;
  }
}
xe("dxLayoutManager", K8);
const su = {
  move(i, e) {
    Ot(i, {
      left: e
    });
  }
}, Yp = {
  moveTo(i, e, t, n) {
    Le.animate(i, {
      type: "slide",
      to: {
        left: e
      },
      duration: t,
      complete: n
    });
  },
  complete(i) {
    Le.stop(i, !0);
  }
}, s0 = (i) => +i, G8 = (i) => Nn(i).left;
class sR extends sC {
  _supportedKeys() {
    return I({}, super._supportedKeys(), {
      pageUp: M,
      pageDown: M
    });
  }
  _getDefaultOptions() {
    return I({}, super._getDefaultOptions(), {
      selectedIndex: 0,
      swipeEnabled: !0,
      animationEnabled: !0,
      loop: !1,
      deferRendering: !0,
      loopItemFocus: !1,
      selectOnFocus: !0,
      selectionMode: "single",
      selectionRequired: !0,
      selectByClick: !1
    });
  }
  _defaultOptionsRules() {
    return super._defaultOptionsRules().concat([{
      device: () => z.real().deviceType === "desktop" && !z.isSimulator(),
      options: {
        focusStateEnabled: !0
      }
    }]);
  }
  _itemClass() {
    return "dx-multiview-item";
  }
  _itemDataKey() {
    return "dxMultiViewItemData";
  }
  _itemContainer() {
    return this._$itemContainer;
  }
  _itemElements() {
    return this._itemContainer().children(this._itemSelector());
  }
  _itemWidth() {
    return this._itemWidthValue || (this._itemWidthValue = ne(this._$wrapper)), this._itemWidthValue;
  }
  _clearItemWidthCache() {
    delete this._itemWidthValue;
  }
  _itemsCount() {
    return this.option("items").length;
  }
  _isAllItemsHidden() {
    const {
      items: e
    } = this.option();
    return e.every((t, n) => !this._isItemVisible(n));
  }
  _normalizeIndex(e, t) {
    let n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : !0;
    const s = this._itemsCount();
    if (this._isAllItemsHidden())
      return;
    e < 0 && (e += s), e >= s && (e -= s);
    const o = t > 0 ? -1 : 1, r = o === -1 ? 0 : s - 1;
    for (; !this._isItemVisible(e) && (n || e !== r); )
      e = (e + o + s) % s;
    return e;
  }
  _getRTLSignCorrection() {
    return this.option("rtlEnabled") ? -1 : 1;
  }
  _init() {
    super._init.apply(this, arguments), this._activeStateUnit = ".dx-multiview-item";
    const e = this.$element();
    e.addClass("dx-multiview"), this._$wrapper = p("<div>").addClass("dx-multiview-wrapper"), this._$wrapper.appendTo(e), this._$itemContainer = p("<div>").addClass("dx-multiview-item-container"), this._$itemContainer.appendTo(this._$wrapper), this.option("loopItemFocus", this.option("loop")), this._findBoundaryIndices(), this._initSwipeable();
  }
  _ensureSelectedItemIsVisible() {
    const {
      loop: e,
      selectedIndex: t
    } = this.option();
    if (this._isItemVisible(t))
      return;
    if (this._isAllItemsHidden()) {
      this.option("selectedIndex", 0);
      return;
    }
    const n = -1 * this._getRTLSignCorrection();
    let s = this._normalizeIndex(t, n, e);
    s === t && (s = this._normalizeIndex(t, -n, e)), this.option("selectedIndex", s);
  }
  _initMarkup() {
    this._deferredItems = [], super._initMarkup(), this._ensureSelectedItemIsVisible();
    const e = this._getSelectedItemIndices();
    this._updateItemsVisibility(e[0]), this._setElementAria(), this._setItemsAria();
  }
  _afterItemElementDeleted(e, t) {
    super._afterItemElementDeleted(e, t), this._deferredItems && this._deferredItems.splice(t.itemIndex, 1);
  }
  _beforeItemElementInserted(e) {
    super._beforeItemElementInserted.apply(this, arguments), this._deferredItems && this._deferredItems.splice(e.index, 0, null);
  }
  _executeItemRenderAction(e, t, n) {
    e = (this.option("items") || []).indexOf(t), super._executeItemRenderAction(e, t, n);
  }
  _renderItemContent(e) {
    const t = w(), n = this, s = w();
    return s.done(() => {
      const o = super._renderItemContent.call(n, e);
      t.resolve(o);
    }), this._deferredItems[e.index] = s, this.option("deferRendering") || s.resolve(), t.promise();
  }
  _render() {
    super._render(), ft(() => {
      const e = this._getSelectedItemIndices();
      this._updateItems(e[0]);
    });
  }
  _getElementAria() {
    return {
      role: "group",
      roledescription: S.format("dxMultiView-elementAriaRoleDescription"),
      label: S.format("dxMultiView-elementAriaLabel")
    };
  }
  _setElementAria() {
    const e = this._getElementAria();
    this.setAria(e, this.$element());
  }
  _setItemsAria() {
    const e = this._itemElements(), t = this._itemsCount();
    e.each((n, s) => {
      const o = this._getItemAria({
        itemIndex: n,
        itemsCount: t
      });
      this.setAria(o, p(s));
    });
  }
  _getItemAria(e) {
    const {
      itemIndex: t,
      itemsCount: n
    } = e;
    return {
      role: "group",
      roledescription: S.format("dxMultiView-itemAriaRoleDescription"),
      label: S.format("dxMultiView-itemAriaLabel", t + 1, n)
    };
  }
  _updateItems(e, t) {
    this._updateItemsPosition(e, t), this._updateItemsVisibility(e, t);
  }
  _modifyByChanges() {
    super._modifyByChanges.apply(this, arguments);
    const e = this._getSelectedItemIndices();
    this._updateItemsVisibility(e[0]);
  }
  _updateItemsPosition(e, t) {
    const n = this._itemElements(), s = f(t) ? -this._animationDirection(t, e) : void 0, o = n.eq(e);
    su.move(o, 0), f(t) && su.move(n.eq(t), 100 * s + "%");
  }
  _isItemVisible(e) {
    var t;
    return ((t = this.option("items")[e]) === null || t === void 0 ? void 0 : t.visible) ?? !0;
  }
  _updateItemsVisibility(e, t) {
    this._itemElements().each((s, o) => {
      const r = p(o), a = s !== e && s !== t;
      a || this._renderSpecificItem(s), r.toggleClass("dx-multiview-item-hidden", a), this.setAria("hidden", a || void 0, r);
    });
  }
  _renderSpecificItem(e) {
    const t = this._itemElements().eq(e), n = t.find(this._itemContentClass()).length > 0;
    f(e) && !n && (this._deferredItems[e].resolve(), Ii(t));
  }
  _refreshItem(e, t) {
    super._refreshItem(e, t), this._updateItemsVisibility(this.option("selectedIndex"));
  }
  _setAriaSelectionAttribute() {
  }
  _updateSelection(e, t) {
    const n = e[0], s = t[0];
    Yp.complete(this._$itemContainer), this._updateItems(s, n);
    const o = this._animationDirection(n, s);
    this._animateItemContainer(o * this._itemWidth(), () => {
      su.move(this._$itemContainer, 0), this._updateItems(n), ne(this._$itemContainer);
    });
  }
  _animateItemContainer(e, t) {
    const n = this.option("animationEnabled") ? 200 : 0;
    Yp.moveTo(this._$itemContainer, e, n, t);
  }
  _animationDirection(e, t) {
    const n = G8(this._$itemContainer), s = (t - e) * this._getRTLSignCorrection() * this._getItemFocusLoopSignCorrection();
    return na(n !== 0 ? n : s);
  }
  _getSwipeDisabledState() {
    return !this.option("swipeEnabled") || this._itemsCount() <= 1;
  }
  _initSwipeable() {
    this._createComponent(this.$element(), Ic, {
      disabled: this._getSwipeDisabledState(),
      elastic: !1,
      itemSizeFunc: this._itemWidth.bind(this),
      onStart: (e) => this._swipeStartHandler(e.event),
      onUpdated: (e) => this._swipeUpdateHandler(e.event),
      onEnd: (e) => this._swipeEndHandler(e.event)
    });
  }
  _findBoundaryIndices() {
    const e = this.option("items");
    let t, n;
    e.forEach((s, o) => {
      const r = !!s?.disabled, a = this._isItemVisible(o);
      !r && a && (t ?? (t = o), n = o);
    }), this._boundaryIndices = {
      firstAvailableIndex: t ?? 0,
      lastAvailableIndex: n ?? e.length - 1,
      firstTrueIndex: 0,
      lastTrueIndex: e.length - 1
    };
  }
  _swipeStartHandler(e) {
    Yp.complete(this._$itemContainer);
    const t = this.option("selectedIndex"), n = this.option("loop"), {
      firstAvailableIndex: s,
      lastAvailableIndex: o
    } = this._boundaryIndices, r = this.option("rtlEnabled");
    e.maxLeftOffset = s0(n || (r ? t > s : t < o)), e.maxRightOffset = s0(n || (r ? t < o : t > s));
  }
  _swipeUpdateHandler(e) {
    const {
      offset: t
    } = e, n = na(t) * this._getRTLSignCorrection(), s = this.option("selectedIndex"), o = this._normalizeIndex(s - n, n);
    s !== o && (su.move(this._$itemContainer, t * this._itemWidth()), this._updateItems(s, o));
  }
  _findNextAvailableIndex(e, t) {
    const {
      items: n,
      loop: s
    } = this.option(), {
      firstAvailableIndex: o,
      lastAvailableIndex: r,
      firstTrueIndex: a,
      lastTrueIndex: l
    } = this._boundaryIndices, d = [a, o].includes(e), u = [l, r].includes(e);
    if (s) {
      if (d && t < 0)
        return r;
      if (u && t > 0)
        return o;
    }
    for (let c = e + t; c >= o && c <= r; c += t) {
      const h = !!n[c].disabled, g = this._isItemVisible(c);
      if (!h && g)
        return c;
    }
    return e;
  }
  _postprocessSwipe(e) {
  }
  _swipeEndHandler(e) {
    const t = e.targetOffset * this._getRTLSignCorrection();
    if (t) {
      const n = this._findNextAvailableIndex(this.option("selectedIndex"), -t);
      this.selectItem(n).fail(() => {
        this._animateItemContainer(0, M);
      }).done(() => {
        this._postprocessSwipe({
          swipedTabsIndex: n
        });
      });
      const s = this.itemElements().filter(".dx-item-selected");
      this.option("focusStateEnabled") && this.option("focusedElement", ee(s));
    } else
      this._animateItemContainer(0, M);
  }
  _getItemFocusLoopSignCorrection() {
    return this._itemFocusLooped ? -1 : 1;
  }
  _moveFocus() {
    super._moveFocus.apply(this, arguments), this._itemFocusLooped = !1;
  }
  _prevItem(e) {
    const t = super._prevItem.apply(this, arguments);
    return this._itemFocusLooped = t.is(e.last()), t;
  }
  _nextItem(e) {
    const t = super._nextItem.apply(this, arguments);
    return this._itemFocusLooped = t.is(e.first()), t;
  }
  _dimensionChanged() {
    this._clearItemWidthCache();
  }
  _visibilityChanged(e) {
    e && this._dimensionChanged();
  }
  _updateSwipeDisabledState() {
    const e = this._getSwipeDisabledState();
    Ic.getInstance(this.$element()).option("disabled", e);
  }
  _dispose() {
    delete this._boundaryIndices, super._dispose();
  }
  _itemOptionChanged(e, t) {
    super._itemOptionChanged(...arguments);
    const {
      selectedItem: n
    } = this.option();
    t === "visible" && e === n && this._ensureSelectedItemIsVisible();
  }
  _optionChanged(e) {
    const {
      value: t
    } = e;
    switch (e.name) {
      case "loop":
        this.option("loopItemFocus", t);
        break;
      case "animationEnabled":
        break;
      case "swipeEnabled":
        this._updateSwipeDisabledState();
        break;
      case "deferRendering":
        this._invalidate();
        break;
      case "items":
        this._updateSwipeDisabledState(), this._findBoundaryIndices(), super._optionChanged(e);
        break;
      case "selectedIndex":
        this._isItemVisible(t) ? super._optionChanged(e) : this._ensureSelectedItemIsVisible();
        break;
      default:
        super._optionChanged(e);
    }
  }
}
xe("dxMultiView", sR);
function oR(i) {
  return i.scrollWidth - i.clientWidth;
}
function U8(i) {
  return i.scrollHeight - i.clientHeight;
}
function j8(i, e) {
  return Math.round(i) <= e;
}
function q8(i, e, t) {
  return Math.round(oR(i) - e) <= t;
}
function Y8(i, e) {
  return Math.round(i) <= e;
}
function X8(i, e, t, n) {
  return Math.round(U8(i) - e - t) <= n;
}
const o0 = "dx-tabs-expanded";
class Z8 extends ga {
  _renderWatchers() {
    super._renderWatchers(), this._startWatcher("badge", this._renderBadge.bind(this));
  }
  _renderBadge(e) {
    if (this._$element.children(".dx-badge").remove(), !e)
      return;
    const t = p("<div>").addClass("dx-tabs-item-badge").addClass("dx-badge").text(e);
    this._$element.append(t);
  }
}
const r0 = {
  vertical: "dx-tabs-vertical",
  horizontal: "dx-tabs-horizontal"
}, a0 = {
  top: "dx-tab-indicator-position-top",
  right: "dx-tab-indicator-position-right",
  bottom: "dx-tab-indicator-position-bottom",
  left: "dx-tab-indicator-position-left"
}, La = {
  top: "dx-tabs-icon-position-top",
  end: "dx-tabs-icon-position-end",
  bottom: "dx-tabs-icon-position-bottom",
  start: "dx-tabs-icon-position-start"
}, l0 = {
  primary: "dx-tabs-styling-mode-primary",
  secondary: "dx-tabs-styling-mode-secondary"
}, Xp = {
  horizontal: "horizontal",
  vertical: "vertical"
}, ou = {
  top: "top",
  right: "right",
  bottom: "bottom",
  left: "left"
}, d0 = {
  horizontal: "horizontal",
  vertical: "vertical"
}, Sr = {
  top: "top",
  end: "end",
  bottom: "bottom",
  start: "start"
}, u0 = {
  primary: "primary",
  secondary: "secondary"
};
class Sh extends sC {
  _getDefaultOptions() {
    return I({}, super._getDefaultOptions(), {
      hoverStateEnabled: !0,
      showNavButtons: !0,
      scrollByContent: !0,
      scrollingEnabled: !0,
      selectionMode: "single",
      orientation: Xp.horizontal,
      iconPosition: Sr.start,
      stylingMode: u0.primary,
      activeStateEnabled: !0,
      selectionRequired: !1,
      selectOnFocus: !0,
      loopItemFocus: !1,
      useInkRipple: !1,
      badgeExpr: (e) => e?.badge,
      _itemAttributes: {
        role: "tab"
      },
      _indicatorPosition: null
    });
  }
  _defaultOptionsRules() {
    const e = pn();
    return super._defaultOptionsRules().concat([{
      device: () => z.real().deviceType !== "desktop",
      options: {
        showNavButtons: !1
      }
    }, {
      device: {
        deviceType: "desktop"
      },
      options: {
        scrollByContent: !1
      }
    }, {
      device: () => z.real().deviceType === "desktop" && !z.isSimulator(),
      options: {
        focusStateEnabled: !0
      }
    }, {
      device: () => nn(e),
      options: {
        iconPosition: Sr.top,
        stylingMode: u0.secondary
      }
    }, {
      device: () => Zt(e),
      options: {
        useInkRipple: !0,
        selectOnFocus: !1,
        iconPosition: Sr.top
      }
    }]);
  }
  _init() {
    const {
      orientation: e,
      stylingMode: t,
      scrollingEnabled: n
    } = this.option(), s = this._getIndicatorPosition();
    super._init(), this._activeStateUnit = ".dx-tab", this.setAria("role", "tablist"), this.$element().addClass("dx-tabs"), this._toggleScrollingEnabledClass(n), this._toggleOrientationClass(e), this._toggleIndicatorPositionClass(s), this._toggleIconPositionClass(), this._toggleStylingModeClass(t), this._renderWrapper(), this._renderMultiple(), this._feedbackHideTimeout = 100;
  }
  _prepareDefaultItemTemplate(e, t) {
    const n = pe(e) ? e?.text : e;
    if (f(n)) {
      const s = p("<span>").addClass("dx-tab-text-span");
      s.text(n);
      const o = p("<span>").addClass("dx-tab-text-span-pseudo");
      o.text(n), o.appendTo(s), s.appendTo(t);
    }
    f(e.html) && t.html(e.html);
  }
  _initTemplates() {
    super._initTemplates(), this._templateManager.addDefaultTemplates({
      item: new rr((e, t) => {
        this._prepareDefaultItemTemplate(t, e);
        const n = cs(t.icon);
        n && n.prependTo(e);
        const s = p("<div>").addClass("dx-tab-text");
        e.wrapInner(s);
      }, ["text", "html", "icon"], this.option("integrationOptions.watchMethod"))
    });
  }
  _itemClass() {
    return "dx-tab";
  }
  _selectedItemClass() {
    return "dx-tab-selected";
  }
  _itemDataKey() {
    return "dxTabData";
  }
  _initMarkup() {
    super._initMarkup(), this.option("useInkRipple") && this._renderInkRipple(), this.$element().addClass("dx-overflow-hidden");
  }
  _postProcessRenderItems() {
    this._renderScrolling();
  }
  _renderScrolling() {
    const e = ["dx-tabs-stretched", o0, "dx-overflow-hidden"];
    if (this.$element().removeClass(e.join(" ")), this.option("scrollingEnabled") && this._isItemsSizeExceeded()) {
      this._scrollable || (this._renderScrollable(), this._renderNavButtons());
      const t = this.getScrollable();
      if (t?.update(), this.option("rtlEnabled")) {
        const s = oR(p(this.getScrollable().container()).get(0));
        t?.scrollTo({
          left: s
        });
      }
      this._updateNavButtonsState();
      const {
        selectedItem: n
      } = this.option();
      this._scrollToItem(n);
    }
    this.option("scrollingEnabled") && this._isItemsSizeExceeded() || (this._cleanScrolling(), this._needStretchItems() && this.$element().addClass("dx-tabs-stretched"), this.$element().removeClass("dx-tabs-nav-buttons").addClass(o0));
  }
  _isVertical() {
    const {
      orientation: e
    } = this.option();
    return e === Xp.vertical;
  }
  _isItemsSizeExceeded() {
    return this._isVertical() ? this._isItemsHeightExceeded() : this._isItemsWidthExceeded();
  }
  _isItemsWidthExceeded() {
    const e = this._getVisibleItems(), t = this._getSummaryItemsSize("width", e, !0), n = ne(this.$element());
    return [t, n].includes(0) ? !1 : t > n - 1;
  }
  _isItemsHeightExceeded() {
    const e = this._getVisibleItems(), t = this._getSummaryItemsSize("height", e, !0), n = le(this.$element());
    return t - 1 > n;
  }
  _needStretchItems() {
    const e = this._getVisibleItems(), t = ne(this.$element()), n = [];
    y(e, (a, l) => {
      n.push(Ee(l, !0));
    });
    const s = Math.max.apply(null, n), o = t / e.length;
    return s > o + 1;
  }
  _cleanNavButtons() {
    !this._leftButton || !this._rightButton || (this._leftButton.$element().remove(), this._rightButton.$element().remove(), this._leftButton = null, this._rightButton = null);
  }
  _cleanScrolling() {
    this._scrollable && (this._$wrapper.appendTo(this.$element()), this._scrollable.$element().remove(), this._scrollable = null, this._cleanNavButtons());
  }
  _renderInkRipple() {
    this._inkRipple = w_();
  }
  _getPointerEvent() {
    return ye.up;
  }
  _toggleActiveState(e, t, n) {
    if (super._toggleActiveState(e, t, n), !this._inkRipple)
      return;
    const s = {
      element: e,
      event: n
    };
    t ? this._inkRipple.showWave(s) : this._inkRipple.hideWave(s);
  }
  _renderMultiple() {
    const {
      selectionMode: e
    } = this.option();
    e === "multiple" && this.option("selectOnFocus", !1);
  }
  _renderWrapper() {
    this._$wrapper = p("<div>").addClass("dx-tabs-wrapper"), this.$element().append(this._$wrapper);
  }
  _itemContainer() {
    return this._$wrapper;
  }
  _getScrollableDirection() {
    return this._isVertical() ? d0.vertical : d0.horizontal;
  }
  _updateScrollable() {
    this.getScrollable() && this._cleanScrolling(), this._renderScrolling();
  }
  _renderScrollable() {
    const e = this.$element().wrapInner(p("<div>").addClass("dx-tabs-scrollable")).children();
    this._scrollable = this._createComponent(e, Qt, {
      direction: this._getScrollableDirection(),
      showScrollbar: "never",
      useKeyboard: !1,
      useNative: !1,
      scrollByContent: this.option("scrollByContent"),
      onScroll: () => {
        this._updateNavButtonsState();
      }
    }), this.$element().append(this._scrollable.$element());
  }
  _scrollToItem(e) {
    if (!this._scrollable)
      return;
    const t = this._editStrategy.getItemElement(e);
    this._scrollable.scrollToElement(t);
  }
  _renderNavButtons() {
    const {
      showNavButtons: e,
      rtlEnabled: t
    } = this.option();
    if (this.$element().toggleClass("dx-tabs-nav-buttons", e), !e)
      return;
    this._leftButton = this._createNavButton(-30, t ? "chevronnext" : "chevronprev");
    const n = this._leftButton.$element();
    n.addClass("dx-tabs-nav-button-left"), this.$element().prepend(n), this._rightButton = this._createNavButton(30, t ? "chevronprev" : "chevronnext");
    const s = this._rightButton.$element();
    s.addClass("dx-tabs-nav-button-right"), this.$element().append(s);
  }
  _updateNavButtonsAriaDisabled() {
    [this._leftButton, this._rightButton].forEach((t) => {
      t?.$element().attr({
        "aria-disabled": null
      });
    });
  }
  _updateNavButtonsState() {
    const e = this._isVertical(), t = this.getScrollable();
    if (e) {
      var n, s;
      (n = this._leftButton) === null || n === void 0 || n.option("disabled", Y8(t.scrollTop(), 1)), (s = this._rightButton) === null || s === void 0 || s.option("disabled", X8(p(t.container()).get(0), t.scrollTop(), 0, 1));
    } else {
      var o, r;
      (o = this._leftButton) === null || o === void 0 || o.option("disabled", j8(t.scrollLeft(), 1)), (r = this._rightButton) === null || r === void 0 || r.option("disabled", q8(p(t.container()).get(0), t.scrollLeft(), 1));
    }
    this._updateNavButtonsAriaDisabled();
  }
  _updateScrollPosition(e, t) {
    var n, s;
    (n = this._scrollable) === null || n === void 0 || n.update(), (s = this._scrollable) === null || s === void 0 || s.scrollBy(e / t);
  }
  _createNavButton(e, t) {
    const n = this._createAction(() => {
      this._holdInterval = setInterval(() => {
        this._updateScrollPosition(e, 5);
      }, 5);
    }), s = R(Zs.name, "dxNavButton"), o = R(ye.up, "dxNavButton"), r = R(ye.out, "dxNavButton"), a = this._createComponent(p("<div>").addClass("dx-tabs-nav-button"), wt, {
      focusStateEnabled: !1,
      icon: t,
      integrationOptions: {},
      elementAttr: {
        role: null,
        "aria-label": null,
        "aria-disabled": null
      },
      onClick: () => {
        this._updateScrollPosition(e, 1);
      }
    }), l = a.$element();
    return _.on(l, s, {
      timeout: 300
    }, (d) => {
      n({
        event: d
      });
    }), _.on(l, o, () => {
      this._clearInterval();
    }), _.on(l, r, () => {
      this._clearInterval();
    }), a;
  }
  _clearInterval() {
    this._holdInterval && clearInterval(this._holdInterval);
  }
  _updateSelection(e) {
    if (this._scrollable)
      return this._scrollable.scrollToElement(this.itemElements().eq(e[0]));
  }
  _visibilityChanged(e) {
    e && this._dimensionChanged();
  }
  _dimensionChanged() {
    this._renderScrolling();
  }
  _enterKeyHandler(e) {
    const {
      focusedElement: t
    } = this.option();
    super._enterKeyHandler(e), this.option("focusedElement", t);
  }
  _itemSelectHandler(e) {
    const {
      selectionMode: t
    } = this.option();
    t === "single" && this.isItemSelected(e.currentTarget) || super._itemSelectHandler(e);
  }
  _clean() {
    this._cleanScrolling(), super._clean();
  }
  _toggleTabsVerticalClass(e) {
    this.$element().toggleClass(r0.vertical, e);
  }
  _toggleTabsHorizontalClass(e) {
    this.$element().toggleClass(r0.horizontal, e);
  }
  _getIndicatorPositionClass(e) {
    return a0[e];
  }
  _getIndicatorPosition() {
    const {
      _indicatorPosition: e,
      rtlEnabled: t
    } = this.option();
    if (e)
      return e;
    const n = this._isVertical();
    return t ? n ? ou.left : ou.bottom : n ? ou.right : ou.bottom;
  }
  _toggleIndicatorPositionClass(e) {
    const t = this._getIndicatorPositionClass(e);
    this._toggleElementClasses(a0, t);
  }
  _toggleScrollingEnabledClass(e) {
    this.$element().toggleClass("dx-tabs-scrolling-enabled", !!e);
  }
  _toggleOrientationClass(e) {
    const t = e === Xp.vertical;
    this._toggleTabsVerticalClass(t), this._toggleTabsHorizontalClass(!t);
  }
  _getTabsIconPositionClass() {
    const {
      iconPosition: e
    } = this.option();
    switch (e) {
      case Sr.top:
        return La.top;
      case Sr.end:
        return La.end;
      case Sr.bottom:
        return La.bottom;
      default:
        return La.start;
    }
  }
  _toggleIconPositionClass() {
    const e = this._getTabsIconPositionClass();
    this._toggleElementClasses(La, e);
  }
  _toggleStylingModeClass(e) {
    const t = l0[e ?? "primary"];
    this._toggleElementClasses(l0, t);
  }
  _toggleElementClasses(e, t) {
    for (const n in e)
      this.$element().removeClass(e[n]);
    this.$element().addClass(t);
  }
  _toggleFocusedDisabledNextClass(e, t) {
    this._itemElements().eq(e).toggleClass("dx-focused-disabled-next-tab", t);
  }
  _toggleFocusedDisabledPrevClass(e, t) {
    this._itemElements().eq(e).toggleClass("dx-focused-disabled-prev-tab", t);
  }
  _toggleFocusedDisabledClasses(e) {
    const {
      selectedIndex: t
    } = this.option();
    this._itemElements().removeClass("dx-focused-disabled-next-tab").removeClass("dx-focused-disabled-prev-tab");
    const n = t - 1, s = t + 1, o = p(e).index(), r = this._itemElements().eq(s).hasClass("dx-state-disabled"), a = this._itemElements().eq(n).hasClass("dx-state-disabled"), l = r && o === s, d = a && o === n;
    this._toggleFocusedDisabledNextClass(t, l), this._toggleFocusedDisabledPrevClass(t, d);
  }
  _updateFocusedElement() {
    const {
      focusStateEnabled: e,
      selectedIndex: t
    } = this.option(), n = this._itemElements();
    if (e && n.length) {
      const s = n.get(t);
      this.option({
        focusedElement: s
      });
    }
  }
  _optionChanged(e) {
    var t;
    const {
      name: n,
      value: s
    } = e;
    switch (n) {
      case "useInkRipple":
      case "scrollingEnabled":
        this._toggleScrollingEnabledClass(s), this._invalidate();
        break;
      case "showNavButtons":
      case "badgeExpr":
        this._invalidate();
        break;
      case "scrollByContent":
        (t = this._scrollable) === null || t === void 0 || t.option(n, s);
        break;
      case "width":
      case "height":
        super._optionChanged(e), this._dimensionChanged();
        break;
      case "selectionMode":
        this._renderMultiple(), super._optionChanged(e);
        break;
      case "focusedElement":
        this._toggleFocusedDisabledClasses(s), super._optionChanged(e), this._scrollToItem(s);
        break;
      case "rtlEnabled": {
        super._optionChanged(e);
        const o = this._getIndicatorPosition();
        this._toggleIndicatorPositionClass(o);
        break;
      }
      case "orientation": {
        this._toggleOrientationClass(s);
        const o = this._getIndicatorPosition();
        this._toggleIndicatorPositionClass(o), ae() && this._updateScrollable();
        break;
      }
      case "iconPosition":
        this._toggleIconPositionClass(), ae() && this._dimensionChanged();
        break;
      case "stylingMode":
        this._toggleStylingModeClass(s), ae() && this._dimensionChanged();
        break;
      case "_indicatorPosition": {
        const o = this._getIndicatorPosition();
        this._toggleIndicatorPositionClass(o);
        break;
      }
      case "selectedIndex":
      case "selectedItem":
      case "selectedItems":
        super._optionChanged(e), this._updateFocusedElement();
        break;
      default:
        super._optionChanged(e);
    }
  }
  _afterItemElementInserted() {
    super._afterItemElementInserted(), this._planPostRenderActions();
  }
  _afterItemElementDeleted(e, t) {
    super._afterItemElementDeleted(e, t), this._renderScrolling();
  }
  getScrollable() {
    return this._scrollable;
  }
}
Sh.ItemClass = Z8;
xe("dxTabs", Sh);
class Q8 extends ga {
  _renderWatchers() {
    this._startWatcher("badge", M), super._renderWatchers();
  }
}
const Er = {
  top: "dx-tabpanel-tabs-position-top",
  right: "dx-tabpanel-tabs-position-right",
  bottom: "dx-tabpanel-tabs-position-bottom",
  left: "dx-tabpanel-tabs-position-left"
}, Ds = {
  top: "top",
  right: "right",
  bottom: "bottom",
  left: "left"
}, J8 = {
  top: "bottom",
  right: "left",
  bottom: "top",
  left: "right"
}, c0 = {
  horizontal: "horizontal",
  vertical: "vertical"
}, h0 = {
  top: "top",
  end: "end",
  bottom: "bottom",
  start: "start"
}, p0 = {
  primary: "primary",
  secondary: "secondary"
};
class yC extends sR {
  _getDefaultOptions() {
    return I({}, super._getDefaultOptions(), {
      itemTitleTemplate: "title",
      hoverStateEnabled: !0,
      selectOnFocus: !1,
      showNavButtons: !1,
      scrollByContent: !0,
      scrollingEnabled: !0,
      tabsPosition: Ds.top,
      iconPosition: h0.start,
      stylingMode: p0.primary,
      onTitleClick: null,
      onTitleHold: null,
      onTitleRendered: null,
      badgeExpr: (e) => e?.badge,
      _tabsIndicatorPosition: null
    });
  }
  _defaultOptionsRules() {
    const e = pn();
    return super._defaultOptionsRules().concat([{
      device: () => z.real().deviceType === "desktop" && !z.isSimulator(),
      options: {
        focusStateEnabled: !0
      }
    }, {
      device: () => !tn.touch,
      options: {
        swipeEnabled: !1
      }
    }, {
      device: {
        platform: "generic"
      },
      options: {
        animationEnabled: !1
      }
    }, {
      device: () => nn(e),
      options: {
        stylingMode: p0.secondary
      }
    }, {
      device: () => Gn(e),
      options: {
        iconPosition: h0.top
      }
    }]);
  }
  _init() {
    super._init(), this.$element().addClass("dx-tabpanel"), this._toggleTabPanelTabsPositionClass();
  }
  _getElementAria() {
    return {
      role: "tabpanel"
    };
  }
  _getItemAria() {
    return {
      role: "tabpanel"
    };
  }
  _initMarkup() {
    super._initMarkup(), this._createTitleActions(), this._renderLayout();
  }
  _prepareTabsItemTemplate(e, t) {
    const n = cs(e?.icon);
    n && t.append(n);
    const s = pe(e) ? e?.title : e;
    if (f(s) && !pe(s)) {
      const o = p("<span>").addClass("dx-tab-text-span");
      o.append(O.createTextNode(s));
      const r = p("<span>").addClass("dx-tab-text-span-pseudo");
      r.append(O.createTextNode(s)), r.appendTo(o), o.appendTo(t);
    }
  }
  _initTemplates() {
    super._initTemplates(), this._templateManager.addDefaultTemplates({
      title: new rr((e, t) => {
        this._prepareTabsItemTemplate(t, e);
        const n = p("<div>").addClass("dx-tab-text");
        e.wrapInner(n);
      }, ["title", "icon"], this.option("integrationOptions.watchMethod"))
    });
  }
  _createTitleActions() {
    this._createTitleClickAction(), this._createTitleHoldAction(), this._createTitleRenderedAction();
  }
  _createTitleClickAction() {
    this._titleClickAction = this._createActionByOption("onTitleClick");
  }
  _createTitleHoldAction() {
    this._titleHoldAction = this._createActionByOption("onTitleHold");
  }
  _createTitleRenderedAction() {
    this._titleRenderedAction = this._createActionByOption("onTitleRendered");
  }
  _renderLayout() {
    if (this._tabs)
      return;
    const e = this.$element();
    this._$tabContainer = p("<div>").addClass("dx-tabpanel-tabs").appendTo(e);
    const t = p("<div>").appendTo(this._$tabContainer);
    this._tabs = this._createComponent(t, Sh, this._tabConfig()), this._$container = p("<div>").addClass("dx-tabpanel-container").appendTo(e), this._$container.append(this._$wrapper);
  }
  _refreshActiveDescendant() {
    if (!this._tabs)
      return;
    const e = this._tabs, t = e.itemElements(), n = p(t[e.option("selectedIndex")]), s = this.getFocusedItemId();
    this.setAria("controls", void 0, p(t)), this.setAria("controls", s, n);
  }
  _getTabsIndicatorPosition() {
    const {
      _tabsIndicatorPosition: e,
      tabsPosition: t
    } = this.option();
    return e ?? J8[t ?? Ds.top];
  }
  _tabConfig() {
    const e = this._getTabsIndicatorPosition(), {
      focusStateEnabled: t,
      hoverStateEnabled: n,
      repaintChangesOnly: s,
      tabIndex: o,
      selectedIndex: r,
      badgeExpr: a,
      itemHoldTimeout: l,
      items: d,
      scrollingEnabled: u,
      scrollByContent: c,
      showNavButtons: h,
      loop: g,
      iconPosition: m,
      stylingMode: C
    } = this.option();
    return {
      selectOnFocus: !0,
      focusStateEnabled: t,
      hoverStateEnabled: n,
      repaintChangesOnly: s,
      tabIndex: o,
      selectedIndex: r,
      badgeExpr: a,
      onItemClick: this._titleClickAction.bind(this),
      onItemHold: this._titleHoldAction.bind(this),
      itemHoldTimeout: l,
      onSelectionChanging: (v) => {
        const E = v.addedItems[0], T = this._getIndexByItemData(E), V = this.selectItem(T), $ = V.state();
        if ($ !== "pending") {
          v.cancel = $ === "rejected";
          return;
        }
        v.cancel = new Promise((G) => {
          V.done(() => {
            G(!1);
          }).fail(() => {
            G(!0);
          });
        });
      },
      onSelectionChanged: () => {
        this._refreshActiveDescendant();
      },
      onItemRendered: this._titleRenderedAction.bind(this),
      itemTemplate: this._getTemplateByOption("itemTitleTemplate"),
      items: d,
      noDataText: null,
      scrollingEnabled: u,
      scrollByContent: c,
      showNavButtons: h,
      itemTemplateProperty: "tabTemplate",
      loopItemFocus: g,
      selectionRequired: !0,
      onOptionChanged: (v) => {
        if (v.name === "focusedElement")
          if (v.value) {
            const E = p(v.value), T = this._itemElements().eq(E.index());
            this.option("focusedElement", ee(T));
          } else
            this.option("focusedElement", v.value);
      },
      onFocusIn: (v) => {
        this._focusInHandler(v.event);
      },
      onFocusOut: (v) => {
        this._isFocusOutHandlerExecuting || this._focusOutHandler(v.event);
      },
      orientation: this._getTabsOrientation(),
      iconPosition: m,
      stylingMode: C,
      _itemAttributes: {
        class: "dx-tabpanel-tab"
      },
      _indicatorPosition: e
    };
  }
  _renderFocusTarget() {
    this._focusTarget().attr("tabIndex", -1);
  }
  _getTabsOrientation() {
    const {
      tabsPosition: e
    } = this.option();
    return [Ds.right, Ds.left].includes(e) ? c0.vertical : c0.horizontal;
  }
  _getTabPanelTabsPositionClass() {
    const {
      tabsPosition: e
    } = this.option();
    switch (e) {
      case Ds.right:
        return Er.right;
      case Ds.bottom:
        return Er.bottom;
      case Ds.left:
        return Er.left;
      case Ds.top:
      default:
        return Er.top;
    }
  }
  _toggleTabPanelTabsPositionClass() {
    for (const t in Er)
      this.$element().removeClass(Er[t]);
    const e = this._getTabPanelTabsPositionClass();
    this.$element().addClass(e);
  }
  _updateTabsOrientation() {
    const e = this._getTabsOrientation();
    this._setTabsOption("orientation", e);
  }
  _toggleWrapperFocusedClass(e) {
    this._toggleFocusClass(e, this._$wrapper);
  }
  _toggleDisabledFocusedClass(e) {
    this._focusTarget().toggleClass("dx-disabled-focused-tab", e);
  }
  _updateFocusState(e, t) {
    super._updateFocusState(e, t);
    const n = e.target === this._tabs._focusTarget().get(0), s = e.target === this._focusTarget().get(0);
    if (n && this._toggleFocusClass(t, this._focusTarget()), n || s) {
      const o = this._isDisabled(this.option("focusedElement"));
      this._toggleWrapperFocusedClass(t && !o), this._toggleDisabledFocusedClass(t && o);
    }
    s && (this._toggleFocusClass(t, this._tabs.$element()), this._toggleFocusClass(t, this._tabs.option("focusedElement")));
  }
  _focusOutHandler(e) {
    this._isFocusOutHandlerExecuting = !0, super._focusOutHandler(e), this._tabs._focusOutHandler(e), this._isFocusOutHandlerExecuting = !1;
  }
  _setTabsOption(e, t) {
    this._tabs && this._tabs.option(e, t);
  }
  _postprocessSwipe(e) {
    this._setTabsOption("selectedIndex", e.swipedTabsIndex);
  }
  _visibilityChanged(e) {
    e && this._tabs._dimensionChanged();
  }
  registerKeyHandler(e, t) {
    super.registerKeyHandler(e, t), this._tabs && this._tabs.registerKeyHandler(e, t);
  }
  repaint() {
    super.repaint(), this._tabs.repaint();
  }
  _updateTabsIndicatorPosition() {
    const e = this._getTabsIndicatorPosition();
    this._setTabsOption("_indicatorPosition", e);
  }
  _optionChanged(e) {
    const {
      name: t,
      value: n,
      fullName: s
    } = e;
    switch (t) {
      case "dataSource":
      default:
        super._optionChanged(e);
        break;
      case "items":
        this._setTabsOption(t, this.option(t)), this.option("repaintChangesOnly") || this._tabs.repaint(), super._optionChanged(e);
        break;
      case "width":
        super._optionChanged(e), this._tabs.repaint();
        break;
      case "selectedIndex":
      case "selectedItem": {
        this._setTabsOption(s, n), super._optionChanged(e);
        const {
          focusStateEnabled: o
        } = this.option();
        if (o === !0) {
          const r = this.option("selectedIndex"), a = this._itemElements().eq(r);
          this.option("focusedElement", ee(a));
        }
        break;
      }
      case "itemHoldTimeout":
      case "focusStateEnabled":
      case "hoverStateEnabled":
        this._setTabsOption(s, n), super._optionChanged(e);
        break;
      case "scrollingEnabled":
      case "scrollByContent":
      case "showNavButtons":
        this._setTabsOption(s, n);
        break;
      case "focusedElement": {
        const o = n && p(n).index(), r = n && this._tabs ? this._tabs._itemElements().eq(o) : n;
        if (this._setTabsOption("focusedElement", ee(r)), n) {
          const a = this._isDisabled(n);
          this._toggleWrapperFocusedClass(!a), this._toggleDisabledFocusedClass(a);
        }
        super._optionChanged(e);
        break;
      }
      case "itemTitleTemplate":
        this._setTabsOption("itemTemplate", this._getTemplateByOption("itemTitleTemplate"));
        break;
      case "onTitleClick":
        this._createTitleClickAction(), this._setTabsOption("onItemClick", this._titleClickAction.bind(this));
        break;
      case "onTitleHold":
        this._createTitleHoldAction(), this._setTabsOption("onItemHold", this._titleHoldAction.bind(this));
        break;
      case "onTitleRendered":
        this._createTitleRenderedAction(), this._setTabsOption("onItemRendered", this._titleRenderedAction.bind(this));
        break;
      case "loop":
        this._setTabsOption("loopItemFocus", n), super._optionChanged(e);
        break;
      case "badgeExpr":
        this._invalidate();
        break;
      case "tabsPosition":
        this._toggleTabPanelTabsPositionClass(), this._updateTabsIndicatorPosition(), this._updateTabsOrientation();
        break;
      case "iconPosition":
        this._setTabsOption("iconPosition", n);
        break;
      case "stylingMode":
        this._setTabsOption("stylingMode", n);
        break;
      case "_tabsIndicatorPosition":
        this._setTabsOption("_indicatorPosition", n);
    }
  }
}
yC.ItemClass = Q8;
xe("dxTabPanel", yC);
class ar {
  constructor(e) {
    this._options = e, this._itemsRunTimeInfo = this._options.itemsRunTimeInfo;
  }
  findInstance() {
    return this._itemsRunTimeInfo.findWidgetInstanceByItem(this._options.item);
  }
  findItemContainer() {
    return this._itemsRunTimeInfo.findItemContainerByItem(this._options.item);
  }
  findPreparedItem() {
    return this._itemsRunTimeInfo.findPreparedItemByItem(this._options.item);
  }
  tryExecute() {
    se.abstract();
  }
}
const Gm = (i, e) => `${e ? "tabs" : "items"}[${i}]`, rR = (i, e) => f(i) && f(e) ? `${i}.${e}` : i || e, Um = (i) => i ? i.replace(/\s/g, "") : void 0, eZ = (i, e) => i ? i.dataField === e || i.name === e || Um(i.title) === e || i.itemType === "group" && Um(i.caption) === e : !1, Xa = (i, e) => `${i}.${e}`, g0 = (i) => {
  const e = i.split(".");
  return e[e.length - 1].replace(/\[\d+]/, "");
}, tZ = (i) => {
  const e = i.split("."), t = [...e];
  for (let n = e.length - 1; n >= 0; n--) {
    if (aR(e[n]))
      return t.join(".");
    t.splice(n, 1);
  }
  return "";
}, aR = (i) => i.indexOf("tabs") > -1, lR = (i, e, t) => {
  const n = i.indexOf(e);
  if (n > -1)
    return Gm(n, t);
  for (let s = 0; s < i.length; s++) {
    const o = i[s], r = o.tabs || o.items;
    if (r) {
      const a = lR(r, e, o.tabs);
      if (a)
        return rR(Gm(s, t), a);
    }
  }
};
function nZ(i) {
  let {
    form: e,
    $formElement: t,
    formOptions: n,
    items: s,
    validationGroup: o,
    extendedLayoutManagerOptions: r,
    onFieldDataChanged: a,
    onContentReady: l,
    onDisposing: d,
    onFieldItemRendered: u
  } = i;
  const c = {
    form: e,
    items: s,
    $formElement: t,
    validationGroup: o,
    onFieldDataChanged: a,
    onContentReady: l,
    onDisposing: d,
    onFieldItemRendered: u,
    validationBoundary: n.scrollingEnabled ? t : void 0,
    scrollingEnabled: n.scrollingEnabled,
    showRequiredMark: n.showRequiredMark,
    showOptionalMark: n.showOptionalMark,
    requiredMark: n.requiredMark,
    optionalMark: n.optionalMark,
    requiredMessage: n.requiredMessage,
    screenByWidth: n.screenByWidth,
    layoutData: n.formData,
    labelLocation: n.labelLocation,
    customizeItem: n.customizeItem,
    minColWidth: n.minColWidth,
    showColonAfterLabel: n.showColonAfterLabel,
    onEditorEnterKey: n.onEditorEnterKey,
    labelMode: n.labelMode
  };
  return x(c, {
    isRoot: r.isRoot,
    colCount: r.colCount,
    alignItemLabels: r.alignItemLabels,
    cssItemClass: r.cssItemClass,
    colCountByScreen: r.colCountByScreen,
    onLayoutChanged: r.onLayoutChanged,
    width: r.width
  });
}
class iZ extends ar {
  tryExecute() {
    const {
      value: e
    } = this._options, t = this.findInstance();
    return t ? (t.option(e), !0) : !1;
  }
}
class m0 extends ar {
  tryExecute() {
    const e = this.findInstance();
    if (e) {
      const {
        optionName: t,
        item: n,
        value: s
      } = this._options, o = this._itemsRunTimeInfo.findItemIndexByItem(n);
      if (o >= 0)
        return e.option(Xa(`items[${o}]`, t), s), !0;
    }
    return !1;
  }
}
class sZ extends ar {
  tryExecute() {
    return !1;
  }
}
class oZ extends ar {
  tryExecute() {
    const e = this.findPreparedItem();
    return e != null && e._prepareGroupItemTemplate && e._renderGroupContentTemplate ? (e._prepareGroupItemTemplate(this._options.item.template), e._renderGroupContentTemplate(), !0) : !1;
  }
}
class rZ extends ar {
  tryExecute() {
    const e = this.findInstance();
    if (e) {
      const {
        value: t
      } = this._options;
      return e.option("dataSource", t), !0;
    }
    return !1;
  }
}
class aZ extends ar {
  tryExecute() {
    const {
      item: e
    } = this._options, t = this.findInstance(), n = t && tt(t.$element()[0], "dxValidator");
    if (n && e) {
      const s = (a) => a.type === "required", o = (n.option("validationRules") || []).some(s), r = (e.validationRules || []).some(s);
      if (!o && !r || o && r)
        return n.option("validationRules", e.validationRules), !0;
    }
    return !1;
  }
}
class lZ extends ar {
  tryExecute() {
    const e = this.findItemContainer(), {
      previousValue: t,
      value: n
    } = this._options;
    return e ? (e.removeClass(t).addClass(n), !0) : !1;
  }
}
const dZ = (i, e) => {
  switch (i) {
    case "editorOptions":
    case "buttonOptions":
      return new iZ(e);
    case "validationRules":
      return new aZ(e);
    case "cssClass":
      return new lZ(e);
    case "badge":
    case "disabled":
    case "icon":
    case "tabTemplate":
    case "title":
      return new m0(x(e, {
        optionName: i
      }));
    case "tabs":
      return new rZ(e);
    case "template": {
      var t, n;
      const s = (e == null || (t = e.item) === null || t === void 0 ? void 0 : t.itemType) ?? ((n = e.itemsRunTimeInfo.findPreparedItemByItem(e?.item)) === null || n === void 0 ? void 0 : n.itemType);
      return s === "simple" ? new sZ(e) : s === "group" ? new oZ(e) : new m0(x(e, {
        optionName: i
      }));
    }
    default:
      return null;
  }
}, uZ = ["items", "isRequired", "validationRules", "visible"];
class Eh extends Rt {
  _init() {
    super._init(), this._dirtyFields = /* @__PURE__ */ new Set(), this._cachedColCountOptions = [], this._itemsRunTimeInfo = new iR(), this._groupsColCount = [], this._attachSyncSubscriptions();
  }
  _getDefaultOptions() {
    return I({}, super._getDefaultOptions(), {
      formID: `dx-${new Xe()}`,
      formData: {},
      colCount: 1,
      screenByWidth: jc,
      labelLocation: "left",
      readOnly: !1,
      onFieldDataChanged: null,
      customizeItem: null,
      onEditorEnterKey: null,
      minColWidth: 200,
      alignItemLabels: !0,
      alignItemLabelsInAllGroups: !0,
      alignRootItemLabels: !0,
      showColonAfterLabel: !0,
      showRequiredMark: !0,
      showOptionalMark: !1,
      requiredMark: "*",
      optionalMark: S.format("dxForm-optionalMark"),
      requiredMessage: S.getFormatter("dxForm-requiredMessage"),
      showValidationSummary: !1,
      scrollingEnabled: !1,
      stylingMode: Pe().editorStylingMode,
      labelMode: "outside",
      isDirty: !1
    });
  }
  _defaultOptionsRules() {
    return super._defaultOptionsRules().concat([{
      device: () => Gn(),
      options: {
        labelLocation: "top"
      }
    }, {
      device: () => Zt(),
      options: {
        showColonAfterLabel: !1
      }
    }]);
  }
  _setOptionsByReference() {
    super._setOptionsByReference(), x(this._optionsByReference, {
      formData: !0,
      validationGroup: !0
    });
  }
  _getGroupColCount(e) {
    return parseInt(e.attr(e0));
  }
  _applyLabelsWidthByCol(e, t) {
    let n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    const s = n.inOneColumn ? QA : Xw + t, o = n.excludeTabbed ? `:not(.${Qw})` : "";
    L8(e, `.${s}${o}`);
  }
  _applyLabelsWidth(e, t, n, s, o) {
    s = n ? 1 : s || this._getGroupColCount(e);
    const r = {
      excludeTabbed: t,
      inOneColumn: n
    };
    let a;
    for (a = 0; a < s; a++)
      this._applyLabelsWidthByCol(e, a, r, o);
  }
  _getGroupElementsInColumn(e, t, n) {
    const s = f(n) ? `.${Jw}${n}` : "", o = `.${Xw}${t} > .${zm} > .${qp}${s}`;
    return e.find(o);
  }
  _applyLabelsWidthWithGroups(e, t, n, s) {
    const {
      alignRootItemLabels: o
    } = this.option();
    if (o === !0) {
      const a = e.find(`.${tR}`);
      for (let l = 0; l < t; l++)
        this._applyLabelsWidthByCol(a, l, n, s);
    }
    if (this.option("alignItemLabelsInAllGroups"))
      this._applyLabelsWidthWithNestedGroups(e, t, n, s);
    else {
      const a = this.$element().find(`.${qp}`);
      let l;
      for (l = 0; l < a.length; l++)
        this._applyLabelsWidth(a.eq(l), n, void 0, void 0, s);
    }
  }
  _applyLabelsWidthWithNestedGroups(e, t, n, s) {
    const o = {
      excludeTabbed: n
    };
    let r, a, l, d;
    for (r = 0; r < t; r++)
      for (d = this._getGroupElementsInColumn(e, r), this._applyLabelsWidthByCol(d, 0, o, s), a = 0; a < this._groupsColCount.length; a++) {
        d = this._getGroupElementsInColumn(e, r, this._groupsColCount[a]);
        const u = this._getGroupColCount(d);
        for (l = 1; l < u; l++)
          this._applyLabelsWidthByCol(d, l, o, s);
      }
  }
  _labelLocation() {
    const {
      labelLocation: e
    } = this.option();
    return e;
  }
  _alignLabelsInColumn(e) {
    let {
      layoutManager: t,
      inOneColumn: n,
      $container: s,
      excludeTabbed: o,
      items: r
    } = e;
    if (!ae() || this._labelLocation() === "top")
      return;
    const a = nR(t._getMarkOptions());
    n ? this._applyLabelsWidth(s, o, !0, void 0, a) : this._checkGrouping(r) ? this._applyLabelsWidthWithGroups(s, t._getColCount(), o, a) : this._applyLabelsWidth(s, o, !1, t._getColCount(), a);
  }
  _prepareFormData() {
    f(this.option("formData")) || this.option("formData", {});
  }
  _setStylingModeClass() {
    const {
      stylingMode: e
    } = this.option();
    e === "underlined" && this.$element().addClass(I8);
  }
  _initMarkup() {
    Ve.addGroup(this._getValidationGroup(), !1), this._clearCachedInstances(), this._prepareFormData(), this.$element().addClass(f8), this._setStylingModeClass(), super._initMarkup(), this.setAria("role", "form", this.$element()), this.option("scrollingEnabled") && this._renderScrollable(), this._renderLayout(), this._renderValidationSummary(), this._lastMarkupScreenFactor = this._targetScreenFactor || this._getCurrentScreenFactor(), this._attachResizeObserverSubscription();
  }
  _attachResizeObserverSubscription() {
    if (ae()) {
      const e = this.$element().get(0);
      zo.unobserve(e), zo.observe(e, () => {
        this._resizeHandler();
      });
    }
  }
  _resizeHandler() {
    this._cachedLayoutManagers.length && y(this._cachedLayoutManagers, (e, t) => {
      var n;
      (n = t.option("onLayoutChanged")) === null || n === void 0 || n(t.isSingleColumnMode());
    });
  }
  _getCurrentScreenFactor() {
    return ae() ? Kf(this.option("screenByWidth")) : "lg";
  }
  _clearCachedInstances() {
    this._itemsRunTimeInfo.clear(), this._cachedLayoutManagers = [];
  }
  _alignLabels(e, t) {
    this._alignLabelsInColumn({
      $container: this.$element(),
      layoutManager: e,
      excludeTabbed: !0,
      items: this.option("items"),
      inOneColumn: t
    }), Ii(this.$element().find(`.${qO}`));
  }
  _clean() {
    this._clearValidationSummary(), super._clean(), this._groupsColCount = [], this._cachedColCountOptions = [], this._lastMarkupScreenFactor = void 0, zo.unobserve(this.$element().get(0));
  }
  _renderScrollable() {
    const e = this.option("useNativeScrolling");
    this._scrollable = new Qt(this.$element(), {
      useNative: !!e,
      useSimulatedScrollbar: !e,
      useKeyboard: !1,
      direction: "both",
      bounceEnabled: !1
    });
  }
  _getContent() {
    var e;
    return this.option("scrollingEnabled") ? p((e = this._scrollable) === null || e === void 0 ? void 0 : e.content()) : this.$element();
  }
  _clearValidationSummary() {
    var e;
    (e = this._$validationSummary) === null || e === void 0 || e.remove(), this._$validationSummary = void 0, this._validationSummary = void 0;
  }
  _renderValidationSummary() {
    this._clearValidationSummary(), this.option("showValidationSummary") && (this._$validationSummary = p("<div>").addClass(E8).appendTo(this._getContent()), this._validationSummary = this._$validationSummary.dxValidationSummary({
      validationGroup: this._getValidationGroup()
    }).dxValidationSummary("instance"));
  }
  _prepareItems(e, t, n, s) {
    if (e) {
      const o = [];
      for (let r = 0; r < e.length; r++) {
        let a = e[r];
        const l = rR(n, Gm(r, s)), d = {
          item: a,
          itemIndex: r,
          path: l
        }, u = this._itemsRunTimeInfo.add(d);
        if (te(a) && (a = {
          dataField: a
        }), X(a)) {
          const c = I({}, a);
          d.preparedItem = c, c.guid = u, this._tryPrepareGroupItemCaption(c), this._tryPrepareGroupItem(c), this._tryPrepareTabbedItem(c, l), this._tryPrepareItemTemplate(c), t && (c.cssItemClass = Qw), c.items && (c.items = this._prepareItems(c.items, t, l)), o.push(c);
        } else
          o.push(a);
      }
      return o;
    }
  }
  _tryPrepareGroupItemCaption(e) {
    e.itemType === "group" && (e._prepareGroupCaptionTemplate = (t) => {
      e.captionTemplate && (e.groupCaptionTemplate = this._getTemplate(t)), e.captionTemplate = this._itemGroupTemplate.bind(this, e);
    }, e._prepareGroupCaptionTemplate(e.captionTemplate));
  }
  _tryPrepareGroupItem(e) {
    e.itemType === "group" && (e.alignItemLabels = Qe(e.alignItemLabels, !0), e._prepareGroupItemTemplate = (t) => {
      e.template && (e.groupContentTemplate = this._getTemplate(t)), e.template = this._itemGroupTemplate.bind(this, e);
    }, e._prepareGroupItemTemplate(e.template));
  }
  _tryPrepareTabbedItem(e, t) {
    e.itemType === "tabbed" && (e.template = this._itemTabbedTemplate.bind(this, e), e.tabs = this._prepareItems(e.tabs, !0, t, !0));
  }
  _tryPrepareItemTemplate(e) {
    e.template && (e.template = this._getTemplate(e.template));
  }
  _checkGrouping(e) {
    if (e) {
      for (let t = 0; t < e.length; t++)
        if (e[t].itemType === "group")
          return !0;
    }
  }
  _renderLayout() {
    const e = this;
    let t = e.option("items");
    const n = e._getContent();
    t = e._prepareItems(t), e._rootLayoutManager = e._renderLayoutManager(n, this._createLayoutManagerOptions(t, {
      isRoot: !0,
      colCount: e.option("colCount"),
      alignItemLabels: e.option("alignItemLabels"),
      screenByWidth: this.option("screenByWidth"),
      colCountByScreen: this.option("colCountByScreen"),
      onLayoutChanged(s) {
        e._alignLabels.bind(e)(e._rootLayoutManager, s);
      },
      onContentReady(s) {
        e._alignLabels(s.component, s.component.isSingleColumnMode());
      }
    }));
  }
  _tryGetItemsForTemplate(e) {
    return e.items || [];
  }
  _itemTabbedTemplate(e, t, n) {
    const s = p("<div>").appendTo(n), o = x({}, e.tabPanelOptions, {
      dataSource: e.tabs,
      onItemRendered: (l) => {
        var d, u;
        (d = e.tabPanelOptions) === null || d === void 0 || (u = d.onItemRendered) === null || u === void 0 || u.call(d, l), D_(l.itemElement);
      },
      itemTemplate: (l, d, u) => {
        const c = p(u), h = Qe(l.alignItemLabels, !0), g = this._renderLayoutManager(c, this._createLayoutManagerOptions(this._tryGetItemsForTemplate(l), {
          colCount: l.colCount,
          alignItemLabels: h,
          screenByWidth: this.option("screenByWidth"),
          colCountByScreen: l.colCountByScreen,
          cssItemClass: l.cssItemClass,
          onLayoutChanged: (m) => {
            this._alignLabelsInColumn({
              $container: c,
              layoutManager: g,
              items: l.items,
              inOneColumn: m
            });
          }
        }));
        this._itemsRunTimeInfo && this._itemsRunTimeInfo.extendRunTimeItemInfoByKey(l.guid, {
          layoutManager: g
        }), h && this._alignLabelsInColumn({
          $container: c,
          layoutManager: g,
          items: l.items,
          inOneColumn: g.isSingleColumnMode()
        });
      }
    }), r = (l, d) => {
      Array.isArray(l) && l.forEach((u) => this._itemsRunTimeInfo.extendRunTimeItemInfoByKey(u.guid, {
        widgetInstance: d
      }));
    }, a = this._createComponent(s, yC, o);
    p(n).parent().addClass(w8), a.on("optionChanged", (l) => {
      l.fullName === "dataSource" && r(l.value, l.component);
    }), r([{
      guid: e.guid
    }, ...e.tabs ?? []], a);
  }
  _itemGroupCaptionTemplate(e, t, n) {
    if (e.groupCaptionTemplate) {
      const s = p("<div>").addClass(C8).attr("id", n).appendTo(t);
      e._renderGroupCaptionTemplate = () => {
        const o = {
          component: this,
          caption: e.caption,
          name: e.name
        };
        e.groupCaptionTemplate.render({
          model: o,
          container: ee(s)
        });
      }, e._renderGroupCaptionTemplate();
      return;
    }
    e.caption && p("<span>").addClass(_8).text(e.caption).attr("id", n).appendTo(t);
  }
  _itemGroupContentTemplate(e, t) {
    const n = p("<div>").addClass(y8).appendTo(t);
    if (e.groupContentTemplate)
      e._renderGroupContentTemplate = () => {
        n.empty();
        const o = {
          formData: this.option("formData"),
          component: this
        };
        e.groupContentTemplate.render({
          model: o,
          container: ee(n)
        });
      }, e._renderGroupContentTemplate();
    else {
      var s;
      const o = this._renderLayoutManager(n, this._createLayoutManagerOptions(this._tryGetItemsForTemplate(e), {
        colCount: e.colCount,
        colCountByScreen: e.colCountByScreen,
        alignItemLabels: e.alignItemLabels,
        cssItemClass: e.cssItemClass
      }));
      (s = this._itemsRunTimeInfo) === null || s === void 0 || s.extendRunTimeItemInfoByKey(e.guid, {
        layoutManager: o
      });
      const r = o._getColCount();
      this._groupsColCount.includes(r) || this._groupsColCount.push(r), t.addClass(Jw + r), t.attr(e0, r);
    }
  }
  _itemGroupTemplate(e, t, n) {
    const {
      id: s
    } = t.editorOptions.inputAttr, o = p("<div>").toggleClass(S8, f(e.caption) && e.caption.length).addClass(qp).appendTo(n), r = {
      role: "group",
      labelledby: s
    };
    this.setAria(r, o), p(n).parent().addClass(b8), this._itemGroupCaptionTemplate(e, o, s), this._itemGroupContentTemplate(e, o);
  }
  _createLayoutManagerOptions(e, t) {
    return nZ({
      form: this,
      formOptions: this.option(),
      $formElement: this.$element(),
      items: e,
      validationGroup: this._getValidationGroup(),
      extendedLayoutManagerOptions: t,
      onFieldDataChanged: (n) => {
        this._isDataUpdating || this._triggerOnFieldDataChanged(n);
      },
      onContentReady: (n) => {
        var s;
        this._itemsRunTimeInfo.addItemsOrExtendFrom(n.component._itemsRunTimeInfo), (s = t.onContentReady) === null || s === void 0 || s.call(t, n);
      },
      onDisposing: (n) => {
        let {
          component: s
        } = n;
        const o = s.getItemsRunTimeInfo();
        this._itemsRunTimeInfo.removeItemsByItems(o);
      },
      onFieldItemRendered: () => {
        var n;
        (n = this._validationSummary) === null || n === void 0 || n.refreshValidationGroup();
      }
    });
  }
  _renderLayoutManager(e, t) {
    const n = {
      lg: t.colCount,
      md: t.colCount,
      sm: t.colCount,
      xs: 1
    };
    this._cachedColCountOptions.push({
      colCountByScreen: x(n, t.colCountByScreen)
    });
    const s = p("<div>");
    s.appendTo(e);
    const o = this._createComponent(s, "dxLayoutManager", t);
    return o.on("autoColCountChanged", () => {
      this._clearAutoColCountChangedTimeout(), this.autoColCountChangedTimeoutId = setTimeout(() => !this._disposed && this._refresh(), 0);
    }), this._cachedLayoutManagers.push(o), o;
  }
  _getValidationGroup() {
    return this.option("validationGroup") || this;
  }
  _createComponent(e, t, n) {
    return n = n || {}, this._extendConfig(n, {
      readOnly: this.option("readOnly")
    }), super._createComponent(e, t, n);
  }
  _attachSyncSubscriptions() {
    const e = this;
    e.on("optionChanged", (t) => {
      const n = t.fullName;
      n === "formData" && (f(t.value) || e._options.silent("formData", t.value = {}), e._triggerOnFieldDataChangedByDataSet(t.value)), e._cachedLayoutManagers.length && y(e._cachedLayoutManagers, (s, o) => {
        n === "formData" && (e._isDataUpdating = !0, o.option("layoutData", t.value), e._isDataUpdating = !1), (t.name === "readOnly" || t.name === "disabled") && o.option(n, t.value);
      });
    });
  }
  _optionChanged(e) {
    const t = e.fullName.split(".");
    t.length > 1 && t[0].search("items") !== -1 && this._itemsOptionChangedHandler(e) || t.length > 1 && t[0].search("formData") !== -1 && this._formDataOptionChangedHandler(e) || this._defaultOptionChangedHandler(e);
  }
  _defaultOptionChangedHandler(e) {
    switch (e.name) {
      case "formData":
        this.option("items") ? en(e.value) && this._clear() : this._invalidate();
        break;
      case "onFieldDataChanged":
      case "alignRootItemLabels":
      case "readOnly":
      case "isDirty":
        break;
      case "items":
      case "colCount":
      case "onEditorEnterKey":
      case "labelLocation":
      case "labelMode":
      case "alignItemLabels":
      case "showColonAfterLabel":
      case "customizeItem":
      case "alignItemLabelsInAllGroups":
      case "showRequiredMark":
      case "showOptionalMark":
      case "requiredMark":
      case "optionalMark":
      case "requiredMessage":
      case "scrollingEnabled":
      case "formID":
      case "colCountByScreen":
      case "screenByWidth":
      case "stylingMode":
        this._invalidate();
        break;
      case "showValidationSummary":
        this._renderValidationSummary();
        break;
      case "minColWidth": {
        const {
          colCount: t
        } = this.option();
        t === "auto" && this._invalidate();
        break;
      }
      case "width":
        super._optionChanged(e), this._rootLayoutManager.option(e.name, e.value), this._alignLabels(this._rootLayoutManager, this._rootLayoutManager.isSingleColumnMode());
        break;
      case "validationGroup":
        Ve.removeGroup(e.previousValue || this), this._invalidate();
        break;
      default:
        super._optionChanged(e);
    }
  }
  _itemsOptionChangedHandler(e) {
    const t = e.fullName.split("."), {
      value: n
    } = e, s = this._getItemPath(t), o = this.option(s), r = e.fullName.replace(`${s}.`, ""), a = r.split(".")[0].replace(/\[\d+]/, ""), l = this._tryCreateItemOptionAction(a, o, o[a], e.previousValue, s);
    let d = this._tryExecuteItemOptionAction(l) || this._tryChangeLayoutManagerItemOption(e.fullName, n);
    if (!d && o) {
      this._changeItemOption(o, r, n);
      const u = this._generateItemsFromData(this.option("items"));
      this.option("items", u), d = !0;
    }
    return d;
  }
  _formDataOptionChangedHandler(e) {
    const t = e.fullName.split("."), {
      value: n
    } = e, s = t.slice(1).join("."), o = this.getEditor(s);
    return o ? o.option("value", n) : this._triggerOnFieldDataChanged({
      dataField: s,
      value: n
    }), !0;
  }
  _tryCreateItemOptionAction(e, t, n, s, o) {
    return e === "tabs" && (this._itemsRunTimeInfo.removeItemsByPathStartWith(`${o}.tabs`), n = this._prepareItems(n, !0, o, !0)), dZ(e, {
      item: t,
      value: n,
      previousValue: s,
      itemsRunTimeInfo: this._itemsRunTimeInfo
    });
  }
  _tryExecuteItemOptionAction(e) {
    return e?.tryExecute();
  }
  _updateValidationGroupAndSummaryIfNeeded(e) {
    const t = g0(e);
    if (uZ.includes(t) && (Ve.addGroup(this._getValidationGroup(), !1), this.option("showValidationSummary"))) {
      var n;
      (n = this._validationSummary) === null || n === void 0 || n.refreshValidationGroup();
    }
  }
  _setLayoutManagerItemOption(e, t, n, s) {
    if (this._updateLockCount > 0) {
      !e._updateLockCount && e.beginUpdate();
      const r = this._itemsRunTimeInfo.findKeyByPath(s);
      this.postponedOperations.add(r, () => (!e._disposed && e.endUpdate(), w().resolve()));
    }
    const o = (r) => {
      if (r.component.off("contentReady", o), aR(s)) {
        const a = tZ(s), l = this._itemsRunTimeInfo.findGroupOrTabLayoutManagerByPath(a);
        l && this._alignLabelsInColumn({
          items: l.option("items"),
          layoutManager: l,
          $container: l.$element(),
          inOneColumn: l.isSingleColumnMode()
        });
      } else
        this._alignLabels(this._rootLayoutManager, this._rootLayoutManager.isSingleColumnMode());
    };
    e.on("contentReady", o), e.option(t, n), this._updateValidationGroupAndSummaryIfNeeded(t);
  }
  _tryChangeLayoutManagerItemOption(e, t) {
    const n = e.split("."), s = g0(e);
    if (s === "items" && n.length > 1) {
      const o = this._getItemPath(n), r = this._itemsRunTimeInfo.findGroupOrTabLayoutManagerByPath(o);
      if (r) {
        this._itemsRunTimeInfo.removeItemsByItems(r.getItemsRunTimeInfo());
        const a = this._prepareItems(t, !1, o);
        return this._setLayoutManagerItemOption(r, s, a, o), !0;
      }
    } else if (n.length > 2) {
      const o = n.length - 2, r = this._getItemPath(n.slice(0, o)), a = this._itemsRunTimeInfo.findGroupOrTabLayoutManagerByPath(r);
      if (a) {
        const l = Xa(n[o], s);
        if (s === "editorType" && a.option(l) !== t)
          return !1;
        if (s === "visible") {
          const d = this.option(Xa(r, "items"));
          if (d != null && d.length) {
            const u = a.option("items");
            d.forEach((c, h) => {
              const g = u[h];
              g.visibleIndex = c.visibleIndex;
            });
          }
        }
        return this._setLayoutManagerItemOption(a, l, t, r), !0;
      }
    }
    return !1;
  }
  _tryChangeLayoutManagerItemOptions(e, t) {
    let n;
    return this.beginUpdate(), y(t, (s, o) => {
      if (n = this._tryChangeLayoutManagerItemOption(Xa(e, s), o), !n)
        return !1;
    }), this.endUpdate(), n;
  }
  _getItemPath(e) {
    let t = e[0], n;
    for (n = 1; n < e.length && e[n].search(/items\[\d+]|tabs\[\d+]/) !== -1; n++)
      t += `.${e[n]}`;
    return t;
  }
  _triggerOnFieldDataChanged(e) {
    this._updateIsDirty(e.dataField), this._createActionByOption("onFieldDataChanged")(e);
  }
  _triggerOnFieldDataChangedByDataSet(e) {
    e && X(e) && Object.keys(e).forEach((t) => {
      this._triggerOnFieldDataChanged({
        dataField: t,
        value: e[t]
      });
    });
  }
  _updateFieldValue(e, t) {
    if (f(this.option("formData"))) {
      const n = this.getEditor(e);
      this.option(`formData.${e}`, t), n && n.option("value") !== t && n.option("value", t);
    }
  }
  _generateItemsFromData(e) {
    const t = this.option("formData"), n = [];
    return !e && f(t) && y(t, (s) => {
      n.push({
        dataField: s
      });
    }), e && y(e, (s, o) => {
      X(o) ? n.push(o) : n.push({
        dataField: o
      });
    }), n;
  }
  _getItemByField(e, t) {
    const n = this, s = X(e) ? e : n._getFieldParts(e), {
      fieldName: o
    } = s, {
      fieldPath: r
    } = s;
    let a;
    return t.length && y(t, (l, d) => {
      const {
        itemType: u
      } = d;
      if (r.length) {
        const c = r.slice();
        d = n._getItemByFieldPath(c, o, d);
      } else if (u === "group" && !(d.caption || d.name) || u === "tabbed" && !d.name) {
        const c = n._getSubItemField(u);
        d.items = n._generateItemsFromData(d.items), d = n._getItemByField({
          fieldName: o,
          fieldPath: r
        }, d[c]);
      }
      if (eZ(d, o))
        return a = d, !1;
    }), a;
  }
  _getFieldParts(e) {
    let t = e, n = t.indexOf(".");
    const s = [];
    for (; n !== -1; )
      s.push(t.substr(0, n)), t = t.substr(n + 1), n = t.indexOf(".");
    return {
      fieldName: t,
      fieldPath: s.reverse()
    };
  }
  _getItemByFieldPath(e, t, n) {
    const s = this, {
      itemType: o
    } = n, r = s._getSubItemField(o), a = o === "group" || o === "tabbed" || n.title;
    let l;
    do
      if (a) {
        const d = n.name || n.caption || n.title, u = f(d), c = Um(d);
        let h;
        if (n[r] = s._generateItemsFromData(n[r]), u && (h = e.pop()), !e.length && (l = s._getItemByField(t, n[r]), l))
          break;
        (!u || u && c === h) && e.length && (l = s._searchItemInEverySubItem(e, t, n[r]));
      } else
        break;
    while (e.length && !f(l));
    return l;
  }
  _getSubItemField(e) {
    return e === "tabbed" ? "tabs" : "items";
  }
  _searchItemInEverySubItem(e, t, n) {
    const s = this;
    let o;
    return y(n, (r, a) => {
      if (o = s._getItemByFieldPath(e.slice(), t, a), o)
        return !1;
    }), o || (o = !1), o;
  }
  _changeItemOption(e, t, n) {
    X(e) && (e[t] = n);
  }
  _dimensionChanged() {
    const e = this._getCurrentScreenFactor();
    this._lastMarkupScreenFactor !== e && (this._isColCountChanged(this._lastMarkupScreenFactor, e) && (this._targetScreenFactor = e, this._refresh(), this._targetScreenFactor = void 0), this._lastMarkupScreenFactor = e);
  }
  _isColCountChanged(e, t) {
    let n = !1;
    return y(this._cachedColCountOptions, (s, o) => {
      if (o.colCountByScreen[e] !== o.colCountByScreen[t])
        return n = !0, !1;
    }), n;
  }
  _refresh() {
    const e = `.${g3}.${dj}:not(.${r9}) .${m3}`;
    _.trigger(this.$element().find(e), "change"), super._refresh();
  }
  _updateIsDirty(e) {
    const t = this.getEditor(e);
    t && (t.option("isDirty") ? this._dirtyFields.add(e) : this._dirtyFields.delete(e), this.option("isDirty", !!this._dirtyFields.size));
  }
  updateRunTimeInfoForEachEditor(e) {
    this._itemsRunTimeInfo.each((t, n) => {
      const {
        widgetInstance: s
      } = n;
      f(s) && ci.isEditor(s) && e(s);
    });
  }
  _clear() {
    this.updateRunTimeInfoForEachEditor((e) => {
      e.clear(), e.option("isValid", !0);
    }), Ve.resetGroup(this._getValidationGroup());
  }
  _updateData(e, t, n) {
    const s = this, o = n ? t : e;
    X(o) ? y(o, (r, a) => {
      s._updateData(n ? `${e}.${r}` : r, a, X(a));
    }) : te(e) && s._updateFieldValue(e, t);
  }
  registerKeyHandler(e, t) {
    super.registerKeyHandler(e, t), this._itemsRunTimeInfo.each((n, s) => {
      f(s.widgetInstance) && s.widgetInstance.registerKeyHandler(e, t);
    });
  }
  _focusTarget() {
    return this.$element().find(`.${zm} [tabindex]`).first();
  }
  _visibilityChanged() {
    this._alignLabels(this._rootLayoutManager, this._rootLayoutManager.isSingleColumnMode());
  }
  _clearAutoColCountChangedTimeout() {
    this.autoColCountChangedTimeoutId && (clearTimeout(this.autoColCountChangedTimeoutId), this.autoColCountChangedTimeoutId = void 0);
  }
  _dispose() {
    this._clearAutoColCountChangedTimeout(), Ve.removeGroup(this._getValidationGroup()), super._dispose();
  }
  clear() {
    this._clear();
  }
  resetValues() {
    this._clear();
  }
  reset(e) {
    this.updateRunTimeInfoForEachEditor((t) => {
      const n = t.option("name");
      e && n in e ? (t.reset(e[n]), this._updateIsDirty(n)) : t.reset();
    }), this._renderValidationSummary();
  }
  updateData(e, t) {
    this._updateData(e, t);
  }
  getEditor(e) {
    return this._itemsRunTimeInfo.findWidgetInstanceByDataField(e) || this._itemsRunTimeInfo.findWidgetInstanceByName(e);
  }
  getButton(e) {
    return this._itemsRunTimeInfo.findWidgetInstanceByName(e);
  }
  updateDimensions() {
    const e = this, t = w();
    return e._scrollable ? e._scrollable.update().done(() => {
      t.resolveWith(e);
    }) : t.resolveWith(e), t.promise();
  }
  itemOption(e, t, n) {
    const s = this._generateItemsFromData(this.option("items")), o = this._getItemByField(e, s), r = lR(s, o);
    if (o)
      switch (arguments.length) {
        case 1:
          return o;
        case 3: {
          const a = this._tryCreateItemOptionAction(t, o, n, o[t], r);
          this._changeItemOption(o, t, n);
          const l = Xa(r, t);
          !this._tryExecuteItemOptionAction(a) && !this._tryChangeLayoutManagerItemOption(l, n) && this.option("items", s);
          break;
        }
        default:
          if (X(t) && !this._tryChangeLayoutManagerItemOptions(r, t)) {
            let a;
            y(t, (l, d) => {
              const u = this._tryCreateItemOptionAction(l, o, d, o[l], r);
              this._changeItemOption(o, l, d), !a && !this._tryExecuteItemOptionAction(u) && (a = !0);
            }), a && this.option("items", s);
          }
      }
  }
  validate() {
    return Ve.validateGroup(this._getValidationGroup());
  }
  getItemID(e) {
    const {
      formID: t
    } = this.option();
    return `dx_${t}_${e || new Xe()}`;
  }
  getTargetScreenFactor() {
    return this._targetScreenFactor;
  }
}
xe("dxForm", Eh);
const cZ = (i) => class extends i {
  init() {
    this._editForm = null, this._updateEditFormDeferred = null, super.init();
  }
  isEditRow(e) {
    return !this.isPopupEditMode() && super.isEditRow(e);
  }
  isFormOrPopupEditMode() {
    return this.isPopupEditMode() || this.isFormEditMode();
  }
  isFormEditMode() {
    return this.option("editing.mode") === xC;
  }
  getFirstEditableColumnIndex() {
    const e = this._firstFormItem;
    if (this.isFormEditMode() && e) {
      const t = this.option(Sn), n = this._dataController.getRowIndexByKey(t), s = this._rowsView.getCellElements(n);
      return this._rowsView._getEditFormEditorVisibleIndex(s, e.column);
    }
    return super.getFirstEditableColumnIndex();
  }
  getEditFormRowIndex() {
    return this.isFormOrPopupEditMode() ? this._getVisibleEditRowIndex() : super.getEditFormRowIndex();
  }
  _isEditColumnVisible() {
    const e = super._isEditColumnVisible(), t = this.option("editing");
    return this.isFormOrPopupEditMode() && t.allowUpdating || e;
  }
  _handleDataChanged(e) {
    if (this.isPopupEditMode()) {
      var t, n;
      const s = this.option("editing.editRowKey"), o = e == null || (t = e.items) === null || t === void 0 ? void 0 : t.some((a) => He(a.key, s)), r = ((n = e.changeTypes) === null || n === void 0 ? void 0 : n.length) && e.changeTypes.every((a) => a === "insert");
      (e.changeType === "refresh" || o && e.isOptionChanged) && !r && this._repaintEditPopup();
    }
    super._handleDataChanged(e);
  }
  getPopupContent() {
    var e;
    const t = (e = this._editPopup) === null || e === void 0 ? void 0 : e.option("visible");
    if (this.isPopupEditMode() && t)
      return this._$popupContent;
  }
  _showAddedRow(e) {
    this.isPopupEditMode() ? this._showEditPopup(e) : super._showAddedRow(e);
  }
  _cancelEditDataCore() {
    super._cancelEditDataCore(), this.isPopupEditMode() && this._hideEditPopup();
  }
  _updateEditRowCore(e, t, n) {
    const s = this._editForm;
    if (this.isPopupEditMode())
      if (this.option("repaintChangesOnly")) {
        var o;
        (o = e.update) === null || o === void 0 || o.call(e, e), this._rowsView.renderDelayedTemplates();
      } else
        s && (this._updateEditFormDeferred = new w().done(() => s.repaint()), this._updateLockCount || this._updateEditFormDeferred.resolve());
    else
      super._updateEditRowCore(e, t, n);
  }
  _showEditPopup(e, t) {
    const n = z.current().deviceType !== "desktop", s = this.addWidgetPrefix(GX), o = x({
      showTitle: !1,
      fullScreen: n,
      wrapperAttr: {
        class: s
      },
      toolbarItems: [{
        toolbar: "bottom",
        location: "after",
        widget: "dxButton",
        options: this._getSaveButtonConfig()
      }, {
        toolbar: "bottom",
        location: "after",
        widget: "dxButton",
        options: this._getCancelButtonConfig()
      }],
      contentTemplate: this._getPopupEditFormTemplate(e)
    }, this.option(Pu));
    if (!this._editPopup) {
      const r = p("<div>").appendTo(this.component.$element()).addClass(s);
      this._editPopup = this._createComponent(r, pi), this._editPopup.on("hiding", this._getEditPopupHiddenHandler()), this._editPopup.on("shown", (a) => {
        if (_.trigger(a.component.$content().find(vC).not(`.${jX}`).first(), "focus"), t) {
          var l;
          (l = this._editForm) === null || l === void 0 || l.repaint();
        }
      });
    }
    this._editPopup.option(o), this._editPopup.show(), super._showEditPopup(e, t);
  }
  _getPopupEditFormTemplate(e) {
    const t = this.component.getVisibleRows()[e], n = {
      row: t,
      values: t.values,
      rowType: t.rowType,
      key: t.key,
      rowIndex: e
    };
    return this._rowsView._addWatchMethod(n, t), (s) => {
      const o = this.getEditFormTemplate(), r = this._createComponent(p("<div>").appendTo(s), Qt);
      this._$popupContent = p(r.content()), o(this._$popupContent, n, {
        isPopupForm: !0
      }), this._rowsView.renderDelayedTemplates(), p(s).parent().attr("aria-label", this.localize("dxDataGrid-ariaEditForm"));
    };
  }
  _repaintEditPopup() {
    const e = this._getVisibleEditRowIndex();
    if (e >= 0) {
      var t, n;
      const s = (t = this._editPopup) === null || t === void 0 ? void 0 : t.option("animation");
      (n = this._editPopup) === null || n === void 0 || n.option("animation", null), this._showEditPopup(e, !0), s !== void 0 && this._editPopup.option("animation", s);
    }
  }
  _hideEditPopup() {
    var e;
    (e = this._editPopup) === null || e === void 0 || e.option("visible", !1);
  }
  optionChanged(e) {
    if (e.name === "editing" && this.isFormOrPopupEditMode()) {
      const {
        fullName: t
      } = e;
      t.indexOf(Gp) === 0 ? (this._handleFormOptionChange(e), e.handled = !0) : t.indexOf(Pu) === 0 && (this._handlePopupOptionChange(e), e.handled = !0);
    }
    super.optionChanged(e);
  }
  _handleFormOptionChange(e) {
    var t;
    if (this.isFormEditMode()) {
      const n = this._getVisibleEditRowIndex();
      n >= 0 && this._dataController.updateItems({
        changeType: "update",
        rowIndices: [n]
      });
    } else
      (t = this._editPopup) !== null && t !== void 0 && t.option("visible") && e.fullName.indexOf(Gp) === 0 && this._repaintEditPopup();
  }
  _handlePopupOptionChange(e) {
    const t = this._editPopup;
    if (t) {
      const n = e.fullName.slice(Pu.length + 1);
      n ? t.option(n, e.value) : t.option(e.value);
    }
  }
  renderFormEditorTemplate(e, t, n, s, o) {
    const r = this, a = p(s), {
      column: l
    } = t, d = e8(t), u = e?.row, c = u?.data, h = n.component, g = l.calculateCellValue(c), m = F.getDisplayValue(l, g, c, u?.rowType), {
      label: C,
      labelMark: v,
      labelMode: E
    } = n.editorOptions || {}, T = x({}, e, {
      data: c,
      cellElement: null,
      isOnForm: !0,
      item: t,
      id: h.getItemID(t.name || t.dataField),
      column: x({}, l, {
        editorType: d,
        editorOptions: x({
          label: C,
          labelMark: v,
          labelMode: E
        }, l.editorOptions, t.editorOptions)
      }),
      columnIndex: l.index,
      setValue: !o && l.allowEditing && function($, G) {
        r.updateFieldValue(T, $, G);
      }
    });
    T.value = g, T.displayValue = m, T.text = l.command ? "" : F.formatValue(m, l);
    const V = this._getFormEditItemTemplate.bind(this)(T, l);
    return this._rowsView.renderTemplate(a, V, T, !!pa(a)).done(() => {
      this._rowsView._updateCell(a, T);
    }), T;
  }
  getFormEditorTemplate(e, t) {
    const n = this.component.columnOption(t.name || t.dataField);
    return (s, o) => {
      const r = p(o), {
        row: a
      } = e;
      if (a != null && a.watch) {
        const l = a.watch(() => n.selector(a.data), () => {
          var d;
          let u = r.find(".dx-widget").first(), c = u.data("dxValidator");
          const h = (d = c) === null || d === void 0 ? void 0 : d.option();
          r.contents().remove(), e = this.renderFormEditorTemplate.bind(this)(e, t, s, r), u = r.find(".dx-widget").first(), c = u.data("dxValidator"), h && !c && u.dxValidator({
            validationRules: h.validationRules,
            validationGroup: h.validationGroup,
            dataGetter: h.dataGetter
          });
        });
        _.on(r, On, l);
      }
      e = this.renderFormEditorTemplate.bind(this)(e, t, s, r);
    };
  }
  getEditFormOptions(e) {
    var t;
    const n = (t = this._getValidationGroupsInForm) === null || t === void 0 ? void 0 : t.call(this, e), s = this.option("editing.form.customizeItem"), o = this.addWidgetPrefix(GA);
    let r = this.option("editing.form.items");
    const a = {};
    if (r)
      qA(r, (l) => {
        const d = l?.name || l?.dataField;
        d && (a[d] = !!l.editorType);
      });
    else {
      const l = this._columnsController.getColumns();
      r = [], y(l, (d, u) => {
        !u.isBand && !u.type && r.push({
          column: u,
          name: u.name,
          dataField: u.dataField
        });
      });
    }
    return x({}, n, {
      items: r,
      formID: `dx-${new Xe()}`,
      customizeItem: (l) => {
        let d;
        const u = l.name || l.dataField;
        if ((l.column || u) && (d = l.column || this._columnsController.columnOption(l.name ? `name:${l.name}` : `dataField:${l.dataField}`)), d) {
          if (l.label = l.label || {}, l.label.text = l.label.text || d.caption, d.dataType === "boolean" && l.label.visible === void 0) {
            const h = this.option("editing.form.labelMode");
            (h === "floating" || h === "static") && (l.label.visible = !0);
          }
          l.template = l.template || this.getFormEditorTemplate(e, l), l.column = d, l.isCustomEditorType = a[u], d.formItem && x(l, d.formItem), l.isRequired === void 0 && d.validationRules && (l.isRequired = d.validationRules.some((h) => h.type === "required"), l.validationRules = []);
          const c = f(l.visible) ? l.visible : !0;
          !this._firstFormItem && c && (this._firstFormItem = l);
        }
        s?.call(this, l), l.cssClass = te(l.cssClass) ? `${l.cssClass} ${o}` : o;
      }
    });
  }
  getEditFormTemplate() {
    return (e, t, n) => {
      const s = this.option(Gp), o = this.getEditFormOptions(t), r = p("<div>").appendTo(e), a = n?.isPopupForm;
      if (this._firstFormItem = void 0, a && r.addClass(this.addWidgetPrefix(UX)), this._editForm = this._createComponent(r, Eh, x({}, s, o)), !a) {
        const l = p("<div>").addClass(this.addWidgetPrefix(YX)).appendTo(e);
        this._createComponent(p("<div>").appendTo(l), wt, this._getSaveButtonConfig()), this._createComponent(p("<div>").appendTo(l), wt, this._getCancelButtonConfig());
      }
      this._editForm.on("contentReady", () => {
        var l;
        this._rowsView.renderDelayedTemplates(), (l = this._editPopup) === null || l === void 0 || l.repaint();
      });
    };
  }
  getEditForm() {
    return this._editForm;
  }
  _endUpdateCore() {
    var e;
    (e = this._updateEditFormDeferred) === null || e === void 0 || e.resolve();
  }
  _beforeEndSaving(e) {
    if (super._beforeEndSaving(e), this.isPopupEditMode()) {
      var t;
      (t = this._editPopup) === null || t === void 0 || t.hide();
    }
  }
  _processDataItemCore(e, t, n, s, o) {
    const {
      type: r
    } = t;
    this.isPopupEditMode() && r === Jn && (e.visible = !1), super._processDataItemCore(e, t, n, s, o);
  }
  _editRowFromOptionChangedCore(e, t) {
    const n = this.isPopupEditMode();
    super._editRowFromOptionChangedCore(e, t, n), n && this._showEditPopup(t);
  }
}, hZ = (i) => class extends i {
  _updateEditItem(e) {
    this._editingController.isFormEditMode() && (e.rowType = "detail");
  }
  _getChangedColumnIndices(e, t, n, s) {
    if (!(s === !1 && t.isEditing && this._editingController.isFormEditMode()))
      return super._getChangedColumnIndices.apply(this, arguments);
  }
}, pZ = (i) => class extends i {
  _renderCellContent(e, t) {
    t.rowType === "data" && this._editingController.isPopupEditMode() && t.row.visible === !1 || super._renderCellContent.apply(this, arguments);
  }
  getCellElements(e) {
    const t = super.getCellElements(e), n = this._editingController, s = n.getEditForm();
    return n.getEditFormRowIndex() === e && t && s ? s.$element().find(`.${this.addWidgetPrefix(GA)}, .${qX}`) : t;
  }
  _getVisibleColumnIndex(e, t, n) {
    if (this._editingController.getEditFormRowIndex() === t && te(n)) {
      const o = this._columnsController.columnOption(n);
      return this._getEditFormEditorVisibleIndex(e, o);
    }
    return super._getVisibleColumnIndex.apply(this, arguments);
  }
  _getEditFormEditorVisibleIndex(e, t) {
    let n = -1;
    return y(e, (s, o) => {
      const r = p(o).find(".dx-field-item-content").data("dx-form-item");
      if (r != null && r.column && t && r.column.index === t.index)
        return n = s, !1;
    }), n;
  }
  _isFormItem(e) {
    const t = e.rowType === "detail" || e.rowType === "detailAdaptive", n = e.rowType === "data" && this._editingController.isPopupEditMode();
    return (t || n) && e.item;
  }
  _updateCell(e, t) {
    this._isFormItem(t) ? this._formItemPrepared(t, e) : super._updateCell(e, t);
  }
  _updateContent() {
    const e = this._editingController, t = e.getEditForm(), n = t?.option("validationGroup");
    return super._updateContent.apply(this, arguments).done(() => {
      const o = e.getEditForm();
      n && o && o !== t && o.option("validationGroup", n);
    });
  }
}, gZ = {
  extenders: {
    controllers: {
      editing: cZ,
      data: hZ
    },
    views: {
      rowsView: pZ
    }
  }
};
J.registerModule("editingFormBased", gZ);
const mZ = (i) => class extends i {
  init() {
    const e = !this._saveEditorHandler;
    if (super.init(), e) {
      let t, n;
      this._pointerUpEditorHandler = () => {
        var s;
        n = (s = this._columnsResizerController) === null || s === void 0 ? void 0 : s.isResizing();
      }, this._pointerDownEditorHandler = (s) => t = p(s.target), this._saveEditorHandler = this.createAction(function(s) {
        const {
          event: o
        } = s, r = p(o.target), a = o[zA], {
          component: l
        } = this;
        if (JX(t) && !t.is(r))
          return;
        function d(u) {
          if (!u)
            return !1;
          const c = u.closest(`.${LX}`), h = l.$element();
          return c.length > 0 && h.closest(c).length === 0;
        }
        if (this.isCellOrBatchEditMode() && !this._editCellInProgress) {
          const u = d(r) || d(a?.$element()), c = a && !a._disposed && a !== this.component, h = !!r.closest(`.${this.addWidgetPrefix(NX)}`).length, g = r.hasClass(this.addWidgetPrefix($X)), m = this.isCellEditMode();
          !n && !u && !g && !(h && m && this.isEditing()) && (pa(r) || c) && this._closeEditItem.bind(this)(r);
        }
      }), _.on(O.getDocument(), ye.up, this._pointerUpEditorHandler), _.on(O.getDocument(), ye.down, this._pointerDownEditorHandler), _.on(O.getDocument(), Te, this._saveEditorHandler);
    }
  }
  isCellEditMode() {
    return this.option("editing.mode") === Wm;
  }
  isBatchEditMode() {
    return this.option("editing.mode") === Hm;
  }
  isCellOrBatchEditMode() {
    return this.isCellEditMode() || this.isBatchEditMode();
  }
  _needToCloseEditableCell(e) {
    const t = this.component.$element();
    let n = this.isEditing();
    if ((!t || !!e.closest(t).length) && e.closest(`.${HX}`).length) {
      const a = e.closest(`.${Fs}> td`), l = this._rowsView.getRowIndex(a.parent()), d = this._rowsView.getCellElements(l);
      if (d != null && d.length) {
        var o;
        const u = d.index(a), h = (o = this._columnsController.getVisibleColumns()[u]) === null || o === void 0 ? void 0 : o.allowEditing, g = this.isEditCell(l, u);
        n = n && !h && !g;
      }
    }
    return n || super._needToCloseEditableCell(e);
  }
  _closeEditItem(e) {
    this._needToCloseEditableCell(e) && this.closeEditCell();
  }
  _focusEditorIfNeed() {
    if (this._needFocusEditor && this.isCellOrBatchEditMode()) {
      var e;
      const t = this._getVisibleEditColumnIndex(), n = (e = this._rowsView) === null || e === void 0 ? void 0 : e._getCellElement(this._getVisibleEditRowIndex(), t);
      this._refocusEditCell = !1, clearTimeout(this._inputFocusTimeoutID), n && !n.find(":focus").length ? this._focusEditingCell(() => {
        this._editCellInProgress = !1;
      }, n, !0) : this._editCellInProgress = !1, this._needFocusEditor = !1;
    } else
      super._focusEditorIfNeed();
  }
  isEditing() {
    if (this.isCellOrBatchEditMode()) {
      const e = f(this.option(Sn)), t = f(this.option(Do));
      return e && t;
    }
    return super.isEditing();
  }
  _handleEditColumnNameChange(e) {
    const t = this._getVisibleEditRowIndex(e.previousValue);
    if (this.isCellOrBatchEditMode() && t !== -1 && f(e.value) && e.value !== e.previousValue) {
      const n = this._columnsController.getVisibleColumnIndex(e.value), s = this._columnsController.getVisibleColumnIndex(e.previousValue);
      this._editCellFromOptionChanged(n, s, t);
    }
  }
  _addRow(e) {
    if (this.isCellEditMode() && this.hasChanges()) {
      const t = new w();
      return this.saveEditData().done(() => {
        this.hasChanges() ? t.reject("cancel") : this.addRow(e).done(t.resolve).fail(t.reject);
      }), t.promise();
    }
    return super._addRow(e);
  }
  editCell(e, t) {
    return this._editCell({
      rowIndex: e,
      columnIndex: t
    });
  }
  _editCell(e) {
    const t = new w();
    let n;
    return this.executeOperation(t, () => {
      n = this._editCellCore(e), W(n).done(t.resolve).fail(t.reject);
    }), n !== void 0 ? n : t.promise();
  }
  _editCellCore(e) {
    const t = this._dataController, n = f(e.oldColumnIndex) || f(e.oldRowIndex), {
      columnIndex: s,
      rowIndex: o,
      column: r,
      item: a
    } = this._getNormalizedEditCellOptions(e), l = {
      data: a?.data,
      cancel: !1,
      column: r
    };
    if (a.key === void 0) {
      this._dataController.fireError("E1043");
      return;
    }
    if (r && (a.rowType === "data" || a.rowType === "detailAdaptive") && !a.removed && this.isCellOrBatchEditMode()) {
      if (!n && this.isEditCell(o, s))
        return !0;
      const d = o + t.getRowIndexOffset();
      return W(this._beforeEditCell(o, s, a)).done((u) => {
        u || this._prepareEditCell(l, a, s, d) || this._processCanceledEditingCell();
      });
    }
    return !1;
  }
  _beforeEditCell(e, t, n) {
    if (this.isCellEditMode() && !n.isNewRow && this.hasChanges()) {
      const s = new w();
      return this.saveEditData().always(() => {
        s.resolve(this.hasChanges());
      }), this.addDeferred(s), s;
    }
    return !1;
  }
  publicMethods() {
    return super.publicMethods().concat(["editCell", "closeEditCell"]);
  }
  _getNormalizedEditCellOptions(e) {
    let {
      oldColumnIndex: t,
      oldRowIndex: n,
      columnIndex: s,
      rowIndex: o
    } = e;
    const r = this._columnsController, a = r.getVisibleColumns(), d = this._dataController.items()[o];
    let u;
    f(t) ? u = a[t] : u = this._getEditColumn(), f(n) || (n = this._getVisibleEditRowIndex()), te(s) && (s = r.columnOption(s, "index"), s = r.getVisibleIndex(s));
    const c = a[s];
    return {
      oldColumn: u,
      columnIndex: s,
      oldRowIndex: n,
      rowIndex: o,
      column: c,
      item: d
    };
  }
  _prepareEditCell(e, t, n, s) {
    return t.isNewRow || (e.key = t.key), this._isEditingStart(e) ? !1 : (this._pageIndex = this._dataController.pageIndex(), this._setEditRowKey(t.key), this._setEditColumnNameByIndex(n), e.column.showEditorAlways || this._addInternalData({
      key: t.key,
      oldData: t.oldData ?? t.data
    }), !0);
  }
  closeEditCell(e, t) {
    let n = W();
    const s = this._getVisibleEditRowIndex();
    if (this.isCellOrBatchEditMode()) {
      const o = new w();
      n = new w(), this.executeOperation(o, () => {
        this._closeEditCellCore(e, s, t).always(n.resolve);
      });
    }
    return n.promise();
  }
  _closeEditCellCore(e, t, n) {
    const s = this._dataController, o = new w(), r = o.promise();
    if (this.isCellEditMode() && this.hasChanges()) {
      if (!n)
        return this.saveEditData().done((a) => {
          if (!this.hasChanges()) {
            this.closeEditCell(!!a).always(o.resolve);
            return;
          }
          o.resolve();
        }), r;
    } else if (this._resetEditRowKey(), this._resetEditColumnName(), t >= 0) {
      const a = [t];
      this._beforeCloseEditCellInBatchMode(a), e || s.updateItems({
        changeType: "update",
        rowIndices: a
      });
    }
    return o.resolve(), r;
  }
  _resetModifiedClassCells(e) {
    if (this.isBatchEditMode()) {
      const t = this._columnsController.getVisibleColumns().length;
      e.forEach((n) => {
        let {
          key: s
        } = n;
        const o = this._dataController.getRowIndexByKey(s);
        for (let r = 0; r < t; r++) {
          const a = this._rowsView._getCellElement(o, r);
          a?.removeClass(mX);
        }
      });
    }
  }
  _prepareChange(e, t, n) {
    const s = p(e.cellElement);
    return this.isBatchEditMode() && e.key !== void 0 && this._applyModified(s, e), super._prepareChange(e, t, n);
  }
  _cancelSaving(e) {
    const t = this._dataController;
    this.isCellOrBatchEditMode() && (this.isBatchEditMode() && this._resetEditIndices(), t.updateItems()), super._cancelSaving(e);
  }
  optionChanged(e) {
    const {
      fullName: t
    } = e;
    e.name === "editing" && t === Do ? (this._handleEditColumnNameChange(e), e.handled = !0) : super.optionChanged(e);
  }
  _editCellFromOptionChanged(e, t, n) {
    const s = this._columnsController.getVisibleColumns();
    e > -1 && ft(() => {
      this._repaintEditCell(s[e], s[t], n);
    });
  }
  _handleEditRowKeyChange(e) {
    if (this.isCellOrBatchEditMode()) {
      const n = this._getVisibleEditColumnIndex(), s = this._getEditRowIndexCorrection(), o = this._dataController.getRowIndexByKey(e.previousValue) + s;
      if (f(e.value) && e.value !== e.previousValue) {
        var t;
        (t = this._editCellFromOptionChanged) === null || t === void 0 || t.call(this, n, n, o);
      }
    } else
      super._handleEditRowKeyChange(e);
  }
  deleteRow(e) {
    if (this.isCellEditMode() && this.isEditing()) {
      const {
        isNewRow: t
      } = this._dataController.items()[e], n = this._dataController.getKeyByRowIndex(e);
      this.closeEditCell(null, t).always(() => {
        e = this._dataController.getRowIndexByKey(n), this._checkAndDeleteRow(e);
      });
    } else
      super.deleteRow(e);
  }
  _checkAndDeleteRow(e) {
    this.isBatchEditMode() ? this._deleteRowCore(e) : super._checkAndDeleteRow(e);
  }
  _refreshCore(e) {
    const {
      isPageChanged: t
    } = e ?? {}, n = this.isBatchEditMode() || t && this.option("scrolling.mode") !== "virtual";
    this.isCellOrBatchEditMode() ? n && (this._resetEditColumnName(), this._resetEditRowKey()) : super._refreshCore(e);
  }
  _allowRowAdding(e) {
    return this.isBatchEditMode() ? !0 : super._allowRowAdding(e);
  }
  _afterDeleteRow(e, t) {
    const n = this._dataController;
    return this.isBatchEditMode() ? (n.updateItems({
      changeType: "update",
      rowIndices: [t, e]
    }), new w().resolve()) : super._afterDeleteRow(e, t);
  }
  _updateEditRow(e, t, n) {
    this.isCellOrBatchEditMode() ? this._updateRowImmediately(e, t, n) : super._updateEditRow(e, t, n);
  }
  _isDefaultButtonVisible(e, t) {
    if (this.isCellOrBatchEditMode()) {
      const n = this.isBatchEditMode();
      switch (e.name) {
        case "save":
        case "cancel":
        case "edit":
          return !1;
        case "delete":
          return super._isDefaultButtonVisible(e, t) && (!n || !t.row.removed);
        case "undelete":
          return n && this.allowDeleting(t) && t.row.removed;
        default:
          return super._isDefaultButtonVisible(e, t);
      }
    }
    return super._isDefaultButtonVisible(e, t);
  }
  _isRowDeleteAllowed() {
    return super._isRowDeleteAllowed() || this.isBatchEditMode();
  }
  _beforeEndSaving(e) {
    if (this.isCellEditMode()) {
      var t;
      ((t = e[0]) === null || t === void 0 ? void 0 : t.type) !== "update" && super._beforeEndSaving(e);
    } else
      this.isBatchEditMode() && this._resetModifiedClassCells(e), super._beforeEndSaving(e);
  }
  prepareEditButtons(e) {
    const t = this.option("editing") ?? {}, n = super.prepareEditButtons(e);
    return (t.allowUpdating || t.allowAdding || t.allowDeleting) && this.isBatchEditMode() && (n.push(this.prepareButtonItem(e, "save", "saveEditData", 21)), n.push(this.prepareButtonItem(e, "revert", "cancelEditData", 22))), n;
  }
  _saveEditDataInner() {
    var e;
    const t = this._dataController.getVisibleRows()[this.getEditRowIndex()], n = this._getEditColumn(), s = n?.showEditorAlways, o = this.isCellEditMode() && !(t != null && t.isNewRow);
    let r;
    return o && s && (r = new w(), this.addDeferred(r)), super._saveEditDataInner().always((e = r) === null || e === void 0 ? void 0 : e.resolve);
  }
  _applyChange(e, t, n) {
    const s = this.isCellEditMode() && e.row && !e.row.isNewRow, {
      showEditorAlways: o
    } = e.column, r = e.column.setCellValue !== e.column.defaultSetCellValue;
    if (o && !n && s && this.hasEditData() && !this.isEditCell(e.rowIndex, e.columnIndex)) {
      this._focusEditingCell(), this._updateEditRow(e.row, !0, r);
      return;
    }
    return super._applyChange(e, t, n);
  }
  _applyChangeCore(e, t) {
    const {
      showEditorAlways: n
    } = e.column, s = this.isCellEditMode() && e.row && !e.row.isNewRow;
    if (n && !t) {
      if (s)
        return this._setEditRowKey(e.row.key, !0), this._setEditColumnNameByIndex(e.columnIndex, !0), this.saveEditData();
      if (this.isBatchEditMode())
        return t = this._needUpdateRow(e.column), super._applyChangeCore(e, t);
    }
    return super._applyChangeCore(e, t);
  }
  _processDataItemCore(e, t, n, s, o) {
    const {
      data: r,
      type: a
    } = t;
    this.isBatchEditMode() && a === qi && (e.data = Ns(e.data, r)), super._processDataItemCore(e, t, n, s, o);
  }
  _processRemoveCore(e, t, n) {
    if (!(this.isBatchEditMode() && !n))
      return super._processRemoveCore(e, t, n);
  }
  _processRemoveIfError(e, t) {
    if (!this.isBatchEditMode())
      return super._processRemoveIfError(e, t);
  }
  _beforeFocusElementInRow(e) {
    super._beforeFocusElementInRow(e);
    const t = e >= 0 ? e : 0, n = this.getFirstEditableColumnIndex();
    n >= 0 && this.editCell(t, n);
  }
}, fZ = (i) => class extends i {
  _createTable() {
    const e = super._createTable.apply(this, arguments), t = this._editingController;
    return t.isCellOrBatchEditMode() && this.option("editing.allowUpdating") && _.on(e, R(Zs.name, "dxDataGridRowsView"), `td:not(.${bh})`, this.createAction(() => {
      t.isEditing() && t.closeEditCell();
    })), e;
  }
  _createRow(e) {
    const t = super._createRow.apply(this, arguments);
    if (e) {
      const n = this._editingController, s = !!e.removed;
      n.isBatchEditMode() && s && t.addClass(WX);
    }
    return t;
  }
}, _Z = {
  extenders: {
    controllers: {
      editing: mZ
    },
    views: {
      rowsView: fZ
    }
  }
};
J.registerModule("editingCellBased", _Z);
const f0 = "__DX_INSERT_INDEX__", dR = "row", Mu = "batch", qr = "cell", uR = ["popup", "form"], _n = {
  valid: "valid",
  invalid: "invalid",
  pending: "pending"
}, Za = function(i) {
  return f(i) && i !== "cancel";
}, cR = function(i, e) {
  return i !== void 0 || i === void 0 && e && !e.isNewRow;
};
class CZ extends Ue.Controller {
  constructor() {
    super(...arguments), this._isValidationInProgress = !1, this._disableApplyValidationResults = !1;
  }
  init() {
    this._editingController = this.getController("editing"), this._editorFactoryController = this.getController("editorFactory"), this._columnsController = this.getController("columns"), this.createAction("onRowValidating"), this._validationState || this.initValidationState();
  }
  initValidationState() {
    this._validationState = [], this._validationStateCache = {};
  }
  _rowIsValidated(e) {
    const t = this._getValidationData(e?.key);
    return !!t && !!t.validated;
  }
  _getValidationData(e, t) {
    const n = xn(e), s = X(n);
    let o;
    return s ? o = this._validationState.filter((r) => He(r.key, e))[0] : o = this._validationStateCache[n], !o && t && (o = {
      key: e,
      isValid: !0
    }, this._validationState.push(o), s || (this._validationStateCache[n] = o)), o;
  }
  _getBrokenRules(e, t) {
    let n;
    return t ? n = t.brokenRules || t.brokenRule && [t.brokenRule] : n = e.brokenRules || [], n;
  }
  _rowValidating(e, t) {
    const n = new w(), s = this._editingController.getChangeByKey(e?.key), o = this._getBrokenRules(e, t), r = t ? t.isValid : e.isValid, a = {
      brokenRules: o,
      isValid: r,
      key: s.key,
      newData: s.data,
      oldData: this._editingController._getOldData(s.key),
      promise: null,
      errorText: this.getHiddenValidatorsErrorText(o)
    };
    return this.executeAction("onRowValidating", a), W(It(a.promise)).always(() => {
      e.isValid = a.isValid, e.errorText = a.errorText, n.resolve(a);
    }), n.promise();
  }
  getHiddenValidatorsErrorText(e) {
    const t = [];
    return y(e, (n, s) => {
      const {
        column: o
      } = s, r = o && o.groupIndex !== void 0 && !o.showWhenGrouped, a = o && o.visible;
      !s.validator.$element().parent().length && (!a || r) && t.push(s.message);
    }), t.join(", ");
  }
  validate(e) {
    let t = !0;
    const n = this._editingController, s = new w(), o = [], r = n.getEditMode();
    if (e = e || r === dR, this._isValidationInProgress)
      return s.resolve(!1).promise();
    if (this._isValidationInProgress = !0, e) {
      n.addDeferred(s);
      const a = n.getChanges();
      y(a, (l, d) => {
        let {
          type: u,
          key: c
        } = d;
        if (u !== "remove") {
          const h = this._getValidationData(c, !0), g = this.validateGroup(h);
          o.push(g), g.done((m) => {
            h.validated = !0, t = t && m.isValid;
          });
        }
      });
    } else if (this._currentCellValidator) {
      const a = this.validateGroup(this._currentCellValidator._findGroup());
      o.push(a), a.done((l) => {
        t = l.isValid;
      });
    }
    return W(...o).done(() => {
      this._isValidationInProgress = !1, s.resolve(t);
    }), s.promise();
  }
  validateGroup(e) {
    var t;
    const n = new w(), s = e && Ve.getGroupConfig(e);
    let o;
    return s != null && s.validators.length && (this.resetRowValidationResults(e), o = Ve.validateGroup(e)), W(((t = o) === null || t === void 0 ? void 0 : t.complete) || o).done((r) => {
      W(this._rowValidating(e, r)).done(n.resolve);
    }), n.promise();
  }
  isRowDataModified(e) {
    return !en(e.data);
  }
  updateValidationState(e) {
    const t = this._editingController.getEditMode(), {
      key: n
    } = e, s = this._getValidationData(n, !0);
    if (uR.includes(t))
      s.isValid = !0;
    else {
      if (e.type === "insert" && !this.isRowDataModified(e)) {
        s.isValid = !0;
        return;
      }
      if (this.setDisableApplyValidationResults(!0), Ve.getGroupConfig(s)) {
        const r = Ve.validateGroup(s);
        W(r.complete || r).done((a) => {
          s.isValid = a.isValid, s.brokenRules = a.brokenRules;
        });
      } else
        (!s.brokenRules || !s.brokenRules.length) && (s.isValid = !0);
      this.setDisableApplyValidationResults(!1);
    }
  }
  setValidator(e) {
    this._currentCellValidator = e;
  }
  renderCellPendingIndicator(e) {
    let t = e.find(".dx-pending-indicator");
    if (!t.length) {
      const n = e;
      t = p("<div>").appendTo(n).addClass("dx-pending-indicator"), this._createComponent(t, Dn), e.addClass("dx-validation-pending");
    }
  }
  disposeCellPendingIndicator(e) {
    const t = e.find(".dx-pending-indicator");
    if (t.length) {
      const n = Dn.getInstance(t);
      n && (n.dispose(), n.$element().remove()), e.removeClass("dx-validation-pending");
    }
  }
  validationStatusChanged(e) {
    const {
      validator: t
    } = e, n = t.option("validationGroup"), {
      column: s
    } = t.option("dataGetter")();
    this.updateCellValidationResult({
      rowKey: n.key,
      columnIndex: s.index,
      validationResult: e
    });
  }
  validatorInitialized(e) {
    e.component.on("validating", this.validationStatusChanged.bind(this)), e.component.on("validated", this.validationStatusChanged.bind(this));
  }
  validatorDisposing(e) {
    const t = e.component, n = t.option("validationGroup"), {
      column: s
    } = t.option("dataGetter")(), o = this.getCellValidationResult({
      rowKey: n?.key,
      columnIndex: s.index
    });
    Za(o) && o.status === _n.pending && this.cancelCellValidationResult({
      change: n,
      columnIndex: s.index
    });
  }
  applyValidationResult(e, t) {
    const {
      validator: n
    } = t, s = n.option("validationGroup"), {
      column: o
    } = n.option("dataGetter")();
    if (t.brokenRules && t.brokenRules.forEach((r) => {
      r.columnIndex = o.index, r.column = o;
    }), e) {
      const r = this.getCellValidationResult({
        rowKey: s.key,
        columnIndex: o.index
      }), a = Za(r) && r.disabledPendingId === t.id;
      if (this._disableApplyValidationResults || a)
        return;
      if (t.status === _n.invalid) {
        const d = e.find(":focus");
        qs(d) || (_.trigger(d, "focus"), _.trigger(d, ye.down));
      }
      const l = !o.editCellTemplate && this._editorFactoryController.getEditorInstance(e);
      t.status === _n.pending ? l ? l.option("validationStatus", _n.pending) : this.renderCellPendingIndicator(e) : l ? l.option("validationStatus", _n.valid) : this.disposeCellPendingIndicator(e), e.toggleClass(this.addWidgetPrefix("invalid"), t.status === _n.invalid);
    }
  }
  _syncInternalEditingData(e) {
    var t;
    const n = this._editingController, s = n.getChangeByKey(e.key), o = n._getOldData(e.key), r = (t = e.row) === null || t === void 0 ? void 0 : t.oldData;
    s && r && !o && n._addInternalData({
      key: e.key,
      oldData: r
    });
  }
  createValidator(e, t) {
    const n = this._editingController, {
      column: s
    } = e;
    let {
      showEditorAlways: o
    } = s;
    if (f(s.command) || !s.validationRules || !Array.isArray(s.validationRules) || !s.validationRules.length)
      return;
    let a = n.getIndexByKey(e.key, n.getChanges()) > -1;
    if (!a) {
      if (!o) {
        var l;
        o = (((l = this._columnsController) === null || l === void 0 ? void 0 : l.getVisibleColumns()) || []).some((g) => g.showEditorAlways);
      }
      const u = He(this.option("editing.editRowKey"), e.key), c = n.isCellOrBatchEditMode() && n.allowUpdating({
        row: e.row
      });
      if (a = u || c && o, c && o) {
        var d;
        n._addInternalData({
          key: e.key,
          oldData: ((d = e.row) === null || d === void 0 ? void 0 : d.oldData) ?? e.data
        });
      }
    }
    if (a) {
      if (t && !t.length) {
        _e.log("E1050");
        return;
      }
      this._syncInternalEditingData(e);
      const u = this._getValidationData(e.key, !0), c = () => {
        const m = n.getChangeByKey(u?.key), C = s.calculateCellValue(m?.data || {});
        return C !== void 0 ? C : e.value;
      }, h = t && t.hasClass("dx-widget");
      t && t.addClass(this.addWidgetPrefix("validator"));
      const g = new wh(t || p("<div>"), {
        name: s.caption,
        validationRules: x(!0, [], s.validationRules),
        validationGroup: u,
        adapter: h ? null : {
          getValue: c,
          applyValidationResults: (m) => {
            this.applyValidationResult(t, m);
          }
        },
        dataGetter() {
          const m = u?.key, C = n.getChangeByKey(m), v = n._getOldData(m);
          return {
            data: Ns(v, C?.data),
            column: s
          };
        },
        onInitialized: this.validatorInitialized.bind(this),
        onDisposing: this.validatorDisposing.bind(this)
      });
      if (h) {
        const m = g.option("adapter");
        if (m) {
          const C = m.bypass, v = () => e.row.isNewRow && !this._isValidationInProgress && !n.isCellModified(e);
          m.getValue = c, m.validationRequestsCallbacks = [], m.bypass = () => C.call(m) || v();
        }
      }
      return g;
    }
  }
  setDisableApplyValidationResults(e) {
    this._disableApplyValidationResults = e;
  }
  getDisableApplyValidationResults() {
    return this._disableApplyValidationResults;
  }
  isCurrentValidatorProcessing(e) {
    let {
      rowKey: t,
      columnIndex: n
    } = e;
    return this._currentCellValidator && He(this._currentCellValidator.option("validationGroup").key, t) && this._currentCellValidator.option("dataGetter")().column.index === n;
  }
  validateCell(e) {
    const t = {
      rowKey: e.option("validationGroup").key,
      columnIndex: e.option("dataGetter")().column.index,
      validationResult: null
    };
    let n = this.getCellValidationResult(t);
    const s = Za(n), o = e.option("adapter");
    if (!s)
      n = e.validate();
    else {
      const a = o.getValue();
      He(a, n.value) || (n = e.validate());
    }
    const r = new w();
    return s && n.status === _n.pending && (this.updateCellValidationResult(t), o.applyValidationResults(n)), W(n.complete || n).done((a) => {
      s && o.applyValidationResults(a), r.resolve(a);
    }), r.promise();
  }
  updateCellValidationResult(e) {
    let {
      rowKey: t,
      columnIndex: n,
      validationResult: s
    } = e;
    const o = this._getValidationData(t);
    if (!o)
      return;
    o.validationResults || (o.validationResults = {});
    let r;
    if (s) {
      if (r = x({}, s), o.validationResults[n] = r, s.status === _n.pending && (this._editingController.getEditMode() === qr && (r.deferred = new w(), r.complete.always(() => {
        r.deferred.resolve();
      }), this._editingController.addDeferred(r.deferred)), this._disableApplyValidationResults)) {
        r.disabledPendingId = s.id;
        return;
      }
    } else
      r = o.validationResults[n];
    r && r.disabledPendingId && delete r.disabledPendingId;
  }
  getCellValidationResult(e) {
    var t;
    let {
      rowKey: n,
      columnIndex: s
    } = e;
    const o = this._getValidationData(n, !0);
    return o == null || (t = o.validationResults) === null || t === void 0 ? void 0 : t[s];
  }
  removeCellValidationResult(e) {
    let {
      change: t,
      columnIndex: n
    } = e;
    const s = this._getValidationData(t?.key);
    s && s.validationResults && (this.cancelCellValidationResult({
      change: t,
      columnIndex: n
    }), delete s.validationResults[n]);
  }
  cancelCellValidationResult(e) {
    let {
      change: t,
      columnIndex: n
    } = e;
    const s = this._getValidationData(t.key);
    if (t && s.validationResults) {
      const o = s.validationResults[n];
      o && (o.deferred && o.deferred.reject("cancel"), s.validationResults[n] = "cancel");
    }
  }
  resetRowValidationResults(e) {
    e && (e.validationResults && delete e.validationResults, delete e.validated);
  }
  isInvalidCell(e) {
    let {
      rowKey: t,
      columnIndex: n
    } = e;
    const s = this.getCellValidationResult({
      rowKey: t,
      columnIndex: n
    });
    return Za(s) && s.status === _n.invalid;
  }
  getCellValidator(e) {
    let {
      rowKey: t,
      columnIndex: n
    } = e;
    const s = this._getValidationData(t), o = s && Ve.getGroupConfig(s), r = o && o.validators;
    return r && r.filter((a) => {
      const {
        column: l
      } = a.option("dataGetter")();
      return l ? l.index === n : !1;
    })[0];
  }
  setCellValidationStatus(e) {
    const t = this.getCellValidationResult({
      rowKey: e.key,
      columnIndex: e.column.index
    });
    f(t) ? e.validationStatus = t !== "cancel" ? t.status : "cancel" : delete e.validationStatus;
  }
}
const vZ = (i) => class extends i {
  processDataItemTreeListHack(e) {
    super.processDataItem.apply(this, arguments);
  }
  processItemsTreeListHack(e, t) {
    return super.processItems.apply(this, arguments);
  }
  _addChange(e) {
    const t = super._addChange.apply(this, arguments);
    return t && e.type !== "remove" && this._validatingController.updateValidationState(t), t;
  }
  _handleChangesChange(e) {
    super._handleChangesChange.apply(this, arguments), e.value.forEach((t) => {
      this._validatingController._getValidationData(t.key) === void 0 && this._validatingController.updateValidationState(t);
    });
  }
  _updateRowAndPageIndices() {
    const e = this, t = e.getView("rowsView").getTopVisibleItemIndex();
    let n = t;
    y(e.getChanges(), (s, o) => {
      let {
        key: r,
        type: a
      } = o;
      const l = this._validatingController._getValidationData(r);
      l && !l.isValid && l.pageIndex !== e._pageIndex && (l.pageIndex = e._pageIndex, a === "insert" ? l.rowIndex = t : l.rowIndex = n, n++);
    });
  }
  _getValidationGroupsInForm(e) {
    return {
      validationGroup: this._validatingController._getValidationData(e.key, !0)
    };
  }
  _validateEditFormAfterUpdate(e, t) {
    t && this._editForm && this._editForm.validate(), super._validateEditFormAfterUpdate.apply(this, arguments);
  }
  _prepareEditCell(e) {
    const t = super._prepareEditCell.apply(this, arguments);
    return t && e.column.showEditorAlways && this._validatingController.updateValidationState({
      key: e.key
    }), t;
  }
  processItems(e, t) {
    const n = this.getChanges(), s = (r, a) => {
      let l = -1;
      const d = r.type === "insert", {
        key: u
      } = r;
      return y(a, (c, h) => {
        if (He(u, d ? h.key : this._dataController.keyOf(h)))
          return l = c, !1;
      }), l;
    };
    e = super.processItems(e, t);
    const o = e.length;
    return this.getEditMode() === Mu && t !== "prepend" && t !== "append" && n.forEach((r) => {
      const {
        key: a
      } = r, l = this._validatingController._getValidationData(a);
      l && r.type && l.pageIndex === this._pageIndex && r?.pageIndex !== this._pageIndex && function(d, u) {
        const c = {
          key: d.key
        };
        if (s(d, e) >= 0)
          return;
        u.rowIndex = u.rowIndex > o ? u.rowIndex % o : u.rowIndex;
        const {
          rowIndex: g
        } = u;
        c[f0] = 1, e.splice(g, 0, c);
      }(r, l);
    }), e;
  }
  processDataItem(e) {
    const t = e.data[f0], n = t ? e.data.key : e.key;
    if (this.getEditMode() === Mu && t && n) {
      const o = this.getChanges(), r = F.getIndexByKey(n, o);
      if (r >= 0) {
        const a = o[r];
        if (a.type !== "insert") {
          const l = this._getOldData(a.key);
          e.data = x(!0, {}, l, a.data), e.key = n;
        }
      }
    }
    super.processDataItem.apply(this, arguments);
  }
  _createInvisibleColumnValidators(e) {
    const t = this, n = this._columnsController.getColumns(), s = this._columnsController.getInvisibleColumns().filter((l) => !l.isBand), o = this._columnsController.getGroupColumns().filter((l) => !l.showWhenGrouped && s.indexOf(l) === -1), r = [], a = (l, d) => this._dataController.getRowIndexByKey(d) >= 0 && s.indexOf(l) < 0;
    return s.push(...o), uR.includes(this.getEditMode()) || y(n, (l, d) => {
      e.forEach((u) => {
        let c;
        if (!a(d, u.key)) {
          if (u.type === "insert")
            c = u.data;
          else if (u.type === "update") {
            const h = t._getOldData(u.key);
            if (!f(h))
              return;
            c = Ns(h, u.data);
          }
          if (c) {
            const h = this._validatingController.createValidator({
              column: d,
              key: u.key,
              value: d.calculateCellValue(c)
            });
            h && r.push(h);
          }
        }
      });
    }), function() {
      r.forEach((l) => {
        l.dispose();
      });
    };
  }
  _beforeSaveEditData(e, t) {
    let n = super._beforeSaveEditData.apply(this, arguments);
    const s = this._validatingController._getValidationData(e?.key, !0);
    if (e) {
      const o = e.type === "remove" || s.isValid;
      n = n || !o;
    } else {
      const o = this._createInvisibleColumnValidators(this.getChanges());
      n = new w(), this.executeOperation(n, () => {
        this._validatingController.validate(!0).done((r) => {
          switch (o(), this._updateRowAndPageIndices(), this.getEditMode()) {
            case qr:
              r || this._focusEditingCell();
              break;
            case Mu:
              r || (this._resetEditRowKey(), this._resetEditColumnName(), this._dataController.updateItems());
          }
          n.resolve(!r);
        });
      });
    }
    return n.promise ? n.promise() : n;
  }
  _beforeEditCell(e, t, n) {
    const s = super._beforeEditCell(e, t, n);
    if (this.getEditMode() === qr) {
      const o = this._rowsView._getCellElement(e, t), r = o && o.data("dxValidator"), a = o && o.closest(".dx-row").data("options"), l = r && r.option("adapter").getValue();
      if (r && cR(l, a)) {
        const d = new w();
        return W(this._validatingController.validateCell(r), s).done((u, c) => {
          d.resolve(u.status === _n.valid && c);
        }), d.promise();
      }
      if (!r)
        return s;
    }
    return !1;
  }
  _afterSaveEditData(e) {
    let t;
    const n = this.getEditMode() === qr;
    if (y(this.getChanges(), (s, o) => {
      const r = this._showErrorRow(o);
      t = t || r;
    }), t) {
      const s = this._rowsView.getScrollable();
      s && (s.update(), s.scrollToElement(t));
    }
    if (e && n && this._needUpdateRow()) {
      const s = this.getEditRowIndex();
      this._dataController.updateItems({
        changeType: "update",
        rowIndices: [s]
      }), this._focusEditingCell();
    } else if (!e) {
      let s = !0;
      n && (s = !(this._columnsController.getColumns().filter((a) => {
        var l;
        return a.showEditorAlways && ((l = a.validationRules) === null || l === void 0 ? void 0 : l.length) > 0;
      }).length > 0)), s && this._validatingController.initValidationState();
    }
  }
  _handleDataChanged(e) {
    const t = this._validatingController._validationState;
    this.option("scrolling.mode") === "standard" && this.resetRowAndPageIndices(), e.changeType === "prepend" && y(t, (n, s) => {
      s.rowIndex += e.items.length;
    }), super._handleDataChanged(e);
  }
  resetRowAndPageIndices() {
    const e = this._validatingController._validationState;
    y(e, (t, n) => {
      n.pageIndex !== this._pageIndex && (delete n.pageIndex, delete n.rowIndex);
    });
  }
  _beforeCancelEditData() {
    this._validatingController.initValidationState(), super._beforeCancelEditData();
  }
  _showErrorRow(e) {
    let t;
    const n = this._dataController.items(), s = this.getIndexByKey(e.key, n), o = this._validatingController._getValidationData(e.key);
    if (!(o != null && o.isValid) && o !== null && o !== void 0 && o.errorText && s >= 0)
      return t = this.getPopupContent(), this._errorHandlingController && this._errorHandlingController.renderErrorRow(o?.errorText, s, t);
  }
  updateFieldValue(e) {
    const t = new w();
    return this._validatingController.removeCellValidationResult({
      change: this.getChangeByKey(e.key),
      columnIndex: e.column.index
    }), super.updateFieldValue.apply(this, arguments).done(() => {
      const n = this._validatingController.getCellValidator({
        rowKey: e.key,
        columnIndex: e.column.index
      });
      W(n && this._validatingController.validateCell(n)).done((s) => {
        this._editorFactoryController.refocus(), t.resolve(s);
      });
    }), t.promise();
  }
  highlightDataCell(e, t) {
    super.highlightDataCell.apply(this, arguments), this._validatingController.setCellValidationStatus(t);
    const n = !!t.setValue, s = this.isCellModified(t), o = f(t.validationStatus);
    if (s && t.column.setCellValue || n && !s && !(t.row.isNewRow || !o)) {
      const a = e.data("dxValidator");
      a && W(this._validatingController.validateCell(a)).done(() => {
        this._validatingController.setCellValidationStatus(t);
      });
    }
  }
  getChangeByKey(e) {
    const t = this.getChanges();
    return t[F.getIndexByKey(e, t)];
  }
  isCellModified(e) {
    const t = super.isCellModified(e), n = this.getChangeByKey(e.key), s = !!e.row && this._validatingController.isInvalidCell({
      rowKey: e.key,
      columnIndex: e.column.index
    });
    return t || this._validatingController._rowIsValidated(n) && s;
  }
}, xZ = function(i, e) {
  const t = p(e).closest("tr").index(), n = p(i._rowsView.getRowElement(t)).first().children().filter(":not(.dx-hidden-cell)");
  return i._rowsView._getWidths(n).reduce((s, o) => s + o, 0);
}, yZ = function(i) {
  let e, t;
  return i.some((n, s) => {
    if (n.command === "transparent")
      return e = s === 0 ? -1 : s, t = s === i.length - 1 ? -1 : s + n.colspan - 1, !0;
  }), {
    startColumnIndex: e,
    endColumnIndex: t
  };
}, bZ = (i) => class extends i {
  _showRevertButton(e) {
    var t, n;
    let s = (t = this._revertTooltip) === null || t === void 0 ? void 0 : t.$element();
    if (!e || !e.length) {
      var o;
      (o = s) === null || o === void 0 || o.remove(), this._revertTooltip = void 0;
      return;
    }
    if (e.find(s).length) {
      var r;
      (r = this._revertTooltip) === null || r === void 0 || r.repaint();
      return;
    }
    const a = this.getRevertButtonContainer(e), l = this.addWidgetPrefix("revert-tooltip");
    (n = s) === null || n === void 0 || n.remove(), s = p("<div>").addClass(l).appendTo(e);
    const d = {
      animation: null,
      visible: !0,
      width: "auto",
      height: "auto",
      shading: !1,
      container: a,
      propagateOutsideClick: !0,
      hideOnOutsideClick: !1,
      wrapperAttr: {
        class: l
      },
      contentTemplate: () => {
        const u = p("<div>").addClass("dx-revert-button"), c = {
          icon: "revert",
          hint: this.option("editing.texts.validationCancelChanges"),
          elementAttr: {
            id: "dxRevertButton",
            "aria-label": S.format("dxDataGrid-ariaRevertButton")
          },
          onClick: () => {
            this._editingController.cancelEditData();
          }
        };
        return new wt(u, c).$element();
      },
      position: {
        my: "left top",
        at: "right top",
        offset: "1 0",
        collision: "flip",
        boundaryOffset: "0 0",
        boundary: this._rowsView.element(),
        of: e
      },
      onPositioned: this.overlayPositionedHandler.bind(this)
    };
    this._revertTooltip = new Tn(s, d);
  }
  _hideFixedGroupCell(e, t) {
    var n, s;
    let o, r;
    const a = (n = this._rowsView) === null || n === void 0 || (s = n.isFixedColumns) === null || s === void 0 ? void 0 : s.call(n), l = this._editingController.isFormOrPopupEditMode();
    if (a && !l) {
      const d = e.closest(".dx-row").next().data("options");
      d && d.rowType === "group" && (o = p(this._rowsView.getRowElement(d.rowIndex)).last(), r = o.find(".dx-group-cell"), r.length && r.get(0).style.visibility !== "hidden" && (r.css("visibility", "hidden"), t.onDisposing = function() {
        r.css("visibility", "");
      }));
    }
  }
  _showValidationMessage(e, t, n) {
    const s = e.find(".dx-dropdowneditor-overlay").data("dxPopup"), o = s && s.option("visible"), r = o ? "top right" : `top ${n}`, a = o ? "top left" : `bottom ${n}`, l = this.getValidationMessageContainer(e);
    let d = "";
    t && t.forEach((g) => {
      d += (d.length ? "<br/>" : "") + lE(g);
    });
    const u = this.addWidgetPrefix("invalid-message");
    this._rowsView.element().find(`.${u}`).remove();
    const c = p("<div>").addClass("dx-invalid-message").addClass("dx-invalid-message-always").addClass(u).html(d).appendTo(e), h = {
      container: l,
      shading: !1,
      width: "auto",
      height: "auto",
      visible: !0,
      animation: !1,
      propagateOutsideClick: !0,
      hideOnOutsideClick: !1,
      wrapperAttr: {
        id: "dxInvalidMessage",
        class: `dx-invalid-message dx-invalid-message-always ${u}`
      },
      position: {
        collision: "flip",
        boundary: this._rowsView.element(),
        boundaryOffset: "0 0",
        offset: {
          x: 0,
          y: !o && ze.mozilla ? -1 : 0
        },
        my: r,
        at: a,
        of: e
      },
      onPositioned: (g) => {
        this.overlayPositionedHandler(g, o), this._shiftValidationMessageIfNeed(g.component.$content(), e);
      }
    };
    this._hideFixedGroupCell(e, h), new Tn(c, h);
  }
  getValidationMessages() {
    var e;
    return (e = this._rowsView.element()) === null || e === void 0 ? void 0 : e.find(this._getValidationMessagesSelector());
  }
  getRevertButton() {
    var e;
    return p((e = this._revertTooltip) === null || e === void 0 ? void 0 : e.element());
  }
  _hideValidationMessage() {
    var e;
    const t = (e = this._rowsView.element()) === null || e === void 0 ? void 0 : e.find(this._getValidationMessagesSelector());
    t?.remove();
  }
  _normalizeValidationMessagePositionAndMaxWidth(e, t, n) {
    const s = this._columnsController.getFixedColumns();
    if (!s || !s.length)
      return;
    let o;
    const r = !t && xZ(this, e.element), a = e.component.$content(), l = Ee(a, !0), d = !t && l > r, u = this._rowsView.getCellIndex(p(e.element).closest("td")), c = yZ(s);
    return !t && (u === c.startColumnIndex || d) ? o = {
      collision: "none flip",
      my: "top left",
      at: n ? "top right" : "bottom left"
    } : u === c.endColumnIndex && (o = {
      collision: "none flip",
      my: "top right",
      at: t || n ? "top left" : "bottom right"
    }, t && (o.offset = "-1 0")), o && {
      position: o,
      maxWidth: d ? r - 2 : void 0
    };
  }
  _shiftValidationMessageIfNeed(e, t) {
    const n = this._revertTooltip && this._revertTooltip.$content();
    if (!n)
      return;
    const s = e.offset(), o = n.offset();
    if (s.top === o.top && s.left + ne(e) > o.left) {
      const r = ne(n) + 2;
      e.css("left", o.left < t.offset().left ? -r : r);
    }
  }
  getOverlayBaseZIndex() {
    return Tn.baseZIndex();
  }
  overlayPositionedHandler(e, t) {
    if (!e.component.__skipPositionProcessing) {
      const n = p(e.element).hasClass(this.addWidgetPrefix("revert-tooltip")), s = !n && this._rowsView.updateFreeSpaceRowHeight(), o = this._normalizeValidationMessagePositionAndMaxWidth(e, n, t);
      e.component.__skipPositionProcessing = !!(s || o), o ? e.component.option(o) : s && e.component.repaint();
    }
  }
  _getRevertTooltipsSelector() {
    return `.dx-editor-cell .${this.addWidgetPrefix("revert-tooltip")}`;
  }
  _getValidationMessagesSelector() {
    const e = this.addWidgetPrefix("invalid-message");
    return `.dx-editor-cell .${e}, .dx-cell-modified .${e}`;
  }
  loseFocus(e) {
    e || this._validatingController.setValidator(null), super.loseFocus();
  }
  updateCellState(e, t, n) {
    var s;
    const o = e?.closest(this._getFocusCellSelector()), r = o != null && o.is("td") ? o : null, a = o?.closest(".dx-row").data("options"), l = a ? this._editingController.getChangeByKey(a.key) : null, d = r && this._columnsController.getVisibleColumns()[r.index()], u = (l == null || (s = l.data) === null || s === void 0 ? void 0 : s[d?.name]) !== void 0 && !this._editingController.isSaving(), c = [];
    if (this._editingController.getEditMode() === qr && (t?.status === _n.invalid || u ? (this._showRevertButton(o), c.push("dxRevertButton")) : this._revertTooltip && this._revertTooltip.$element().remove()), t && t.status === _n.invalid && r && d && t && t.brokenRules) {
      const g = [];
      t.brokenRules.forEach((m) => {
        m.message && g.push(m.message);
      }), g.length && (this._showValidationMessage(o, g, d.alignment || "left"), c.push("dxInvalidMessage"));
    }
    this._updateAriaValidationAttributes(o, c), !n && this._rowsView.element() && this._rowsView.updateFreeSpaceRowHeight();
  }
  _updateAriaValidationAttributes(e, t) {
    if (t.length === 0)
      return;
    const n = this._editingController.getEditMode();
    if ([qr, Mu, dR].includes(n)) {
      const o = this._getCurrentFocusElement(e);
      o.attr("aria-labelledby", t.join(" ")), o.attr("aria-invalid", !0);
    }
  }
  _getCurrentFocusElement(e) {
    return this._editingController.isEditing() ? e.find(CC).first() : e;
  }
  focus(e, t) {
    if (!arguments.length)
      return super.focus();
    if (this._hideValidationMessage(), e != null && e.hasClass("dx-row") || e != null && e.hasClass("dx-master-detail-cell"))
      return super.focus(e, t);
    const n = e?.closest(this._getFocusCellSelector()), s = n && (n.data("dxValidator") || e.find(`.${this.addWidgetPrefix("validator")}`).eq(0).data("dxValidator")), o = n && n.closest(".dx-row").data("options"), r = o ? this._editingController.getChangeByKey(o.key) : null;
    let a;
    if (s) {
      this._validatingController.setValidator(s);
      const l = s.option("adapter").getValue();
      if (cR(l, o) || this._validatingController._rowIsValidated(r))
        return this._editingController.waitForDeferredOperations().done(() => {
          this._rowsView.isElementInside(e) && W(this._validatingController.validateCell(s)).done((u) => {
            a = u;
            const {
              column: c
            } = a.validator.option("dataGetter")();
            r && c && !this._validatingController.isCurrentValidatorProcessing({
              rowKey: r.key,
              columnIndex: c.index
            }) || (!nn(pn()) && a.status === _n.invalid && (t = !0), this.updateCellState(e, a, t), super.focus.call(this, e, t));
          });
        }), super.focus(e, t);
    }
    return this.updateCellState(e, a, t), super.focus(e, t);
  }
  getEditorInstance(e) {
    const t = e.find(".dx-texteditor").eq(0);
    return F.getWidgetInstance(t);
  }
  getValidationMessageContainer(e) {
    return e.closest(`.${this.addWidgetPrefix("content")}`);
  }
  getRevertButtonContainer(e) {
    return e.closest(`.${this.addWidgetPrefix("content")}`).parent();
  }
  hasOverlayElements() {
    const e = this.getValidationMessages(), t = this.getRevertButton();
    return super.hasOverlayElements() || !!(e != null && e.length) || !!(t != null && t.length);
  }
}, wZ = (i) => class extends i {
  _getValidationStatus(e) {
    return (Za(e) ? e.status : e) || _n.valid;
  }
  _isCellChanged(e, t, n, s, o) {
    var r, a;
    const l = (r = e.cells) === null || r === void 0 ? void 0 : r[s], d = this._getValidationStatus({
      status: l?.validationStatus
    }), u = this._validatingController.getCellValidationResult({
      rowKey: e.key,
      columnIndex: s
    }), c = this._validatingController._getValidationData(e.key), h = this._getValidationStatus(u), g = JSON.stringify(t.modifiedValues) !== JSON.stringify(e.modifiedValues), m = d !== h && g, C = p(l?.cellElement).hasClass(this.addWidgetPrefix("invalid")), v = l == null || (a = l.column.validationRules) === null || a === void 0 ? void 0 : a.length, E = e.isEditing !== t.isEditing && v, T = m || c.isValid && C;
    return E || T ? !0 : super._isCellChanged.apply(this, arguments);
  }
}, SZ = (i) => class extends i {
  updateFreeSpaceRowHeight(e) {
    const t = this;
    let n, s, o;
    const r = t.element(), a = r && r.find(`.${t.addWidgetPrefix("invalid-message")} .dx-overlay-content`);
    if (super.updateFreeSpaceRowHeight(e), a && a.length && (n = t._getRowElements(), o = t._getFreeSpaceRowElements(e), s = o.first(), s && n.length === 1 && (!s.is(":visible") || he(a) > he(s))))
      return o.show(), js(o, he(a)), !0;
  }
  _formItemPrepared(e, t) {
    super._formItemPrepared.apply(this, arguments), qt(() => {
      const n = t.find(".dx-widget").first();
      n.length && !n.children().length || this._validatingController.createValidator(e, n);
    });
  }
  _cellPrepared(e, t) {
    this._editingController.isFormOrPopupEditMode() || this._validatingController.createValidator(t, e), super._cellPrepared.apply(this, arguments);
  }
  _restoreErrorRow(e) {
    this._editingController && this._editingController.hasChanges() && this._getRowElements(e).each((t, n) => {
      const s = p(n).data("options");
      if (s) {
        const o = this._editingController.getChangeByKey(s.key);
        o && this._editingController._showErrorRow(o);
      }
    });
  }
}, EZ = {
  defaultOptions: () => ({
    editing: {
      texts: {
        validationCancelChanges: S.format("dxDataGrid-validationCancelChanges")
      }
    }
  }),
  controllers: {
    validating: CZ
  },
  extenders: {
    controllers: {
      editing: vZ,
      editorFactory: bZ,
      data: wZ
    },
    views: {
      rowsView: SZ
    }
  }
};
J.registerModule("validating", EZ);
const Zp = "scrolling.legacyMode", hR = (i) => i.option("scrolling.loadTwoPagesOnStart") || i._controller.isVirtual() || i._controller.getViewportItemIndex() > 0, Bu = (i) => i._cache.length ? i._cache[0].pageIndex : -1, jm = (i) => i._cache.length ? i._cache[i._cache.length - 1].pageIndex : -1, Dc = (i, e, t) => {
  i._isChangedFiring = !0, e(t), i._isChangedFiring = !1;
}, _0 = (i, e, t) => {
  if (i._isDelayChanged)
    return i._isDelayChanged = !1, Dc(i, e, t), !0;
}, IZ = (i) => {
  const e = i._dataOptions.pageSize();
  if (i.option("scrolling.preventPreload"))
    return 0;
  let n = i._controller.viewportSize();
  if (i._controller.isVirtualMode() && i.option("scrolling.removeInvisiblePages")) {
    n = 0;
    const s = i._controller.viewportSize() * i._controller.viewportItemSize();
    let o = i._controller.getContentOffset();
    const r = i._controller.getViewportPosition(), a = i._controller.virtualItemsCount(), l = i._dataOptions.totalItemsCount();
    for (let d = a.begin; d < l && !(o >= r + s); d++) {
      const u = i._controller.getItemSizes()[d] || i._controller.viewportItemSize();
      o += u, o >= r && n++;
    }
  }
  return e && n > 0 ? Math.ceil(n / e) : 1;
}, $u = (i, e) => {
  const t = i.option("scrolling.preloadEnabled");
  let n = IZ(i);
  const s = i._controller.isAppendMode();
  return n && (e ? n = t ? 1 : 0 : (t && n++, (s || !hR(i)) && n--)), n;
}, DZ = (i) => {
  let e = -1;
  const t = Bu(i), n = i._dataOptions;
  return t < 0 ? e = i._pageIndex : i._cache[i._pageIndex - t] ? t >= 0 && i._controller.viewportSize() >= 0 && (t > 0 && (jm(i) + 1 === n.pageCount() && i._cache.length < $u(i) + 1 || i._pageIndex === t && $u(i, !0)) && (e = t - 1), e < 0 && t + i._cache.length <= i._pageIndex + $u(i) && (e = t + i._cache.length)) : e = i._pageIndex, i._loadingPageIndexes[e] && (e = -1), e;
}, TZ = (i, e) => {
  const t = i._dataOptions;
  if (e === i.pageIndex() || !t.isLoading() && e < t.pageCount() || !t.hasKnownLastPage() && e === t.pageCount())
    return t.pageIndex(e), i._loadingPageIndexes[e] = !0, W(t.load()).always(() => {
      i._loadingPageIndexes[e] = !1;
    });
}, C0 = (i, e, t, n, s) => {
  const o = i._dataOptions, r = o.items().slice();
  let a = X(t) ? t : void 0;
  const l = t === "prepend", d = o.viewportItems();
  t && te(t) && !i._isDelayChanged && (a = {
    changeType: t,
    items: r
  }, s && (a.removeCount = s.itemsCount, a.removeCount && o.correctCount && (a.removeCount = o.correctCount(d, a.removeCount, l))));
  let u = s ? s.itemsLength : 0;
  u && o.correctCount && (u = o.correctCount(d, u, l)), t === "append" ? (d.push.apply(d, r), s && d.splice(0, u)) : l ? (d.unshift.apply(d, r), s && d.splice(-u)) : i._dataOptions.viewportItems(r), o.updateLoading(), i._lastPageIndex = i.pageIndex(), i._isDelayChanged = n, n || Dc(i, e, a);
};
class OZ {
  constructor(e, t) {
    this._dataOptions = t, this._controller = e, this._pageIndex = this._lastPageIndex = t.pageIndex(), this._cache = [], this._loadingPageIndexes = {};
  }
  option() {
    return this._controller.option.apply(this._controller, arguments);
  }
  viewportItemIndexChanged(e) {
    const t = this._dataOptions.pageSize(), n = this._dataOptions.pageCount(), s = this._controller.isVirtualMode(), o = this._controller.isAppendMode(), r = this._dataOptions.totalItemsCount();
    let a;
    if (t && (s || o) && r >= 0) {
      const l = this._controller.viewportSize();
      if (l && e + l >= r && !this._controller.isVirtual())
        if (this._dataOptions.hasKnownLastPage()) {
          a = n - 1;
          const d = r % t;
          a > 0 && d > 0 && d < l && a--;
        } else
          a = n;
      else {
        a = Math.floor(e / t);
        const d = n - 1;
        a = Math.max(a, 0), a = Math.min(a, d);
      }
      return this.pageIndex(a), this.load();
    }
  }
  pageIndex(e) {
    const t = this._controller.isVirtualMode(), n = this._controller.isAppendMode();
    return this.option(Zp) !== !1 && (t || n) ? (e !== void 0 && (this._pageIndex = e), this._pageIndex) : this._dataOptions.pageIndex(e);
  }
  beginPageIndex(e) {
    let t = Bu(this);
    return t < 0 && (t = e !== void 0 ? e : this.pageIndex()), t;
  }
  endPageIndex() {
    const e = jm(this);
    return e > 0 ? e : this._lastPageIndex;
  }
  pageSize() {
    return this._dataOptions.pageSize();
  }
  load() {
    const e = this._dataOptions;
    let t;
    const n = this._controller.isVirtualMode(), s = this._controller.isAppendMode();
    if (this.option(Zp) !== !1 && (n || s)) {
      const o = DZ(this);
      if (o >= 0) {
        const r = TZ(this, o);
        r && (t = new w(), r.done(() => {
          const a = this._delayDeferred;
          a ? a.done(t.resolve).fail(t.reject) : t.resolve();
        }).fail(t.reject), e.updateLoading());
      }
    } else
      t = e.load();
    return !t && this._lastPageIndex !== this.pageIndex() && this._dataOptions.onChanged({
      changeType: "pageIndex"
    }), t || new w().resolve();
  }
  loadIfNeed() {
    const e = this._controller.isVirtualMode(), t = this._controller.isAppendMode();
    if ((e || t) && !this._dataOptions.isLoading() && (!this._isChangedFiring || this._controller.isVirtual())) {
      const n = this._controller.getViewportPosition();
      n > 0 ? this._controller._setViewportPositionCore(n) : this.load();
    }
  }
  handleDataChanged(e, t) {
    const n = this._dataOptions;
    let s = this._cache.length, o, r;
    const a = this._controller.isVirtualMode(), l = this._controller.isAppendMode();
    if (t && t.changes)
      Dc(this, e, t);
    else if (this.option(Zp) !== !1 && (a || l)) {
      const d = Bu(this);
      if (d >= 0 && (a && d + this._cache.length !== n.pageIndex() && d - 1 !== n.pageIndex() && (s = 0, this._cache = []), l)) {
        if (n.pageIndex() === 0)
          this._cache = [];
        else if (n.pageIndex() < jm(this)) {
          Dc(this, e, {
            changeType: "append",
            items: []
          });
          return;
        }
      }
      const u = {
        pageIndex: n.pageIndex(),
        itemsLength: n.items(!0).length,
        itemsCount: this.itemsCount(!0)
      };
      this.option("scrolling.removeInvisiblePages") && a ? r = this._cache.length > Math.max($u(this) + (this.option("scrolling.preloadEnabled") ? 1 : 0), 2) : _0(this, e, {
        isDelayed: !0
      });
      let c;
      d === n.pageIndex() + 1 ? (r && (c = this._cache.pop()), o = "prepend", this._cache.unshift(u)) : (r && (c = this._cache.shift()), o = "append", this._cache.push(u));
      const h = a && s === 0 && hR(this);
      C0(this, e, this._cache.length > 1 ? o : void 0, h, c), this._delayDeferred = this.load().done(() => {
        _0(this, e) && this.load();
      });
    } else
      C0(this, e, t);
  }
  getDelayDeferred() {
    return this._delayDeferred;
  }
  itemsCount(e) {
    let t = 0;
    const n = this._controller.isVirtualMode();
    return !e && n ? this._cache.forEach((s) => {
      t += s.itemsCount;
    }) : t = this._dataOptions.itemsCount(), t;
  }
  virtualItemsCount() {
    let e = Bu(this);
    e < 0 && (e = this._dataOptions.pageIndex());
    const t = e * this._dataOptions.pageSize(), n = this._cache.length * this._dataOptions.pageSize(), s = Math.max(0, this._dataOptions.totalItemsCount() - n - t);
    return {
      begin: t,
      end: s
    };
  }
  reset() {
    this._loadingPageIndexes = {}, this._cache = [];
  }
}
const ru = "scrolling.legacyMode", v0 = (i) => i.option("scrolling.mode") === "virtual" || i._isVirtual, AZ = (i) => i.option("scrolling.mode") === "infinite" && !i._isVirtual;
function pR(i, e, t) {
  let n;
  const s = [], o = [];
  t = t || i;
  function r(u) {
    const c = u.element ? u.$element() : u, h = Un.offset(c);
    return h ? u.scrollTop() - (h.top - i.offset().top) : i.offset().top;
  }
  const a = {
    on(u, c, h) {
      u.on("scroll", h);
    },
    off(u, c, h) {
      u.off("scroll", h);
    }
  };
  function l(u) {
    const c = u.get(0).nodeName === "#document", h = u.get(0).nodeType === fe().Node.ELEMENT_NODE;
    let g = u.data("dxScrollable"), m = a;
    if (!g && (g = c && p(fe()) || h && u.css("overflowY") === "auto" && u, m = _, !g))
      return;
    const C = function(v) {
      return function() {
        let E = v.scrollTop() - r(v);
        E = E > 0 ? E : 0, e(E);
      };
    }(g);
    m.on(g, "scroll", C), s.push((v) => {
      const E = r(g), T = g.scrollTo ? "scrollTo" : "scrollTop";
      v - E >= 0 && g[T](v + E);
    }), o.push(() => {
      m.off(g, "scroll", C);
    });
  }
  const d = (u) => p(u.get(0).parentNode ?? u.get(0).host);
  for (n = t.parent(); n.length; n = d(n))
    l(n);
  return {
    scrollTo(u) {
      y(s, (c, h) => {
        h(u);
      });
    },
    dispose() {
      y(o, (u, c) => {
        c();
      });
    }
  };
}
class gR {
  constructor(e, t, n) {
    this._dataOptions = t, this.component = e, this._viewportSize = e.option(ru) === !1 ? 15 : 0, this._viewportItemSize = 20, this._viewportItemIndex = 0, this._position = 0, this._isScrollingBack = !1, this._contentSize = 0, this._itemSizes = {}, this._sizeRatio = 1, this._isVirtual = n, this.positionChanged = Ie(), this._dataLoader = new OZ(this, this._dataOptions);
  }
  getItemSizes() {
    return this._itemSizes;
  }
  option(e, t) {
    return this.component.option.apply(this.component, arguments);
  }
  isVirtual() {
    return this._isVirtual;
  }
  virtualItemsCount() {
    if (v0(this)) {
      const e = this._dataOptions, t = e.totalItemsCount();
      if (this.option(ru) === !1 && t !== -1) {
        const n = this.getViewportParams(), s = e.loadedOffset(), o = e.loadedItemCount(), r = Math.max(n.skip, s), a = Math.min(n.take, o), l = Math.max(t - (r + a), 0);
        return {
          begin: r,
          end: l
        };
      }
      return this._dataLoader.virtualItemsCount.apply(this._dataLoader, arguments);
    }
  }
  getScrollingTimeout() {
    const e = this.option("scrolling.renderAsync");
    let t = 0;
    return f(e) ? e && (t = this.option("scrolling.timeout") ?? 0) : (t = Math.min(this.option("scrolling.timeout") || 0, this._dataOptions.changingDuration()), t < this.option("scrolling.renderingThreshold") && (t = this.option("scrolling.minTimeout") || 0)), t;
  }
  setViewportPosition(e) {
    const t = new w(), n = this.getScrollingTimeout();
    return clearTimeout(this._scrollTimeoutID), n > 0 ? this._scrollTimeoutID = setTimeout(() => {
      this._setViewportPositionCore(e), t.resolve();
    }, n) : (this._setViewportPositionCore(e), t.resolve()), t.promise();
  }
  getViewportPosition() {
    return this._position;
  }
  getItemIndexByPosition(e, t, n) {
    e = e ?? this._position;
    const s = this.getItemSize();
    let o = 0, r = 0;
    const a = Object.keys(this._itemSizes).concat(-1);
    for (let l = 0; l < a.length && o < e; l++) {
      const d = parseInt(a[l]);
      let u = (e - o) / s;
      if (d < 0 || r + u < d) {
        r += u, this._sizeRatio < 1 && f(t) && (r = t + n / this._viewportItemSize);
        break;
      } else
        u = d - r, o += u * s, r += u;
      const c = this._itemSizes[d];
      o += c, r += o < e ? 1 : (e - o + c) / c;
    }
    return Math.round(50 * r) / 50;
  }
  isScrollingBack() {
    return this._isScrollingBack;
  }
  _setViewportPositionCore(e) {
    const t = this._position || 0;
    this._position = e, t !== this._position && (this._isScrollingBack = this._position < t);
    const n = this.getItemIndexByPosition(), s = this.setViewportItemIndex(n);
    return this.positionChanged.fire(), s;
  }
  setContentItemSizes(e) {
    const t = this.virtualItemsCount();
    if (this._contentSize = e.reduce((n, s) => n + s, 0), t) {
      e.forEach((o, r) => {
        this._itemSizes[t.begin + r] = o;
      });
      const n = (t.begin + t.end + this.itemsCount()) * this._viewportItemSize, s = F.getContentHeightLimit(ze);
      n > s ? this._sizeRatio = s / n : this._sizeRatio = 1;
    }
  }
  getItemSize() {
    return this._viewportItemSize * this._sizeRatio;
  }
  getItemOffset(e, t) {
    const n = this.virtualItemsCount();
    let s = e;
    if (!n)
      return 0;
    let o = 0;
    const r = this._dataOptions.totalItemsCount();
    return Object.keys(this._itemSizes).forEach((a) => {
      s && (t ? a >= r - e : a < e) && (o += this._itemSizes[a], s--);
    }), Math.floor(o + s * this._viewportItemSize * this._sizeRatio);
  }
  getContentOffset(e) {
    const t = e === "end", n = this.virtualItemsCount();
    return n ? this.getItemOffset(t ? n.end : n.begin, t) : 0;
  }
  getVirtualContentSize() {
    return this.virtualItemsCount() ? this.getContentOffset("begin") + this.getContentOffset("end") + this._contentSize : 0;
  }
  getViewportItemIndex() {
    return this._viewportItemIndex;
  }
  setViewportItemIndex(e) {
    if (this._viewportItemIndex = e, this.option(ru) !== !1)
      return this._dataLoader.viewportItemIndexChanged.apply(this._dataLoader, arguments);
  }
  viewportItemSize(e) {
    return e !== void 0 && (this._viewportItemSize = e), this._viewportItemSize;
  }
  viewportSize(e) {
    return e !== void 0 && (this._viewportSize = e), this._viewportSize;
  }
  viewportHeight(e, t) {
    const n = t ?? this._position, s = this.getItemIndexByPosition(n), o = this.getItemIndexByPosition(n + e, s, e);
    this.viewportSize(Math.ceil(o - s)), !f(t) && this._viewportItemIndex !== s && this._setViewportPositionCore(n);
  }
  reset(e) {
    this._dataLoader.reset(), e || (this._itemSizes = {});
  }
  subscribeToWindowScrollEvents(e) {
    this._windowScroll = this._windowScroll || pR(e, (t) => {
      this.viewportItemSize() && this.setViewportPosition(t);
    });
  }
  dispose() {
    clearTimeout(this._scrollTimeoutID), this._windowScroll && this._windowScroll.dispose(), this._windowScroll = null;
  }
  scrollTo(e) {
    this._windowScroll && this._windowScroll.scrollTo(e);
  }
  isVirtualMode() {
    return v0(this);
  }
  isAppendMode() {
    return AZ(this);
  }
  getViewportParams() {
    const e = this.option("scrolling.mode") === "virtual", t = this._dataOptions.totalItemsCount(), s = this._dataOptions.hasKnownLastPage() && this._viewportItemIndex > t ? t : this._viewportItemIndex, o = this._viewportSize + s, r = this.option("scrolling.prerenderedRowChunkSize") || 1, a = this.isScrollingBack(), l = this.option("scrolling.prerenderedRowCount") ?? 1, d = a ? l : 0, u = a ? 0 : l, c = Math.floor(Math.max(0, s - d) / r) * r;
    let h = Math.ceil((o + u - c) / r) * r;
    if (e) {
      const g = Math.max(0, t - c);
      h = Math.min(h, g);
    }
    return {
      skip: c,
      take: h
    };
  }
  itemsCount() {
    let e = 0;
    return this.option(ru) ? e = this._dataLoader.itemsCount.apply(this._dataLoader, arguments) : e = this._dataOptions.itemsCount(), e;
  }
  pageIndex() {
    return this._dataLoader.pageIndex(...arguments);
  }
  beginPageIndex() {
    return this._dataLoader.beginPageIndex(...arguments);
  }
  endPageIndex() {
    return this._dataLoader.endPageIndex(...arguments);
  }
  pageSize() {
    return this._dataLoader.pageSize(...arguments);
  }
  load() {
    return this._dataLoader.load(...arguments);
  }
  loadIfNeed() {
    return this._dataLoader.loadIfNeed(...arguments);
  }
  handleDataChanged() {
    return this._dataLoader.handleDataChanged(...arguments);
  }
  getDelayDeferred() {
    return this._dataLoader.getDelayDeferred();
  }
}
const mR = "dx-freespace-row", RZ = "dx-row-inserted", Ce = "scrolling.legacyMode", FZ = ["beginPageIndex", "endPageIndex", "pageIndex"], Xt = function(i) {
  return i.option("scrolling.mode") === "virtual";
}, Ai = function(i) {
  return i.option("scrolling.mode") === "infinite";
}, ei = function(i) {
  return Xt(i) || Ai(i);
}, x0 = function(i, e, t, n) {
  for (let s = 0; s < e + 1; s++) {
    const o = i[t ? i.length - 1 - s : s];
    o && !n(o, s === e, t) && e++;
  }
  return e;
}, Nu = function(i, e) {
  return i.rowType === "data" && !i.isNewRow || i.rowType === "group" && e.isGroupItemCountable(i.data);
}, kZ = function(i) {
  return i.forEach((e, t) => {
    e.rowIndex = t;
  }), i;
}, Qp = function(i) {
  const e = i._virtualScrollController.beginPageIndex(-1);
  Xt(i) && (e < 0 || i.viewportSize() >= 0 && i.getViewportItemIndex() >= 0 && (e * i.pageSize() > i.getViewportItemIndex() || e * i.pageSize() + i.itemsCount() < i.getViewportItemIndex() + i.viewportSize()) && i._dataSource.isLoading() ? i._isLoading || (i._isLoading = !0, i.loadingChanged.fire(!0)) : i._isLoading && (i._isLoading = !1, i.loadingChanged.fire(!1)));
}, Gt = function(i, e, t) {
  if (i.option(Ce) === !1 && FZ.includes(e)) {
    const s = i._dataSource;
    return s.pageIndex.apply(s, t);
  }
  const n = i._virtualScrollController;
  return n[e].apply(n, t);
}, y0 = function(i, e) {
  const t = i.toArray().map((s) => p(s).parent(`.${e}`).get(0)).filter((s) => s);
  t.length && (i = p(t));
  const n = e === mR ? i.length - 1 : i.length;
  for (let s = 0; s < n; s++)
    i.eq(s).remove();
}, VZ = (i) => class extends i {
  init() {
    super.init.apply(this, arguments), this._items = [], this._totalCount = -1, this._isLoaded = !0, this._loadPageCount = 1, this._virtualScrollController = new gR(this.component, this._getVirtualScrollDataOptions());
  }
  dispose() {
    this._virtualScrollController.dispose(), super.dispose.apply(this, arguments);
  }
  _getVirtualScrollDataOptions() {
    const e = this;
    return {
      pageSize: () => e.pageSize(),
      totalItemsCount: () => e.totalItemsCount(),
      hasKnownLastPage: () => e.hasKnownLastPage(),
      pageIndex: (t) => e._dataSource.pageIndex(t),
      isLoading: () => e._dataSource.isLoading() && !e.isCustomLoading(),
      pageCount: () => e.pageCount(),
      load: () => e._dataSource.load(),
      updateLoading() {
        Qp(e);
      },
      itemsCount: () => e.itemsCount(!0),
      items: () => e._dataSource.items(),
      viewportItems(t) {
        return t && (e._items = t), e._items;
      },
      onChanged(t) {
        e.changed.fire(t);
      },
      changingDuration() {
        return e.isLoading() ? 300 : e._renderTime || 0;
      }
    };
  }
  _handleLoadingChanged(e) {
    if (this.option(Ce) === !1) {
      super._handleLoadingChanged.apply(this, arguments);
      return;
    }
    (!Xt(this) || this._isLoadingAll) && (this._isLoading = e, super._handleLoadingChanged.apply(this, arguments)), e ? this._startLoadTime = /* @__PURE__ */ new Date() : this._startLoadTime = void 0;
  }
  _handleLoadError() {
    this.option(Ce) !== !1 && (this._isLoading = !1, this.loadingChanged.fire(!1)), super._handleLoadError.apply(this, arguments);
  }
  _handleDataChanged(e) {
    if (this.option(Ce) === !1) {
      this._items = this._dataSource.items().slice(), this._totalCount = this._dataSourceTotalCount(!0), super._handleDataChanged.apply(this, arguments);
      return;
    }
    const t = super._handleDataChanged.bind(this);
    this._virtualScrollController.handleDataChanged(t, e);
  }
  _customizeRemoteOperations(e, t) {
    const n = this.option(Ce) === !1;
    let s = this.option("scrolling.renderAsync");
    f(s) || (s = this._renderTime >= this.option("scrolling.renderingThreshold")), (Xt(this) || Ai(this) && n) && !t.reload && (t.skip || n) && !s && (e.delay = void 0), super._customizeRemoteOperations.apply(this, arguments);
  }
  items() {
    return this._items;
  }
  _dataSourceTotalCount(e) {
    return this.option(Ce) === !1 && Xt(this) && !e ? this._totalCount : super._dataSourceTotalCount();
  }
  itemsCount(e) {
    return e || this.option(Ce) === !1 ? super.itemsCount() : this._virtualScrollController.itemsCount();
  }
  load(e) {
    return this.option(Ce) === !1 || e ? super.load(e) : this._virtualScrollController.load();
  }
  isLoading() {
    return this.option(Ce) === !1 ? this._dataSource.isLoading() : this._isLoading;
  }
  isLoaded() {
    return this._dataSource.isLoaded() && this._isLoaded;
  }
  resetPagesCache(e) {
    e || this._virtualScrollController.reset(!0), super.resetPagesCache.apply(this, arguments);
  }
  _changeRowExpandCore() {
    const e = super._changeRowExpandCore.apply(this, arguments);
    return this.option(Ce) === !1 || (this.resetPagesCache(), Qp(this)), e;
  }
  reload() {
    this._dataSource.pageIndex(this.pageIndex());
    const e = this._virtualScrollController;
    if (this.option(Ce) !== !1 && e) {
      const t = new w();
      return super.reload.apply(this, arguments).done((n) => {
        const s = e.getDelayDeferred();
        s ? s.done(t.resolve).fail(t.reject) : t.resolve(n);
      }).fail(t.reject), t;
    }
    return super.reload.apply(this, arguments);
  }
  refresh(e, t) {
    if (this.option(Ce) !== !1) {
      const {
        storeLoadOptions: n
      } = e, s = this._dataSource;
      t.reload ? (this._virtualScrollController.reset(), s.items().length = 0, this._isLoaded = !1, Qp(this), this._isLoaded = !0, Ai(this) ? (this.pageIndex(0), s.pageIndex(0), n.pageIndex = 0, e.pageIndex = 0, n.skip = 0) : (s.pageIndex(this.pageIndex()), s.paginate() && (e.pageIndex = this.pageIndex(), n.skip = this.pageIndex() * this.pageSize()))) : Ai(this) && n.skip && this._totalCountCorrection < 0 && (n.skip += this._totalCountCorrection);
    }
    return super.refresh.apply(this, arguments);
  }
  loadPageCount(e) {
    if (!f(e))
      return this._loadPageCount;
    this._loadPageCount = e;
  }
  _handleDataLoading(e) {
    const t = this.loadPageCount(), n = this.pageSize(), s = this.option(Ce) === !1, {
      storeLoadOptions: o
    } = e, r = f(o.take);
    e.loadPageCount = t, !e.isCustomLoading && s && r && t > 1 && n > 0 && (o.take = t * n), super._handleDataLoading.apply(this, arguments);
  }
  _loadPageSize() {
    return super._loadPageSize.apply(this, arguments) * this.loadPageCount();
  }
  beginPageIndex() {
    return Gt(this, "beginPageIndex", [...arguments]);
  }
  endPageIndex() {
    return Gt(this, "endPageIndex", [...arguments]);
  }
  pageIndex(e) {
    return Gt(this, "pageIndex", [...arguments]);
  }
  virtualItemsCount() {
    return Gt(this, "virtualItemsCount", [...arguments]);
  }
  getContentOffset() {
    return Gt(this, "getContentOffset", [...arguments]);
  }
  getVirtualContentSize() {
    return Gt(this, "getVirtualContentSize", [...arguments]);
  }
  setContentItemSizes() {
    return Gt(this, "setContentItemSizes", [...arguments]);
  }
  setViewportPosition() {
    return Gt(this, "setViewportPosition", [...arguments]);
  }
  getViewportItemIndex() {
    return Gt(this, "getViewportItemIndex", [...arguments]);
  }
  setViewportItemIndex(e) {
    return Gt(this, "setViewportItemIndex", [...arguments]);
  }
  getItemIndexByPosition() {
    return Gt(this, "getItemIndexByPosition", [...arguments]);
  }
  viewportSize() {
    return Gt(this, "viewportSize", [...arguments]);
  }
  viewportItemSize() {
    return Gt(this, "viewportItemSize", [...arguments]);
  }
  getItemSize() {
    return Gt(this, "getItemSize", [...arguments]);
  }
  getItemSizes() {
    return Gt(this, "getItemSizes", [...arguments]);
  }
  loadIfNeed() {
    return Gt(this, "loadIfNeed", [...arguments]);
  }
}, PZ = (i) => class extends i {
  dispose() {
    const e = this._rowsScrollController;
    e && e.dispose(), super.dispose.apply(this, arguments);
  }
  _refreshDataSource() {
    const e = super._refreshDataSource.apply(this, arguments) || new w().resolve().promise();
    return e.done(this.initVirtualRows.bind(this)), e;
  }
  _loadDataSource() {
    if (this._rowsScrollController && ei(this)) {
      var e;
      const {
        loadPageCount: t
      } = f(this._loadViewportParams) ? this.getLoadPageParams() : {
        loadPageCount: 0
      };
      t >= 1 && ((e = this._dataSource) === null || e === void 0 || e.loadPageCount(t));
    }
    return super._loadDataSource.apply(this, arguments);
  }
  getRowPageSize() {
    const e = this.option("scrolling.rowPageSize"), t = this.pageSize();
    return t && t < e ? t : e;
  }
  reload() {
    const e = this._rowsScrollController || this._dataSource, t = e && e.getItemIndexByPosition(), n = super.reload.apply(this, arguments);
    return n && n.done(() => {
      if (Xt(this) || F.isVirtualRowRendering(this)) {
        const o = this.getRowIndexOffset(), r = Math.floor(t) - o, {
          component: a
        } = this, l = a.getScrollable && a.getScrollable(), d = this.dataSource().operationTypes().sorting;
        if (l && !d && r >= 0) {
          var s;
          const u = a.getRowElement(r), c = u && u[0] && p(u[0]);
          let h = c && ((s = c.position()) === null || s === void 0 ? void 0 : s.top);
          const g = ze.chrome && Number(ze.version ?? 0) >= 91, m = ze.mozilla || g ? 1 : 0;
          h && h > m && (h = Math.round(h + he(c) * (t % 1)), l.scrollTo({
            y: h
          }));
        }
      }
    });
  }
  initVirtualRows() {
    const e = F.isVirtualRowRendering(this);
    if (this._allItems = null, this._loadViewportParams = null, this.option("scrolling.mode") !== "virtual" && !e || !e || this.option(Ce) !== !1 && !this.option("scrolling.rowPageSize")) {
      this._visibleItems = null, this._rowsScrollController = null;
      return;
    }
    const t = !Xt(this) && this.pageIndex() >= this.pageCount() ? this.pageCount() - 1 : this.pageIndex();
    this._rowPageIndex = Math.ceil(t * this.pageSize() / this.getRowPageSize()), this._visibleItems = this.option(Ce) === !1 ? null : [], this._viewportChanging = !1, this._needUpdateViewportAfterLoading = !1, this._rowsScrollController || (this._rowsScrollController = new gR(this.component, this._getRowsScrollDataOptions(), !0), this._rowsScrollController.positionChanged.add(() => {
      var n;
      if (this.option(Ce) === !1) {
        this._viewportChanging = !0, this.loadViewport(), this._viewportChanging = !1;
        return;
      }
      (n = this._dataSource) === null || n === void 0 || n.setViewportItemIndex(this._rowsScrollController.getViewportItemIndex());
    })), this.option(Ce) === !1 && this._updateLoadViewportParams(), this.isLoaded() && this.option(Ce) !== !1 && this._rowsScrollController.load();
  }
  isViewportChanging() {
    return this._viewportChanging;
  }
  _getRowsScrollDataOptions() {
    const e = this, t = function(n) {
      return Nu(n, e._dataSource);
    };
    return {
      pageSize: () => e.getRowPageSize(),
      loadedOffset() {
        var n;
        return Xt(e) && ((n = e._dataSource) === null || n === void 0 ? void 0 : n.lastLoadOptions().skip) || 0;
      },
      loadedItemCount: () => e._itemCount,
      totalItemsCount() {
        return ei(e) ? e.totalItemsCount() : e.option(Ce) === !1 ? e._itemCount : e._items.filter(t).length;
      },
      hasKnownLastPage: () => e.option(Ce) === !1 ? e.hasKnownLastPage() : !0,
      pageIndex(n) {
        return n !== void 0 && (e._rowPageIndex = n), e._rowPageIndex;
      },
      isLoading: () => e.isLoading(),
      pageCount() {
        return Math.ceil(this.totalItemsCount() / this.pageSize()) || 1;
      },
      load() {
        e._rowsScrollController.pageIndex() >= this.pageCount() && (e._rowPageIndex = this.pageCount() - 1, e._rowsScrollController.pageIndex(e._rowPageIndex)), !(!this.items().length && this.totalItemsCount()) && e._rowsScrollController.handleDataChanged((n) => {
          n = n || {}, n.changeType = n.changeType || "refresh", n.items = n.items || e._visibleItems, e._visibleItems.forEach((s, o) => {
            s.rowIndex = o;
          }), e._fireChanged(n);
        });
      },
      updateLoading() {
      },
      itemsCount() {
        return this.items(!0).length;
      },
      correctCount: (n, s, o) => x0(n, s, o, (r, a, l) => r.isNewRow ? a && !l : a && l ? !r.isNewRow : t(r)),
      items(n) {
        let s = e._items;
        if (e.option(Ce)) {
          const o = e.dataSource(), r = o?.virtualItemsCount(), a = r ? r.begin : 0, l = e.getRowPageSize();
          let d = e._rowPageIndex * l - a, u = l;
          if (d < 0)
            return [];
          d && (d = this.correctCount(s, d), s = s.slice(d)), u && (u = this.correctCount(s, u), s = s.slice(0, u));
        }
        return n ? s.filter(t) : s;
      },
      viewportItems(n) {
        return n && e.option(Ce) !== !1 && (e._visibleItems = n), e._visibleItems;
      },
      onChanged() {
      },
      changingDuration() {
        const n = e.dataSource();
        return n != null && n.isLoading() && e.option(Ce) !== !1 ? 300 : n?._renderTime || 0;
      }
    };
  }
  _updateItemsCore(e) {
    const t = this.getRowIndexDelta();
    if (super._updateItemsCore.apply(this, arguments), this.option(Ce) === !1 && F.isVirtualRowRendering(this)) {
      e.changeType === "update" && e.rowIndices.length === 0 && e.cancelEmptyChanges && (e.cancel = !0);
      return;
    }
    const n = this._rowsScrollController;
    if (n) {
      const s = this._visibleItems, o = e.changeType === "refresh" || e.isLiveUpdate;
      if (e.changeType === "append" && e.items && !e.items.length)
        return;
      o || e.changeType === "append" || e.changeType === "prepend" ? (e.cancel = !0, o && n.reset(!0), n.load()) : (e.changeType === "update" ? e.rowIndices.forEach((r, a) => {
        const l = e.changeTypes[a], d = e.items[a];
        l === "update" ? s[r] = d : l === "insert" ? s.splice(r, 0, d) : l === "remove" && s.splice(r, 1);
      }) : (s.forEach((r, a) => {
        s[a] = this._items[a + t] || s[a];
      }), e.items = s), kZ(s));
    }
  }
  _updateLoadViewportParams() {
    const e = this._rowsScrollController.getViewportParams(), t = this.pageSize();
    if (e && !ei(this) && t > 0) {
      const n = this.pageIndex() * t;
      e.skip += n;
    }
    this._loadViewportParams = e;
  }
  _processItems() {
    const e = super._processItems.apply(this, arguments);
    if (this.option(Ce) === !1) {
      const t = this._dataSource;
      let n = t?.lastLoadOptions().skip ?? 0, s, o, r, a = !1, l = [];
      e.forEach((d) => {
        const {
          rowType: u
        } = d, c = Nu(d, t), h = u === "group" && (s || c || o !== "group" && n > 0), g = u === "data" && c && (s || o !== "group");
        !d.isNewRow && f(s) && (h || g) && !(r && !a) && n++, (h || g) && (a = !0), d.isNewRow ? l.push(d) : (l.forEach((m) => {
          m.loadIndex = n;
        }), l = []), d.loadIndex = n, s = c, o = u, r = d.isNewRow;
      }), l.forEach((d) => {
        d.loadIndex = n;
      });
    }
    return e;
  }
  _afterProcessItems(e) {
    if (this._itemCount = e.filter((t) => Nu(t, this._dataSource)).length, f(this._loadViewportParams)) {
      this._updateLoadViewportParams();
      let t = e;
      if (this._allItems = e, e.length) {
        const {
          skipForCurrentPage: n
        } = this.getLoadPageParams(!0), s = e[0].loadIndex + n, {
          take: o
        } = this._loadViewportParams;
        t = e.filter((r) => {
          const a = r.isNewRow && r.loadIndex === s && o === 0, l = r.loadIndex >= s, d = r.loadIndex < s + o || a;
          return l && d;
        });
      }
      return t;
    }
    return super._afterProcessItems.apply(this, arguments);
  }
  _applyChange(e) {
    const t = this, {
      items: n
    } = e, {
      changeType: s
    } = e;
    let {
      removeCount: o
    } = e;
    if (o) {
      const r = s === "prepend";
      o = x0(t._items, o, r, (a, l) => a.rowType === "data" && !a.isNewRow || a.rowType === "group" && (t._dataSource.isGroupItemCountable(a.data) || l)), e.removeCount = o;
    }
    switch (s) {
      case "prepend":
        t._items.unshift.apply(t._items, n), o && t._items.splice(-o);
        break;
      case "append":
        t._items.push.apply(t._items, n), o && t._items.splice(0, o);
        break;
      default:
        super._applyChange(e);
    }
  }
  items(e) {
    return e ? this._allItems || this._items : this._visibleItems || this._items;
  }
  getRowIndexDelta() {
    let e = 0;
    if (this.option(Ce)) {
      const t = this._visibleItems;
      t && t[0] && (e = this._items.indexOf(t[0]));
    }
    return e < 0 ? 0 : e;
  }
  getRowIndexOffset(e, t) {
    let n = 0;
    const s = this.dataSource(), o = this._rowsScrollController, r = this.option(Ce) === !1, a = ei(this);
    if (o && !e)
      if (r && f(this._loadViewportParams)) {
        const {
          skipForCurrentPage: d,
          pageIndex: u
        } = this.getLoadPageParams(!0), c = this.items(!0);
        if (n = a ? u * this.pageSize() : 0, c.length) {
          const h = c[0].loadIndex;
          n += c.filter((g) => g.loadIndex < h + d).length;
        }
      } else
        n = o.beginPageIndex() * o.pageSize();
    else if (a && r && s) {
      var l;
      const d = s.lastLoadOptions();
      t && (l = d.skips) !== null && l !== void 0 && l.length ? n = d.skips.reduce((u, c) => u + c, 0) : n = d.skip ?? 0;
    } else
      Xt(this) && s && (n = s.beginPageIndex() * s.pageSize());
    return n;
  }
  getDataIndex() {
    return this.option(Ce) === !1 ? this.getRowIndexOffset(!0, !0) : super.getDataIndex.apply(this, arguments);
  }
  viewportSize() {
    const e = this._rowsScrollController, t = this._dataSource, n = e?.viewportSize.apply(e, arguments);
    return this.option(Ce) === !1 ? n : t?.viewportSize.apply(t, arguments);
  }
  viewportHeight(e, t) {
    var n;
    (n = this._rowsScrollController) === null || n === void 0 || n.viewportHeight(e, t);
  }
  viewportItemSize() {
    const e = this._rowsScrollController, t = this._dataSource, n = e?.viewportItemSize.apply(e, arguments);
    return this.option(Ce) === !1 ? n : t?.viewportItemSize.apply(t, arguments);
  }
  setViewportPosition() {
    const e = this._rowsScrollController, t = this._dataSource;
    this._isPaging = !1, e ? e.setViewportPosition.apply(e, arguments) : t?.setViewportPosition.apply(t, arguments);
  }
  setContentItemSizes(e) {
    const t = this._rowsScrollController, n = this._dataSource, s = t?.setContentItemSizes(e);
    return this.option(Ce) === !1 ? s : n?.setContentItemSizes(e);
  }
  getPreloadedRowCount() {
    const e = this.option("scrolling.preloadedRowCount"), t = this.option("scrolling.preloadEnabled");
    if (f(e))
      return e;
    const n = this.viewportSize();
    return t ? 2 * n : n;
  }
  getLoadPageParams(e) {
    var t, n;
    const s = this.pageSize(), o = this._loadViewportParams, r = (t = this._dataSource) === null || t === void 0 ? void 0 : t.lastLoadOptions(), a = r?.pageIndex || 0, l = r?.take || 0, d = this._rowsScrollController.isScrollingBack(), u = d ? this.getPreloadedRowCount() : 0, c = d ? 0 : this.getPreloadedRowCount(), h = ((n = this._dataSource) === null || n === void 0 ? void 0 : n.totalCountCorrection()) || 0, g = Math.max(0, o.skip - u), m = e ? a : Math.floor(s ? g / s : 0), C = m * s, v = o.skip - C, E = o.take + v + c - h, V = Math.ceil(s ? (e ? l : E) / s : 0);
    return {
      pageIndex: m,
      loadPageCount: Math.max(1, V),
      skipForCurrentPage: Math.max(0, v)
    };
  }
  _updateVisiblePageIndex(e) {
    if (!this._rowsScrollController)
      return;
    if (f(e)) {
      this._silentOption("paging.pageIndex", e), this.pageChanged.fire();
      return;
    }
    const t = this._rowsScrollController.getViewportItemIndex(), n = Math.floor(t / this.pageSize());
    this.pageIndex() !== n && (this._silentOption("paging.pageIndex", n), this.updateItems({
      changeType: "pageIndex"
    }));
  }
  _getChangedLoadParams() {
    const e = this.getLoadPageParams(!0), {
      pageIndex: t,
      loadPageCount: n
    } = this.getLoadPageParams(), s = this._pageIndexIsValid(t);
    let o = null;
    return !this._isLoading && s && (t !== e.pageIndex || n !== e.loadPageCount) && (o = {
      pageIndex: t,
      loadPageCount: n
    }), o;
  }
  _pageIndexIsValid(e) {
    let t = !0;
    return (Ai(this) && this.hasKnownLastPage() || Xt(this)) && (t = e * this.pageSize() < this.totalItemsCount()), t;
  }
  _loadItems(e, t) {
    const n = ei(this), s = this._dataSource, o = this._getChangedLoadParams(), r = s?.loadPageCount() ?? 0, a = this.pageSize() * r, l = s?.pageIndex() ?? 0, d = o?.pageIndex === l, u = Ai(this) && this.totalItemsCount() < a, c = this.option("editing.refreshMode") === "repaint", h = o?.pageIndex > l;
    let g = !1;
    if (!s || n && e && (c && t || h || d && u))
      return g;
    if (n && this._isLoading && (this._needUpdateViewportAfterLoading = !0), n && o) {
      g = !0, s.pageIndex(o.pageIndex), s.loadPageCount(o.loadPageCount), this._repaintChangesOnly = !0, this._needUpdateDimensions = !0;
      const m = this._viewportChanging;
      this.load().always(() => {
        this._repaintChangesOnly = void 0, this._needUpdateDimensions = void 0;
      }).done(() => {
        const C = this.pageCount() > 0 && this.pageIndex() === this.pageCount() - 1;
        (m || C) && this._updateVisiblePageIndex(), this._needUpdateViewportAfterLoading && (this._needUpdateViewportAfterLoading = !1, this.loadViewport({
          checkLoadedParamsOnly: !0
        }));
      });
    }
    return g;
  }
  loadViewport(e) {
    const {
      checkLoadedParamsOnly: t,
      checkLoading: n,
      viewportIsNotFilled: s
    } = e ?? {};
    if (ei(this) || F.isVirtualRowRendering(this)) {
      var r;
      this._updateLoadViewportParams();
      const l = this._loadItems(n, !s), d = (r = this._dataSource) === null || r === void 0 ? void 0 : r.isCustomLoading(), u = n && !d && this._isLoading;
      if (!(l || u || t)) {
        var a;
        const h = !((a = this._editingController) !== null && a !== void 0 && (a = a.getChanges()) !== null && a !== void 0 && a.length);
        this.updateItems({
          repaintChangesOnly: !0,
          needUpdateDimensions: !0,
          useProcessedItemsCache: h,
          cancelEmptyChanges: !0
        });
      }
    }
  }
  updateViewport() {
    var e;
    const t = this.viewportSize(), n = this.items().length, s = t > n, o = ((e = this._loadViewportParams) === null || e === void 0 ? void 0 : e.take) ?? 0, r = this._rowsScrollController, a = r?.getViewportParams().take;
    (s || o < a) && !this._isPaging && n && this.loadViewport({
      checkLoading: !0,
      viewportIsNotFilled: s
    });
  }
  loadIfNeed() {
    if (this.option(Ce) === !1)
      return;
    const e = this._rowsScrollController;
    e && e.loadIfNeed();
    const t = this._dataSource;
    return t && t.loadIfNeed();
  }
  getItemSize() {
    const e = this._rowsScrollController;
    if (e)
      return e.getItemSize.apply(e, arguments);
    const t = this._dataSource;
    return t && t.getItemSize.apply(t, arguments);
  }
  getItemSizes() {
    const e = this._rowsScrollController;
    if (e)
      return e.getItemSizes.apply(e, arguments);
    const t = this._dataSource;
    return t && t.getItemSizes.apply(t, arguments);
  }
  getContentOffset() {
    const e = this._rowsScrollController;
    if (e)
      return e.getContentOffset.apply(e, arguments);
    const t = this._dataSource;
    return t && t.getContentOffset.apply(t, arguments);
  }
  refresh(e) {
    const t = this._dataSource;
    return t && e && e.load && Ai(this) && t.resetCurrentTotalCount(), super.refresh.apply(this, arguments);
  }
  topItemIndex() {
    var e;
    return (e = this._loadViewportParams) === null || e === void 0 ? void 0 : e.skip;
  }
  bottomItemIndex() {
    const e = this._loadViewportParams;
    return e && e.skip + e.take;
  }
  virtualItemsCount() {
    const e = this._rowsScrollController;
    if (e)
      return e.virtualItemsCount.apply(e, arguments);
    const t = this._dataSource;
    return t?.virtualItemsCount.apply(t, arguments);
  }
  pageIndex(e) {
    const t = ei(this), n = this._rowsScrollController;
    return this.option(Ce) === !1 && t && n && e === void 0 ? this.option("paging.pageIndex") ?? 0 : super.pageIndex.apply(this, arguments);
  }
  _fireChanged(e) {
    super._fireChanged.apply(this, arguments);
    const {
      operationTypes: t
    } = e;
    if (this.option(Ce) === !1 && ei(this) && t) {
      const {
        fullReload: n,
        pageIndex: s
      } = t;
      e.isDataChanged && !n && s && this._updateVisiblePageIndex(this._dataSource.pageIndex());
    }
  }
  _getPagingOptionValue(e) {
    let t = super._getPagingOptionValue.apply(this, arguments);
    return this.option(Ce) === !1 && ei(this) && (t = this[e]()), t;
  }
  isEmpty() {
    return this.option(Ce) === !1 ? !this.items(!0).length : super.isEmpty.apply(this, arguments);
  }
  isLastPageLoaded() {
    let e = !1;
    if (this.option(Ce) === !1 && ei(this)) {
      const {
        pageIndex: t,
        loadPageCount: n
      } = this.getLoadPageParams(!0), s = this.pageCount();
      e = t + n >= s;
    } else
      e = super.isLastPageLoaded.apply(this, arguments);
    return e;
  }
  reset() {
    this._itemCount = 0, this._allItems = null, super.reset.apply(this, arguments);
  }
  _applyFilter() {
    var e;
    return (e = this._dataSource) === null || e === void 0 || e.loadPageCount(1), super._applyFilter.apply(this, arguments);
  }
  getVirtualContentSize() {
    var e;
    return (e = this._dataSource) === null || e === void 0 ? void 0 : e.getVirtualContentSize.apply(this._dataSource, arguments);
  }
  setViewportItemIndex() {
    var e;
    return (e = this._dataSource) === null || e === void 0 ? void 0 : e.setViewportItemIndex.apply(this._dataSource, arguments);
  }
}, MZ = (i) => class extends i {
  dispose() {
    super.dispose.apply(this, arguments), clearTimeout(this._resizeTimeout);
  }
  _updateMasterDataGridCore(e) {
    return W(super._updateMasterDataGridCore.apply(this, arguments)).done((t) => {
      const n = Xt(e) && e.option(Ce) === !1;
      !t && n && e.getScrollable() && e.updateDimensions();
    });
  }
  hasResizeTimeout() {
    return f(this._resizeTimeout);
  }
  resize() {
    let e;
    if (Xt(this) || F.isVirtualRowRendering(this)) {
      clearTimeout(this._resizeTimeout), this._resizeTimeout = null;
      const t = /* @__PURE__ */ new Date() - this._lastTime, n = this.option("scrolling.updateTimeout");
      this._lastTime && t < n ? (e = new w(), this._resizeTimeout = setTimeout(() => {
        this._resizeTimeout = null, super.resize.apply(this).done(e.resolve).fail(e.reject), this._lastTime = /* @__PURE__ */ new Date();
      }, n), this._lastTime = /* @__PURE__ */ new Date()) : (e = super.resize.apply(this), this._dataController.isLoaded() && (this._lastTime = /* @__PURE__ */ new Date()));
    } else
      e = super.resize.apply(this);
    return e;
  }
}, BZ = (i) => class extends i {
  init() {
    var e;
    super.init(), this._dataController.pageChanged.add((t) => {
      const n = this._scrollTop;
      this.scrollToPage(t ?? this._dataController.pageIndex()), this.option(Ce) === !1 && this._scrollTop === n && this._dataController.updateViewport();
    }), this._dataController.dataSourceChanged.add(() => {
      !this._scrollTop && this._scrollToCurrentPageOnResize();
    }), (e = this._dataController.stateLoaded) === null || e === void 0 || e.add(() => {
      this._scrollToCurrentPageOnResize();
    }), this._scrollToCurrentPageOnResize();
  }
  dispose() {
    clearTimeout(this._scrollTimeoutID), super.dispose();
  }
  _scrollToCurrentPageOnResize() {
    if (this._dataController.pageIndex() > 0) {
      const e = () => {
        this.resizeCompleted.remove(e), this.scrollToPage(this._dataController.pageIndex());
      };
      this.resizeCompleted.add(e);
    }
  }
  scrollToPage(e) {
    const t = this._dataController ? this._dataController.pageSize() : 0;
    let n;
    if (Xt(this) || Ai(this)) {
      const s = this._dataController.getItemSize(), o = this._dataController.getItemSizes(), r = e * t;
      n = r * s;
      for (const a in o)
        parseInt(a) < r && (n += o[a] - s);
    } else
      n = 0;
    this.scrollTo({
      y: n,
      x: this._scrollLeft
    });
  }
  renderDelayedTemplates() {
    this.waitAsyncTemplates().done(() => {
      this._updateContentPosition(!0);
    }), super.renderDelayedTemplates.apply(this, arguments);
  }
  _renderCore(e) {
    const t = /* @__PURE__ */ new Date(), n = super._renderCore.apply(this, arguments), s = this._dataController._dataSource;
    if (s && e) {
      const o = e.items ? e.items.length : 20, r = this._dataController.viewportSize() || 20;
      F.isVirtualRowRendering(this) && o > 0 && this.option(Ce) !== !1 ? s._renderTime = (/* @__PURE__ */ new Date() - t) * r / o : s._renderTime = /* @__PURE__ */ new Date() - t;
    }
    return n;
  }
  _getRowElements(e) {
    const t = super._getRowElements(e);
    return t && t.not(".dx-virtual-row");
  }
  _removeRowsElements(e, t, n) {
    let s = this._getRowElements(e).toArray();
    n === "append" ? s = s.slice(0, t) : s = s.slice(-t), s.map((o) => {
      const r = p(o);
      this._errorHandlingController && this._errorHandlingController.removeErrorRow(r.next()), r.remove();
    });
  }
  _updateContent(e, t) {
    let n;
    const s = this._findContentElement(), o = t && t.changeType, r = w(), a = s.children().first();
    return o === "append" || o === "prepend" ? this.waitAsyncTemplates().done(() => {
      const l = this._getBodies(e);
      l.length === 1 ? this._getBodies(a)[o === "append" ? "append" : "prepend"](l.children()) : l[o === "append" ? "appendTo" : "prependTo"](a), e.remove(), n = this._getFreeSpaceRowElements(a), y0(n, mR), t.removeCount && this._removeRowsElements(a, t.removeCount, o), this._restoreErrorRow(a), r.resolve();
    }).fail(r.reject) : super._updateContent.apply(this, arguments).done(() => {
      o === "update" && this._restoreErrorRow(a), r.resolve();
    }).fail(r.reject), r.promise().done(() => {
      this._updateBottomLoading();
    });
  }
  _addVirtualRow(e, t, n, s) {
    if (!s)
      return;
    let o = this._createEmptyRow("dx-virtual-row", t, s);
    o = this._wrapRowIfNeed(e, o), this._appendEmptyRow(e, o, n);
  }
  _updateContentItemSizes() {
    const e = this._getRowHeights(), t = this._correctRowHeights(e);
    this._dataController.setContentItemSizes(t);
  }
  _updateViewportSize(e, t) {
    f(e) || (e = this._hasHeight ? he(this.element()) : he(fe())), this._dataController.viewportHeight(e, t);
  }
  _getRowHeights() {
    var e, t;
    const n = (e = this._editingController) === null || e === void 0 || (t = e.isPopupEditMode) === null || t === void 0 ? void 0 : t.call(e);
    let s = this._getRowElements(this._tableElement).toArray();
    return n && (s = s.filter((o) => !p(o).hasClass(RZ))), s.map((o) => Ge(o).height);
  }
  _correctRowHeights(e) {
    const t = this._dataController, n = t._dataSource, s = [], o = t.getVisibleRows();
    let r = 0, a = !0, l = -1;
    for (let d = 0; d < e.length; d++) {
      const u = o[d];
      f(u) && (this.option(Ce) === !1 ? (l >= 0 && l !== u.loadIndex && (s.push(r), r = 0), l = u.loadIndex) : Nu(u, n) && (a ? a = !1 : (s.push(r), r = 0)), r += e[d]);
    }
    return r > 0 && s.push(r), s;
  }
  _updateContentPosition(e) {
    const t = this._rowHeight || 20;
    if (this._dataController.viewportItemSize(t), Xt(this) || F.isVirtualRowRendering(this)) {
      if (this._dataController.isEmpty())
        return;
      e || this._updateContentItemSizes();
      const s = this._dataController.getContentOffset("begin"), o = this._dataController.getContentOffset("end"), r = this.getTableElements(), a = r.children("tbody").children(".dx-virtual-row");
      y0(a, "dx-virtual-row"), r.each((l, d) => {
        const u = l > 0, c = this._isFixedTableRendering;
        this._isFixedTableRendering = u, this._addVirtualRow(p(d), u, "top", s), this._addVirtualRow(p(d), u, "bottom", o), this._isFixedTableRendering = c;
      });
    }
  }
  _isTableLinesDisplaysCorrect(e) {
    return e.find(".dx-column-lines").length > 0 === this.option("showColumnLines");
  }
  _isColumnElementsEqual(e, t) {
    let n = e.length === t.length;
    return n && y(e, (s, o) => {
      if (o.style.width !== t[s].style.width)
        return n = !1, n;
    }), n;
  }
  _getCellClasses(e) {
    const t = [], {
      cssClass: n
    } = e, s = e.command === "expand";
    return n && t.push(n), s && t.push(this.addWidgetPrefix("group-space")), t;
  }
  _findBottomLoadPanel(e) {
    const t = e || this.element(), n = t && t.find(`.${this.addWidgetPrefix("bottom-load-panel")}`);
    if (n && n.length)
      return n;
  }
  _updateBottomLoading() {
    const e = this, t = Xt(this), n = Ai(this), s = !e._dataController.hasKnownLastPage() && e._dataController.isLoaded() && (t || n), o = e._findContentElement(), r = e._findBottomLoadPanel(o);
    s ? r || p("<div>").addClass(e.addWidgetPrefix("bottom-load-panel")).append(e._createComponent(p("<div>"), Dn, {
      elementAttr: {
        role: null,
        "aria-label": null
      }
    }).$element()).appendTo(o) : r && r.remove();
  }
  _handleScroll(e) {
    const t = this.option(Ce) === !0, n = e.scrollOffset.top === 0, o = this._scrollTop !== e.scrollOffset.top || e.forceUpdateScrollPosition, r = this._hasHeight || !t && n;
    o && r && this._rowHeight && (this._scrollTop = e.scrollOffset.top, (Xt(this) || this.option("scrolling.rowRenderingMode") !== "standard") && this.option(Ce) === !1 && (this._updateContentItemSizes(), this._updateViewportSize(null, this._scrollTop)), this._dataController.setViewportPosition(e.scrollOffset.top)), super._handleScroll.apply(this, arguments);
  }
  _needUpdateRowHeight(e) {
    return super._needUpdateRowHeight.apply(this, arguments) || e > 0 && Ai(this) && !F.isVirtualRowRendering(this);
  }
  _updateRowHeight() {
    if (super._updateRowHeight.apply(this, arguments), this._rowHeight) {
      this._updateContentPosition();
      const e = this._hasHeight ? he(this.element()) : he(fe());
      this.option(Ce) === !1 ? (this._updateViewportSize(e), this._dataController.updateViewport()) : this._dataController.viewportSize(Math.ceil(e / this._rowHeight));
    }
  }
  updateFreeSpaceRowHeight() {
    const e = super.updateFreeSpaceRowHeight.apply(this, arguments);
    return e && this._updateContentPosition(), e;
  }
  setLoading(e, t) {
    const n = this._dataController, s = n.pageIndex() > 0 && n.isLoaded() && !!this._findBottomLoadPanel();
    this.option(Ce) === !1 && e && n.isViewportChanging() || (s && (e = !1), super.setLoading.call(this, e, t));
  }
  isGridDragging() {
    return this.component.option("isDragging");
  }
  throwHeightWarningIfNeed() {
    const e = this.isGridDragging();
    if (this._hasHeight === void 0 || e)
      return;
    !this._hasHeight && ei(this) && !this._heightWarningIsThrown && (this._heightWarningIsThrown = !0, _e.log("W1025"));
  }
  _resizeCore() {
    const e = this, t = e.element();
    super._resizeCore(), this.throwHeightWarningIfNeed(), e.component.$element() && !e._windowScroll && pa(t) && (e._windowScroll = pR(t, (n) => {
      !e._hasHeight && e._rowHeight && e._dataController.setViewportPosition(n);
    }, e.component.$element()), e.on("disposing", () => {
      e._windowScroll.dispose();
    })), this.option(Ce) !== !1 && e.loadIfNeed();
  }
  loadIfNeed() {
    var e, t;
    (e = this._dataController) === null || e === void 0 || (t = e.loadIfNeed) === null || t === void 0 || t.call(e);
  }
  _restoreErrorRow(e) {
    if (this.option(Ce) === !1) {
      var t;
      (t = this._errorHandlingController) === null || t === void 0 || t.removeErrorRow();
    }
    super._restoreErrorRow.apply(this, arguments);
  }
}, $Z = {
  defaultOptions: () => ({
    scrolling: {
      timeout: 300,
      updateTimeout: 300,
      minTimeout: 0,
      renderingThreshold: 100,
      removeInvisiblePages: !0,
      rowPageSize: 5,
      prerenderedRowChunkSize: 1,
      mode: "standard",
      preloadEnabled: !1,
      rowRenderingMode: "standard",
      loadTwoPagesOnStart: !1,
      legacyMode: !1,
      prerenderedRowCount: 1
    }
  }),
  extenders: {
    controllers: {
      data: PZ,
      resizing: MZ
    },
    views: {
      rowsView: BZ
    }
  }
};
J.registerModule("virtualScrolling", $Z);
gh.extend(VZ);
const bC = (i, e) => {
  const t = p($t.getWindow()), {
    top: n
  } = i.offset();
  let s;
  if ($e(e)) {
    if (e < n)
      return n - e;
    s = Ju(t) - e + t.scrollTop();
  } else {
    const o = n - t.scrollTop(), r = Ju(t) - o - he(i);
    s = Math.max(o, r);
  }
  return 0.9 * s;
};
class Jp extends tC {
  _getDefaultOptions() {
    return x(super._getDefaultOptions(), {
      orientation: "horizontal",
      tabIndex: null,
      onHoverStart: M
    });
  }
  _initDataAdapter() {
    this._dataAdapter = this.option("_dataAdapter"), this._dataAdapter || super._initDataAdapter();
  }
  _renderContentImpl() {
    this._renderContextMenuOverlay(), super._renderContentImpl();
    const e = this._dataAdapter.getNodeByKey(this.option("_parentKey"));
    e && this._renderItems(this._getChildNodes(e)), this._renderDelimiter();
  }
  _renderDelimiter() {
    this.$contentDelimiter = p("<div>").appendTo(this._itemContainer()).addClass("dx-context-menu-content-delimiter");
  }
  _getOverlayOptions() {
    return x(!0, super._getOverlayOptions(), {
      onPositioned: this._overlayPositionedActionHandler.bind(this),
      position: {
        precise: !0
      }
    });
  }
  _overlayPositionedActionHandler(e) {
    this._showDelimiter(e);
  }
  _hoverEndHandler(e) {
    super._hoverEndHandler(e), this._toggleFocusClass(!1, e.currentTarget);
  }
  _isMenuHorizontal() {
    return this.option("orientation") === "horizontal";
  }
  _hoverStartHandler(e) {
    this.option("onHoverStart")(e), super._hoverStartHandler(e), this._toggleFocusClass(!0, e.currentTarget);
  }
  _drawSubmenu(e) {
    this._actions.onShowing({
      rootItem: ee(e),
      submenu: this
    }), super._drawSubmenu(e), this._actions.onShown({
      rootItem: ee(e),
      submenu: this
    });
  }
  _hideSubmenu(e) {
    this._actions.onHiding({
      cancel: !0,
      rootItem: ee(e),
      submenu: this
    }), super._hideSubmenu(e), this._actions.onHidden({
      rootItem: ee(e),
      submenu: this
    });
  }
  _showDelimiter(e) {
    if (!this.$contentDelimiter)
      return;
    const t = this._itemContainer().children(".dx-submenu").eq(0), n = this.option("position").of.find(".dx-context-menu-container-border"), s = {
      of: t,
      precise: !0
    }, o = e.position, r = o.v.location, a = o.h.location, l = n.offset(), d = Math.round(l.left), u = Math.round(l.top), c = ne(n), h = le(n), g = ne(t), m = le(t);
    this.$contentDelimiter.css("display", "block"), xl(this.$contentDelimiter, this._isMenuHorizontal() ? c < g ? c : g : 3), js(this.$contentDelimiter, this._isMenuHorizontal() ? 3 : h < m ? h : m), this._isMenuHorizontal() ? r > u ? Math.round(a) === d ? (s.offset = "0 -2.5", s.at = s.my = "left top") : (s.offset = "0 -2.5", s.at = s.my = "right top") : (js(this.$contentDelimiter, 5), Math.round(a) === d ? (s.offset = "0 5", s.at = s.my = "left bottom") : (s.offset = "0 5", s.at = s.my = "right bottom")) : a > d ? Math.round(r) === u ? (s.offset = "-2.5 0", s.at = s.my = "left top") : (s.offset = "-2.5 0", s.at = s.my = "left bottom") : Math.round(r) === u ? (s.offset = "2.5 0", s.at = s.my = "right top") : (s.offset = "2.5 0", s.at = s.my = "right bottom"), Un.setup(this.$contentDelimiter, s);
  }
  _getContextMenuPosition() {
    return this.option("position");
  }
  isOverlayVisible() {
    return this._overlay.option("visible");
  }
  getOverlayContent() {
    return this._overlay.$content();
  }
}
const Lu = "dx-menu-adaptive-mode", NZ = `${Lu}-overlay-wrapper`, LZ = {
  show: 50,
  hide: 300
}, b0 = ["onSubmenuShowing", "onSubmenuShown", "onSubmenuHiding", "onSubmenuHidden", "onItemContextMenu", "onItemClick", "onSelectionChanged", "onItemRendered"];
class qm extends eC {
  _getDefaultOptions() {
    return x(super._getDefaultOptions(), {
      orientation: "horizontal",
      submenuDirection: "auto",
      showFirstSubmenuMode: {
        name: "onClick",
        delay: {
          show: 50,
          hide: 300
        }
      },
      hideSubmenuOnMouseLeave: !1,
      onSubmenuShowing: null,
      onSubmenuShown: null,
      onSubmenuHiding: null,
      onSubmenuHidden: null,
      adaptivityEnabled: !1
    });
  }
  _setOptionsByReference() {
    super._setOptionsByReference(), x(this._optionsByReference, {
      animation: !0,
      selectedItem: !0
    });
  }
  _itemElements() {
    const e = super._itemElements(), t = this._submenuItemElements();
    return e.add(t);
  }
  _submenuItemElements() {
    let e = [];
    const t = this._submenus.length && this._submenus[0];
    return t && t.itemsContainer() && (e = t.itemsContainer().find(".dx-menu-item")), e;
  }
  _focusTarget() {
    return this.$element();
  }
  _isMenuHorizontal() {
    return this.option("orientation") === "horizontal";
  }
  _moveFocus(e) {
    const t = this._getAvailableItems(), n = this._isMenuHorizontal(), s = this._getActiveItem(!0);
    let o, r, a, l;
    switch (e) {
      case "up":
        r = n ? "showSubmenu" : this._getItemsNavigationOperation("prevItem"), o = n ? s : t, a = this._getKeyboardNavigationAction(r, o), l = a();
        break;
      case "down":
        r = n ? "showSubmenu" : this._getItemsNavigationOperation("nextItem"), o = n ? s : t, a = this._getKeyboardNavigationAction(r, o), l = a();
        break;
      case "right":
        r = n ? this._getItemsNavigationOperation("nextItem") : "showSubmenu", o = n ? t : s, a = this._getKeyboardNavigationAction(r, o), l = a();
        break;
      case "left":
        r = n ? this._getItemsNavigationOperation("prevItem") : "showSubmenu", o = n ? t : s, a = this._getKeyboardNavigationAction(r, o), l = a();
        break;
      default:
        return super._moveFocus(e);
    }
    l && l.length !== 0 && this.option("focusedElement", ee(l));
  }
  _getItemsNavigationOperation(e) {
    let t = e;
    return this.option("rtlEnabled") && (t = e === "prevItem" ? "nextItem" : "prevItem"), t;
  }
  _getKeyboardNavigationAction(e, t) {
    let n = M;
    switch (e) {
      case "showSubmenu":
        t.hasClass("dx-state-disabled") || (n = this._showSubmenu.bind(this, t));
        break;
      case "nextItem":
        n = this._nextItem.bind(this, t);
        break;
      case "prevItem":
        n = this._prevItem.bind(this, t);
    }
    return n;
  }
  _clean() {
    super._clean(), this.option("templatesRenderAsynchronously") && clearTimeout(this._resizeEventTimer);
  }
  _visibilityChanged(e) {
    e && (this._menuItemsWidth || this._updateItemsWidthCache(), this._dimensionChanged());
  }
  _isAdaptivityEnabled() {
    return this.option("adaptivityEnabled") && this.option("orientation") === "horizontal";
  }
  _updateItemsWidthCache() {
    const e = this.$element().find("ul").first().children("li").children(".dx-menu-item");
    this._menuItemsWidth = this._getSummaryItemsSize("width", e, !0);
  }
  _dimensionChanged() {
    if (!this._isAdaptivityEnabled())
      return;
    const e = Ee(this.$element());
    this._toggleAdaptiveMode(this._menuItemsWidth > e);
  }
  _init() {
    super._init(), this._submenus = [];
  }
  _initActions() {
    this._actions = {}, y(b0, (e, t) => {
      this._actions[t] = this._createActionByOption(t);
    });
  }
  _initMarkup() {
    this._visibleSubmenu = null, this.$element().addClass("dx-menu"), super._initMarkup(), this._addCustomCssClass(this.$element()), this.setAria("role", "menubar");
  }
  _setAriaRole(e) {
    const t = this._isAdaptivityEnabled() && e ? void 0 : "menubar";
    this.setAria({
      role: t
    });
  }
  _render() {
    super._render(), this._initAdaptivity();
  }
  _isTargetOutOfComponent(e) {
    const t = p(e).closest(".dx-menu").length !== 0, n = p(e).closest(".dx-context-menu").length !== 0;
    return !(t || n);
  }
  _focusOutHandler(e) {
    const {
      relatedTarget: t
    } = e;
    t && this._isTargetOutOfComponent(t) && this._hideVisibleSubmenu(), super._focusOutHandler(e);
  }
  _renderHamburgerButton() {
    return this._hamburger = new wt(p("<div>").addClass("dx-menu-hamburger-button"), {
      icon: "menu",
      activeStateEnabled: !1,
      onClick: this._toggleTreeView.bind(this)
    }), this._hamburger.$element();
  }
  _toggleTreeView(e) {
    pe(e) && (e = !this._overlay.option("visible")), this._overlay.option("visible", e), e && this._treeView.focus(), this._toggleHamburgerActiveState(e);
  }
  _toggleHamburgerActiveState(e) {
    this._hamburger && this._hamburger.$element().toggleClass("dx-state-active", e);
  }
  _toggleAdaptiveMode(e) {
    const t = this.$element().find(".dx-menu-horizontal"), n = this.$element().find(`.${Lu}`);
    e ? this._hideVisibleSubmenu() : (this._treeView && this._treeView.collapseAll(), this._overlay && this._toggleTreeView(e)), this._setAriaRole(e), t.toggle(!e), n.toggle(e);
  }
  _removeAdaptivity() {
    this._$adaptiveContainer && (this._toggleAdaptiveMode(!1), this._$adaptiveContainer.remove(), this._$adaptiveContainer = null, this._treeView = null, this._hamburger = null, this._overlay = null);
  }
  _treeviewItemClickHandler(e) {
    this._actions.onItemClick(e), e.node.children.length || this._toggleTreeView(!1);
  }
  _getAdaptiveOverlayOptions() {
    const t = this.option("rtlEnabled") ? "right" : "left";
    return {
      _ignoreFunctionValueDeprecation: !0,
      maxHeight: () => bC(this.$element()),
      deferRendering: !1,
      shading: !1,
      animation: !1,
      hideOnParentScroll: !0,
      onHidden: () => {
        this._toggleHamburgerActiveState(!1);
      },
      height: "auto",
      hideOnOutsideClick: (n) => !p(n.target).closest(".dx-menu-hamburger-button").length,
      position: {
        collision: "flipfit",
        at: `bottom ${t}`,
        my: `top ${t}`,
        of: this._hamburger.$element()
      }
    };
  }
  _getTreeViewOptions() {
    const e = {};
    return y(["rtlEnabled", "width", "accessKey", "activeStateEnabled", "animation", "dataSource", "disabled", "displayExpr", "displayExpr", "focusStateEnabled", "hint", "hoverStateEnabled", "itemsExpr", "items", "itemTemplate", "selectedExpr", "selectionMode", "tabIndex", "visible"], (t, n) => {
      e[n] = this.option(n);
    }), y(["onItemContextMenu", "onSelectionChanged", "onItemRendered"], (t, n) => {
      e[n] = (s) => {
        this._actions[n](s);
      };
    }), x(e, {
      dataSource: this.getDataSource(),
      animationEnabled: !!this.option("animation"),
      onItemClick: this._treeviewItemClickHandler.bind(this),
      onItemExpanded: (t) => {
        this._overlay.repaint(), this._actions.onSubmenuShown(t);
      },
      onItemCollapsed: (t) => {
        this._overlay.repaint(), this._actions.onSubmenuHidden(t);
      },
      selectNodesRecursive: !1,
      selectByClick: this.option("selectByClick"),
      expandEvent: "click",
      _supportItemUrl: !0
    });
  }
  _initAdaptivity() {
    if (!this._isAdaptivityEnabled())
      return;
    this._$adaptiveContainer = p("<div>").addClass(Lu);
    const e = this._renderHamburgerButton();
    this._treeView = this._createComponent(p("<div>"), xd, this._getTreeViewOptions()), this._overlay = this._createComponent(p("<div>"), Tn, this._getAdaptiveOverlayOptions()), this._overlay.$content().append(this._treeView.$element()).addClass(Lu).addClass(this.option("cssClass")), this._overlay.$wrapper().addClass(NZ), this._$adaptiveContainer.append(e), this._$adaptiveContainer.append(this._overlay.$element()), this.$element().append(this._$adaptiveContainer), this._updateItemsWidthCache(), this._dimensionChanged();
  }
  _getDelay(e) {
    const {
      delay: t
    } = this.option("showFirstSubmenuMode");
    return f(t) ? X(t) ? t[e] : t : LZ[e];
  }
  _keyboardHandler(e) {
    return super._keyboardHandler(e, !!this._visibleSubmenu);
  }
  _renderContainer() {
    const e = p("<div>");
    return e.appendTo(this.$element()).addClass(this._isMenuHorizontal() ? "dx-menu-horizontal" : "dx-menu-vertical"), super._renderContainer(e);
  }
  _renderSubmenuItems(e, t) {
    const n = this._createSubmenu(e, t);
    return this._submenus.push(n), this._renderBorderElement(t), n;
  }
  _getKeyboardListeners() {
    return super._getKeyboardListeners().concat(this._visibleSubmenu);
  }
  _createSubmenu(e, t) {
    const n = p("<div>").addClass("dx-context-menu").appendTo(t), s = this._getChildNodes(e), o = this._createComponent(n, Jp, x(this._getSubmenuOptions(), {
      _dataAdapter: this._dataAdapter,
      _parentKey: e.internalFields.key,
      items: s,
      onHoverStart: this._clearTimeouts.bind(this),
      position: this.getSubmenuPosition(t)
    }));
    return this._attachSubmenuHandlers(t, o), o;
  }
  _getSubmenuOptions() {
    const e = p("<div>"), t = this._isMenuHorizontal();
    return {
      itemTemplate: this.option("itemTemplate"),
      target: e,
      orientation: this.option("orientation"),
      selectionMode: this.option("selectionMode"),
      cssClass: this.option("cssClass"),
      selectByClick: this.option("selectByClick"),
      hoverStateEnabled: this.option("hoverStateEnabled"),
      activeStateEnabled: this.option("activeStateEnabled"),
      focusStateEnabled: this.option("focusStateEnabled"),
      animation: this.option("animation"),
      showSubmenuMode: this.option("showSubmenuMode"),
      displayExpr: this.option("displayExpr"),
      disabledExpr: this.option("disabledExpr"),
      selectedExpr: this.option("selectedExpr"),
      itemsExpr: this.option("itemsExpr"),
      onFocusedItemChanged: (n) => {
        n.component.option("visible") && this.option("focusedElement", n.component.option("focusedElement"));
      },
      onSelectionChanged: this._nestedItemOnSelectionChangedHandler.bind(this),
      onItemClick: this._nestedItemOnItemClickHandler.bind(this),
      onItemRendered: this._nestedItemOnItemRenderedHandler.bind(this),
      onLeftFirstItem: t ? null : this._moveMainMenuFocus.bind(this, "prevItem"),
      onLeftLastItem: t ? null : this._moveMainMenuFocus.bind(this, "nextItem"),
      onCloseRootSubmenu: this._moveMainMenuFocus.bind(this, t ? "prevItem" : null),
      onExpandLastSubmenu: t ? this._moveMainMenuFocus.bind(this, "nextItem") : null
    };
  }
  _getShowFirstSubmenuMode() {
    if (!this._isDesktopDevice())
      return "onClick";
    const e = this.option("showFirstSubmenuMode");
    return X(e) ? e.name : e;
  }
  _moveMainMenuFocus(e) {
    const t = this._getAvailableItems(), n = t.length, s = t.filter(".dx-menu-item-expanded").eq(0);
    let o = t.index(s);
    this._hideSubmenu(this._visibleSubmenu), o += e === "prevItem" ? -1 : 1, o >= n ? o = 0 : o < 0 && (o = n - 1);
    const r = t.eq(o);
    this.option("focusedElement", ee(r));
  }
  _nestedItemOnSelectionChangedHandler(e) {
    const t = e.addedItems.length && e.addedItems[0], n = Jp.getInstance(e.element), {
      onSelectionChanged: s
    } = this._actions;
    s(e), t && this._clearSelectionInSubmenus(t[0], n), this._clearRootSelection(), this._setOptionWithoutOptionChange("selectedItem", t);
  }
  _clearSelectionInSubmenus(e, t) {
    const n = !arguments.length;
    y(this._submenus, (s, o) => {
      const r = o._itemContainer(), a = !r.is(t && t._itemContainer()), l = r.find(`.${this._selectedItemClass()}`);
      if (a && l.length || n) {
        l.removeClass(this._selectedItemClass());
        const d = this._getItemData(l);
        d && (d.selected = !1), o._clearSelectedItems();
      }
    });
  }
  _clearRootSelection() {
    const e = this.$element().find(".dx-menu-items-container").first().children().children().filter(`.${this._selectedItemClass()}`);
    if (e.length) {
      const t = this._getItemData(e);
      t.selected = !1, e.removeClass(this._selectedItemClass());
    }
  }
  _nestedItemOnItemClickHandler(e) {
    this._actions.onItemClick(e);
  }
  _nestedItemOnItemRenderedHandler(e) {
    this._actions.onItemRendered(e);
  }
  _attachSubmenuHandlers(e, t) {
    const s = t.getOverlayContent().find(".dx-submenu"), o = R(ad, `${this.NAME}_submenu`);
    t.option({
      onShowing: this._submenuOnShowingHandler.bind(this, e, t),
      onShown: this._submenuOnShownHandler.bind(this, e, t),
      onHiding: this._submenuOnHidingHandler.bind(this, e, t),
      onHidden: this._submenuOnHiddenHandler.bind(this, e, t)
    }), y(s, (r, a) => {
      _.off(a, o), _.on(a, o, null, this._submenuMouseLeaveHandler.bind(this, e));
    });
  }
  _submenuOnShowingHandler(e, t, n) {
    let {
      rootItem: s
    } = n;
    const o = e.children(".dx-context-menu-container-border"), r = this._getVisibilityChangeEventParams(s, t, e);
    this._actions.onSubmenuShowing(r), o.show(), e.addClass("dx-menu-item-expanded");
  }
  _submenuOnShownHandler(e, t, n) {
    let {
      rootItem: s
    } = n;
    const o = this._getVisibilityChangeEventParams(s, t, e);
    this._actions.onSubmenuShown(o);
  }
  _submenuOnHidingHandler(e, t, n) {
    const s = e.children(".dx-context-menu-container-border"), o = this._getVisibilityChangeEventParams(n.rootItem, t, e, !0);
    n.itemData = o.itemData, n.rootItem = o.rootItem, n.submenuContainer = o.submenuContainer, n.submenu = o.submenu, this._actions.onSubmenuHiding(n), n.cancel || (this._visibleSubmenu === t && (this._visibleSubmenu = null), s.hide(), e.removeClass("dx-menu-item-expanded"));
  }
  _submenuOnHiddenHandler(e, t, n) {
    let {
      rootItem: s
    } = n;
    const o = this._getVisibilityChangeEventParams(s, t, e, !0);
    this._actions.onSubmenuHidden(o);
  }
  _getVisibilityChangeEventParams(e, t, n, s) {
    let o, r;
    if (e) {
      const a = s ? p(e).closest(".dx-menu-item")[0] : e;
      o = this._getItemData(a), r = p(a).find(".dx-submenu").first();
    } else {
      const a = p(t._overlay.content());
      o = this._getItemData(n), r = a.find(".dx-submenu").first();
    }
    return {
      itemData: o,
      rootItem: ee(n),
      submenuContainer: ee(r),
      submenu: t
    };
  }
  _submenuMouseLeaveHandler(e, t) {
    const n = p(t.relatedTarget).parents(".dx-context-menu")[0], s = this._getSubmenuByRootElement(e).getOverlayContent()[0];
    this.option("hideSubmenuOnMouseLeave") && n !== s && (this._clearTimeouts(), setTimeout(this._hideSubmenuAfterTimeout.bind(this), this._getDelay("hide")));
  }
  _hideSubmenuAfterTimeout() {
    if (!this._visibleSubmenu)
      return;
    const e = p(this._visibleSubmenu.$element().context).hasClass("dx-state-hover"), t = this._visibleSubmenu.getOverlayContent().find(".dx-state-hover").length;
    !this._visibleSubmenu.getOverlayContent().get(0).querySelector(":hover") && !t && !e && this._visibleSubmenu.hide();
  }
  _getSubmenuByRootElement(e) {
    if (!e)
      return !1;
    const t = e.children(".dx-context-menu");
    return t.length && Jp.getInstance(t);
  }
  getSubmenuPosition(e) {
    const t = this._isMenuHorizontal(), n = this.option("submenuDirection").toLowerCase(), s = this.option("rtlEnabled"), o = {
      collision: "flip",
      of: e,
      precise: !0
    };
    switch (n) {
      case "leftortop":
        o.at = "left top", o.my = t ? "left bottom" : "right top";
        break;
      case "rightorbottom":
        o.at = t ? "left bottom" : "right top", o.my = "left top";
        break;
      default:
        t ? (o.at = s ? "right bottom" : "left bottom", o.my = s ? "right top" : "left top") : (o.at = s ? "left top" : "right top", o.my = s ? "right top" : "left top");
    }
    return o;
  }
  _renderBorderElement(e) {
    p("<div>").appendTo(e).addClass("dx-context-menu-container-border").hide();
  }
  _itemPointerDownHandler(e) {
    if (p(e.target).closest(this._itemElements()).hasClass("dx-menu-item-has-submenu")) {
      this.option("focusedElement", null);
      return;
    }
    super._itemPointerDownHandler(e);
  }
  _hoverStartHandler(e) {
    const t = R(ye.move, this.NAME), n = this._getItemElementByEventArgs(e), s = this._dataAdapter.getNodeByItem(this._getItemData(n)), o = f(e.buttons) && e.buttons === 1 || !f(e.buttons) && e.which === 1;
    if (!this._isItemDisabled(n)) {
      if (_.off(n, t), !this._hasChildren(s)) {
        this._showSubmenuTimer = setTimeout(this._hideSubmenuAfterTimeout.bind(this), this._getDelay("hide"));
        return;
      }
      if (this._getShowFirstSubmenuMode() === "onHover" && !o) {
        const r = this._getSubmenuByElement(n);
        this._clearTimeouts(), r.isOverlayVisible() || (_.on(n, t, this._itemMouseMoveHandler.bind(this)), this._showSubmenuTimer = this._getDelay("hide"));
      }
    }
  }
  _hoverEndHandler(e) {
    const t = this._getItemElementByEventArgs(e), n = p(e.relatedTarget);
    super._hoverEndHandler(e), this._clearTimeouts(), !this._isItemDisabled(t) && (n.hasClass("dx-context-menu-content-delimiter") || this.option("hideSubmenuOnMouseLeave") && !n.hasClass("dx-menu-items-container") && (this._hideSubmenuTimer = setTimeout(() => {
      this._hideSubmenuAfterTimeout();
    }, this._getDelay("hide"))));
  }
  _hideVisibleSubmenu() {
    return this._visibleSubmenu ? (this._hideSubmenu(this._visibleSubmenu), !0) : !1;
  }
  _showSubmenu(e) {
    const t = this._getSubmenuByElement(e);
    this._visibleSubmenu !== t && this._hideVisibleSubmenu(), t && (this._clearTimeouts(), this.focus(), t.show(), this.option("focusedElement", t.option("focusedElement"))), this._visibleSubmenu = t, this._hoveredRootItem = e;
  }
  _hideSubmenu(e) {
    e && e.hide(), this._visibleSubmenu === e && (this._visibleSubmenu = null), this._hoveredRootItem = null;
  }
  _itemMouseMoveHandler(e) {
    if (e.pointers && e.pointers.length)
      return;
    const t = p(e.currentTarget);
    f(this._showSubmenuTimer) && (this._clearTimeouts(), this._showSubmenuTimer = setTimeout(() => {
      const n = this._getSubmenuByElement(t);
      n && !n.isOverlayVisible() && this._showSubmenu(t);
    }, this._getDelay("show")));
  }
  _clearTimeouts() {
    clearTimeout(this._hideSubmenuTimer), clearTimeout(this._showSubmenuTimer);
  }
  _getSubmenuByElement(e, t) {
    const n = this._getSubmenuByRootElement(e);
    if (n)
      return n;
    t = t ?? this._getItemData(e);
    const s = this._dataAdapter.getNodeByItem(t);
    return this._hasChildren(s) && this._renderSubmenuItems(s, e);
  }
  _updateSubmenuVisibilityOnClick(e) {
    const t = e.args.length && e.args[0];
    if (!t || this._disabledGetter(t.itemData))
      return;
    const n = p(t.itemElement), s = this._getSubmenuByElement(n, t.itemData);
    if (this._updateSelectedItemOnClick(e), this._visibleSubmenu) {
      if (this._visibleSubmenu === s) {
        this.option("showFirstSubmenuMode") === "onClick" && this._hideSubmenu(this._visibleSubmenu);
        return;
      }
      this._hideSubmenu(this._visibleSubmenu);
    }
    s && (s.isOverlayVisible() || this._showSubmenu(n));
  }
  _optionChanged(e) {
    if (b0.includes(e.name)) {
      this._initActions();
      return;
    }
    switch (e.name) {
      case "orientation":
      case "submenuDirection":
        this._invalidate();
        break;
      case "showFirstSubmenuMode":
      case "hideSubmenuOnMouseLeave":
        break;
      case "showSubmenuMode":
        this._changeSubmenusOption(e.name, e.value);
        break;
      case "adaptivityEnabled":
        e.value ? this._initAdaptivity() : this._removeAdaptivity();
        break;
      case "width":
        this._isAdaptivityEnabled() && (this._treeView.option(e.name, e.value), this._overlay.option(e.name, e.value)), super._optionChanged(e), this._dimensionChanged();
        break;
      case "animation":
        this._isAdaptivityEnabled() && this._treeView.option("animationEnabled", !!e.value), super._optionChanged(e);
        break;
      default:
        this._isAdaptivityEnabled() && (e.name === e.fullName || e.name === "items") && this._treeView.option(e.fullName, e.value), super._optionChanged(e);
    }
  }
  _changeSubmenusOption(e, t) {
    y(this._submenus, (n, s) => {
      s.option(e, t);
    });
  }
  selectItem(e) {
    this._hideSubmenu(this._visibleSubmenu), super.selectItem(e);
  }
  unselectItem(e) {
    this._hideSubmenu(this._visibleSubmenu), super.unselectItem(e);
  }
}
xe("dxMenu", qm);
const eg = {
  "=": "filter-operation-equals",
  "<>": "filter-operation-not-equals",
  "<": "filter-operation-less",
  "<=": "filter-operation-less-equal",
  ">": "filter-operation-greater",
  ">=": "filter-operation-greater-equal",
  default: "filter-operation-default",
  notcontains: "filter-operation-not-contains",
  contains: "filter-operation-contains",
  startswith: "filter-operation-starts-with",
  endswith: "filter-operation-ends-with",
  between: "filter-operation-between"
}, w0 = {
  "=": "equal",
  "<>": "notEqual",
  "<": "lessThan",
  "<=": "lessThanOrEqual",
  ">": "greaterThan",
  ">=": "greaterThanOrEqual",
  startswith: "startsWith",
  contains: "contains",
  notcontains: "notContains",
  endswith: "endsWith",
  between: "between"
}, HZ = "dx-filter-menu", Ha = "input:not([type='hidden'])", WZ = ["date", "datetime", "number"], zZ = S.format("dxDataGrid-ariaSearchBox");
function aa(i) {
  return i.option("filterRow.applyFilter") === "onClick";
}
const tg = function(i) {
  const e = i && i.children(), t = e && e.data("dxComponents"), n = t && t.length && e.data(t[0]);
  return n instanceof ci ? n : null;
}, ng = function(i, e) {
  let t = "", n = "";
  const s = wC(i, e), o = F.getFormatOptionsByColumn(e, "filterRow");
  return Array.isArray(s) ? (t = F.formatValue(s[0], o), n = F.formatValue(s[1], o), n !== "" && (t += ` - ${n}`)) : f(s) && (t = F.formatValue(s, o)), t;
};
function wC(i, e) {
  if (e)
    return aa(i) && e.bufferedFilterValue !== void 0 ? e.bufferedFilterValue : e.filterValue;
}
const bi = function(i, e) {
  if (e)
    return aa(i) && e.bufferedSelectedFilterOperation !== void 0 ? e.bufferedSelectedFilterOperation : e.selectedFilterOperation;
}, KZ = function(i, e) {
  return e && WZ.includes(e.dataType) && Array.isArray(i) ? !1 : i !== void 0;
}, Ym = function(i, e, t) {
  const n = i._columnsController.columnOption(e), s = wC(i, n), o = t.closest(`.${i.addWidgetPrefix("filter-range-overlay")}`).length, r = t.hasClass(i.addWidgetPrefix("filter-range-start"));
  return s && Array.isArray(s) && bi(i, n) === "between" ? r ? s[0] : s[1] : !o && KZ(s, n) ? s : null;
}, GZ = function(i, e, t, n) {
  if (bi(i, t) === "between") {
    const s = wC(i, t);
    return n.hasClass(i.addWidgetPrefix("filter-range-start")) ? [e, Array.isArray(s) ? s[1] : void 0] : [Array.isArray(s) ? s[0] : s, e];
  }
  return e;
}, UZ = function(i, e) {
  const t = e.value === "" ? null : e.value, n = e.container, s = i._columnsController.columnOption(e.column.index), o = Ym(i, s.index, n);
  if (!f(o) && !f(t))
    return;
  i._applyFilterViewController.setHighLight(n, o !== t);
  const r = aa(i) ? "bufferedFilterValue" : "filterValue", a = GZ(i, t, s, n), l = bi(i, s) === "between", d = e.notFireEvent || l && Array.isArray(a) && a.includes(void 0);
  i._columnsController.columnOption(s.index, r, a, d);
}, jZ = (i) => class extends i {
  init() {
    super.init(), this._applyFilterViewController = this.getController("applyFilter");
  }
  optionChanged(e) {
    switch (e.name) {
      case "filterRow":
      case "showColumnLines":
        this._invalidate(!0, !0), e.handled = !0;
        break;
      case "syncLookupFilterValues":
        e.value ? this.updateLookupDataSource() : this.render(), e.handled = !0;
        break;
      default:
        super.optionChanged(e);
    }
  }
  _updateEditorValue(e, t) {
    const n = tg(t);
    n && n.option("value", Ym(this, e.index, t));
  }
  _columnOptionChanged(e) {
    const t = this, {
      optionNames: n
    } = e;
    let s, o, r, a;
    if (F.checkChanges(n, ["filterValue", "bufferedFilterValue", "selectedFilterOperation", "bufferedSelectedFilterOperation", "filterValues", "filterType"]) && e.columnIndex !== void 0) {
      const l = t._columnsController.getVisibleIndex(e.columnIndex), d = t._columnsController.columnOption(e.columnIndex);
      if (s = t._getCellElement(t.element().find(`.${t.addWidgetPrefix("filter-row")}`).index(), l) ?? p(), o = s.find(".dx-editor-container").first(), n.filterValue || n.bufferedFilterValue) {
        t._updateEditorValue(d, o);
        const u = s.find(`.${t.addWidgetPrefix("filter-range-overlay")}`).data("dxOverlay");
        u && (r = u.$content().find(".dx-editor-container"), t._updateEditorValue(d, r.first()), t._updateEditorValue(d, r.last())), (!u || !u.option("visible")) && t._updateFilterRangeContent(s, ng(t, d));
      }
      (n.selectedFilterOperation || n.bufferedSelectedFilterOperation) && l >= 0 && d && (a = s.find(".dx-menu"), a.length && (t._updateFilterOperationChooser(a, d, o), bi(t, d) === "between" ? t._renderFilterRangeContent(s, d) : o.find(".dx-filter-range-content").length && (t._renderEditor(o, t._getEditorOptions(o, d)), t._hideFilterRange())));
      return;
    }
    super._columnOptionChanged(e);
  }
  _renderCore() {
    return this._filterRangeOverlayInstance = null, super._renderCore.apply(this, arguments);
  }
  _resizeCore() {
    var e;
    super._resizeCore.apply(this, arguments), (e = this._filterRangeOverlayInstance) === null || e === void 0 || e.repaint();
  }
  isFilterRowVisible() {
    return this._isElementVisible(this.option("filterRow"));
  }
  isVisible() {
    return super.isVisible() || this.isFilterRowVisible();
  }
  _initFilterRangeOverlay(e, t) {
    const n = this, s = {}, o = e.find(".dx-editor-container"), r = n.addWidgetPrefix("filter-range-overlay"), a = p("<div>").addClass(r).appendTo(e);
    return n._createComponent(a, Tn, {
      height: "auto",
      shading: !1,
      showTitle: !1,
      focusStateEnabled: !1,
      hideOnOutsideClick: !0,
      wrapperAttr: {
        class: r
      },
      animation: !1,
      position: {
        my: "top",
        at: "top",
        of: o.length && o || e,
        offset: "0 -1"
      },
      contentTemplate(l) {
        let d, u = p("<div>").addClass(`dx-editor-container ${n.addWidgetPrefix("filter-range-start")}`).appendTo(l);
        return t = n._columnsController.columnOption(t.index), d = n._getEditorOptions(u, t), d.sharedData = s, n._renderEditor(u, d), _.on(u.find(Ha), "keydown", (c) => {
          let h = e.find("[tabindex]").not(c.target).first();
          Ye(c) === "tab" && c.shiftKey && (c.preventDefault(), n._hideFilterRange(), h.length || (h = e.prev().find("[tabindex]").last()), _.trigger(h, "focus"));
        }), u = p("<div>").addClass(`dx-editor-container ${n.addWidgetPrefix("filter-range-end")}`).appendTo(l), d = n._getEditorOptions(u, t), d.sharedData = s, n._renderEditor(u, d), _.on(u.find(Ha), "keydown", (c) => {
          Ye(c) === "tab" && !c.shiftKey && (c.preventDefault(), n._hideFilterRange(), _.trigger(e.next().find("[tabindex]").first(), "focus"));
        }), p(l).addClass(n.getWidgetContainerClass());
      },
      onShown(l) {
        const d = l.component.$content().find(".dx-editor-container").first();
        _.trigger(d.find(Ha), "focus");
      },
      onHidden() {
        t = n._columnsController.columnOption(t.index), e.find(".dx-menu").parent().addClass("dx-editor-with-menu"), bi(n, t) === "between" && (n._updateFilterRangeContent(e, ng(n, t)), n.component.updateDimensions());
      }
    });
  }
  _updateFilterRangeOverlay(e) {
    const t = this._filterRangeOverlayInstance;
    t && t.option(e);
  }
  _showFilterRange(e, t) {
    const n = this, s = e.children(`.${n.addWidgetPrefix("filter-range-overlay")}`);
    let o = s.length && s.data("dxOverlay");
    !o && t && (o = n._initFilterRangeOverlay(e, t)), o.option("visible") || (n._filterRangeOverlayInstance && n._filterRangeOverlayInstance.hide(), n._filterRangeOverlayInstance = o, n._updateFilterRangeOverlay({
      width: Ee(e, !0) + 1
    }), n._filterRangeOverlayInstance && n._filterRangeOverlayInstance.show());
  }
  _hideFilterRange() {
    const e = this._filterRangeOverlayInstance;
    e && e.hide();
  }
  getFilterRangeOverlayInstance() {
    return this._filterRangeOverlayInstance;
  }
  _createRow(e) {
    const t = super._createRow(e);
    return e.rowType === "filter" && (t.addClass(this.addWidgetPrefix("filter-row")), this.option("useLegacyKeyboardNavigation") || _.on(t, "keydown", (n) => A_("filterRow", this, n))), t;
  }
  _getRows() {
    const e = super._getRows();
    return this.isFilterRowVisible() && e.push({
      rowType: "filter"
    }), e;
  }
  _renderFilterCell(e, t) {
    const n = this, {
      column: s
    } = t, o = p(e);
    n.component.option("showColumnHeaders") && n.setAria("describedby", s.headerId, o), n.setAria("label", S.format("dxDataGrid-ariaFilterCell"), o), o.addClass("dx-editor-cell");
    const r = p("<div>").appendTo(o), a = p("<div>").addClass("dx-editor-container").appendTo(r);
    if (bi(n, s) === "between")
      n._renderFilterRangeContent(o, s);
    else {
      const d = n._getEditorOptions(a, s);
      n._renderEditor(a, d);
    }
    const {
      alignment: l
    } = s;
    l && l !== "center" && o.find(Ha).first().css("textAlign", s.alignment), s.filterOperations && s.filterOperations.length && n._renderFilterOperationChooser(r, s, a);
  }
  _renderCellContent(e, t) {
    const n = this, {
      column: s
    } = t;
    if (t.rowType === "filter") {
      if (s.command)
        e.html("&nbsp;");
      else if (s.allowFiltering) {
        n.renderTemplate(e, n._renderFilterCell.bind(n), t).done(() => {
          n._updateCell(e, t);
        });
        return;
      }
    }
    super._renderCellContent.apply(this, arguments);
  }
  _getEditorOptions(e, t) {
    const n = this, s = {
      editorOptions: {
        inputAttr: n._getFilterInputAccessibilityAttributes(t)
      }
    }, o = x(s, t, {
      value: Ym(n, t.index, e),
      parentType: "filterRow",
      showAllText: n.option("filterRow.showAllText"),
      updateValueTimeout: n.option("filterRow.applyFilter") === "onClick" ? 0 : 700,
      width: null,
      setValue(r, a) {
        UZ(n, {
          column: t,
          value: r,
          container: e,
          notFireEvent: a
        });
      }
    });
    return bi(n, t) === "between" && (e.hasClass(n.addWidgetPrefix("filter-range-start")) ? o.placeholder = n.option("filterRow.betweenStartText") : o.placeholder = n.option("filterRow.betweenEndText")), o;
  }
  _getFilterInputAccessibilityAttributes(e) {
    const t = S.format("dxDataGrid-ariaFilterCell");
    return this.component.option("showColumnHeaders") ? {
      "aria-label": t,
      "aria-describedby": e.headerId
    } : {
      "aria-label": t
    };
  }
  _renderEditor(e, t) {
    e.empty();
    const n = p("<div>").appendTo(e), s = this._dataController.dataSource();
    if (t.lookup && this.option("syncLookupFilterValues")) {
      this._applyFilterViewController.setCurrentColumnForFiltering(t);
      const o = this._dataController.getCombinedFilter();
      this._applyFilterViewController.setCurrentColumnForFiltering(null);
      const r = F.getWrappedLookupDataSource(t, s, o), a = I({}, t, {
        lookup: I({}, t.lookup, {
          dataSource: r
        })
      });
      return this._editorFactoryController.createEditor(n, a);
    }
    return this._editorFactoryController.createEditor(n, t);
  }
  _renderFilterRangeContent(e, t) {
    const n = this, s = e.find(".dx-editor-container").first();
    s.empty();
    const o = p("<div>").addClass("dx-filter-range-content").attr("tabindex", this.option("tabIndex"));
    _.on(o, "focusin", () => {
      n._showFilterRange(e, t);
    }), o.appendTo(s), n._updateFilterRangeContent(e, ng(n, t));
  }
  _updateFilterRangeContent(e, t) {
    const n = e.find(".dx-filter-range-content");
    n.length && (t === "" ? n.html("&nbsp;") : n.text(t));
  }
  _updateFilterOperationChooser(e, t, n) {
    const s = this;
    let o;
    const r = function() {
      const l = qm.getInstance(e);
      l && l.option("focusedElement", null), o && s._focusEditor(n);
    }, a = this._editorFactoryController;
    s._createComponent(e, qm, {
      integrationOptions: {},
      activeStateEnabled: !1,
      selectionMode: "single",
      cssClass: `${s.getWidgetContainerClass()} dx-cell-focus-disabled ${HZ}`,
      showFirstSubmenuMode: "onHover",
      hideSubmenuOnMouseLeave: !0,
      items: [{
        disabled: !(t.filterOperations && t.filterOperations.length),
        icon: eg[bi(s, t) || "default"],
        selectable: !1,
        items: s._getFilterOperationMenuItems(t)
      }],
      onItemRendered: (l) => {
        let {
          itemElement: d
        } = l;
        this.setAria("label", zZ, p(d));
      },
      onItemClick(l) {
        var d;
        const u = l.itemData.name, c = bi(s, t);
        let h = !1;
        const g = aa(s), m = {};
        if (l.itemData.items || u && u === c)
          return;
        u ? (m[g ? "bufferedSelectedFilterOperation" : "selectedFilterOperation"] = u, (u === "between" || c === "between") && (h = u === "between", m[g ? "bufferedFilterValue" : "filterValue"] = null)) : (m[g ? "bufferedFilterValue" : "filterValue"] = null, m[g ? "bufferedSelectedFilterOperation" : "selectedFilterOperation"] = t.defaultSelectedFilterOperation || null);
        const v = !((d = l.itemData) !== null && d !== void 0 && d.name) ? !1 : void 0;
        if (s._columnsController.columnOption(t.index, m, void 0, v), s._applyFilterViewController.setHighLight(n, !0), !u) {
          const E = tg(n);
          E && E.NAME === "dxDateBox" && !E.option("isValid") && (E.clear(), E.option("isValid", !0));
        }
        h ? s._showFilterRange(n.closest(".dx-editor-cell"), t) : s._focusEditor(n);
      },
      onSubmenuShowing() {
        o = s._isEditorFocused(n), a.loseFocus();
      },
      onSubmenuHiding() {
        _.trigger(e, "blur"), r();
      },
      onContentReady(l) {
        _.on(e, "blur", () => {
          l.component._hideSubmenuAfterTimeout(), r();
        });
      },
      rtlEnabled: s.option("rtlEnabled")
    });
  }
  _isEditorFocused(e) {
    return e.hasClass("dx-focused") || e.parents(".dx-focused").length;
  }
  _focusEditor(e) {
    this._editorFactoryController.focus(e), _.trigger(e.find(Ha), "focus");
  }
  _renderFilterOperationChooser(e, t, n) {
    const s = this;
    let o;
    s.option("filterRow.showOperationChooser") && (e.addClass("dx-editor-with-menu"), o = p("<div>").prependTo(e), s._updateFilterOperationChooser(o, t, n));
  }
  _getFilterOperationMenuItems(e) {
    const t = this;
    let n = [{}];
    const s = t.option("filterRow"), o = s && s.operationDescriptions || {};
    if (e.filterOperations && e.filterOperations.length) {
      const r = e.filterOperations.filter((a) => f(w0[a]));
      n = mt(r, (a) => {
        const l = w0[a];
        return {
          name: a,
          selected: (bi(t, e) || e.defaultFilterOperation) === a,
          text: o[l],
          icon: eg[a]
        };
      }), n.push({
        name: null,
        text: s && s.resetOperationText,
        icon: eg.default
      });
    }
    return n;
  }
  _handleDataChanged(e) {
    var t, n, s, o, r;
    const a = (t = this._dataController) === null || t === void 0 || (n = t.dataSource) === null || n === void 0 ? void 0 : n.call(t), l = a == null || (s = a.lastLoadOptions) === null || s === void 0 ? void 0 : s.call(a);
    if (super._handleDataChanged.apply(this, arguments), (o = e.operationTypes) !== null && o !== void 0 && o.filtering || (r = e.operationTypes) !== null && r !== void 0 && r.fullReload) {
      var d;
      this.updateLookupDataSource(((d = e.operationTypes) === null || d === void 0 ? void 0 : d.filtering) || l?.filter);
    }
  }
  updateLookupDataSource(e) {
    if (!this.option("syncLookupFilterValues") || !this.element())
      return;
    const t = this._columnsController.getVisibleColumns(), n = this._dataController.dataSource(), s = this._applyFilterViewController, o = this.element().find(`.${this.addWidgetPrefix("filter-row")}`).index();
    o !== -1 && t.forEach((r, a) => {
      if (!r.lookup || r.calculateCellValue !== r.defaultCalculateCellValue)
        return;
      const l = this._getCellElement(o, a), d = tg(l?.find(".dx-editor-container"));
      if (d) {
        s.setCurrentColumnForFiltering(r);
        const u = this._dataController.getCombinedFilter() || null;
        s.setCurrentColumnForFiltering(null);
        const c = d.option("dataSource");
        if (!e || !He(c.__dataGridSourceFilter || null, u)) {
          const g = F.getWrappedLookupDataSource(r, n, u);
          d.option("dataSource", g);
        }
      }
    });
  }
  getColumnElements(e, t) {
    var n;
    const s = this._getRows();
    return (s == null || (n = s[e]) === null || n === void 0 ? void 0 : n.rowType) === "filter" && arguments.length < 2 ? this.getCellElements(e) : super.getColumnElements(e, t);
  }
}, qZ = (i) => class extends i {
  skipCalculateColumnFilters() {
    return !1;
  }
  _calculateAdditionalFilter() {
    if (this.skipCalculateColumnFilters())
      return super._calculateAdditionalFilter();
    const e = [super._calculateAdditionalFilter()], t = this._columnsController.getVisibleColumns(null, !0), n = this._applyFilterController;
    return y(t, function() {
      var s;
      const o = ((s = n.getCurrentColumnForFiltering()) === null || s === void 0 ? void 0 : s.index) === this.index;
      if (this.allowFiltering && this.calculateFilterExpression && f(this.filterValue) && !o) {
        const r = this.createFilterExpression(this.filterValue, this.selectedFilterOperation || this.defaultFilterOperation, "filterRow");
        e.push(r);
      }
    }), F.combineFilters(e);
  }
};
class YZ extends Ue.ViewController {
  init() {
    this._columnsController = this.getController("columns");
  }
  _getHeaderPanel() {
    return this._headerPanel || (this._headerPanel = this.getView("headerPanel")), this._headerPanel;
  }
  setHighLight(e, t) {
    aa(this) && (e && e.toggleClass("dx-highlight-outline", t) && e.closest(".dx-editor-cell").toggleClass("dx-filter-modified", t), this._getHeaderPanel().enableApplyButton(t));
  }
  applyFilter() {
    const e = this._columnsController.getColumns();
    this._columnsController.beginUpdate();
    for (let t = 0; t < e.length; t++) {
      const n = e[t];
      n.bufferedFilterValue !== void 0 && (this._columnsController.columnOption(t, "filterValue", n.bufferedFilterValue), n.bufferedFilterValue = void 0), n.bufferedSelectedFilterOperation !== void 0 && (this._columnsController.columnOption(t, "selectedFilterOperation", n.bufferedSelectedFilterOperation), n.bufferedSelectedFilterOperation = void 0);
    }
    this._columnsController.endUpdate(), this.removeHighLights();
  }
  removeHighLights() {
    if (aa(this)) {
      const e = this.getView("columnHeadersView").element();
      e.find(`.${this.addWidgetPrefix("filter-row")} .dx-highlight-outline`).removeClass("dx-highlight-outline"), e.find(`.${this.addWidgetPrefix("filter-row")} .dx-filter-modified`).removeClass("dx-filter-modified"), this._getHeaderPanel().enableApplyButton(!1);
    }
  }
  setCurrentColumnForFiltering(e) {
    this._currentColumn = e;
  }
  getCurrentColumnForFiltering() {
    return this._currentColumn;
  }
}
const XZ = (i) => class extends i {
  _startResizing() {
    const e = this;
    if (super._startResizing.apply(e, arguments), e.isResizing()) {
      const t = e._columnHeadersView.getFilterRangeOverlayInstance();
      if (t) {
        const n = t.$element().closest("td").index();
        (n === e._targetPoint.columnIndex || n === e._targetPoint.columnIndex + 1) && t.$content().hide();
      }
    }
  }
  _endResizing() {
    const e = this;
    let t;
    if (e.isResizing()) {
      const n = e._columnHeadersView.getFilterRangeOverlayInstance();
      n && (t = n.$element().closest("td"), e._columnHeadersView._updateFilterRangeOverlay({
        width: Ee(t, !0) + 1
      }), n.$content().show());
    }
    super._endResizing.apply(e, arguments);
  }
}, ZZ = (i) => class extends i {
  updateFieldValue(e) {
    return e.column.lookup && (this._needUpdateLookupDataSource = !0), super.updateFieldValue.apply(this, arguments);
  }
  _afterSaveEditData(e) {
    if (this._needUpdateLookupDataSource && !e) {
      var t;
      (t = this.getView("columnHeadersView")) === null || t === void 0 || t.updateLookupDataSource();
    }
    return this._needUpdateLookupDataSource = !1, super._afterSaveEditData.apply(this, arguments);
  }
  _afterCancelEditData() {
    return this._needUpdateLookupDataSource = !1, super._afterCancelEditData.apply(this, arguments);
  }
}, QZ = (i) => class extends i {
  init() {
    super.init(), this._dataController = this.getController("data"), this._applyFilterViewController = this.getController("applyFilter");
  }
  optionChanged(e) {
    e.name === "filterRow" ? (this._invalidate(), e.handled = !0) : super.optionChanged(e);
  }
  _getToolbarItems() {
    const e = super._getToolbarItems();
    return this._prepareFilterItem().concat(e);
  }
  _prepareFilterItem() {
    const e = this, t = [];
    if (e._isShowApplyFilterButton()) {
      const n = e.option("filterRow.applyFilterText"), l = {
        widget: "dxButton",
        options: {
          icon: "apply-filter",
          disabled: !e._columnsController.getColumns().filter((d) => d.bufferedFilterValue !== void 0).length,
          onClick: function() {
            e._applyFilterViewController.applyFilter();
          },
          hint: n,
          text: n,
          onInitialized: function(d) {
            p(d.element).addClass(e._getToolbarButtonClass("dx-apply-button"));
          }
        },
        showText: "inMenu",
        name: "applyFilterButton",
        location: "after",
        locateInMenu: "auto",
        sortIndex: 10
      };
      t.push(l);
    }
    return t;
  }
  _isShowApplyFilterButton() {
    const e = this.option("filterRow");
    return !!(e != null && e.visible) && e.applyFilter === "onClick";
  }
  enableApplyButton(e) {
    this.setToolbarItemDisabled("applyFilterButton", !e);
  }
}, JZ = {
  defaultOptions: () => ({
    syncLookupFilterValues: !0,
    filterRow: {
      visible: !1,
      showOperationChooser: !0,
      showAllText: S.format("dxDataGrid-filterRowShowAllText"),
      resetOperationText: S.format("dxDataGrid-filterRowResetOperationText"),
      applyFilter: "auto",
      applyFilterText: S.format("dxDataGrid-applyFilterText"),
      operationDescriptions: {
        equal: S.format("dxDataGrid-filterRowOperationEquals"),
        notEqual: S.format("dxDataGrid-filterRowOperationNotEquals"),
        lessThan: S.format("dxDataGrid-filterRowOperationLess"),
        lessThanOrEqual: S.format("dxDataGrid-filterRowOperationLessOrEquals"),
        greaterThan: S.format("dxDataGrid-filterRowOperationGreater"),
        greaterThanOrEqual: S.format("dxDataGrid-filterRowOperationGreaterOrEquals"),
        startsWith: S.format("dxDataGrid-filterRowOperationStartsWith"),
        contains: S.format("dxDataGrid-filterRowOperationContains"),
        notContains: S.format("dxDataGrid-filterRowOperationNotContains"),
        endsWith: S.format("dxDataGrid-filterRowOperationEndsWith"),
        between: S.format("dxDataGrid-filterRowOperationBetween"),
        isBlank: S.format("dxFilterBuilder-filterOperationIsBlank"),
        isNotBlank: S.format("dxFilterBuilder-filterOperationIsNotBlank")
      },
      betweenStartText: S.format("dxDataGrid-filterRowOperationBetweenStartText"),
      betweenEndText: S.format("dxDataGrid-filterRowOperationBetweenEndText")
    }
  }),
  controllers: {
    applyFilter: YZ
  },
  extenders: {
    controllers: {
      data: qZ,
      columnsResizer: XZ,
      editing: ZZ
    },
    views: {
      columnHeadersView: jZ,
      headerPanel: QZ
    }
  }
};
J.registerModule("filterRow", JZ);
Xo.setEditorClass(ma);
function fR(i) {
  i = i || [];
  for (let e = 0; e < i.length; e++)
    i[e].selected = !1, fR(i[e].items);
}
function _R(i) {
  const e = i.NAME === "dxTreeView" ? ".dx-treeview-select-all-item" : ".dx-list-select-all-checkbox";
  return i.$element().find(e).dxCheckBox("instance");
}
function S0(i, e) {
  if (i.option("searchValue"))
    return;
  const t = _R(i);
  if (t && e !== null && e !== void 0 && e.length) {
    t.option("value", void 0);
    const n = t.option("onValueChanged");
    t.option("onValueChanged", (s) => {
      t.option("onValueChanged", n);
      const o = i.unselectAll();
      da(o) ? o.always(() => {
        n?.(s);
      }) : n?.(s);
    });
  }
}
function e7(i, e, t) {
  if (e ^ t) {
    if (i.selected = !0, t && i.items) {
      for (let n = 0; n < i.items.length; n++)
        if (!i.items[n].selected) {
          i.selected = void 0;
          break;
        }
    }
  } else
    (t || i.selected) && (i.selected = !1, fR(i.items));
}
class t7 extends Ue.View {
  getPopupContainer() {
    return this._popupContainer;
  }
  getListComponent() {
    return this._listComponent;
  }
  applyHeaderFilter(e) {
    const t = this.getListComponent(), n = t.option("searchValue"), s = _R(t), o = !n && !e.isFilterBuilder && s?.option("value"), r = [], a = function(l, d, u) {
      y(d, (c, h) => {
        if (h.selected !== void 0 && !!h.selected ^ u) {
          const g = t._getNode(h), C = t._hasChildren(g) && h.items && h.items.some((v) => v.selected);
          if (!n || !C) {
            l.push(h.value);
            return;
          }
        }
        h.items && h.items.length && a(l, h.items, u);
      });
    };
    o ? (e.type === "tree" && (e.filterType = "exclude"), Array.isArray(e.filterValues) && (e.filterValues = [])) : e.type === "tree" && (e.filterType && (e.filterType = "include"), a(r, t.option("items"), !1), e.filterValues = r), e.filterValues && !e.filterValues.length && (e.filterValues = null), e.apply(), this.hideHeaderFilterMenu();
  }
  showHeaderFilterMenu(e, t) {
    const n = this;
    if (t) {
      n._initializePopupContainer(t);
      const s = n.getPopupContainer();
      n.hideHeaderFilterMenu(), n.updatePopup(e, t), s.show();
    }
  }
  hideHeaderFilterMenu() {
    const e = this.getPopupContainer();
    e && e.hide();
  }
  updatePopup(e, t) {
    const n = this, s = this.option("showColumnLines"), o = t.alignment === "right" ^ !s ? "left" : "right";
    n._popupContainer.setAria({
      role: "dialog",
      label: S.format("dxDataGrid-headerFilterLabel")
    }), n._popupContainer && (n._cleanPopupContent(), n._popupContainer.option("position", {
      my: `${o} top`,
      at: `${o} bottom`,
      of: e,
      collision: "fit fit"
    }));
  }
  _getSearchExpr(e, t) {
    const {
      lookup: n
    } = e, {
      useDefaultSearchExpr: s
    } = e, o = t.dataSource, r = t.search.searchExpr;
    if (r)
      return r;
    if (s || f(o) && !B(o))
      return "text";
    if (n)
      return n.displayExpr || "this";
    if (e.dataSource) {
      const {
        group: a
      } = e.dataSource;
      if (Array.isArray(a) && a.length > 0)
        return a[0].selector;
      if (B(a) && !e.remoteFiltering)
        return a;
    }
    return e.dataField || e.selector;
  }
  _cleanPopupContent() {
    this._popupContainer && this._popupContainer.$content().empty();
  }
  _initializePopupContainer(e) {
    const t = this, n = t.element(), s = this._normalizeHeaderFilterOptions(e), {
      height: o,
      width: r
    } = s, a = {
      width: r,
      height: o,
      visible: !1,
      shading: !1,
      showTitle: !1,
      showCloseButton: !1,
      hideOnParentScroll: !1,
      dragEnabled: !1,
      hideOnOutsideClick: !0,
      wrapperAttr: {
        class: "dx-header-filter-menu"
      },
      focusStateEnabled: !1,
      toolbarItems: [{
        toolbar: "bottom",
        location: "after",
        widget: "dxButton",
        options: {
          text: s.texts.ok,
          onClick() {
            t.applyHeaderFilter(e);
          }
        }
      }, {
        toolbar: "bottom",
        location: "after",
        widget: "dxButton",
        options: {
          text: s.texts.cancel,
          onClick() {
            t.hideHeaderFilterMenu();
          }
        }
      }],
      resizeEnabled: !0,
      onShowing(l) {
        l.component.$content().parent().addClass("dx-dropdowneditor-overlay"), t._initializeListContainer(e, s), e.onShowing && e.onShowing(l);
      },
      onShown() {
        t.getListComponent().focus();
      },
      onHidden: e.onHidden,
      onInitialized(l) {
        const {
          component: d
        } = l;
        d.option("animation", d._getDefaultOptions().animation);
      },
      _loopFocus: !0
    };
    f(t._popupContainer) ? t._popupContainer.option(a) : t._popupContainer = t._createComponent(n, pi, a);
  }
  _initializeListContainer(e, t) {
    const n = this, s = n._popupContainer.$content(), o = !e.isFilterBuilder && t.allowSelectAll, r = {
      searchEnabled: t.search.enabled,
      searchTimeout: t.search.timeout,
      searchEditorOptions: t.search.editorOptions,
      searchMode: t.search.mode || "",
      dataSource: e.dataSource,
      onContentReady() {
        n.renderCompleted.fire();
      },
      itemTemplate(l, d, u) {
        const c = p(u);
        return e.encodeHtml ? c.text(l.text) : c.html(l.text);
      }
    };
    function a(l) {
      l.fullName === "searchValue" && o && n.option("headerFilter.hideSelectAllOnSearch") !== !1 && (e.type === "tree" ? l.component.option("showCheckBoxesMode", l.value ? "normal" : "selectAll") : l.component.option("selectionMode", l.value ? "multiple" : "all"));
    }
    e.type === "tree" ? n._listComponent = n._createComponent(p("<div>").appendTo(s), xd, x(r, {
      showCheckBoxesMode: o ? "selectAll" : "normal",
      onOptionChanged: a,
      keyExpr: "id"
    })) : n._listComponent = n._createComponent(p("<div>").appendTo(s), fa, x(r, {
      searchExpr: n._getSearchExpr(e, t),
      pageLoadMode: "scrollBottom",
      showSelectionControls: !0,
      selectionMode: o ? "all" : "multiple",
      onOptionChanged: a,
      onSelectionChanged(l) {
        const {
          component: d
        } = l, u = d.option("items"), c = d.option("selectedItems");
        if (!d._selectedItemsUpdating && !d.option("searchValue") && !e.isFilterBuilder) {
          const h = e.filterValues || [], g = e.filterType === "exclude";
          c.length === 0 && u.length && (h.length <= 1 || g && h.length === u.length - 1) ? (e.filterType = "include", e.filterValues = []) : c.length === u.length && (e.filterType = "exclude", e.filterValues = []);
        }
        y(u, (h, g) => {
          const m = F.getIndexByKey(g, c, null) >= 0;
          if (!!g.selected !== m) {
            g.selected = m, e.filterValues = e.filterValues || [];
            const v = F.getIndexByKey(g.value, e.filterValues, null);
            v >= 0 && e.filterValues.splice(v, 1);
            const E = e.filterType === "exclude";
            m ^ E && e.filterValues.push(g.value);
          }
        }), S0(d, e.filterValues);
      },
      onContentReady(l) {
        const {
          component: d
        } = l, u = d.option("items"), c = [];
        y(u, function() {
          this.selected && c.push(this);
        }), d._selectedItemsUpdating = !0, d.option("selectedItems", c), d._selectedItemsUpdating = !1, S0(d, e.filterValues);
      }
    }));
  }
  _normalizeHeaderFilterOptions(e) {
    const t = this.option("headerFilter") || {}, n = e.headerFilter || {}, s = {
      search: {
        enabled: t.allowSearch,
        timeout: t.searchTimeout
      }
    }, o = {
      search: {
        enabled: n.allowSearch,
        mode: n.searchMode,
        timeout: n.searchTimeout
      }
    };
    return x(!0, {}, t, s, n, o);
  }
  _renderCore() {
    this.element().addClass("dx-header-filter-menu");
  }
}
const Ih = function(i) {
  return f(i.allowHeaderFiltering) ? i.allowHeaderFiltering : i.allowFiltering;
}, CR = (i) => class extends i {
  optionChanged(e) {
    if (e.name === "headerFilter") {
      const t = this.name === "columnHeadersView";
      this._invalidate(t, t), e.handled = !0;
    } else
      super.optionChanged(e);
  }
  _applyColumnState(e) {
    let t;
    const {
      rootElement: n
    } = e, {
      column: s
    } = e;
    if (e.name === "headerFilter") {
      if (n.find(".dx-header-filter").remove(), Ih(s)) {
        t = super._applyColumnState(e).toggleClass("dx-header-filter-empty", this._isHeaderFilterEmpty(s)), this.option("useLegacyKeyboardNavigation") || t.attr("tabindex", this.option("tabindex") || 0);
        const o = S.format("dxDataGrid-headerFilterIndicatorLabel", s.caption);
        t.attr("aria-label", o), t.attr("aria-haspopup", "dialog"), t.attr("role", "button");
      }
      return t;
    }
    return super._applyColumnState(e);
  }
  _isHeaderFilterEmpty(e) {
    return !e.filterValues || !e.filterValues.length;
  }
  _getIndicatorClassName(e) {
    return e === "headerFilter" ? "dx-header-filter" : super._getIndicatorClassName(e);
  }
  _renderIndicator(e) {
    const t = e.container, n = e.indicator;
    if (e.name === "headerFilter") {
      const s = this.option("rtlEnabled");
      if (t.children().length && (!s && e.columnAlignment === "right" || s && e.columnAlignment === "left")) {
        t.prepend(n);
        return;
      }
    }
    super._renderIndicator(e);
  }
}, n7 = {
  month: (i) => ue.getMonthNames()[i - 1],
  quarter: (i) => ue.format(new Date(2e3, 3 * i - 1), "quarter")
};
function vR(i, e, t) {
  return e = e || [], t = t || [], i.forEach((n) => {
    if (f(n.key)) {
      const s = e.length === 1;
      if (e.push(s ? n.key - 1 : n.key), n.items)
        vR(n.items, e, t);
      else {
        const o = new Date(Date.UTC.apply(Date, e));
        t.push(o);
      }
      e.pop();
    } else
      t.push(null);
  }), t;
}
function i7(i, e) {
  const t = vR(i), n = un(t), s = F.getHeaderFilterGroupParameters(I({}, e, {
    calculateCellValue: (o) => o
  }));
  return ps.queryByOptions(n, {
    group: s
  }).toArray();
}
function s7(i) {
  return i?.slice(-1) === "Z" || i?.slice(-3) === "'Z'";
}
const o7 = function(i, e, t) {
  const n = or.getGroupInterval(e), s = F.getFormatOptionsByColumn(e, "headerFilter");
  return n && (s.groupInterval = n[t], F.isDateType(e.dataType) ? s.format = n7[n[t]] : e.dataType === "number" && (s.getDisplayFormat = function() {
    const o = {
      format: e.format,
      target: "headerFilter"
    }, r = F.formatValue(i, o), a = i + n[t], l = F.formatValue(a, o);
    return r && l ? `${r} - ${l}` : "";
  })), s;
};
class r7 extends Ue.ViewController {
  init() {
    this._columnsController = this.getController("columns"), this._dataController = this.getController("data"), this._headerFilterView = this.getView("headerFilterView");
  }
  _updateSelectedState(e, t) {
    let n = e.length;
    const s = t.filterType === "exclude";
    for (; n--; ) {
      const o = e[n];
      "items" in e[n] && this._updateSelectedState(e[n].items, t), e7(o, F.getIndexByKey(e[n].value, t.filterValues, null) > -1, s);
    }
  }
  _normalizeGroupItem(e, t, n) {
    let s, o;
    const {
      path: r
    } = n, {
      valueSelector: a
    } = n, {
      displaySelector: l
    } = n, {
      column: d
    } = n;
    return a && l ? (s = a(e), o = l(e)) : (s = e.key, o = s), X(e) ? e = x({}, e) : e = {}, r.push(s), r.length === 1 ? e.value = r[0] : e.value = r.join("/"), e.text = this.getHeaderItemText(o, d, t, n.headerFilterOptions), e;
  }
  getHeaderItemText(e, t, n, s) {
    let o = F.formatValue(e, o7(e, t, n));
    return o || (o = s.texts.emptyValue), o;
  }
  _processGroupItems(e, t, n, s) {
    const o = this;
    let r, a;
    const {
      column: l
    } = s, {
      lookup: d
    } = l, {
      level: u
    } = s;
    n = n || [], t = t || 0, d && (r = Be(d.displayExpr), a = Be(d.valueExpr));
    for (let c = 0; c < e.length; c++)
      e[c] = o._normalizeGroupItem(e[c], t, {
        column: s.column,
        headerFilterOptions: s.headerFilterOptions,
        displaySelector: r,
        valueSelector: a,
        path: n
      }), "items" in e[c] && (t === u || !f(e[c].value) ? delete e[c].items : o._processGroupItems(e[c].items, t + 1, n, s)), n.pop();
  }
  getDataSource(e) {
    var t;
    const n = this._dataController.dataSource(), s = n?.remoteOperations().grouping, o = F.getHeaderFilterGroupParameters(e, s), r = (t = e.headerFilter) === null || t === void 0 ? void 0 : t.dataSource, a = this.option("headerFilter");
    let l = !1;
    const d = {
      component: this.component
    };
    if (!n)
      return;
    if (f(r) && !B(r))
      d.dataSource = lo(r);
    else if (e.lookup)
      if (l = !0, this.option("syncLookupFilterValues")) {
        this._currentColumn = e;
        const h = this._dataController.getCombinedFilter();
        this._currentColumn = null, d.dataSource = F.getWrappedLookupDataSource(e, n, h);
      } else
        d.dataSource = F.normalizeLookupDataSource(e.lookup);
    else {
      const h = Array.isArray(o) ? o.length - 1 : 0;
      this._currentColumn = e;
      const g = this._dataController.getCombinedFilter();
      this._currentColumn = null, d.dataSource = {
        filter: g,
        group: o,
        useDefaultSearch: !0,
        load: (m) => {
          const C = new w();
          return m.dataField = e.dataField || e.name, n.load(m).done((v) => {
            s && s7(e.serializationFormat) && h > 3 && (v = i7(v, e)), c._processGroupItems(v, null, null, {
              level: h,
              column: e,
              headerFilterOptions: a
            }), C.resolve(v);
          }).fail(C.reject), C;
        }
      };
    }
    B(r) && r.call(e, d);
    const u = d.dataSource.postProcess, c = this;
    return d.dataSource.postProcess = function(h) {
      let g = h;
      return l && (g = g.filter((m) => m[e.lookup.valueExpr] !== null), this.pageIndex() === 0 && !this.searchValue() && (g = g.slice(0), g.unshift(null)), c._processGroupItems(g, null, null, {
        level: 0,
        column: e,
        headerFilterOptions: a
      })), g = u && u.call(this, g) || g, c._updateSelectedState(g, e), g;
    }, d.dataSource;
  }
  getCurrentColumn() {
    return this._currentColumn;
  }
  showHeaderFilterMenu(e, t) {
    const n = this._columnsController, s = x(!0, {}, this._columnsController.getColumns()[e]);
    if (s) {
      const o = n.getVisibleIndex(e), a = (t ? this.getView("headerPanel") : this.getView("columnHeadersView")).getColumnElements().eq(t ? s.groupIndex : o);
      this.showHeaderFilterMenuBase({
        columnElement: a,
        column: s,
        applyFilter: !0,
        apply() {
          n.columnOption(e, {
            filterValues: this.filterValues,
            filterType: this.filterType
          });
        }
      });
    }
  }
  showHeaderFilterMenuBase(e) {
    const t = this, {
      column: n
    } = e;
    if (n) {
      const s = or.getGroupInterval(n), o = t._dataController.dataSource(), r = o && o.remoteOperations().filtering, a = e.onHidden;
      x(e, n, {
        type: s && s.length > 1 ? "tree" : "list",
        remoteFiltering: r,
        onShowing: (l) => {
          const d = l.component.$overlayContent().dxResizable("instance");
          d && d.option("onResizeEnd", (u) => {
            let c = this._columnsController.columnOption(e.dataField, "headerFilter");
            c = c || {}, c.width = u.width, c.height = u.height, this._columnsController.columnOption(e.dataField, "headerFilter", c, !0);
          });
        },
        onHidden: () => {
          a?.(), O_(this);
        }
      }), e.dataSource = t.getDataSource(e), e.isFilterBuilder && (e.dataSource.filter = null, e.alignment = "right"), t._headerFilterView.showHeaderFilterMenu(e.columnElement, e);
    }
  }
  hideHeaderFilterMenu() {
    this._headerFilterView.hideHeaderFilterMenu();
  }
}
const a7 = (i) => class extends CR(i) {
  _renderCellContent(e, t) {
    const n = this;
    let s;
    const {
      column: o
    } = t;
    !o.command && Ih(o) && n.option("headerFilter.visible") && t.rowType === "header" && (s = n._applyColumnState({
      name: "headerFilter",
      rootElement: e,
      column: o,
      showColumnLines: n.option("showColumnLines")
    }), s && n._subscribeToIndicatorEvent(s, o, "headerFilter")), super._renderCellContent.apply(this, arguments);
  }
  _subscribeToIndicatorEvent(e, t, n) {
    n === "headerFilter" && _.on(e, Te, this.createAction((s) => {
      s.event.stopPropagation(), CT(e, this), this._headerFilterController.showHeaderFilterMenu(t.index, !1);
    }));
  }
  _updateIndicator(e, t, n) {
    const s = super._updateIndicator(e, t, n);
    s && this._subscribeToIndicatorEvent(s, t, n);
  }
  _updateHeaderFilterIndicators() {
    this.option("headerFilter.visible") && this._updateIndicators("headerFilter");
  }
  _needUpdateFilterIndicators() {
    return !0;
  }
  _columnOptionChanged(e) {
    const {
      optionNames: t
    } = e, n = F.checkChanges(t, ["filterValues", "filterValue"]), s = F.checkChanges(t, ["filterValues", "filterType"]);
    (n || s) && this._needUpdateFilterIndicators() && this._updateHeaderFilterIndicators(), s || super._columnOptionChanged(e);
  }
}, l7 = (i) => class extends CR(i) {
  _createGroupPanelItem(e, t) {
    const n = this, s = super._createGroupPanelItem.apply(n, arguments);
    let o;
    return !t.command && Ih(t) && n.option("headerFilter.visible") && (o = n._applyColumnState({
      name: "headerFilter",
      rootElement: s,
      column: {
        alignment: ro(n.option("rtlEnabled")),
        filterValues: t.filterValues,
        allowHeaderFiltering: !0,
        caption: t.caption
      },
      showColumnLines: !0
    }), o && _.on(o, Te, n.createAction((r) => {
      const {
        event: a
      } = r;
      a.stopPropagation(), this._headerFilterController.showHeaderFilterMenu(t.index, !0);
    }))), s;
  }
}, d7 = (i) => class extends i {
  skipCalculateColumnFilters() {
    return !1;
  }
  _calculateAdditionalFilter() {
    if (this.skipCalculateColumnFilters())
      return super._calculateAdditionalFilter();
    const e = [super._calculateAdditionalFilter()], t = this._columnsController.getVisibleColumns(null, !0), s = this._headerFilterController.getCurrentColumn();
    return y(t, (o, r) => {
      let a;
      if (!(s && s.index === r.index) && Ih(r) && r.calculateFilterExpression && Array.isArray(r.filterValues) && r.filterValues.length) {
        let l = [];
        y(r.filterValues, (d, u) => {
          Array.isArray(u) ? a = u : (r.deserializeValue && !F.isDateType(r.dataType) && r.dataType !== "number" && (u = r.deserializeValue(u)), a = r.createFilterExpression(u, "=", "headerFilter")), a && (a.columnIndex = r.index), l.push(a);
        }), l = F.combineFilters(l, "or"), e.push(r.filterType === "exclude" ? ["!", l] : l);
      }
    }), F.combineFilters(e);
  }
}, u7 = {
  defaultOptions: () => ({
    syncLookupFilterValues: !0,
    headerFilter: {
      visible: !1,
      width: 252,
      height: 325,
      allowSelectAll: !0,
      search: {
        enabled: !1,
        timeout: 500,
        mode: "contains",
        editorOptions: {}
      },
      texts: {
        emptyValue: S.format("dxDataGrid-headerFilterEmptyValue"),
        ok: S.format("dxDataGrid-headerFilterOK"),
        cancel: S.format("dxDataGrid-headerFilterCancel")
      }
    }
  }),
  controllers: {
    headerFilter: r7
  },
  views: {
    headerFilterView: t7
  },
  extenders: {
    controllers: {
      data: d7
    },
    views: {
      columnHeadersView: a7,
      headerPanel: l7
    }
  }
};
J.registerModule("headerFilter", u7);
function c7(i, e) {
  const t = p("<div>").addClass("dx-filterbuilder-range-start"), n = p("<div>").addClass("dx-filterbuilder-range-end");
  let s = i.value || [];
  const o = function(a) {
    return a && a.length > 0 ? a[0] : null;
  }, r = function(a) {
    return a && a.length === 2 ? a[1] : null;
  };
  e.append(t), e.append(p("<span>").addClass("dx-filterbuilder-range-separator").text("–")), e.append(n), e.addClass("dx-filterbuilder-range"), this._editorFactory.createEditor.call(this, t, x({}, i.field, i, {
    value: o(s),
    parentType: "filterBuilder",
    setValue(a) {
      s = [a, r(s)], i.setValue(s);
    }
  })), this._editorFactory.createEditor.call(this, n, x({}, i.field, i, {
    value: r(s),
    parentType: "filterBuilder",
    setValue(a) {
      s = [o(s), a], i.setValue(s);
    }
  }));
}
function E0(i, e) {
  return {
    name: "between",
    caption: i,
    icon: "range",
    valueSeparator: "–",
    dataTypes: ["number", "date", "datetime"],
    editorTemplate: c7.bind(e),
    notForLookup: !0
  };
}
const h7 = {
  "=": "equal",
  "<>": "notequal",
  "<": "less",
  "<=": "lessorequal",
  ">": "greater",
  ">=": "greaterorequal",
  notcontains: "doesnotcontain",
  contains: "contains",
  startswith: "startswith",
  endswith: "endswith",
  isblank: "isblank",
  isnotblank: "isnotblank"
}, p7 = {
  "=": "equal",
  "<>": "notEqual",
  "<": "lessThan",
  "<=": "lessThanOrEqual",
  ">": "greaterThan",
  ">=": "greaterThanOrEqual",
  startswith: "startsWith",
  contains: "contains",
  notcontains: "notContains",
  endswith: "endsWith",
  isblank: "isBlank",
  isnotblank: "isNotBlank",
  between: "between"
}, xR = {
  getIconByFilterOperation: (i) => h7[i],
  getNameByFilterOperation: (i) => p7[i]
}, g7 = {
  number: ["=", "<>", "<", ">", "<=", ">=", "isblank", "isnotblank"],
  string: ["contains", "notcontains", "startswith", "endswith", "=", "<>", "isblank", "isnotblank"],
  date: ["=", "<>", "<", ">", "<=", ">=", "isblank", "isnotblank"],
  datetime: ["=", "<>", "<", ">", "<=", ">=", "isblank", "isnotblank"],
  boolean: ["=", "<>", "isblank", "isnotblank"],
  object: ["isblank", "isnotblank"]
}, m7 = {
  date: "shortDate",
  datetime: "shortDateShortTime"
}, f7 = ["=", "<>", "isblank", "isnotblank"], _7 = ["caption", "customizeText", "dataField", "dataType", "editorTemplate", "falseText", "editorOptions", "filterOperations", "format", "lookup", "trueText", "calculateFilterExpression", "name"];
function C7(i, e) {
  const t = i.format || m7[i.dataType];
  return qT.format(e, t);
}
function Qo(i) {
  return i && i.length > 1 && i[0] === "!" && !Ft(i);
}
function uo(i) {
  return Qo(i) ? i[1] : i;
}
function v7(i, e) {
  return Qo(i) ? i[1] = e : i = e, i;
}
function x7(i, e) {
  (function(t) {
    return t.indexOf("!") !== -1;
  })(e) ? Qo(i) || function(t) {
    const n = t.slice(0);
    t.length = 0, t.push("!", n);
  }(i) : Qo(i) && function(t) {
    const n = uo(t);
    t.length = 0, [].push.apply(t, n);
  }(i);
}
function y7(i, e) {
  x7(i, e);
  const t = uo(i);
  let n;
  return e = function(s) {
    return s.indexOf("!") === -1 ? s : s.substring(1);
  }(e), function(s, o) {
    for (n = 0; n < s.length; n++)
      Array.isArray(s[n]) || (s[n] = o);
  }(t, e), i;
}
function b7(i, e) {
  const t = lr(i);
  return e.filter((n) => n.value === t)[0];
}
function yR(i) {
  if (Ft(i))
    return "and";
  let e = "";
  for (let t = 0; t < i.length; t++) {
    const n = i[t];
    if (!Array.isArray(n)) {
      if (e && e !== n)
        throw vt.Error("E4019");
      n !== "!" && (e = n);
    }
  }
  return e;
}
function lr(i) {
  const e = uo(i);
  let t = yR(e);
  return t || (t = "and"), e !== i && (t = `!${t}`), t;
}
function w7(i) {
  return i.lookup && f7 || g7[i.dataType || "string"];
}
function S7(i) {
  return Array.isArray(i) && i.length;
}
function bR(i) {
  const e = S7(i.filterOperations) ? i.filterOperations : w7(i);
  return x([], e);
}
function Xm(i, e) {
  const t = xR.getNameByFilterOperation(i);
  return e && e[t] ? e[t] : t;
}
function E7(i, e) {
  for (let t = 0; t < e.length; t++)
    if (e[t].value === i)
      return e[t];
  throw new _e.Error("E1048", i);
}
function ls(i, e) {
  const t = i.filter((n) => n.name === e);
  return t.length ? t[0] : null;
}
function I7(i, e, t) {
  const n = bR(i), s = !!i.lookup;
  return t.forEach((o) => {
    if (!i.filterOperations && n.indexOf(o.name) === -1) {
      const r = o && o.dataTypes;
      !(s ? !!o.notForLookup : !1) && r && r.indexOf(i.dataType || "string") >= 0 && n.push(o.name);
    }
  }), n.map((o) => {
    const r = ls(t, o);
    return r ? {
      icon: r.icon || "icon-none",
      text: r.caption || ta(r.name),
      value: r.name,
      isCustom: !0
    } : {
      icon: xR.getIconByFilterOperation(o) || "icon-none",
      text: Xm(o, e),
      value: o
    };
  });
}
function SC(i) {
  return i.defaultFilterOperation || bR(i)[0];
}
function D7(i, e) {
  const t = [i.dataField, "", ""], n = SC(i);
  return Qm(t, n, e), t;
}
function Zm(i, e) {
  const t = uo(i), n = t.indexOf(e);
  return t.splice(n, 1), t.length !== 1 && t.splice(n, 1), i;
}
function wR(i) {
  const e = EC(i), t = e ? IC(i) : i;
  return e ? ["!", [t]] : [t];
}
function Tc(i, e) {
  const t = uo(e), n = lr(t);
  return t.length === 1 ? t.unshift(i) : t.push(i, n), e;
}
function Oc(i, e) {
  for (let n = 0; n < e.length; n++)
    if (e[n].name === i || e[n].dataField.toLowerCase() === i.toLowerCase())
      return e[n];
  const t = OR(e, !0).filter((n) => n.dataField.toLowerCase() === i.toLowerCase());
  if (t.length > 0)
    return t[0];
  throw new _e.Error("E1047", i);
}
function co(i) {
  return Array.isArray(i) ? i.length < 2 || Array.isArray(i[0]) || Array.isArray(i[1]) : !1;
}
function Ft(i) {
  return Array.isArray(i) ? i.length > 1 && !Array.isArray(i[0]) && !Array.isArray(i[1]) : !1;
}
function I0(i, e, t) {
  t = t || "and";
  const n = yR(i).toLowerCase() || t;
  let s = [];
  for (let o = 0; o < i.length; o++)
    co(i[o]) ? (s.push(DC(i[o], e, t)), s = sg(s, n)) : Ft(i[o]) && (s.push(Ac(i[o], e)), s = sg(s, n));
  return s.length === 0 && (s = sg(s, n)), s;
}
function T7(i, e) {
  const t = ls(e, i[1]);
  return t && t.name === i[1];
}
function Ac(i, e) {
  return T7(i, e) || i.length < 3 && (i[2] = i[1], i[1] = "="), i;
}
function EC(i) {
  return i.indexOf("not") !== -1;
}
function IC(i) {
  return i.substring(3).toLowerCase();
}
function ig(i, e) {
  const t = EC(e);
  return e = t ? IC(e) : e, t ? ["!", i, e] : [i, e];
}
function sg(i, e) {
  const t = EC(e);
  e = t ? IC(e) : e, i.push(e);
  let n = i;
  return t && (n = ["!", n]), n;
}
function DC(i, e, t) {
  return t = t || "and", i ? (i = x(!0, [], i), Ft(i) ? ig(Ac(i, e), t) : Qo(i) ? ["!", Ft(i[1]) ? ig(Ac(i[1], e), t) : Qo(i[1]) ? ig(DC(i[1], e), t) : I0(i[1], e, t)] : I0(i, e, t)) : wR(t);
}
function O7(i) {
  return i.reduce((e, t) => {
    if (f(t.dataField)) {
      const n = {};
      for (const s in t)
        t[s] && _7.includes(s) && (n[s] = t[s]);
      n.defaultCalculateFilterExpression = or.defaultCalculateFilterExpression, f(n.dataType) || (n.dataType = "string"), f(n.trueText) || (n.trueText = S.format("dxDataGrid-trueText")), f(n.falseText) || (n.falseText = S.format("dxDataGrid-falseText")), e.push(n);
    }
    return e;
  }, []);
}
function D0(i, e, t, n) {
  const s = Oc(i[0], e), o = Ac(i, t), r = t.length && ls(t, o[1]);
  return r && r.calculateFilterExpression ? r.calculateFilterExpression.apply(r, [o[2], s, e]) : s.createFilterExpression ? s.createFilterExpression.apply(s, [o[2], o[1], n]) : s.calculateFilterExpression ? s.calculateFilterExpression.apply(s, [o[2], o[1], n]) : s.defaultCalculateFilterExpression.apply(s, [o[2], o[1], n]);
}
function la(i, e, t, n) {
  if (!f(i))
    return null;
  if (Qo(i))
    return ["!", la(i[1], e, t, n)];
  const s = uo(i);
  if (Ft(s))
    return D0(s, e, t, n) || null;
  let o = [], r;
  const a = lr(s);
  for (let l = 0; l < s.length; l++)
    co(s[l]) ? (r = la(s[l], e, t, n), r && (l && o.push(a), o.push(r))) : Ft(s[l]) && (r = D0(s[l], e, t, n), r && (o.length && o.push(a), o.push(r)));
  return o.length === 1 && (o = o[0]), o.length ? o : null;
}
function cl(i) {
  const e = uo(i);
  let t;
  if (e.length === 0)
    return null;
  const n = [];
  for (t = 0; t < e.length; t++)
    if (co(e[t])) {
      const s = cl(e[t]);
      s ? e[t] = s : n.push(e[t]);
    } else
      Ft(e[t]) && (R7(e[t]) || n.push(e[t]));
  for (t = 0; t < n.length; t++)
    Zm(e, n[t]);
  return e.length === 1 || (e.splice(e.length - 1, 1), e.length === 1 && (i = v7(i, e[0])), i.length === 0) ? null : i;
}
function SR(i, e, t) {
  if (e === "") {
    t("");
    return;
  }
  const {
    lookup: n
  } = i;
  if (n.items)
    t(n.calculateCellValue(e) || "");
  else {
    const s = B(n.dataSource) ? n.dataSource({}) : n.dataSource;
    new In(s).loadSingle(n.valueExpr, e).done((r) => {
      let a = "";
      r && (a = n.displayExpr ? Be(n.displayExpr)(r) : r), i.customizeText && (a = i.customizeText({
        value: e,
        valueText: a
      })), t(a);
    }).fail(() => {
      t("");
    });
  }
}
function ER(i, e, t, n, s) {
  let o;
  return e === !0 ? o = i.trueText || S.format("dxDataGrid-trueText") : e === !1 ? o = i.falseText || S.format("dxDataGrid-falseText") : o = C7(i, e), i.customizeText && (o = i.customizeText.call(i, {
    value: e,
    valueText: o,
    target: n
  })), t && t.customizeText && (o = t.customizeText.call(t, {
    value: e,
    valueText: o,
    field: i,
    target: n
  }, s)), o;
}
function A7(i, e, t, n) {
  const s = {
    values: e
  };
  return e.map((o) => ER(i, o, t, n, s));
}
function og(i) {
  return i === "" || i === null;
}
function IR(i, e, t) {
  let n = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : "filterBuilder";
  if (og(e))
    return "";
  if (Array.isArray(e)) {
    const s = new w();
    return W.apply(this, A7(i, e, t, n)).done(function() {
      for (var o = arguments.length, r = new Array(o), a = 0; a < o; a++)
        r[a] = arguments[a];
      const l = r.some((d) => !og(d)) ? r.map((d) => og(d) ? "?" : d) : "";
      s.resolve(l);
    }), s;
  }
  return ER(i, e, t, n);
}
function T0(i, e) {
  return i.some((t) => t.dataField === e);
}
function DR(i, e, t) {
  const {
    dataField: n
  } = t;
  TC(n) && (t.parentId = AR(n), !T0(e, t.parentId) && !T0(i, t.parentId) && DR(i, e, {
    id: t.parentId,
    dataType: "object",
    dataField: t.parentId,
    caption: TR(t.parentId, !0),
    filterOperations: ["isblank", "isnotblank"],
    defaultCalculateFilterExpression: or.defaultCalculateFilterExpression
  })), e.push(t);
}
function TR(i, e) {
  let t = "";
  if (e)
    i = i.substring(i.lastIndexOf(".") + 1);
  else if (TC(i))
    return i.split(".").forEach((n, s, o) => {
      t += ta(n), s !== o.length - 1 && (t += ".");
    }), t;
  return ta(i);
}
function OR(i, e) {
  const t = [];
  for (let n = 0; n < i.length; n++) {
    const s = x(!0, {
      caption: TR(i[n].dataField, e)
    }, i[n]);
    s.id = s.name || s.dataField, e ? DR(i, t, s) : t.push(s);
  }
  return t;
}
function TC(i) {
  return i.lastIndexOf(".") !== -1;
}
function AR(i) {
  return i.substring(0, i.lastIndexOf("."));
}
function RR(i, e) {
  if (TC(i.dataField)) {
    const t = AR(i.dataField);
    for (let n = 0; n < e.length; n++)
      if (e[n].dataField === t)
        return `${RR(e[n], e)}.${i.caption}`;
  }
  return i.caption;
}
function Qm(i, e, t) {
  let n = ls(t, e);
  return n ? (n.hasValue === !1 ? (i[1] = e, i.length = 2) : (i[1] = e, i[2] = ""), i) : (e === "isblank" ? (i[1] = "=", i[2] = null) : e === "isnotblank" ? (i[1] = "<>", i[2] = null) : (n = ls(t, i[1]), (n || i.length === 2 || i[2] === null) && (i[2] = ""), i[1] = e), i);
}
function O0(i) {
  let e;
  return i[2] === null ? i[1] === "=" ? e = "isblank" : e = "isnotblank" : e = i[1], e;
}
function R7(i) {
  return i[2] !== "";
}
function F7(i, e, t) {
  const n = x(!0, [], i);
  let s = -1;
  return n.some((o, r) => {
    if (o.name === "between")
      return s = r, !0;
  }), s !== -1 ? n[s] = x(E0(e, t), n[s]) : n.unshift(E0(e, t)), n;
}
function Vl(i, e) {
  return i[0] === e;
}
function Jm(i, e) {
  return !i || i.length === 0 ? null : Ft(i) ? Vl(i, e) ? null : i : FR(i, [e], !1);
}
function FR(i, e, t) {
  const n = [];
  return i.forEach((s) => {
    Ft(s) ? Vl(s, e[0]) ? t ? (n.push(e), t = !1) : n.splice(n.length - 1, 1) : n.push(s) : (n.length || co(s)) && n.push(s);
  }), n.length === 0 ? null : (t && (n.push("and"), n.push(e)), n.length === 1 ? n[0] : n);
}
function A0(i, e) {
  return i === null || i.length === 0 ? e : Ft(i) ? Vl(i, e[0]) ? e : [i, "and", e] : lr(i) !== "and" ? [e, "and", i] : FR(i, e, !0);
}
function k7(i, e) {
  return i === null || i.length === 0 ? [] : Ft(i) ? Vl(i, e) ? [i] : [] : lr(i) !== "and" ? [] : i.filter((s) => Ft(s) && Vl(s, e));
}
function kR(i, e) {
  return i === null || i.length === 0 ? !1 : Ft(i) ? i[0] === e : i.some((t) => (Ft(t) || co(t)) && kR(t, e));
}
const ef = function(i, e, t) {
  if (Array.isArray(e)) {
    const n = e.length - 1;
    i.empty(), e.forEach((s, o) => {
      p("<span>").addClass("dx-filterbuilder-text-part").text(s).appendTo(i), o !== n && p("<span>").addClass("dx-filterbuilder-text-separator").text(t && t.valueSeparator ? t.valueSeparator : "|").addClass("dx-filterbuilder-text-separator-empty").appendTo(i);
    });
  } else
    e ? i.text(e) : i.text(S.format("dxFilterBuilder-enterValueText"));
};
function VR(i) {
  const e = function(s, o) {
    return o ? `${o}/${s}` : s;
  }, t = function(s, o) {
    let r = [];
    return s.forEach((a) => {
      if (a.items) {
        const l = t(a.items, e(a.text, o));
        r = r.concat(l);
      }
      a.selected && r.push(e(a.text, o));
    }), r;
  }, n = i && i.getController("headerFilter");
  return {
    dataTypes: ["string", "date", "datetime", "number", "boolean", "object"],
    calculateFilterExpression: function(s, o, r) {
      const a = [], l = s.length - 1;
      return s && s.forEach((d, u) => {
        if (Ft(d) || co(d)) {
          const c = la(d, r, [], "headerFilter");
          a.push(c);
        } else {
          const c = la([o.dataField, "=", d], r, [], "headerFilter");
          a.push(c);
        }
        u !== l && a.push("or");
      }), a.length === 1 ? a[0] : a;
    },
    editorTemplate(s, o) {
      const r = p("<div>").addClass("dx-filterbuilder-item-value-text").appendTo(o), a = x(!0, {}, i.columnOption(s.field.dataField));
      return ef(r, s.text && s.text.split("|")), a.filterType = "include", a.filterValues = s.value ? s.value.slice() : [], n.showHeaderFilterMenuBase({
        columnElement: r,
        column: a,
        apply() {
          l = this.filterValues, s.setValue(l);
          var l;
          n.hideHeaderFilterMenu(), s.closeEditor();
        },
        onHidden() {
          s.closeEditor();
        },
        isFilterBuilder: !0
      }), o;
    },
    customizeText: function(s, o) {
      o = o || {};
      const {
        value: r
      } = s;
      let a = i.columnOption(s.field.dataField);
      const l = a && a.headerFilter, d = a && a.lookup, u = o.values || [r];
      if (l && l.dataSource || d && d.dataSource) {
        const h = new w(), g = o.items || new w();
        if (!o.items) {
          a = x({}, a, {
            filterType: "include",
            filterValues: u
          });
          const m = n.getDataSource(a);
          m.paginate = !1;
          const C = new In(m), v = C.store().key();
          if (v) {
            const {
              values: E
            } = o;
            if (E && E.length > 1) {
              const T = E.reduce((V, $) => (V.length && V.push("or"), V.push([v, "=", $]), V), []);
              C.filter(T);
            } else
              C.filter([v, "=", s.value]);
          } else
            s.field.calculateDisplayValue && _e.log("W1017");
          o.items = g, C.load().done(g.resolve);
        }
        return g.done((m) => {
          const C = u.indexOf(s.value);
          h.resolve(t(m, null)[C]);
        }), h;
      }
      return n.getHeaderItemText(r, a, 0, i.option("headerFilter"));
    }
  };
}
function V7(i) {
  return x(VR(i), {
    name: "anyof",
    icon: "selectall",
    caption: S.format("dxFilterBuilder-filterOperationAnyOf")
  });
}
function P7(i) {
  const e = VR(i);
  return x({}, e, {
    calculateFilterExpression(t, n, s) {
      const o = e.calculateFilterExpression(t, n, s);
      return !o || o.length === 0 ? null : o[0] === "!" ? o : ["!", o];
    },
    name: "noneof",
    icon: "unselectall",
    caption: S.format("dxFilterBuilder-filterOperationNoneOf")
  });
}
const M7 = ["=", "<>", "<", "<=", ">", ">=", "notcontains", "contains", "startswith", "endswith", "between"];
function Ri(i) {
  return i.name || i.dataField;
}
function B7(i) {
  i.forEach((e) => {
    const t = Ri(e);
    if (!f(t) && e.allowFiltering)
      throw new _e.Error("E1049", e.caption);
  });
}
const rg = function() {
  return {
    filterType: "include",
    filterValues: void 0
  };
}, PR = function(i) {
  const e = i.filterValues || [];
  return !or.getGroupInterval(i) && !(i.headerFilter && i.headerFilter.dataSource) || e.length === 1 && e[0] === null;
}, $7 = function(i, e) {
  if (!i)
    return rg();
  let t;
  const n = i[1], s = i[2], o = Array.isArray(s);
  if (!o && !PR(e))
    return rg();
  switch (n) {
    case "anyof":
    case "=":
      t = "include";
      break;
    case "noneof":
    case "<>":
      t = "exclude";
      break;
    default:
      return rg();
  }
  return {
    filterType: t,
    filterValues: o ? s : [s]
  };
}, R0 = function(i) {
  const e = i.filterValue;
  if (f(e)) {
    const t = i.selectedFilterOperation || i.defaultFilterOperation || SC(i);
    return [Ri(i), t, i.filterValue];
  }
  return null;
}, F0 = function(i) {
  let e, t;
  const {
    filterValues: n
  } = i;
  return n ? (n.length === 1 && PR(i) && !Array.isArray(n[0]) ? (i.filterType === "exclude" ? e = "<>" : e = "=", t = n[0]) : (i.filterType === "exclude" ? e = "noneof" : e = "anyof", t = n), [Ri(i), e, t]) : null;
}, k0 = function(i, e, t) {
  const n = $7(t, e);
  i.columnOption(Ri(e), n);
}, V0 = function(i, e, t) {
  let n, s = t?.[1];
  const o = t?.[2], r = e.filterOperations || e.defaultFilterOperations, a = !r || r.indexOf(s) >= 0, l = s === e.defaultFilterOperation, d = M7.includes(s);
  (a || l) && d && (o !== null && o !== "") ? (l && !f(e.selectedFilterOperation) && (s = e.selectedFilterOperation), n = {
    filterValue: o,
    selectedFilterOperation: s
  }) : n = {
    filterValue: void 0,
    selectedFilterOperation: void 0
  }, i.columnOption(Ri(e), n);
};
class N7 extends Ue.Controller {
  init() {
    this._dataController = this.getController("data"), this._columnsController = this.getController("columns"), this._dataController.isFilterSyncActive() && (this._columnsController.isAllDataTypesDefined() ? this._initSync() : this._dataController.dataSourceChanged.add(() => this._initSync()));
  }
  publicMethods() {
    return ["getCustomFilterOperations"];
  }
  syncFilterValue() {
    const e = this, t = this._columnsController.getFilteringColumns();
    this._skipSyncColumnOptions = !0, t.forEach((n) => {
      const s = k7(e.option("filterValue"), Ri(n));
      if (s.length === 1) {
        const o = s[0];
        k0(this._columnsController, n, o), V0(this._columnsController, n, o);
      } else
        f(n.filterValues) && k0(this._columnsController, n, null), f(n.filterValue) && V0(this._columnsController, n, null);
    }), this._skipSyncColumnOptions = !1;
  }
  _initSync() {
    const e = this._columnsController.getColumns(), t = this._dataController.pageIndex();
    if (B7(e), !this.option("filterValue")) {
      const n = this._columnsController.getFilteringColumns(), s = this.getFilterValueFromColumns(n);
      this._silentOption("filterValue", s);
    }
    this.syncFilterValue(), this._dataController.pageIndex(t);
  }
  _getSyncFilterRow(e, t) {
    const n = R0(t);
    return f(n) ? A0(e, n) : Jm(e, Ri(t));
  }
  _getSyncHeaderFilter(e, t) {
    const n = F0(t);
    return n ? A0(e, n) : Jm(e, Ri(t));
  }
  getFilterValueFromColumns(e) {
    if (!this._dataController.isFilterSyncActive())
      return null;
    const t = ["and"];
    return e && e.forEach((n) => {
      const s = F0(n), o = R0(n);
      s && Tc(s, t), o && Tc(o, t);
    }), cl(t);
  }
  syncFilterRow(e, t) {
    this.option("filterValue", this._getSyncFilterRow(this.option("filterValue"), e));
  }
  syncHeaderFilter(e) {
    this.option("filterValue", this._getSyncHeaderFilter(this.option("filterValue"), e));
  }
  getCustomFilterOperations() {
    const e = this.option("filterBuilder.customOperations") ?? [];
    return [V7(this.component), P7(this.component)].concat(e);
  }
}
const L7 = (i) => class extends i {
  optionChanged(e) {
    switch (e.name) {
      case "filterValue":
        this._applyFilter(), this.isFilterSyncActive() && this._filterSyncController.syncFilterValue(), e.handled = !0;
        break;
      case "filterSyncEnabled":
        e.handled = !0;
        break;
      case "columns":
        if (this.isFilterSyncActive()) {
          const t = this._columnsController.getColumnByPath(e.fullName);
          if (t && !this._filterSyncController._skipSyncColumnOptions) {
            const n = this._parseColumnPropertyName(e.fullName);
            this._filterSyncController._skipSyncColumnOptions = !0, n === "filterType" ? (e.value === "exclude" || e.previousValue === "exclude") && this._filterSyncController.syncHeaderFilter(t) : n === "filterValues" ? this._filterSyncController.syncHeaderFilter(t) : ["filterValue", "selectedFilterOperation"].includes(n) && this._filterSyncController.syncFilterRow(t, t.filterValue), this._filterSyncController._skipSyncColumnOptions = !1;
          }
        }
        super.optionChanged(e);
        break;
      default:
        super.optionChanged(e);
    }
  }
  isFilterSyncActive() {
    const e = this.option("filterSyncEnabled");
    return e === "auto" ? this.option("filterPanel.visible") : e;
  }
  skipCalculateColumnFilters() {
    return (f(this.option("filterValue")) || this._filterSyncController._skipSyncColumnOptions) && this.isFilterSyncActive();
  }
  _calculateAdditionalFilter() {
    if (this.option("filterPanel.filterEnabled") === !1)
      return super._calculateAdditionalFilter();
    const e = [super._calculateAdditionalFilter()], t = this._columnsController.getFilteringColumns();
    let n = this.option("filterValue");
    if (this.isFilterSyncActive()) {
      const r = this._headerFilterController.getCurrentColumn(), a = this._applyFilterController.getCurrentColumnForFiltering(), l = r || a;
      (r || f(a?.filterValue)) && n && (n = Jm(n, Ri(l)));
    }
    const s = this._filterSyncController.getCustomFilterOperations(), o = la(n, t, s, "filterBuilder");
    return o && e.push(o), F.combineFilters(e);
  }
  _parseColumnPropertyName(e) {
    const t = e.match(/.*\.(.*)/);
    return t ? t[1] : null;
  }
  clearFilter(e) {
    this.component.beginUpdate(), arguments.length > 0 ? (e === "filterValue" && this.option("filterValue", null), super.clearFilter(e)) : (this.option("filterValue", null), super.clearFilter()), this.component.endUpdate();
  }
  _applyFilter() {
    return this._filterSyncController._skipSyncColumnOptions ? new w().resolve() : super._applyFilter.apply(this, arguments);
  }
}, H7 = (i) => class extends i {
  optionChanged(e) {
    e.name === "filterValue" ? this._updateHeaderFilterIndicators() : super.optionChanged(e);
  }
  _isHeaderFilterEmpty(e) {
    return this._dataController.isFilterSyncActive() ? !kR(this.option("filterValue"), Ri(e)) : super._isHeaderFilterEmpty(e);
  }
  _needUpdateFilterIndicators() {
    return !this._dataController.isFilterSyncActive();
  }
}, W7 = {
  defaultOptions: () => ({
    filterValue: null,
    filterSyncEnabled: "auto"
  }),
  controllers: {
    filterSync: N7
  },
  extenders: {
    controllers: {
      data: L7
    },
    views: {
      columnHeadersView: H7
    }
  }
};
J.registerModule("filterSync", W7);
const P0 = "dx-filterbuilder-action-icon", au = "dx-state-active", M0 = "filterBuilder", z7 = [{
  name: "onEditorPreparing",
  config: {
    excludeValidators: ["disabled", "readOnly"],
    category: "rendering"
  }
}, {
  name: "onEditorPrepared",
  config: {
    excludeValidators: ["disabled", "readOnly"],
    category: "rendering"
  }
}, {
  name: "onValueChanged",
  config: {
    excludeValidators: ["disabled", "readOnly"]
  }
}], B0 = {
  and: "and",
  or: "or",
  notAnd: "!and",
  notOr: "!or"
}, K7 = HA(class {
});
class MR extends Rt {
  _getDefaultOptions() {
    return x(super._getDefaultOptions(), {
      onEditorPreparing: null,
      onEditorPrepared: null,
      onValueChanged: null,
      fields: [],
      groupOperations: ["and", "or", "notAnd", "notOr"],
      maxGroupLevel: void 0,
      value: null,
      allowHierarchicalFields: !1,
      groupOperationDescriptions: {
        and: S.format("dxFilterBuilder-and"),
        or: S.format("dxFilterBuilder-or"),
        notAnd: S.format("dxFilterBuilder-notAnd"),
        notOr: S.format("dxFilterBuilder-notOr")
      },
      customOperations: [],
      closePopupOnTargetScroll: !0,
      filterOperationDescriptions: {
        between: S.format("dxFilterBuilder-filterOperationBetween"),
        equal: S.format("dxFilterBuilder-filterOperationEquals"),
        notEqual: S.format("dxFilterBuilder-filterOperationNotEquals"),
        lessThan: S.format("dxFilterBuilder-filterOperationLess"),
        lessThanOrEqual: S.format("dxFilterBuilder-filterOperationLessOrEquals"),
        greaterThan: S.format("dxFilterBuilder-filterOperationGreater"),
        greaterThanOrEqual: S.format("dxFilterBuilder-filterOperationGreaterOrEquals"),
        startsWith: S.format("dxFilterBuilder-filterOperationStartsWith"),
        contains: S.format("dxFilterBuilder-filterOperationContains"),
        notContains: S.format("dxFilterBuilder-filterOperationNotContains"),
        endsWith: S.format("dxFilterBuilder-filterOperationEndsWith"),
        isBlank: S.format("dxFilterBuilder-filterOperationIsBlank"),
        isNotBlank: S.format("dxFilterBuilder-filterOperationIsNotBlank")
      }
    });
  }
  _optionChanged(e) {
    switch (e.name) {
      case "closePopupOnTargetScroll":
        break;
      case "onEditorPreparing":
      case "onEditorPrepared":
      case "onValueChanged":
        this._initActions();
        break;
      case "customOperations":
        this._initCustomOperations(), this._invalidate();
        break;
      case "fields":
      case "maxGroupLevel":
      case "groupOperations":
      case "allowHierarchicalFields":
      case "groupOperationDescriptions":
      case "filterOperationDescriptions":
        this._invalidate();
        break;
      case "value":
        if (e.value !== e.previousValue) {
          const t = this._disableInvalidateForValue;
          t || (this._initModel(), this._invalidate()), this._disableInvalidateForValue = !1, this.executeAction("onValueChanged", {
            value: e.value,
            previousValue: e.previousValue
          }), this._disableInvalidateForValue = t;
        }
        break;
      default:
        super._optionChanged(e);
    }
  }
  getFilterExpression() {
    const e = this._getNormalizedFields(), t = x(!0, [], this._model);
    return la(cl(t), e, this._customOperations, M0);
  }
  _getNormalizedFields() {
    return O7(this.option("fields"));
  }
  _updateFilter() {
    this._disableInvalidateForValue = !0;
    const e = x(!0, [], this._model), t = cl(e), n = cl(this._getModel(this.option("value")));
    JSON.stringify(n) !== JSON.stringify(t) && this.option("value", t), this._disableInvalidateForValue = !1, this._fireContentReadyAction();
  }
  _init() {
    this._initCustomOperations(), this._initModel(), this._initEditorFactory(), this._initActions(), super._init();
  }
  _initEditorFactory() {
    this._editorFactory = new K7();
  }
  _initCustomOperations() {
    this._customOperations = F7(this.option("customOperations"), this.option("filterOperationDescriptions.between"), this);
  }
  _getDefaultGroupOperation() {
    var e;
    return ((e = this.option("groupOperations")) === null || e === void 0 ? void 0 : e[0]) ?? B0.and;
  }
  _getModel(e) {
    return DC(e, this._customOperations, this._getDefaultGroupOperation());
  }
  _initModel() {
    this._model = this._getModel(this.option("value"));
  }
  _initActions() {
    const e = this;
    e._actions = {}, z7.forEach((t) => {
      const n = x({}, t.config);
      e._actions[t.name] = e._createActionByOption(t.name, n);
    });
  }
  executeAction(e, t) {
    const n = this._actions[e];
    return n && n(t);
  }
  _initMarkup() {
    this.$element().addClass("dx-filterbuilder"), super._initMarkup(), this._addAriaAttributes(this.$element(), S.format("dxFilterBuilder-filterAriaRootElement"), "tree"), this._createGroupElementByCriteria(this._model).appendTo(this.$element());
  }
  _addAriaAttributes(e, t, n, s, o, r) {
    if (!e || !e.length)
      return;
    const a = {
      role: n
    };
    t && (e.text().length > 0 ? a.title = t : a["aria-label"] = t), f(s) && (a["aria-haspopup"] = `${s}`), f(o) && (a["aria-expanded"] = `${o}`), f(r) && (a["aria-level"] = `${r}`), e.attr(a);
  }
  _createConditionElement(e, t, n) {
    return p("<div>").addClass("dx-filterbuilder-group").append(this._createConditionItem(e, t, n));
  }
  _createGroupElementByCriteria(e, t) {
    let n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0;
    const s = this._createGroupElement(e, t, n), o = s.find(".dx-filterbuilder-group-content"), r = uo(e);
    for (let a = 0; a < r.length; a++) {
      const l = r[a];
      co(l) ? this._createGroupElementByCriteria(l, e, n + 1).appendTo(o) : Ft(l) && this._createConditionElement(l, e, `${n + 1}`).appendTo(o);
    }
    return s;
  }
  _createGroupElement(e, t, n) {
    const s = new Xe(), o = p("<div>").addClass("dx-filterbuilder-group-item"), r = p("<div>").addClass("dx-filterbuilder-group-content").attr("id", `${s}`), a = p("<div>").addClass("dx-filterbuilder-group").append(o).append(r);
    return t != null && this._createRemoveButton(() => {
      Zm(t, e), a.remove(), this._updateFilter();
    }, "group").appendTo(o), this._addAriaAttributes(o, S.format("dxFilterBuilder-filterAriaGroupItem"), "treeitem", null, null, `${n + 1}`), this._addAriaAttributes(r, "", "group"), o.attr("aria-owns", `${s}`), this._createGroupOperationButton(e).appendTo(o), this._createAddButton(() => {
      const l = wR(this._getDefaultGroupOperation());
      Tc(l, e), this._createGroupElement(l, e, n + 1).appendTo(r), this._updateFilter();
    }, () => {
      const l = this.option("fields")[0], d = D7(l, this._customOperations);
      Tc(d, e), this._createConditionElement(d, e, n + 1).appendTo(r), this._updateFilter();
    }, n).appendTo(o), a;
  }
  _createButton(e) {
    return p("<div>").text(e);
  }
  _createGroupOperationButton(e) {
    const t = this._getGroupOperations(e);
    let n = b7(e, t);
    const s = n.text, o = t && t.length < 2 ? this._createButton(s).addClass("dx-state-disabled") : this._createButtonWithMenu({
      caption: s,
      menu: {
        items: t,
        displayExpr: "text",
        keyExpr: "value",
        onItemClick: (r) => {
          n !== r.itemData && (y7(e, r.itemData.value), o.text(r.itemData.text), n = r.itemData, this._updateFilter());
        },
        onContentReady(r) {
          r.component.selectItem(n);
        },
        cssClass: "dx-filterbuilder-group-operations"
      }
    });
    return this._addAriaAttributes(o, S.format("dxFilterBuilder-filterAriaOperationButton"), "combobox", !0, !1), o.addClass("dx-filterbuilder-text").addClass("dx-filterbuilder-group-operation").attr("tabindex", 0);
  }
  _createButtonWithMenu(e) {
    const t = this, n = function() {
      t.$element().find(`.${au}`).removeClass(au).attr("aria-expanded", "false"), t.$element().find(".dx-overlay .dx-treeview").remove(), t.$element().find(".dx-overlay").remove();
    }, s = this.option("rtlEnabled"), o = s ? "right" : "left", r = this._createButton(e.caption);
    x(e.menu, {
      focusStateEnabled: !0,
      selectionMode: "single",
      onItemClick: (a = e.menu.onItemClick, function(l) {
        a(l), l.event.type === "dxclick" && n();
      }),
      onHiding() {
        r.removeClass(au).attr("aria-expanded", "false");
      },
      position: {
        my: `${o} top`,
        at: `${o} bottom`,
        offset: "0 1",
        of: r,
        collision: "flip"
      },
      animation: null,
      onHidden() {
        n();
      },
      cssClass: `dx-filterbuilder-overlay ${e.menu.cssClass}`,
      rtlEnabled: s
    });
    var a;
    return e.popup = {
      onShown(l) {
        const d = p(l.component.content()).find(".dx-treeview"), u = d.dxTreeView("instance");
        _.on(d, "keyup keydown", (c) => {
          const h = Ye(c);
          (c.type === "keydown" && h === "tab" || c.type === "keyup" && (h === "escape" || h === "enter")) && (l.component.hide(), _.trigger(e.menu.position.of, "focus"));
        }), u.focus(), u.option("focusedElement", null);
      }
    }, this._subscribeOnClickAndEnterKey(r, () => {
      n(), t._createPopupWithTreeView(e, t.$element()), r.addClass(au).attr("aria-expanded", "true");
    }), r;
  }
  _hasValueButton(e) {
    const t = ls(this._customOperations, e[1]);
    return t ? t.hasValue !== !1 : e[2] !== null;
  }
  _createOperationButtonWithMenu(e, t) {
    const n = this, s = I7(t, this.option("filterOperationDescriptions"), this._customOperations);
    let o = E7(O0(e), s);
    const r = this._createButtonWithMenu({
      caption: o.text,
      menu: {
        items: s,
        displayExpr: "text",
        onItemRendered(a) {
          a.itemData.isCustom && p(a.itemElement).addClass("dx-filterbuilder-menu-custom-operation");
        },
        onContentReady(a) {
          a.component.selectItem(o);
        },
        onItemClick: (a) => {
          if (o !== a.itemData) {
            o = a.itemData, Qm(e, o.value, n._customOperations);
            const l = r.siblings().filter(".dx-filterbuilder-item-value");
            n._hasValueButton(e) ? (l.length !== 0 && l.remove(), n._createValueButton(e, t).appendTo(r.parent())) : l.remove(), r.text(o.text), this._updateFilter();
          }
        },
        cssClass: "dx-filterbuilder-operations"
      }
    }).addClass("dx-filterbuilder-text").addClass("dx-filterbuilder-item-operation").attr("tabindex", 0);
    return this._addAriaAttributes(r, S.format("dxFilterBuilder-filterAriaItemOperation"), "combobox", !0, !1), r;
  }
  _createOperationAndValueButtons(e, t, n) {
    this._createOperationButtonWithMenu(e, t).appendTo(n), this._hasValueButton(e) && this._createValueButton(e, t).appendTo(n);
  }
  _createFieldButtonWithMenu(e, t, n) {
    const s = this, o = this.option("allowHierarchicalFields"), r = OR(e, o);
    let a = Oc(n.name || n.dataField, r);
    const l = function(u, c) {
      return o ? RR(u, c) : u.caption;
    };
    t[0] = a.name || a.dataField;
    const d = this._createButtonWithMenu({
      caption: l(a, r),
      menu: {
        items: r,
        dataStructure: "plain",
        keyExpr: "id",
        parentId: "parentId",
        displayExpr: "caption",
        onItemClick: (u) => {
          if (a !== u.itemData) {
            a = u.itemData, t[0] = a.name || a.dataField, t[2] = a.dataType === "object" ? null : "", Qm(t, SC(a), s._customOperations), d.siblings().filter(".dx-filterbuilder-text").remove(), s._createOperationAndValueButtons(t, a, d.parent());
            const c = l(a, u.component.option("items"));
            d.text(c), this._updateFilter();
          }
        },
        onContentReady(u) {
          u.component.selectItem(a);
        },
        cssClass: "dx-filterbuilder-fields"
      }
    }).addClass("dx-filterbuilder-text").addClass("dx-filterbuilder-item-field").attr("tabindex", 0);
    return this._addAriaAttributes(d, S.format("dxFilterBuilder-filterAriaItemField"), "combobox", !0, !1), d;
  }
  _createConditionItem(e, t, n) {
    const s = p("<div>").addClass("dx-filterbuilder-group-item"), o = this._getNormalizedFields(), r = Oc(e[0], o);
    return this._addAriaAttributes(s, "", "treeitem", null, null, n), this._createRemoveButton(() => {
      Zm(t, e), s.parent().children().length === 1 ? s.parent().remove() : s.remove(), this._updateFilter();
    }, "condition").appendTo(s), this._createFieldButtonWithMenu(o, e, r).appendTo(s), this._createOperationAndValueButtons(e, r, s), s;
  }
  _getGroupOperations(e) {
    let t = this.option("groupOperations");
    const n = this.option("groupOperationDescriptions");
    return (!t || !t.length) && (t = [lr(e).replace("!", "not")]), t.map((s) => ({
      text: n[s],
      value: B0[s]
    }));
  }
  _createRemoveButton(e, t) {
    const n = p("<div>").addClass(P0).addClass("dx-icon-remove").addClass("dx-filterbuilder-action").attr("tabindex", 0);
    if (t) {
      const s = S.format("dxFilterBuilder-filterAriaRemoveButton", t);
      this._addAriaAttributes(n, s, "button");
    }
    return this._subscribeOnClickAndEnterKey(n, e), n;
  }
  _createAddButton(e, t, n) {
    let s;
    const o = this.option("maxGroupLevel");
    return f(o) && n >= o ? (s = this._createButton(), this._subscribeOnClickAndEnterKey(s, t)) : s = this._createButtonWithMenu({
      menu: {
        items: [{
          caption: S.format("dxFilterBuilder-addCondition"),
          click: t
        }, {
          caption: S.format("dxFilterBuilder-addGroup"),
          click: e
        }],
        displayExpr: "caption",
        onItemClick(r) {
          r.itemData.click();
        },
        cssClass: "dx-filterbuilder-add-condition"
      }
    }), this._addAriaAttributes(s, S.format("dxFilterBuilder-filterAriaAddButton"), "combobox", !0, !1), s.addClass(P0).addClass("dx-icon-plus").addClass("dx-filterbuilder-action").attr("tabindex", 0);
  }
  _createValueText(e, t, n) {
    const s = this, o = p("<div>").html("&nbsp;").addClass("dx-filterbuilder-item-value-text").attr("tabindex", 0).appendTo(n);
    this._addAriaAttributes(o, S.format("dxFilterBuilder-filterAriaItemValue"), "button", !0);
    const r = e[2], a = ls(s._customOperations, e[1]);
    return !a && t.lookup ? SR(t, r, (l) => {
      ef(o, l);
    }) : W(IR(t, r, a)).done((l) => {
      ef(o, l, a);
    }), s._subscribeOnClickAndEnterKey(o, (l) => {
      l.type === "keyup" && l.stopPropagation(), s._createValueEditorWithEvents(e, t, n);
    }), o;
  }
  _updateConditionValue(e, t, n) {
    e[2] !== t && (e[2] = t), n(), this._updateFilter();
  }
  _addDocumentKeyUp(e, t) {
    let n = !1, s = !1;
    const o = O.getDocument(), r = (l) => {
      if (n || s) {
        s = !1;
        return;
      }
      t(l);
    };
    _.on(o, "keyup", r);
    const a = e.find("input");
    _.on(a, "compositionstart", () => {
      n = !0;
    }), _.on(a, "compositionend", () => {
      n = !1, s = !0;
    }), _.on(a, "keydown", (l) => {
      l.which !== 229 && (s = !1);
    }), this._documentKeyUpHandler = r;
  }
  _addDocumentClick(e, t) {
    const n = O.getDocument(), s = (o) => {
      this._isFocusOnEditorParts(e, o.target) || (_.trigger(e.find("input"), "change"), t());
    };
    _.on(n, "dxpointerdown", s), this._documentClickHandler = s;
  }
  _isFocusOnEditorParts(e, t) {
    const n = t || O.getActiveElement();
    return p(n).closest(e.children()).length || p(n).closest(".dx-dropdowneditor-overlay").length;
  }
  _removeEvents() {
    const e = O.getDocument();
    f(this._documentKeyUpHandler) && _.off(e, "keyup", this._documentKeyUpHandler), f(this._documentClickHandler) && _.off(e, "dxpointerdown", this._documentClickHandler);
  }
  _dispose() {
    this._removeEvents(), super._dispose();
  }
  _createValueEditorWithEvents(e, t, n) {
    let s = e[2];
    const o = () => (n.empty(), this._removeEvents(), this._createValueText(e, t, n)), r = () => {
      this._updateConditionValue(e, s, () => {
        o();
      });
    }, a = {
      value: s === "" ? null : s,
      filterOperation: O0(e),
      setValue(d) {
        s = d === null ? "" : d;
      },
      closeEditor: r,
      text: n.text()
    };
    n.empty();
    const l = this._createValueEditor(n, t, a);
    _.trigger(l.find("input").not(":hidden").eq(0), "focus"), this._removeEvents(), this._addDocumentClick(l, r), this._addDocumentKeyUp(l, (d) => {
      const u = Ye(d);
      if (u === "tab") {
        if (this._isFocusOnEditorParts(l))
          return;
        this._updateConditionValue(e, s, () => {
          o(), d.shiftKey && _.trigger(n.prev(), "focus");
        });
      }
      u === "escape" && _.trigger(o(), "focus"), u === "enter" && this._updateConditionValue(e, s, () => {
        _.trigger(o(), "focus");
      });
    }), this._fireContentReadyAction();
  }
  _createValueButton(e, t) {
    const n = p("<div>").addClass("dx-filterbuilder-text").addClass("dx-filterbuilder-item-value");
    return this._createValueText(e, t, n), n;
  }
  _createValueEditor(e, t, n) {
    const s = p("<div>").attr("tabindex", 0).appendTo(e), o = ls(this._customOperations, n.filterOperation), r = o && o.editorTemplate ? o.editorTemplate : t.editorTemplate;
    return r ? this._getTemplate(r).render({
      model: x({
        field: t
      }, n),
      container: s
    }) : this._editorFactory.createEditor.call(this, s, x({}, t, n, {
      parentType: M0
    })), s;
  }
  _createPopupWithTreeView(e, t) {
    const n = this, s = p("<div>").addClass(e.menu.cssClass).appendTo(t);
    this._createComponent(s, pi, {
      onHiding: e.menu.onHiding,
      onHidden: e.menu.onHidden,
      rtlEnabled: e.menu.rtlEnabled,
      position: e.menu.position,
      animation: e.menu.animation,
      contentTemplate(o) {
        const r = p("<div>").appendTo(o);
        n._createComponent(r, xd, e.menu), this.repaint();
      },
      _ignoreFunctionValueDeprecation: !0,
      maxHeight: () => bC(e.menu.position.of),
      visible: !0,
      focusStateEnabled: !1,
      preventScrollEvents: !1,
      container: s,
      hideOnOutsideClick: !0,
      onShown: e.popup.onShown,
      shading: !1,
      width: "auto",
      height: "auto",
      showTitle: !1,
      _wrapperClassExternal: e.menu.cssClass,
      _ignorePreventScrollEventsDeprecation: !0
    });
  }
  _subscribeOnClickAndEnterKey(e, t) {
    _.on(e, "dxclick", t), _.on(e, "keyup", (n) => {
      Ye(n) === "enter" && t(n);
    });
  }
}
xe("dxFilterBuilder", MR);
class G7 extends Ue.View {
  init() {
    super.init(), this._columnsController = this.getController("columns"), this._filterSyncController = this.getController("filterSync");
  }
  optionChanged(e) {
    switch (e.name) {
      case "filterBuilder":
      case "filterBuilderPopup":
        this._invalidate(), e.handled = !0;
        break;
      default:
        super.optionChanged(e);
    }
  }
  _renderCore() {
    this._updatePopupOptions();
  }
  _updatePopupOptions() {
    this.option("filterBuilderPopup.visible") ? this._initPopup() : this._filterBuilderPopup && this._filterBuilderPopup.hide();
  }
  _disposePopup() {
    this._filterBuilderPopup && (this._filterBuilderPopup.dispose(), this._filterBuilderPopup = void 0), this._filterBuilder && (this._filterBuilder.dispose(), this._filterBuilder = void 0);
  }
  _initPopup() {
    const e = this;
    e._disposePopup(), e._filterBuilderPopup = e._createComponent(e.element(), pi, x({
      title: S.format("dxDataGrid-filterBuilderPopupTitle"),
      contentTemplate: (t) => e._getPopupContentTemplate(t),
      onOptionChanged(t) {
        t.name === "visible" && e.option("filterBuilderPopup.visible", t.value);
      },
      toolbarItems: e._getPopupToolbarItems()
    }, e.option("filterBuilderPopup"), {
      onHidden() {
        O_(e), e._disposePopup();
      }
    }));
  }
  _getPopupContentTemplate(e) {
    const t = p(e), n = p("<div>").appendTo(p(e));
    this._filterBuilder = this._createComponent(n, MR, x({
      value: this.option("filterValue"),
      fields: this._columnsController.getFilteringColumns()
    }, this.option("filterBuilder"), {
      customOperations: this._filterSyncController.getCustomFilterOperations()
    })), this._createComponent(t, nA, {
      direction: "both"
    });
  }
  _getPopupToolbarItems() {
    const e = this;
    return [{
      toolbar: "bottom",
      location: "after",
      widget: "dxButton",
      options: {
        text: S.format("OK"),
        onClick() {
          const t = e._filterBuilder.option("value");
          e.option("filterValue", t), e._filterBuilderPopup.hide();
        }
      }
    }, {
      toolbar: "bottom",
      location: "after",
      widget: "dxButton",
      options: {
        text: S.format("Cancel"),
        onClick() {
          e._filterBuilderPopup.hide();
        }
      }
    }];
  }
}
const U7 = {
  defaultOptions: () => ({
    filterBuilder: {
      groupOperationDescriptions: {
        and: S.format("dxFilterBuilder-and"),
        or: S.format("dxFilterBuilder-or"),
        notAnd: S.format("dxFilterBuilder-notAnd"),
        notOr: S.format("dxFilterBuilder-notOr")
      },
      filterOperationDescriptions: {
        between: S.format("dxFilterBuilder-filterOperationBetween"),
        equal: S.format("dxFilterBuilder-filterOperationEquals"),
        notEqual: S.format("dxFilterBuilder-filterOperationNotEquals"),
        lessThan: S.format("dxFilterBuilder-filterOperationLess"),
        lessThanOrEqual: S.format("dxFilterBuilder-filterOperationLessOrEquals"),
        greaterThan: S.format("dxFilterBuilder-filterOperationGreater"),
        greaterThanOrEqual: S.format("dxFilterBuilder-filterOperationGreaterOrEquals"),
        startsWith: S.format("dxFilterBuilder-filterOperationStartsWith"),
        contains: S.format("dxFilterBuilder-filterOperationContains"),
        notContains: S.format("dxFilterBuilder-filterOperationNotContains"),
        endsWith: S.format("dxFilterBuilder-filterOperationEndsWith"),
        isBlank: S.format("dxFilterBuilder-filterOperationIsBlank"),
        isNotBlank: S.format("dxFilterBuilder-filterOperationIsNotBlank")
      }
    },
    filterBuilderPopup: {}
  }),
  views: {
    filterBuilderView: G7
  }
};
J.registerModule("filterBuilder", U7);
class j7 extends Ue.View {
  init() {
    this._dataController = this.getController("data"), this._columnsController = this.getController("columns"), this._filterSyncController = this.getController("filterSync"), this._dataController.dataSourceChanged.add(() => this.render());
  }
  isVisible() {
    return this.option("filterPanel.visible") && this._dataController.dataSource();
  }
  _renderCore() {
    const e = this.element();
    if (e.empty(), !!!this._columnsController.getColumns().length)
      return;
    e.addClass(this.addWidgetPrefix("filter-panel"));
    const n = p("<div>").addClass(this.addWidgetPrefix("filter-panel-left")).appendTo(e);
    this._renderFilterBuilderText(e, n);
  }
  _renderFilterBuilderText(e, t) {
    const n = this._getFilterElement(), s = this._getTextElement();
    if (this.option("filterValue") || this._filterValueBuffer) {
      const o = this._getCheckElement(), r = this._getRemoveButtonElement();
      t.append(o).append(n).append(s), e.append(r);
      return;
    }
    t.append(n).append(s);
  }
  _getCheckElement() {
    const e = this, t = p("<div>").addClass(this.addWidgetPrefix("filter-panel-checkbox"));
    return e._createComponent(t, Qs, {
      value: e.option("filterPanel.filterEnabled"),
      onValueChanged(n) {
        e.option("filterPanel.filterEnabled", n.value);
      }
    }), t.attr("title", this.option("filterPanel.texts.filterEnabledHint")), t;
  }
  _getFilterElement() {
    const e = this, t = p("<div>").addClass("dx-icon-filter");
    return _.on(t, "click", () => e._showFilterBuilder()), rl("filterPanel", e, t, void 0, () => e._showFilterBuilder()), e._addTabIndexToElement(t), t;
  }
  _getTextElement() {
    const e = this, t = p("<div>").addClass(e.addWidgetPrefix("filter-panel-text"));
    let n;
    const s = e.option("filterValue");
    return s ? W(e.getFilterText(s, this._filterSyncController.getCustomFilterOperations())).done((o) => {
      const r = e.option("filterPanel.customizeText");
      if (r) {
        const a = r({
          component: e.component,
          filterValue: s,
          text: o
        });
        typeof a == "string" && (o = a);
      }
      t.text(o);
    }) : (n = e.option("filterPanel.texts.createFilter"), t.text(n)), _.on(t, "click", () => e._showFilterBuilder()), rl("filterPanel", e, t, void 0, () => e._showFilterBuilder()), e._addTabIndexToElement(t), t;
  }
  _showFilterBuilder() {
    this.option("filterBuilderPopup.visible", !0);
  }
  _getRemoveButtonElement() {
    const e = this, t = () => e.option("filterValue", null), n = p("<div>").addClass(e.addWidgetPrefix("filter-panel-clear-filter")).text(e.option("filterPanel.texts.clearFilter"));
    return _.on(n, "click", t), rl("filterPanel", this, n, void 0, t), e._addTabIndexToElement(n), n;
  }
  _addTabIndexToElement(e) {
    if (!this.option("useLegacyKeyboardNavigation")) {
      const t = this.option("tabindex") || 0;
      e.attr("tabindex", t);
    }
  }
  optionChanged(e) {
    switch (e.name) {
      case "filterValue":
        this._invalidate(), this.option("filterPanel.filterEnabled", !0), e.handled = !0;
        break;
      case "filterPanel":
        this._invalidate(), e.handled = !0;
        break;
      default:
        super.optionChanged(e);
    }
  }
  _getConditionText(e, t, n) {
    let s = `[${e}] ${t}`;
    return f(n) && (s += n), s;
  }
  _getValueMaskedText(e) {
    return Array.isArray(e) ? `('${e.join("', '")}')` : ` '${e}'`;
  }
  _getValueText(e, t, n) {
    const s = new w(), o = t && t.customizeText;
    if (f(n) || o)
      if (!o && e.lookup)
        SR(e, n, (r) => {
          s.resolve(this._getValueMaskedText(r));
        });
      else {
        const r = Array.isArray(n) ? n : F.getDisplayValue(e, n, null);
        W(IR(e, r, t, "filterPanel")).done((a) => {
          s.resolve(this._getValueMaskedText(a));
        });
      }
    else
      s.resolve("");
    return s.promise();
  }
  getConditionText(e, t) {
    const n = this, s = e[1], o = new w(), r = ls(t.customOperations, s);
    let a;
    const l = Oc(e[0], t.columns), d = l.caption || "", u = e[2];
    return r ? a = r.caption || ZE.captionize(r.name) : u === null ? a = Xm(s === "=" ? "isblank" : "isnotblank", t.filterOperationDescriptions) : a = Xm(s, t.filterOperationDescriptions), this._getValueText(l, r, u).done((c) => {
      o.resolve(n._getConditionText(d, a, c));
    }), o;
  }
  getGroupText(e, t, n) {
    const s = this, o = new w(), r = [], a = lr(e);
    return e.forEach((l) => {
      Ft(l) ? r.push(s.getConditionText(l, t)) : co(l) && r.push(s.getGroupText(l, t, !0));
    }), W.apply(this, r).done(function() {
      let l;
      for (var d = arguments.length, u = new Array(d), c = 0; c < d; c++)
        u[c] = arguments[c];
      a.startsWith("!") ? l = `${t.groupOperationDescriptions[`not${a.substring(1, 2).toUpperCase()}${a.substring(2)}`].split(" ")[0]} ${u[0]}` : l = u.join(` ${t.groupOperationDescriptions[a]} `), n && (l = `(${l})`), o.resolve(l);
    }), o;
  }
  getFilterText(e, t) {
    const n = {
      customOperations: t,
      columns: this._columnsController.getFilteringColumns(),
      filterOperationDescriptions: this.option("filterBuilder.filterOperationDescriptions"),
      groupOperationDescriptions: this.option("filterBuilder.groupOperationDescriptions")
    };
    return Ft(e) ? this.getConditionText(e, n) : this.getGroupText(e, n);
  }
}
const q7 = (i) => class extends i {
  optionChanged(e) {
    e.name === "filterPanel" ? (this._applyFilter(), e.handled = !0) : super.optionChanged(e);
  }
}, Y7 = {
  defaultOptions: () => ({
    filterPanel: {
      visible: !1,
      filterEnabled: !0,
      texts: {
        createFilter: S.format("dxDataGrid-filterPanelCreateFilter"),
        clearFilter: S.format("dxDataGrid-filterPanelClearFilter"),
        filterEnabledHint: S.format("dxDataGrid-filterPanelFilterEnabledHint")
      }
    }
  }),
  views: {
    filterPanelView: j7
  },
  extenders: {
    controllers: {
      data: q7
    }
  }
};
J.registerModule("filterPanel", Y7);
function BR(i) {
  return !!(i.allowSearch ?? i.allowFiltering);
}
function $R(i, e) {
  const {
    lookup: t
  } = i;
  return i.parseValue ? t ? i.parseValue.call(t, e) : i.parseValue(e) : e;
}
const X7 = (i) => class extends i {
  optionChanged(e) {
    switch (e.fullName) {
      case "searchPanel.text":
      case "searchPanel":
        this._applyFilter(), e.handled = !0;
        break;
      default:
        super.optionChanged(e);
    }
  }
  publicMethods() {
    return super.publicMethods().concat(["searchByText"]);
  }
  _calculateAdditionalFilter() {
    var e, t, n;
    const s = (e = this._dataController) === null || e === void 0 || (t = e.getDataSource) === null || t === void 0 ? void 0 : t.call(e), o = s == null || (n = s.loadOptions) === null || n === void 0 || (n = n.call(s)) === null || n === void 0 ? void 0 : n.langParams, r = super._calculateAdditionalFilter(), a = this.calculateSearchFilter(this.option("searchPanel.text"), o);
    return F.combineFilters([r, a]);
  }
  searchByText(e) {
    this.option("searchPanel.text", e);
  }
  calculateSearchFilter(e, t) {
    let n;
    const s = this._columnsController.getColumns(), o = this.option("searchPanel.searchVisibleColumnsOnly");
    let r;
    const a = [];
    if (!e)
      return null;
    function l(u) {
      const c = Be(r.valueExpr);
      for (let h = 0; h < u.length; h++) {
        const g = c(u[h]);
        a.push(n.createFilterExpression(g, null, "search"));
      }
    }
    for (let u = 0; u < s.length; u++)
      if (n = s[u], !(o && !n.visible) && BR(n) && n.calculateFilterExpression) {
        var d;
        r = n.lookup;
        const c = $R(n, e);
        (d = r) !== null && d !== void 0 && d.items ? un(r.items, {
          langParams: t
        }).filter(n.createFilterExpression.call({
          dataField: r.displayExpr,
          dataType: r.dataType,
          calculateFilterExpression: n.calculateFilterExpression
        }, c, null, "search")).enumerate().done(l) : c !== void 0 && a.push(n.createFilterExpression(c, null, "search"));
      }
    return a.length === 0 ? ["!"] : F.combineFilters(a, "or");
  }
}, Z7 = (i) => class extends i {
  optionChanged(e) {
    if (e.name === "searchPanel") {
      if (e.fullName === "searchPanel.text") {
        const t = this.getSearchTextEditor();
        t && t.option("value", e.value);
      } else
        this._invalidate();
      e.handled = !0;
    } else
      super.optionChanged(e);
  }
  _getToolbarItems() {
    const e = super._getToolbarItems();
    return this._prepareSearchItem(e);
  }
  _prepareSearchItem(e) {
    const t = this, n = this._dataController, s = this.option("searchPanel");
    if (s && s.visible) {
      const o = {
        template(r, a, l) {
          const d = p("<div>").addClass(t.addWidgetPrefix("search-panel")).appendTo(l);
          t._editorFactoryController.createEditor(d, {
            width: s.width,
            placeholder: s.placeholder,
            parentType: "searchPanel",
            value: t.option("searchPanel.text"),
            updateValueTimeout: 700,
            setValue(u) {
              n.searchByText(u);
            },
            editorOptions: {
              inputAttr: {
                "aria-label": S.format(`${t.component.NAME}-ariaSearchInGrid`)
              }
            }
          }), t.resize();
        },
        name: "searchPanel",
        location: "after",
        locateInMenu: "never",
        sortIndex: 40
      };
      e.push(o);
    }
    return e;
  }
  getSearchTextEditor() {
    const e = this, t = e.element(), n = t.find(`.${e.addWidgetPrefix("search-panel")}`).filter(function() {
      return p(this).closest(`.${e.addWidgetPrefix("header-panel")}`).is(t);
    });
    return n.length ? n.dxTextBox("instance") : null;
  }
}, Q7 = (i) => class extends i {
  init() {
    super.init.apply(this, arguments), this._searchParams = [], this._dataController = this.getController("data");
  }
  dispose() {
    clearTimeout(this._highlightTimer), super.dispose();
  }
  _getFormattedSearchText(e, t) {
    const n = $R(e, t), s = F.getFormatOptionsByColumn(e, "search");
    return F.formatValue(n, s);
  }
  _getStringNormalizer() {
    var e, t, n;
    const s = this.option("searchPanel.highlightCaseSensitive"), o = (e = this._dataController) === null || e === void 0 || (t = e.getDataSource) === null || t === void 0 ? void 0 : t.call(e), r = o == null || (n = o.loadOptions) === null || n === void 0 || (n = n.call(o)) === null || n === void 0 ? void 0 : n.langParams;
    return (a) => Mt(a, s, r);
  }
  _findHighlightingTextNodes(e, t, n) {
    var s;
    const o = this;
    let r = t.parent(), a;
    const l = this._getStringNormalizer(), d = l(n), u = [];
    if (!r.length)
      r = p("<div>").append(t);
    else if (e)
      if (e.groupIndex >= 0 && !e.showWhenGrouped)
        a = t;
      else {
        const c = o._columnsController.getVisibleIndex(e.index);
        a = r.children("td").eq(c).find("*");
      }
    return a = (s = a) !== null && s !== void 0 && s.length ? a : r.find("*"), a.each((c, h) => {
      const g = p(h).contents();
      for (let m = 0; m < g.length; m++) {
        const C = g.get(m);
        C.nodeType === 3 && l(C.textContent ?? C.nodeValue ?? "").includes(d) && u.push(C);
      }
    }), u;
  }
  _highlightSearchTextCore(e, t) {
    const n = this, s = p("<span>").addClass(n.addWidgetPrefix("search-text")), o = e.text(), r = e[0], a = this._getStringNormalizer(), l = a(o).indexOf(a(t));
    if (l >= 0)
      return r.textContent ? r.textContent = o.substr(0, l) : r.nodeValue = o.substr(0, l), e.after(s.text(o.substr(l, t.length))), e = p(O.createTextNode(o.substr(l + t.length))).insertAfter(s), n._highlightSearchTextCore(e, t);
  }
  _highlightSearchText(e, t, n) {
    const s = this, o = this._getStringNormalizer();
    let r = s.option("searchPanel.text");
    t && n && (r = r && s._getFormattedSearchText(n, r)), r && s.option("searchPanel.highlightSearchText") && s._findHighlightingTextNodes(n, e, r).forEach((l) => {
      t ? o(p(l).text()) === o(r ?? "") && p(l).replaceWith(p("<span>").addClass(s.addWidgetPrefix("search-text")).text(p(l).text())) : s._highlightSearchTextCore(p(l), r);
    });
  }
  _renderCore() {
    const e = super._renderCore.apply(this, arguments);
    return (this.option().rowTemplate || this.option("dataRowTemplate")) && (this.option("templatesRenderAsynchronously") ? (clearTimeout(this._highlightTimer), this._highlightTimer = setTimeout(() => {
      this._highlightSearchText(this.getTableElement());
    })) : this._highlightSearchText(this.getTableElement())), e;
  }
  _updateCell(e, t) {
    const {
      column: n
    } = t, o = (n.lookup && n.lookup.dataType || n.dataType) !== "string";
    BR(n) && !t.isOnForm && (this.option("templatesRenderAsynchronously") ? (this._searchParams.length || (clearTimeout(this._highlightTimer), this._highlightTimer = setTimeout(() => {
      this._searchParams.forEach((r) => {
        this._highlightSearchText.apply(this, r);
      }), this._searchParams = [];
    })), this._searchParams.push([e, o, n])) : this._highlightSearchText(e, o, n)), super._updateCell(e, t);
  }
}, J7 = {
  defaultOptions: () => ({
    searchPanel: {
      visible: !1,
      width: 160,
      placeholder: S.format("dxDataGrid-searchPanelPlaceholder"),
      highlightSearchText: !0,
      highlightCaseSensitive: !1,
      text: "",
      searchVisibleColumnsOnly: !1
    }
  }),
  extenders: {
    controllers: {
      data: X7
    },
    views: {
      headerPanel: Z7,
      rowsView: Q7
    }
  }
};
J.registerModule("search", J7);
const eQ = I({}, dd, {
  isGridCompatibilityMode: !1,
  showInfo: !1,
  displayMode: "adaptive",
  maxPagesCount: 10,
  pageCount: 1,
  visible: !0,
  hasKnownLastPage: !0,
  pagesNavigatorVisible: "auto",
  showPageSizeSelector: !0,
  allowedPageSizes: [5, 10],
  showNavigationButtons: !1,
  itemCount: 1,
  label: S.format("dxPagination-ariaLabel")
}), ot = I({}, eQ, {
  pageSize: 5,
  pageIndex: 1,
  pageIndexChangedInternal: () => {
  },
  pageSizeChangedInternal: () => {
  }
}), tQ = "dx-pager", nQ = "dx-pagination", iQ = "dx-light-mode", sQ = "dx-pages", oQ = "dx-page-indexes", rQ = "dx-page", aQ = "dx-selection", lQ = "dx-page-size", dQ = "dx-page-sizes", uQ = "dx-page-size dx-selection", cQ = "dx-first-child", hl = l_(void 0), pl = l_(void 0), hQ = {};
class NR extends bn {
  constructor() {
    super(...arguments), this.state = {};
  }
  getConfig() {
    return {
      isGridCompatibilityMode: this.props.isGridCompatibilityMode
    };
  }
  getChildContext() {
    return I({}, this.context, {
      [pl.id]: this.getConfig() || pl.defaultValue
    });
  }
  render() {
    return this.props.children;
  }
}
NR.defaultProps = hQ;
function pQ(i) {
  return i[pl.id] ? i[pl.id] : pl.defaultValue;
}
function LR(i) {
  var e;
  return !!((e = pQ(i)) !== null && e !== void 0 && e.isGridCompatibilityMode);
}
function Vi(i, e) {
  let t = e;
  return LR(i) && (t = e.replace("dxPagination", "dxPager")), S.getFormatter(t)();
}
const gQ = "dx-info", mQ = {
  pageCount: ot.pageCount,
  pageIndex: ot.pageIndex,
  itemCount: ot.itemCount
};
class HR extends bn {
  constructor() {
    super(...arguments), this.state = {}, this.refs = null, this.rootElementRef = ct();
  }
  getInfoText() {
    return this.props.infoText ?? Vi(this.context, "dxPagination-infoText");
  }
  getText() {
    const {
      pageCount: e,
      pageIndex: t,
      itemCount: n
    } = this.props;
    return Fi(this.getInfoText(), (t + 1).toString(), e?.toString(), n?.toString());
  }
  render() {
    return gt(1, "div", "dx-info", this.getText(), 0, null, null, this.props.rootElementRef);
  }
}
HR.defaultProps = mQ;
const fQ = {
  className: "",
  label: "",
  tabIndex: 0,
  selected: !1
};
class Pl extends vs {
  constructor(e) {
    super(e), this.state = {}, this.refs = null, this.widgetRef = ct(), this.keyboardEffect = this.keyboardEffect.bind(this), this.subscribeToClick = this.subscribeToClick.bind(this);
  }
  getComponentProps() {
    return this.props;
  }
  getKeyboardContext() {
    return this.context[hl.id] ? this.context[hl.id] : hl.defaultValue;
  }
  componentWillUpdate(e, t, n) {
    super.componentWillUpdate(e, t, n);
  }
  createEffects() {
    return [new et(this.keyboardEffect, [this.getKeyboardContext(), this.props.onClick]), new et(this.subscribeToClick, [this.props.onClick])];
  }
  updateEffects() {
    var e, t;
    (e = this._effects[0]) === null || e === void 0 || e.update([this.getKeyboardContext(), this.props.onClick]), (t = this._effects[1]) === null || t === void 0 || t.update([this.props.onClick]);
  }
  keyboardEffect() {
    return this.getKeyboardContext().registerKeyboardAction(this.widgetRef.current, this.props.onClick);
  }
  subscribeToClick() {
    return uG(this.widgetRef.current, this.props.onClick);
  }
  render() {
    return gt(1, "div", this.props.className, this.props.children, 0, {
      tabIndex: this.props.tabIndex,
      role: "button",
      "aria-label": this.props.label,
      "aria-current": this.props.selected ? "page" : void 0
    }, null, this.widgetRef);
  }
}
Pl.defaultProps = fQ;
const _Q = {
  allowedPageSizes: [],
  pageSize: ot.pageSize,
  pageSizeChangedInternal: ot.pageSizeChangedInternal
};
class WR extends bn {
  constructor(e) {
    super(e), this.state = {}, this.refs = null, this.__getterCache = {
      pageSizesText: void 0
    }, this.state = {}, this.onPageSizeChange = this.onPageSizeChange.bind(this);
  }
  getPageSizesText() {
    if (this.__getterCache.pageSizesText !== void 0)
      return this.__getterCache.pageSizesText;
    const e = (() => {
      const {
        pageSize: t,
        allowedPageSizes: n
      } = this.props;
      return n.map((s, o) => {
        const {
          text: r,
          value: a
        } = s;
        return {
          className: ld({
            [a === t ? uQ : lQ]: !0,
            [cQ]: o === 0
          }),
          click: this.onPageSizeChange(a),
          label: Fi(Vi(this.context, "dxPagination-pageSize"), a || Vi(this.context, "dxPagination-pageSizesAllText")),
          text: r
        };
      });
    })();
    return this.__getterCache.pageSizesText = e, e;
  }
  onPageSizeChange(e) {
    return () => (this.props.pageSizeChangedInternal(e), this.props.pageSize);
  }
  componentWillUpdate(e) {
    (this.props.pageSize !== e.pageSize || this.props.allowedPageSizes !== e.allowedPageSizes || this.props.pageSizeChangedInternal !== e.pageSizeChangedInternal) && (this.__getterCache.pageSizesText = void 0);
  }
  render() {
    return Cs(this.getPageSizesText().map((e) => {
      let {
        text: t,
        className: n,
        label: s,
        click: o
      } = e;
      return qe(2, Pl, {
        className: n,
        label: s,
        onClick: o,
        children: t
      }, t);
    }), 0);
  }
}
WR.defaultProps = _Q;
const zR = {
  label: "",
  labelMode: Zt(pn()) ? "floating" : "static"
}, CQ = {
  className: "",
  activeStateEnabled: !1,
  disabled: !1,
  focusStateEnabled: !1,
  hoverStateEnabled: !1,
  tabIndex: 0,
  visible: !0,
  rtlEnabled: !1
}, $0 = I({}, dd, {
  _feedbackHideTimeout: 400,
  _feedbackShowTimeout: 30,
  cssText: "",
  aria: {},
  classes: "",
  name: "",
  addWidgetClass: !0
}), KR = I({}, CQ, {
  aria: $0.aria,
  classes: $0.classes,
  readOnly: !1,
  name: "",
  value: null,
  validationError: null,
  validationErrors: null,
  validationMessageMode: "auto",
  validationMessagePosition: "bottom",
  validationStatus: "valid",
  isValid: !0,
  isDirty: !1,
  inputAttr: {}
}), GR = {
  hoverStateEnabled: !0,
  activeStateEnabled: !0,
  focusStateEnabled: z.real().deviceType === "desktop" && !z.isSimulator()
}, vQ = I({}, KR, GR, zR, {
  placeholder: "",
  hoverStateEnabled: !0,
  searchEnabled: !1,
  value: null,
  isReactComponentWrapper: !0
});
class UR extends bn {
  constructor() {
    super(...arguments), this.state = {}, this.refs = null;
  }
  get componentProps() {
    return this.props;
  }
  render() {
    return qe(2, oC, {
      componentType: mC,
      componentProps: this.componentProps,
      templateNames: ["dropDownButtonTemplate", "groupTemplate", "itemTemplate"]
    });
  }
}
UR.defaultProps = vQ;
function jR(i, e) {
  return i + 10 * Math.max(...e).toString().length;
}
function xQ(i) {
  var e;
  const t = fe();
  return i ? (e = t.getComputedStyle) === null || e === void 0 ? void 0 : e.call(t, i) : null;
}
function yQ(i) {
  return i ? Number(i.replace("px", "")) : 0;
}
function ds(i, e) {
  const t = xQ(e) ?? {};
  return yQ(t[i]);
}
function bQ(i) {
  const e = ds("paddingLeft", i) + ds("paddingRight", i);
  return ds("width", i) - e;
}
function Hu(i) {
  const e = ds("marginLeft", i) + ds("marginRight", i), t = ds("width", i);
  return e + t;
}
function qR(i) {
  return ds("minWidth", i);
}
const wQ = {
  allowedPageSizes: []
}, SQ = I({}, wQ, {
  pageSize: ot.pageSize,
  pageSizeChangedInternal: ot.pageSizeChangedInternal
});
class YR extends vs {
  constructor(e) {
    super(e), this.state = {
      minWidth: 10
    }, this.refs = null, this.updateWidth = this.updateWidth.bind(this);
  }
  componentWillUpdate(e, t, n) {
    super.componentWillUpdate(e, t, n);
  }
  createEffects() {
    const e = [this.props, this.state.minWidth, this.props.pageSize, this.props.pageSizeChangedInternal, this.props.allowedPageSizes];
    return [new et(this.updateWidth, e)];
  }
  updateEffects() {
    var e;
    const t = [this.props, this.state.minWidth, this.props.pageSize, this.props.pageSizeChangedInternal, this.props.allowedPageSizes];
    (e = this._effects[0]) === null || e === void 0 || e.update(t);
  }
  updateWidth() {
    var e;
    const t = qR((e = this.props.parentRef) === null || e === void 0 ? void 0 : e.current);
    this.setState((n) => ({
      minWidth: t > 0 ? t : n.minWidth
    }));
  }
  getWidth() {
    var e;
    return jR(this.state.minWidth, (e = this.props.allowedPageSizes) === null || e === void 0 ? void 0 : e.map((t) => t.value));
  }
  getInputAttributes() {
    return {
      "aria-label": Vi(this.context, "dxPagination-ariaPageSize")
    };
  }
  render() {
    const {
      allowedPageSizes: e,
      pageSize: t,
      pageSizeChangedInternal: n
    } = this.props;
    return qe(2, UR, {
      displayExpr: "text",
      valueExpr: "value",
      dataSource: e,
      value: t,
      valueChange: n,
      width: this.getWidth(),
      inputAttr: this.getInputAttributes()
    });
  }
}
YR.defaultProps = SQ;
const EQ = {
  isLargeDisplayMode: !0,
  pageSize: ot.pageSize,
  pageSizeChangedInternal: ot.pageSizeChangedInternal,
  allowedPageSizes: ot.allowedPageSizes
};
class XR extends vs {
  constructor(e) {
    super(e), this.state = {}, this.refs = null, this.rootElementRef = ct(), this.htmlRef = ct(), this.__getterCache = {
      normalizedPageSizes: void 0
    }, this.setRootElementRef = this.setRootElementRef.bind(this);
  }
  createEffects() {
    return [new et(this.setRootElementRef, [])];
  }
  setRootElementRef() {
    const {
      rootElementRef: e
    } = this.props;
    e && (e.current = this.htmlRef.current);
  }
  getAllText() {
    return Vi(this.context, "dxPagination-pageSizesAllText");
  }
  getNormalizedPageSizes() {
    if (this.__getterCache.normalizedPageSizes !== void 0)
      return this.__getterCache.normalizedPageSizes;
    const e = this.props.allowedPageSizes.map((t) => t === "all" || t === 0 ? {
      text: this.getAllText(),
      value: 0
    } : {
      text: String(t),
      value: t
    });
    return this.__getterCache.normalizedPageSizes = e, e;
  }
  componentWillUpdate(e) {
    super.componentWillUpdate(), this.props.allowedPageSizes !== e.allowedPageSizes && (this.__getterCache.normalizedPageSizes = void 0);
  }
  render() {
    const e = this.getNormalizedPageSizes(), {
      pageSize: t,
      pageSizeChangedInternal: n,
      isLargeDisplayMode: s
    } = this.props;
    return gt(1, "div", dQ, [s && qe(2, WR, {
      allowedPageSizes: this.getNormalizedPageSizes(),
      pageSize: t,
      pageSizeChangedInternal: n
    }), !s && qe(2, YR, {
      parentRef: this.htmlRef,
      allowedPageSizes: e,
      pageSize: t,
      pageSizeChangedInternal: n
    })], 0, null, null, this.htmlRef);
  }
}
XR.defaultProps = EQ;
const IQ = {
  index: 0,
  selected: !1,
  className: rQ
};
class OC extends bn {
  constructor() {
    super(...arguments), this.state = {}, this.refs = null;
  }
  getLabel() {
    return Fi(Vi(this.context, "dxPagination-page"), this.getValue());
  }
  getValue() {
    return this.props.index + 1;
  }
  getClassName() {
    return ld({
      [`${this.props.className}`]: !!this.props.className,
      [aQ]: !!this.props.selected
    });
  }
  render() {
    return qe(2, Pl, {
      className: this.getClassName(),
      label: this.getLabel(),
      onClick: this.props.onClick,
      selected: this.props.selected,
      children: this.getValue()
    });
  }
}
OC.defaultProps = IQ;
const DQ = {
  maxPagesCount: ot.maxPagesCount,
  pageCount: ot.pageCount,
  pageIndex: ot.pageIndex,
  pageIndexChangedInternal: ot.pageIndexChangedInternal
};
function N0(i, e, t) {
  switch (!0) {
    case i === 1:
      return "high";
    case i + e === t - 1:
      return "low";
    default:
      return "both";
  }
}
function ZR(i, e, t) {
  let n = [], s = [];
  switch (t) {
    case "none":
      n = [...i];
      break;
    case "both":
      n = [0, "low", ...i, "high", e - 1], s = i.slice(1, -1);
      break;
    case "high":
      n = [0, ...i, "high", e - 1], s = i.slice(0, -1);
      break;
    case "low":
      n = [0, "low", ...i, e - 1], s = i.slice(1);
  }
  return {
    slidingWindowIndexes: i,
    indexesForReuse: s,
    pageIndexes: n
  };
}
function L0(i, e, t, n) {
  const s = [];
  for (let o = 0; o < e; o += 1)
    s.push(o + i);
  return ZR(s, t, n);
}
class QR extends bn {
  constructor(e) {
    super(e), this.state = {}, this.refs = null, this.canReuseSlidingWindow = this.canReuseSlidingWindow.bind(this), this.generatePageIndexes = this.generatePageIndexes.bind(this), this.isSlidingWindowMode = this.isSlidingWindowMode.bind(this), this.onPageClick = this.onPageClick.bind(this);
  }
  getConfig() {
    return this.context[dn.id] ? this.context[dn.id] : dn.defaultValue;
  }
  getSlidingWindowState() {
    const e = this.slidingWindowStateHolder;
    return e || {
      indexesForReuse: [],
      slidingWindowIndexes: []
    };
  }
  canReuseSlidingWindow(e, t) {
    const {
      indexesForReuse: n
    } = this.getSlidingWindowState(), s = n.slice(-1)[0] < e - 1, o = n.includes(t);
    return s && o;
  }
  generatePageIndexes() {
    const {
      pageCount: e,
      pageIndex: t
    } = this.props;
    let n = 0;
    const {
      slidingWindowIndexes: s
    } = this.getSlidingWindowState();
    t === s[0] ? n = t - 1 : t === s[s.length - 1] ? n = t + 2 - 4 : t < 4 ? n = 1 : t >= e - 4 ? n = e - 4 - 1 : n = t - 1;
    const o = N0(n, 4, e), r = L0(n, 4, e, o), {
      pageIndexes: a
    } = r;
    return this.slidingWindowStateHolder = r, a;
  }
  isSlidingWindowMode() {
    const {
      maxPagesCount: e,
      pageCount: t
    } = this.props;
    return t <= 4 || t <= e;
  }
  onPageClick(e) {
    this.props.pageIndexChangedInternal(e);
  }
  getPageIndexes() {
    const {
      pageCount: e
    } = this.props;
    if (this.isSlidingWindowMode())
      return L0(0, e, e, "none").pageIndexes;
    if (this.canReuseSlidingWindow(e, this.props.pageIndex)) {
      const {
        slidingWindowIndexes: t
      } = this.getSlidingWindowState(), n = N0(t[0], 4, e);
      return ZR(t, e, n).pageIndexes;
    }
    return this.generatePageIndexes();
  }
  getPages() {
    var e;
    const {
      pageIndex: t
    } = this.props, n = (r) => {
      const a = r === "low" || r === "high" ? null : {
        index: r,
        onClick: () => this.onPageClick(r),
        selected: t === r
      };
      return {
        key: r.toString(),
        pageProps: a
      };
    }, s = this.getPageIndexes();
    return ((e = this.getConfig()) !== null && e !== void 0 && e.rtlEnabled ? [...s].reverse() : s).map((r) => n(r));
  }
  render() {
    const e = this.getPages().map((t) => {
      let {
        key: n,
        pageProps: s
      } = t;
      return s ? qe(2, OC, {
        index: s.index,
        selected: s.selected,
        onClick: s.onClick
      }, n) : gt(1, "div", "dx-separator", ". . .", 16, null, n);
    });
    return Cs(e, 0);
  }
}
QR.defaultProps = DQ;
const TQ = I({}, KR, GR, zR, {
  value: 0,
  isReactComponentWrapper: !0
});
class JR extends bn {
  constructor() {
    super(...arguments), this.state = {}, this.refs = null;
  }
  get componentProps() {
    return this.props;
  }
  render() {
    return qe(2, oC, {
      componentType: Sc,
      componentProps: this.componentProps,
      templateNames: []
    });
  }
}
JR.defaultProps = TQ;
const OQ = `${gQ}  dx-info-text`, AQ = {
  pageIndex: ot.pageIndex,
  pageCount: ot.pageCount,
  pageIndexChangedInternal: ot.pageIndexChangedInternal
};
class eF extends vs {
  constructor(e) {
    super(e), this.state = {
      minWidth: 10
    }, this.refs = null, this.pageIndexRef = ct(), this.updateWidth = this.updateWidth.bind(this), this.selectLastPageIndex = this.selectLastPageIndex.bind(this), this.valueChange = this.valueChange.bind(this);
  }
  componentWillUpdate(e, t, n) {
    super.componentWillUpdate(e, t, n);
  }
  createEffects() {
    return [new et(this.updateWidth, [this.state.minWidth])];
  }
  updateEffects() {
    var e;
    (e = this._effects[0]) === null || e === void 0 || e.update([this.state.minWidth]);
  }
  updateWidth() {
    var e;
    const t = (e = this.pageIndexRef.current) === null || e === void 0 ? void 0 : e.querySelector(".dx-page-index"), n = t ? qR(t) : 0;
    this.setState((s) => ({
      minWidth: n > 0 ? n : s.minWidth
    }));
  }
  getValue() {
    return this.props.pageIndex + 1;
  }
  getWidth() {
    return jR(this.state.minWidth, [this.props.pageCount]);
  }
  getPagesCountText() {
    return (this.props.pagesCountText ?? "") || Vi(this.context, "dxPagination-pagesCountText");
  }
  getInputAttributes() {
    return {
      "aria-label": Vi(this.context, "dxPagination-ariaPageNumber")
    };
  }
  selectLastPageIndex() {
    this.props.pageIndexChangedInternal(this.props.pageCount - 1);
  }
  valueChange(e) {
    this.props.pageIndexChangedInternal(e - 1);
  }
  render() {
    return gt(1, "div", "dx-light-pages", [qe(2, JR, {
      className: "dx-page-index",
      min: 1,
      max: Math.max(this.props.pageCount, this.getValue()),
      width: this.getWidth(),
      value: this.getValue(),
      valueChange: this.valueChange,
      inputAttr: this.getInputAttributes()
    }), gt(1, "span", OQ, this.getPagesCountText(), 0), qe(2, OC, {
      className: "dx-pages-count",
      selected: !1,
      index: this.props.pageCount - 1,
      onClick: this.selectLastPageIndex
    })], 4, null, null, this.pageIndexRef);
  }
}
eF.defaultProps = AQ;
const RQ = {
  nextEnabledClass: "dx-navigate-button dx-next-button",
  prevEnabledClass: "dx-navigate-button dx-prev-button",
  nextDisabledClass: "dx-button-disable dx-navigate-button dx-next-button",
  prevDisabledClass: "dx-button-disable dx-navigate-button dx-prev-button"
}, FQ = {
  next: "prev",
  prev: "next"
};
function kQ(i) {
  return i === "next" ? 1 : -1;
}
const VQ = {
  isLargeDisplayMode: !0,
  maxPagesCount: ot.maxPagesCount,
  pageCount: ot.pageCount,
  pageIndex: ot.pageIndex,
  pageIndexChangedInternal: ot.pageIndexChangedInternal,
  showNavigationButtons: ot.showNavigationButtons,
  itemCount: ot.itemCount
};
class tF extends bn {
  constructor(e) {
    super(e), this.state = {}, this.refs = null, this.__getterCache = {
      prevButtonProps: void 0,
      nextButtonProps: void 0
    }, this.pageIndexChangedInternal = this.pageIndexChangedInternal.bind(this), this.getButtonProps = this.getButtonProps.bind(this), this.canNavigateToPage = this.canNavigateToPage.bind(this), this.getNextPageIndex = this.getNextPageIndex.bind(this), this.canNavigateTo = this.canNavigateTo.bind(this), this.navigateToPage = this.navigateToPage.bind(this);
  }
  getConfig() {
    return this.context[dn.id] ? this.context[dn.id] : dn.defaultValue;
  }
  pageIndexChangedInternal(e) {
    this.canNavigateToPage(e) && this.props.pageIndexChangedInternal(e);
  }
  getButtonProps(e) {
    var t;
    const n = (t = this.getConfig()) !== null && t !== void 0 && t.rtlEnabled ? FQ[e] : e, s = this.canNavigateTo(n);
    return {
      className: RQ[`${e}${s ? "Enabled" : "Disabled"}Class`],
      tabIndex: s ? 0 : -1,
      navigate: () => this.navigateToPage(n)
    };
  }
  canNavigateToPage(e) {
    return this.props.hasKnownLastPage ? e >= 0 && e <= this.props.pageCount - 1 : e >= 0;
  }
  getNextPageIndex(e) {
    return this.props.pageIndex + kQ(e);
  }
  canNavigateTo(e) {
    return this.canNavigateToPage(this.getNextPageIndex(e));
  }
  navigateToPage(e) {
    this.pageIndexChangedInternal(this.getNextPageIndex(e));
  }
  getRenderPrevButton() {
    const {
      isLargeDisplayMode: e,
      showNavigationButtons: t
    } = this.props;
    return (!e || t) ?? !1;
  }
  getRenderNextButton() {
    return this.getRenderPrevButton() || !this.props.hasKnownLastPage;
  }
  getPrevButtonProps() {
    if (this.__getterCache.prevButtonProps !== void 0)
      return this.__getterCache.prevButtonProps;
    const e = (() => this.getButtonProps("prev"))();
    return this.__getterCache.prevButtonProps = e, e;
  }
  getNextButtonProps() {
    if (this.__getterCache.nextButtonProps !== void 0)
      return this.__getterCache.nextButtonProps;
    const e = (() => this.getButtonProps("next"))();
    return this.__getterCache.nextButtonProps = e, e;
  }
  componentWillUpdate(e, t, n) {
    (this.context[dn.id] !== n[dn.id] || this.props.hasKnownLastPage !== e.hasKnownLastPage || this.props.pageCount !== e.pageCount || this.props.pageIndex !== e.pageIndex || this.props.pageIndexChangedInternal !== e.pageIndexChangedInternal) && (this.__getterCache.prevButtonProps = void 0, this.__getterCache.nextButtonProps = void 0);
  }
  getPrevButtonLabel() {
    return Vi(this.context, "dxPagination-prevPage");
  }
  getNextButtonLabel() {
    return Vi(this.context, "dxPagination-nextPage");
  }
  render() {
    const {
      className: e,
      tabIndex: t,
      navigate: n
    } = this.getPrevButtonProps(), {
      isLargeDisplayMode: s,
      maxPagesCount: o,
      pageCount: r,
      pageIndex: a,
      pagesCountText: l
    } = this.props;
    return Cs([this.getRenderPrevButton() && qe(2, Pl, {
      label: this.getPrevButtonLabel(),
      className: e,
      tabIndex: t,
      onClick: n
    }), s && qe(2, QR, {
      maxPagesCount: o,
      pageCount: r,
      pageIndex: a,
      pageIndexChangedInternal: this.pageIndexChangedInternal
    }), !s && qe(2, eF, {
      pageCount: r,
      pageIndex: a,
      pageIndexChangedInternal: this.pageIndexChangedInternal,
      pagesCountText: l
    }), this.getRenderNextButton() && qe(2, Pl, {
      label: this.getNextButtonLabel(),
      className: this.getNextButtonProps().className,
      tabIndex: this.getNextButtonProps().tabIndex,
      onClick: this.getNextButtonProps().navigate
    })], 0);
  }
}
tF.defaultProps = VQ;
const PQ = I({}, ot, {
  infoTextVisible: !0,
  isLargeDisplayMode: !0
});
class nF extends vs {
  constructor(e) {
    super(e), this.state = {}, this.refs = null, this.widgetElementRef = ct(), this.widgetRootElementRef = ct(), this.pagesRef = ct(), this.infoTextRef = ct(), this.__getterCache = {
      keyboardAction: void 0
    }, this.state = {}, this.__getterCache = {}, this.setRootElementRef = this.setRootElementRef.bind(this), this.createFakeInstance = this.createFakeInstance.bind(this);
  }
  createEffects() {
    return [new et(this.setRootElementRef, [])];
  }
  getChildContext() {
    return I({}, this.context, {
      [hl.id]: this.getKeyboardAction() || hl.defaultValue
    });
  }
  setRootElementRef() {
    const {
      rootElementRef: e
    } = this.props;
    e && this.widgetRootElementRef && (e.current = this.widgetRootElementRef.current);
  }
  createFakeInstance() {
    return {
      option: () => !1,
      element: () => {
        var e;
        return (e = this.widgetRootElementRef) === null || e === void 0 ? void 0 : e.current;
      },
      _createActionByOption: () => (e) => {
        var t, n;
        (t = (n = this.props).onKeyDown) === null || t === void 0 || t.call(n, e);
      }
    };
  }
  getKeyboardAction() {
    return {
      registerKeyboardAction: (e, t) => {
        const n = this.createFakeInstance();
        return yT("pager", n, e, void 0, t);
      }
    };
  }
  getInfoVisible() {
    const {
      infoTextVisible: e,
      showInfo: t
    } = this.props;
    return !!t && e;
  }
  getPageIndexSelectorVisible() {
    return this.props.pageSize !== 0;
  }
  getNormalizedDisplayMode() {
    const {
      displayMode: e,
      lightModeEnabled: t
    } = this.props;
    return e === "adaptive" && t !== void 0 ? t ? "compact" : "full" : e ?? "adaptive";
  }
  getPagesContainerVisible() {
    return !!this.props.pagesNavigatorVisible && this.props.pageCount > 0;
  }
  getPagesContainerVisibility() {
    if (this.props.pagesNavigatorVisible === "auto" && this.props.pageCount === 1 && this.props.hasKnownLastPage)
      return "hidden";
  }
  getIsLargeDisplayMode() {
    const e = this.getNormalizedDisplayMode();
    let t = !1;
    return e === "adaptive" ? t = this.props.isLargeDisplayMode : t = e === "full", t;
  }
  getClasses() {
    const e = {
      [`${this.props.className}`]: !!this.props.className,
      [tQ]: !!this.props.isGridCompatibilityMode,
      [nQ]: !this.props.isGridCompatibilityMode,
      [iQ]: !this.getIsLargeDisplayMode()
    };
    return ld(e);
  }
  getAria() {
    return {
      role: "navigation",
      label: this.props.label ?? ""
    };
  }
  componentWillUpdate(e) {
    super.componentWillUpdate(), this.props.onKeyDown !== e.onKeyDown && (this.__getterCache.keyboardAction = void 0);
  }
  render() {
    const {
      isGridCompatibilityMode: e,
      rtlEnabled: t,
      visible: n,
      showPageSizeSelector: s,
      allowedPageSizesRef: o,
      pageSize: r,
      pageSizeChangedInternal: a,
      allowedPageSizes: l,
      infoTextRef: d,
      infoText: u,
      pageCount: c,
      pageIndex: h,
      itemCount: g,
      pagesRef: m,
      hasKnownLastPage: C,
      maxPagesCount: v,
      pageIndexChangedInternal: E,
      pagesCountText: T,
      showNavigationButtons: V,
      style: $,
      width: G,
      height: H,
      elementAttr: ce,
      hint: re,
      disabled: me,
      tabIndex: dt,
      accessKey: Ke,
      activeStateEnabled: ut,
      focusStateEnabled: gn,
      hoverStateEnabled: kt
    } = this.props, Kt = ki(qe(2, ah, I({
      rootElementRef: this.widgetRootElementRef,
      rtlEnabled: t,
      classes: this.getClasses(),
      visible: n,
      aria: this.getAria(),
      style: $,
      width: G,
      height: H,
      hint: re,
      disabled: me,
      tabIndex: dt,
      accessKey: Ke,
      activeStateEnabled: ut,
      focusStateEnabled: gn,
      hoverStateEnabled: kt
    }, ce, {
      children: [s && qe(2, XR, {
        rootElementRef: o,
        isLargeDisplayMode: this.getIsLargeDisplayMode(),
        pageSize: r,
        pageSizeChangedInternal: a,
        allowedPageSizes: l
      }), this.getPagesContainerVisible() && gt(1, "div", sQ, [this.getInfoVisible() && qe(2, HR, {
        rootElementRef: d,
        infoText: u,
        pageCount: c,
        pageIndex: h,
        itemCount: g
      }), this.getPageIndexSelectorVisible() && gt(1, "div", oQ, qe(2, tF, {
        hasKnownLastPage: C,
        isLargeDisplayMode: this.getIsLargeDisplayMode(),
        maxPagesCount: v,
        pageCount: c,
        pageIndex: h,
        pageIndexChangedInternal: E,
        pagesCountText: T,
        showNavigationButtons: V,
        itemCount: g
      }), 2, null, null, m)], 0, {
        style: {
          visibility: this.getPagesContainerVisibility()
        }
      })]
    })));
    return qe(2, NR, {
      isGridCompatibilityMode: e,
      children: Kt
    });
  }
}
nF.defaultProps = PQ;
function MQ(i) {
  let {
    parent: e,
    allowedPageSizes: t,
    pages: n
  } = i;
  return e - (t + n) > 0;
}
function BQ(i) {
  let {
    parent: e,
    allowedPageSizes: t,
    pages: n,
    info: s
  } = i;
  const o = t + n + s;
  return e - o > 0;
}
function $Q(i) {
  let {
    parent: e,
    allowedPageSizes: t,
    pages: n,
    info: s
  } = i;
  const o = bQ(e), r = Hu(t), a = Hu(s), l = Hu(n);
  return {
    parent: o,
    allowedPageSizes: r,
    info: a + ds("marginLeft", s) + ds("marginRight", s),
    pages: l
  };
}
const NQ = {
  paginationProps: I({}, ot)
};
class iF extends vs {
  constructor(e) {
    super(e), this.state = {
      infoTextVisible: !0,
      isLargeDisplayMode: !0
    }, this.refs = null, this.parentRef = ct(), this.infoTextRef = ct(), this.pagesRef = ct(), this.allowedPageSizesRef = ct(), this.elementsWidth = {}, this.actualIsLargeDisplayMode = !0, this.actualInfoTextVisible = !0, this.subscribeToResize = this.subscribeToResize.bind(this), this.effectUpdateChildProps = this.effectUpdateChildProps.bind(this), this.updateAdaptivityProps = this.updateAdaptivityProps.bind(this);
  }
  componentWillUpdate(e, t, n) {
    super.componentWillUpdate(e, t, n);
  }
  createEffects() {
    return [new et(this.subscribeToResize, [this.state.infoTextVisible, this.state.isLargeDisplayMode]), new et(this.effectUpdateChildProps, [this.props, this.state.infoTextVisible, this.state.isLargeDisplayMode, this.props.paginationProps, this.props.contentTemplate])];
  }
  updateEffects() {
    var e, t;
    (e = this._effects[0]) === null || e === void 0 || e.update([this.state.infoTextVisible, this.state.isLargeDisplayMode]), (t = this._effects[1]) === null || t === void 0 || t.update([this.props, this.state.infoTextVisible, this.state.isLargeDisplayMode, this.props.paginationProps, this.props.contentTemplate]);
  }
  subscribeToResize() {
    const e = () => {
      this.getParentWidth() > 0 && this.updateAdaptivityProps();
    };
    return qo.add(e), () => {
      qo.remove(e);
    };
  }
  effectUpdateChildProps() {
    this.getParentWidth() > 0 && this.updateAdaptivityProps();
  }
  getContentAttributes() {
    const {
      className: e,
      displayMode: t,
      isGridCompatibilityMode: n,
      hasKnownLastPage: s,
      infoText: o,
      label: r,
      lightModeEnabled: a,
      maxPagesCount: l,
      onKeyDown: d,
      pageCount: u,
      pageIndex: c,
      pageIndexChangedInternal: h,
      pageSize: g,
      pageSizeChangedInternal: m,
      allowedPageSizes: C,
      pagesCountText: v,
      pagesNavigatorVisible: E,
      rtlEnabled: T,
      showInfo: V,
      showNavigationButtons: $,
      showPageSizeSelector: G,
      itemCount: H,
      visible: ce,
      style: re,
      width: me,
      height: dt,
      elementAttr: Ke,
      hint: ut,
      disabled: gn,
      tabIndex: kt,
      accessKey: Kt,
      activeStateEnabled: Et,
      focusStateEnabled: Re,
      hoverStateEnabled: Fe
    } = this.props.paginationProps;
    return {
      pageSize: g,
      pageIndex: c,
      pageIndexChangedInternal: h,
      pageSizeChangedInternal: m,
      isGridCompatibilityMode: n,
      className: e,
      showInfo: V,
      infoText: o,
      lightModeEnabled: a,
      displayMode: t,
      maxPagesCount: l,
      pageCount: u,
      pagesCountText: v,
      visible: ce,
      hasKnownLastPage: s,
      pagesNavigatorVisible: E,
      showPageSizeSelector: G,
      allowedPageSizes: C,
      rtlEnabled: T,
      showNavigationButtons: $,
      itemCount: H,
      onKeyDown: d,
      label: r,
      style: re,
      width: me,
      height: dt,
      elementAttr: Ke,
      hint: ut,
      disabled: gn,
      tabIndex: kt,
      accessKey: Kt,
      activeStateEnabled: Et,
      focusStateEnabled: Re,
      hoverStateEnabled: Fe
    };
  }
  getParentWidth() {
    var e;
    return (e = this.parentRef) !== null && e !== void 0 && e.current ? Hu(this.parentRef.current) : 0;
  }
  updateAdaptivityProps() {
    var e, t, n, s;
    const o = $Q({
      parent: (e = this.parentRef) === null || e === void 0 ? void 0 : e.current,
      allowedPageSizes: (t = this.allowedPageSizesRef) === null || t === void 0 ? void 0 : t.current,
      info: (n = this.infoTextRef) === null || n === void 0 ? void 0 : n.current,
      pages: (s = this.pagesRef) === null || s === void 0 ? void 0 : s.current
    });
    if (this.actualInfoTextVisible !== this.state.infoTextVisible || this.actualIsLargeDisplayMode !== this.state.isLargeDisplayMode)
      return;
    const r = !f(this.elementsWidth);
    r && (this.elementsWidth = {}), (r || this.state.isLargeDisplayMode) && (this.elementsWidth.allowedPageSizes = o.allowedPageSizes, this.elementsWidth.pages = o.pages), (r || this.state.infoTextVisible) && (this.elementsWidth.info = o.info), this.actualIsLargeDisplayMode = MQ({
      parent: o.parent,
      allowedPageSizes: this.elementsWidth.allowedPageSizes,
      pages: this.elementsWidth.pages
    }), this.actualInfoTextVisible = BQ(I({}, o, {
      info: this.elementsWidth.info
    })), this.setState(() => ({
      infoTextVisible: this.actualInfoTextVisible
    })), this.setState(() => ({
      isLargeDisplayMode: this.actualIsLargeDisplayMode
    }));
  }
  render() {
    const {
      infoTextVisible: e,
      isLargeDisplayMode: t
    } = this.state, {
      props: {
        contentTemplate: n
      }
    } = this;
    return ki(qe(2, n, I({
      rootElementRef: this.parentRef,
      allowedPageSizesRef: this.allowedPageSizesRef,
      infoTextRef: this.infoTextRef,
      pagesRef: this.pagesRef,
      infoTextVisible: e,
      isLargeDisplayMode: t
    }, this.getContentAttributes())));
  }
}
iF.defaultProps = NQ;
let sF = class extends ql {
  constructor(e) {
    super(e), this.__getterCache = {}, this.pageIndexChangedInternal = this.pageIndexChangedInternal.bind(this), this.pageSizeChangedInternal = this.pageSizeChangedInternal.bind(this);
  }
  createEffects() {
    return [Yl()];
  }
  pageIndexChangedInternal(e) {
    const t = e + 1;
    this.setState(() => ({
      pageIndex: t
    })), this.props.pageIndexChangedInternal(t);
  }
  getPageIndex() {
    return this.props.pageIndex - 1;
  }
  pageSizeChangedInternal(e) {
    this.setState(() => ({
      pageSize: e
    })), this.props.pageSizeChangedInternal(e);
  }
  getClassName() {
    return ld({
      "dx-datagrid-pager": LR(this.context),
      [`${this.props.className}`]: !!this.props.className
    });
  }
  getPaginationProps() {
    return I({}, this.props, {
      className: this.getClassName(),
      pageIndex: this.getPageIndex(),
      pageIndexChangedInternal: (e) => this.pageIndexChangedInternal(e),
      pageSizeChangedInternal: (e) => this.pageSizeChangedInternal(e)
    });
  }
  render() {
    return qe(2, iF, {
      contentTemplate: nF,
      paginationProps: this.getPaginationProps()
    });
  }
};
sF.defaultProps = ot;
function LQ(i) {
  return i < 1 ? 1 : i;
}
function HQ(i) {
  return i < 0 ? 0 : i;
}
function oF(i, e) {
  return i > 0 && e > 0 ? Math.max(1, Math.ceil(e / i)) : 1;
}
function WQ(i, e, t) {
  if (i < 1)
    return 1;
  const n = oF(e, t);
  return Math.min(i, n);
}
function zQ(i, e, t) {
  const n = LQ(i), s = HQ(t), o = oF(n, t), r = WQ(e, n, s);
  return {
    pageSize: n,
    pageIndex: r,
    itemCount: s,
    pageCount: o
  };
}
const KQ = ["pageSize", "pageIndex", "itemCount"];
class GQ extends hd {
  _optionChanged(e) {
    switch (e.name) {
      case "pageIndex": {
        const t = this.option("pageIndexChanged");
        t && t(e.value);
        break;
      }
      case "pageSize": {
        const t = this.option("pageSizeChanged");
        t && t(e.value);
        break;
      }
    }
    super._optionChanged(e);
  }
  getPageCount() {
    return this.option("pageCount");
  }
  _validateOptions(e) {
    if (e._skipValidation || this.option("_skipValidation"))
      return e;
    const t = super._validateOptions(e);
    let {
      pageSize: n,
      pageIndex: s,
      itemCount: o
    } = t, r = hi(t, KQ);
    n === void 0 && (n = this.option("pageSize")), s === void 0 && (s = this.option("pageIndex")), o === void 0 && (o = this.option("itemCount"));
    const a = zQ(n, s, o);
    return I({}, r, a);
  }
}
class UQ extends GQ {
  getProps() {
    const e = super.getProps();
    return e.onKeyDown = this._wrapKeyDownHandler(e.onKeyDown), e;
  }
  get _propsInfo() {
    return {
      twoWay: [
        ["pageSize", "defaultPageSize", "pageSizeChangedInternal", "pageSizeChanged"],
        ["pageIndex", "defaultPageIndex", "pageIndexChangedInternal", "pageIndexChanged"]
      ],
      allowNull: [],
      elements: [],
      templates: [],
      props: ["defaultPageSize", "pageSizeChanged", "pageSizeChangedInternal", "defaultPageIndex", "pageIndexChanged", "pageIndexChangedInternal", "isGridCompatibilityMode", "className", "showInfo", "infoText", "lightModeEnabled", "displayMode", "maxPagesCount", "pageCount", "pagesCountText", "visible", "hasKnownLastPage", "pagesNavigatorVisible", "showPageSizeSelector", "allowedPageSizes", "rtlEnabled", "showNavigationButtons", "itemCount", "label", "onKeyDown", "pageSize", "pageIndex", "width", "height", "elementAttr", "hint", "disabled", "tabIndex", "accessKey", "activeStateEnabled", "focusStateEnabled", "hoverStateEnabled", "_skipValidation"]
    };
  }
  get _viewComponent() {
    return sF;
  }
}
const H0 = function(i) {
  return 1 + (parseInt(i.pageIndex()) || 0);
};
class jQ extends Ue.View {
  init() {
    const e = this.getController("data");
    e.changed.add((t) => {
      if (t && t.repaintChangesOnly) {
        const n = this._pager;
        n ? n.option({
          pageIndex: H0(e),
          pageSize: e.pageSize(),
          pageCount: e.pageCount(),
          itemCount: e.totalCount(),
          hasKnownLastPage: e.hasKnownLastPage()
        }) : this.render();
      } else
        (!t || t.changeType !== "update" && t.changeType !== "updateSelection" && t.changeType !== "updateFocusedRow") && (this._pager = null, this.render());
    });
  }
  dispose() {
    this._pager = null;
  }
  optionChanged(e) {
    const {
      name: t
    } = e, n = t === "pager", s = t === "paging", o = t === "dataSource", r = t === "scrolling", a = this.getController("data");
    if (n || s || r || o) {
      if (e.handled = !0, a.skipProcessingPagingChange(e.fullName))
        return;
      (n || s) && (this._pageSizes = null), o || (this._pager = null, this._invalidate(), ae() && n && this.component && this.component.resize());
    }
  }
  _renderCore() {
    const e = this, t = e.element().addClass(e.addWidgetPrefix("pager")), n = e.option("pager") ?? {}, s = e.getController("data"), o = e.getController("keyboardNavigation"), r = {
      maxPagesCount: 10,
      pageIndex: H0(s),
      pageCount: s.pageCount(),
      pageSize: s.pageSize(),
      showPageSizeSelector: n.showPageSizeSelector,
      showInfo: n.showInfo,
      displayMode: n.displayMode,
      pagesNavigatorVisible: n.visible,
      showNavigationButtons: n.showNavigationButtons,
      label: n.label,
      allowedPageSizes: e.getPageSizes(),
      itemCount: s.totalCount(),
      hasKnownLastPage: s.hasKnownLastPage(),
      rtlEnabled: e.option("rtlEnabled"),
      isGridCompatibilityMode: !0,
      _skipValidation: !0,
      pageIndexChanged(a) {
        s.pageIndex() !== a - 1 && s.pageIndex(a - 1);
      },
      pageSizeChanged(a) {
        s.pageSize(a);
      },
      onKeyDown: (a) => o && o.executeAction("onKeyDown", a)
    };
    if (f(n.infoText) && (r.infoText = n.infoText), this._pager) {
      this._pager.repaint();
      return;
    }
    ae() ? this._pager = e._createComponent(t, UQ, r) : t.addClass("dx-pager").html('<div class="dx-pages"><div class="dx-page"></div></div>');
  }
  getPager() {
    return this._pager;
  }
  getPageSizes() {
    const e = this, t = e.getController("data"), n = e.option("pager"), s = n && n.allowedPageSizes, o = t.pageSize();
    return (!f(e._pageSizes) || !e._pageSizes.includes(o)) && (e._pageSizes = [], n && (Array.isArray(s) ? e._pageSizes = s : s && o > 1 && (e._pageSizes = [Math.floor(o / 2), o, 2 * o]))), e._pageSizes;
  }
  isVisible() {
    const e = this.getController("data"), t = this.option("pager");
    let n = t && t.visible;
    const s = this.option("scrolling");
    return n === "auto" && (s && (s.mode === "virtual" || s.mode === "infinite") ? n = !1 : n = e.pageCount() > 1 || e.isLoaded() && !e.hasKnownLastPage()), !!n;
  }
  getHeight() {
    return this.getElementHeight();
  }
}
const qQ = {
  defaultOptions: () => ({
    pager: {
      visible: "auto",
      showPageSizeSelector: !1,
      allowedPageSizes: "auto",
      label: S.format("dxPager-ariaLabel")
    }
  }),
  views: {
    pagerView: jQ
  }
};
J.registerModule("pager", qQ);
const W0 = "columns-separator-transparent", Cn = "dxDataGridResizingReordering", gl = function(i) {
  return i.option("allowColumnResizing") || i.getController("columns").isColumnOptionUsed("allowResizing");
}, rF = function(i) {
  return i.option("allowColumnReordering") || i.getController("columns").isColumnOptionUsed("allowReordering");
};
class YQ extends Ue.View {
  init() {
    super.init(), this._tablePositionController = this.getController("tablePosition"), this._subscribeToCallback();
  }
  dispose() {
    this._unsubscribeFromCallback(), super.dispose();
  }
  optionChanged(e) {
    e.name === "allowColumnResizing" && (this._unsubscribeFromCallback(), e.value && (this._subscribeToCallback(), this._invalidate())), super.optionChanged(e);
  }
  _renderCore() {
    const e = super._renderCore();
    return this.element().addClass(this.addWidgetPrefix("tracker")), this.hide(), e;
  }
  _unsubscribeFromCallback() {
    this._positionChanged && this._tablePositionController.positionChanged.remove(this._positionChanged);
  }
  _subscribeToCallback() {
    const e = this;
    e._positionChanged = function(t) {
      const n = e.element();
      n && n.hasClass(e.addWidgetPrefix("tracker")) && (n.css({
        top: t.top
      }), js(n, t.height));
    }, this._tablePositionController.positionChanged.add(e._positionChanged);
  }
  isVisible() {
    return gl(this);
  }
  show() {
    this.element().show();
  }
  hide() {
    this.element() && this.element().hide();
  }
  setHeight(e) {
    js(this.element(), e);
  }
}
class aF extends Ue.View {
  _renderSeparator() {
  }
  _renderCore(e) {
    const t = super._renderCore(e);
    return this._isShown = !0, this._renderSeparator(), this.hide(), t;
  }
  show() {
    this._isShown = !0;
  }
  hide() {
    this._isShown = !1;
  }
  height(e) {
    const t = this.element();
    if (t)
      if (f(e))
        js(t, e);
      else
        return le(t);
  }
  width(e) {
    const t = this.element();
    if (t)
      if (f(e))
        xl(t, e);
      else
        return ne(t);
  }
}
class XQ extends aF {
  init() {
    super.init(), this._tablePositionController = this.getController("tablePosition"), this._init();
  }
  dispose() {
    this._unsubscribeFromCallback(), super.dispose();
  }
  optionChanged(e) {
    e.name === "allowColumnResizing" && (e.value ? (this._init(), this._invalidate(), this.hide(!0)) : (this._unsubscribeFromCallback(), this._isTransparent = gl(this), this.hide(!0))), super.optionChanged(e);
  }
  _renderSeparator() {
    super._renderSeparator(), this.element().addClass(this.addWidgetPrefix("columns-separator"));
  }
  _subscribeToCallback() {
    const e = this;
    let t;
    e._positionChanged = function(n) {
      t = e.element(), t && (t.css({
        top: n.top
      }), js(t, n.height));
    }, e._tablePositionController.positionChanged.add(e._positionChanged);
  }
  _unsubscribeFromCallback() {
    this._positionChanged && this._tablePositionController.positionChanged.remove(this._positionChanged);
  }
  _init() {
    this._isTransparent = gl(this), this.isVisible() && this._subscribeToCallback();
  }
  isVisible() {
    return this.option("showColumnHeaders") && (rF(this) || gl(this));
  }
  show() {
    const e = this, t = this.element();
    t && !e._isShown && (e._isTransparent ? t.removeClass(e.addWidgetPrefix(W0)) : t.show()), super.show();
  }
  hide(e) {
    const t = this.element(), n = this.addWidgetPrefix(W0);
    t && (this._isShown || e) && (this._isTransparent ? (t.addClass(n), t.css("left", ""), t.show()) : (t.hasClass(n) && t.removeClass(n), t.hide())), super.hide();
  }
  moveByX(e) {
    const t = this.element();
    t && t.css("left", e === null ? 0 : e - this._parentElement().offset().left);
  }
  changeCursor(e) {
    e = f(e) ? e : "";
    const t = this.element();
    t && t.css("cursor", e);
  }
}
class ZQ extends aF {
  init() {
    super.init(), this.getController("data").loadingChanged.add((t) => {
      t || this.hide();
    });
  }
  _renderSeparator() {
    super._renderSeparator(), this.element().addClass("dx-block-separator").html("&nbsp;");
  }
  hide() {
    const e = this, t = this._parentElement(), n = this.element();
    n && this._isShown && n.css("display", "none"), t && !t.children(".dx-block-separator").length && t.prepend(e.element()), super.hide();
  }
  isVisible() {
    const e = this.option("groupPanel"), t = this.option("columnChooser");
    return e && e.visible || t && t.enabled;
  }
  show(e) {
    const t = this.element();
    if (t && !this._isShown)
      switch (e) {
        case "group":
          this.element().css("display", "block");
          break;
        case "columnChooser":
          (function(n) {
            Le.stop(t, !0), Le.animate(t, {
              type: "slide",
              from: {
                width: 0,
                display: n.display
              },
              to: n,
              duration: 300,
              easing: "swing"
            });
          })({
            width: "100%",
            display: "block"
          });
          break;
        default:
          t.css("display", "");
      }
    super.show();
  }
}
class QQ extends Ue.View {
  init() {
    super.init();
    const e = this.getController("data");
    this._controller = this.getController("draggingHeader"), this._columnsResizerViewController = this.getController("columnsResizer"), this._columnsController = this.getController("columns"), this._isDragging = !1, e.loadingChanged.add((t) => {
      const n = this.element();
      !t && n && n.hide();
    });
  }
  isDragging() {
    return this._isDragging;
  }
  _getDraggingPanelByPos(e) {
    let t;
    return y(this._dragOptions.draggingPanels, (n, s) => {
      if (s) {
        const o = s.getBoundingRect();
        if (o && (o.bottom === void 0 || e.y < o.bottom) && (o.top === void 0 || e.y > o.top) && (o.left === void 0 || e.x > o.left) && (o.right === void 0 || e.x < o.right))
          return t = s, !1;
      }
    }), t;
  }
  _renderCore() {
    this.element().addClass(`${this.addWidgetPrefix("drag-header")} ${this.addWidgetPrefix("text-content")} dx-widget`).hide();
  }
  _resetTargetColumnOptions() {
    const e = this._dropOptions;
    e.targetColumnIndex = -1, delete e.targetColumnElement, delete e.isLast, delete e.posX, delete e.posY;
  }
  _getVisibleIndexObject(e, t) {
    return f(e) ? {
      columnIndex: t,
      rowIndex: e
    } : t;
  }
  dispose() {
    const e = this.element();
    this._dragOptions = null, e && e.parent().find(`.${this.addWidgetPrefix("drag-header")}`).remove();
  }
  isVisible() {
    const e = this._columnsController.getCommonSettings();
    return this.option("showColumnHeaders") && (rF(this) || e.allowGrouping || e.allowHiding);
  }
  dragHeader(e) {
    const {
      columnElement: t
    } = e, n = !!e.sourceColumn.type;
    this._isDragging = !0, this._dragOptions = e, this._dropOptions = {
      sourceIndex: e.index,
      sourceColumnIndex: this._getVisibleIndexObject(e.rowIndex, e.columnIndex),
      sourceColumnElement: e.columnElement,
      sourceLocation: e.sourceLocation
    };
    const s = O.getDocument();
    this._onSelectStart = s.onselectstart, s.onselectstart = function() {
      return !1;
    }, this._controller.drag(this._dropOptions), this.element().css({
      textAlign: t && t.css("textAlign"),
      height: t && (n && t.get(0).clientHeight || le(t)),
      width: t && (n && t.get(0).clientWidth || ne(t)),
      whiteSpace: t && t.css("whiteSpace")
    }).addClass(this.addWidgetPrefix("drag-action")).toggleClass("dx-drag-command-cell", n).text(n ? "" : e.sourceColumn.caption), this.element().appendTo(XT.getSwatchContainer(t));
  }
  moveHeader(e) {
    const t = e.event, {
      that: n
    } = t.data, s = st(t), o = n._columnsResizerViewController ? n._columnsResizerViewController.isResizing() : !1, r = n._dragOptions;
    if (n._isDragging && !o) {
      const a = n.element(), l = Math.abs(s.x - r.columnElement.offset().left - r.deltaX), d = Math.abs(s.y - r.columnElement.offset().top - r.deltaY);
      if (a.is(":visible") || l > 5 || d > 5) {
        a.show();
        const u = s.x - r.deltaX, c = s.y - r.deltaY;
        a.css({
          left: u,
          top: c
        }), n.dockHeader(s);
      }
      t.preventDefault();
    }
  }
  dockHeader(e) {
    const t = this, n = t._getDraggingPanelByPos(e), s = t._controller, o = t._dropOptions, r = t._dragOptions;
    if (n) {
      const a = t.option("rtlEnabled"), l = n.getName() === "columnChooser", d = l ? "y" : "x", u = n.getName(), c = u === "headers" ? r.rowIndex : void 0, {
        sourceColumn: h
      } = r, g = n.getColumnElements(c, h?.ownerBand) || [], m = r.pointsByTarget = r.pointsByTarget || {}, C = u === "columnChooser" ? [] : m[u] || s._generatePointsByColumns(x({}, r, {
        targetDraggingPanel: n,
        columns: n.getColumns(c),
        columnElements: g,
        isVerticalOrientation: l,
        startColumnIndex: u === "headers" ? p(g[0]).index() : 0
      }));
      if (m[u] = C, o.targetLocation = u, C.length > 0)
        for (let v = 0; v < C.length; v++) {
          const E = C[v + 1] && (C[v][d] + C[v + 1][d]) / 2;
          if (E === void 0 || (a && d === "x" ? e[d] > E : e[d] < E)) {
            o.targetColumnIndex = t._getVisibleIndexObject(c, C[v].columnIndex), g[v] ? (o.targetColumnElement = g.eq(v), o.isLast = !1) : (o.targetColumnElement = g.last(), o.isLast = !0), o.posX = C[v].x, o.posY = C[v].y, s.dock(o);
            break;
          }
        }
      else
        t._resetTargetColumnOptions(), s.dock(o);
    }
  }
  dropHeader(e) {
    const t = e.event, {
      that: n
    } = t.data, s = n._controller;
    n.element().hide(), s && n._isDragging && s.drop(n._dropOptions), n.element().appendTo(n._parentElement()), n._dragOptions = null, n._dropOptions = null, n._isDragging = !1, O.getDocument().onselectstart = n._onSelectStart || null;
  }
}
const Wa = function(i) {
  return i.option("columnResizingMode") !== "widget";
};
class JQ extends Ue.ViewController {
  init() {
    this._subscribesToCallbacks = [], gl(this) && this._init();
  }
  dispose() {
    this._unsubscribes(), super.dispose();
  }
  optionChanged(e) {
    super.optionChanged(e), e.name === "allowColumnResizing" && (e.value ? (this._init(), this._subscribeToEvents()) : this._unsubscribes());
  }
  _isHeadersRowArea(e) {
    if (this._columnHeadersView) {
      const t = this._columnHeadersView.element();
      if (t) {
        const n = t.offset().top, s = this._columnHeadersView.getHeadersRowHeight();
        return e >= n && e <= n + s;
      }
    }
    return !1;
  }
  _isRtlParentStyle() {
    var e;
    return this.option("rtlEnabled") && ((e = this._$parentContainer) === null || e === void 0 ? void 0 : e.parent().css("direction")) === "rtl";
  }
  _correctColumnIndexForPoint(e, t, n) {
    e.columnIndex -= t;
  }
  _pointCreated(e, t, n) {
    const s = Wa(this), o = this.option("rtlEnabled"), r = this._isRtlParentStyle(), a = !s && o && !r ? 0 : 1;
    if (e.index >= a && e.index < t + (!s && (!o || r) ? 1 : 0)) {
      this._correctColumnIndexForPoint(e, a, n);
      const l = n[e.columnIndex] || {}, d = n[e.columnIndex + 1] || {};
      return !(s ? l.allowResizing && d.allowResizing : l.allowResizing);
    }
    return !0;
  }
  _getTargetPoint(e, t, n) {
    if (e) {
      for (let s = 0; s < e.length; s++)
        if (!(e[s].x === e[0].x && e[s + 1] && e[s].x === e[s + 1].x) && e[s].x - n <= t && t <= e[s].x + n)
          return e[s];
    }
    return null;
  }
  getSeparatorOffsetX(e) {
    var t;
    const n = Wa(this), s = this.option("rtlEnabled"), o = this._isRtlParentStyle(), r = e[0].getBoundingClientRect().width;
    return (((t = e.offset()) === null || t === void 0 ? void 0 : t.left) ?? 0) + ((n || o) && s ? 0 : r);
  }
  _moveSeparator(e) {
    var t;
    const n = e.event, s = n.data, o = s._columnsSeparatorView.width(), r = Wa(s), a = o / 2, l = s._$parentContainer.offset(), d = l.left, u = st(n), c = this._isRtlParentStyle(), h = (t = s._draggingHeaderView) === null || t === void 0 ? void 0 : t.isDragging();
    if (s._isResizing && s._resizingInfo) {
      if ((d <= u.x || !r && c) && (!r || u.x <= d + ne(s._$parentContainer)) && s._updateColumnsWidthIfNeeded(u.x)) {
        const g = s._columnHeadersView.getColumnElements().eq(s._resizingInfo.currentColumnIndex);
        if (g.length) {
          const m = this.getSeparatorOffsetX(g);
          s._columnsSeparatorView.moveByX(m), s._tablePositionController.update(s._targetPoint.y), n.preventDefault();
        }
      }
    } else
      h || (s._isHeadersRowArea(u.y) ? (s._previousParentOffset && (s._previousParentOffset.left !== l.left || s._previousParentOffset.top !== l.top) && s.pointsByColumns(null), s._targetPoint = s._getTargetPoint(s.pointsByColumns(), u.x, o), s._previousParentOffset = l, s._isReadyResizing = !1, s._targetPoint ? (s._columnsSeparatorView.changeCursor("col-resize"), s._columnsSeparatorView.moveByX(s._targetPoint.x - a), s._tablePositionController.update(s._targetPoint.y), s._isReadyResizing = !0, n.preventDefault()) : (s._columnsSeparatorView.changeCursor(), s._columnsSeparatorView.moveByX(null))) : (s.pointsByColumns(null), s._isReadyResizing = !1, s._columnsSeparatorView.changeCursor(), s._columnsSeparatorView.moveByX(null)));
  }
  _endResizing(e) {
    const n = e.event.data;
    n._isResizing && (n.pointsByColumns(null), n._resizingInfo = null, n._columnsSeparatorView.hide(), n._columnsSeparatorView.changeCursor(), n._trackerView.hide(), n._isReadyResizing = !1, n._isResizing = !1);
  }
  _getNextColumnIndex(e) {
    return e + 1;
  }
  _setupResizingInfo(e) {
    const t = this._targetPoint.columnIndex, n = this._getNextColumnIndex(t), s = this._columnHeadersView.getHeaderElement(t), o = this._columnHeadersView.getHeaderElement(n);
    this._resizingInfo = {
      startPosX: e,
      currentColumnIndex: t,
      currentColumnWidth: s != null && s.length ? Ge(s[0]).width : 0,
      nextColumnIndex: n,
      nextColumnWidth: o != null && o.length ? Ge(o[0]).width : 0,
      needToInvertResizing: this._needToInvertResizing(s)
    };
  }
  _startResizing(e) {
    const t = e.event, n = t.data, s = st(t);
    if (Zl(t) && (n._isHeadersRowArea(s.y) ? (n._targetPoint = n._getTargetPoint(n.pointsByColumns(), s.x, 10), n._targetPoint && (n._columnsSeparatorView.moveByX(n._targetPoint.x - n._columnsSeparatorView.width() / 2), n._isReadyResizing = !0)) : n._isReadyResizing = !1), n._isReadyResizing) {
      n._setupResizingInfo(s.x), n._isResizing = !0, n._tablePositionController.update(n._targetPoint.y), n._columnsSeparatorView.show(), n._trackerView.show();
      const o = n.component.getScrollable();
      o && n._isRtlParentStyle() && (n._scrollRight = ne(o.$content()) - ne(o.container()) - o.scrollLeft()), t.preventDefault(), t.stopPropagation();
    }
    this.isResizing() && this._editorFactoryController.loseFocus();
  }
  _generateColumnsTopYIndex() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : !1;
    const t = this, n = t._columnsController.getRowCount(), s = {}, o = (r) => {
      const a = Math.ceil(r.x);
      return s[a] || (s[a] = r.y), !0;
    };
    for (let r = 0; r < n - 1; r++) {
      const a = t._columnHeadersView.getColumnElements(r);
      a && a.length > 0 && F.getPointsByColumns(a, o, !1, 0, e);
    }
    return s;
  }
  _generatePointsByColumns() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : !1;
    const t = this, n = t._generateColumnsTopYIndex(e), s = t._columnsController ? t._columnsController.getVisibleColumns() : [], o = t._columnHeadersView.getColumnElements();
    t._pointsByColumns = [], o && o.length > 0 && (t._pointsByColumns = F.getPointsByColumns(o, (r) => t._pointCreated(((a) => {
      const l = Math.ceil(a.x);
      return n[l] && (a.y = n[l]), a;
    })(r), o.length, s), !1, 0, e));
  }
  _needToInvertResizing(e) {
    const t = this.option("rtlEnabled"), n = this._isRtlParentStyle();
    return (Wa(this) || n) && t;
  }
  _unsubscribeFromEvents() {
    this._moveSeparatorHandler && _.off(O.getDocument(), R(ye.move, Cn), this._moveSeparatorHandler), this._startResizingHandler && _.off(this._$parentContainer, R(ye.down, Cn), this._startResizingHandler), this._endResizingHandler && (_.off(this._columnsSeparatorView.element(), R(ye.up, Cn), this._endResizingHandler), _.off(O.getDocument(), R(ye.up, Cn), this._endResizingHandler));
  }
  _subscribeToEvents() {
    this._moveSeparatorHandler = this.createAction(this._moveSeparator), this._startResizingHandler = this.createAction(this._startResizing), this._endResizingHandler = this.createAction(this._endResizing), _.on(O.getDocument(), R(ye.move, Cn), this, this._moveSeparatorHandler), _.on(this._$parentContainer, R(ye.down, Cn), this, this._startResizingHandler), _.on(this._columnsSeparatorView.element(), R(ye.up, Cn), this, this._endResizingHandler), _.on(O.getDocument(), R(ye.up, Cn), this, this._endResizingHandler);
  }
  _updateColumnsWidthIfNeeded(e) {
    let t, n = !1, s = this._rowsView.contentWidth();
    const o = this._resizingInfo, r = this._columnsController, a = r.getVisibleColumns(), l = this._columnsSeparatorView.width(), d = Wa(this), u = d && this.option("adaptColumnWidthByRatio") && !this.option("columnAutoWidth"), c = this._isRtlParentStyle(), h = a[o.currentColumnIndex], g = a[o.nextColumnIndex], {
      needToInvertResizing: m
    } = o;
    function C(V) {
      return te(V) && V.endsWith("%");
    }
    function v(V, $, G, H) {
      if (V) {
        const ce = V.width;
        ce && (H = C(ce)), H ? (r.columnOption(V.index, "visibleWidth", $), r.columnOption(V.index, "width", `${($ / G * 100).toFixed(3)}%`)) : (r.columnOption(V.index, "visibleWidth", null), r.columnOption(V.index, "width", $));
      }
    }
    t = e - o.startPosX, m && (t = -t);
    let {
      cellWidth: E,
      nextCellWidth: T
    } = function(V) {
      let $, G, H;
      const ce = o.currentColumnWidth + V, re = h && h.minWidth || l, me = {};
      return ce >= re ? me.cellWidth = ce : (me.cellWidth = re, H = !0), d && (G = o.nextColumnWidth - V, $ = g && g.minWidth || l, G >= $ ? H ? me.nextCellWidth = o.nextColumnWidth - (V + re - ce) : me.nextCellWidth = G : (me.nextCellWidth = $, me.cellWidth = o.currentColumnWidth + (V - $ + G))), me;
    }(t);
    if (n = h.width !== E, n) {
      if (r.beginUpdate(), E = Math.floor(E), s = function(V, $) {
        if ($.every((H) => H.width)) {
          const H = $.reduce((ce, re) => (C(re.width) && (ce += parseFloat(re.width)), ce), 0);
          H > 100 && (V = V / H * 100);
        }
        return V;
      }(s, a), v(h, E, s, u), d)
        T = Math.floor(T), v(g, T, s, u);
      else {
        const V = this._columnHeadersView.getColumnWidths();
        if (V[o.currentColumnIndex] = E, !(V.reduce((G, H) => G + H, 0) > this._rowsView.contentWidth())) {
          const G = F.getLastResizableColumnIndex(a);
          G >= 0 && r.columnOption(a[G].index, "visibleWidth", "auto");
        }
        for (let G = 0; G < V.length; G++)
          a[G] && a[G] !== h && a[G].width === void 0 && r.columnOption(a[G].index, "width", V[G]);
      }
      if (r.endUpdate(), !d) {
        this.component.updateDimensions();
        const V = this.component.getScrollable();
        if (V && c) {
          const $ = ne(V.$content()) - ne(V.container()) - this._scrollRight;
          V.scrollTo({
            left: $
          });
        }
      }
    }
    return n;
  }
  _subscribeToCallback(e, t) {
    e.add(t), this._subscribesToCallbacks.push({
      callback: e,
      handler: t
    });
  }
  _unsubscribeFromCallbacks() {
    for (let e = 0; e < this._subscribesToCallbacks.length; e++) {
      const t = this._subscribesToCallbacks[e];
      t.callback.remove(t.handler);
    }
    this._subscribesToCallbacks = [];
  }
  _unsubscribes() {
    this._unsubscribeFromEvents(), this._unsubscribeFromCallbacks();
  }
  _init() {
    const e = () => {
      this._isResizing || this.pointsByColumns(null);
    }, t = (o) => {
      this._scrollLeft !== o.left && (this._scrollLeft = o.left, this.pointsByColumns(null));
    };
    this._columnsSeparatorView = this.getView("columnsSeparatorView"), this._columnHeadersView = this.getView("columnHeadersView"), this._trackerView = this.getView("trackerView"), this._rowsView = this.getView("rowsView"), this._columnsController = this.getController("columns"), this._tablePositionController = this.getController("tablePosition"), this._editorFactoryController = this.getController("editorFactory"), this._draggingHeaderView = this.component.getView("draggingHeaderView"), this._$parentContainer = this.component.$element(), this._subscribeToCallback(this._columnHeadersView.renderCompleted, e), this._subscribeToCallback(this._columnHeadersView.resizeCompleted, e), this._subscribeToCallback(this._columnsSeparatorView.renderCompleted, () => {
      this._unsubscribeFromEvents(), this._subscribeToEvents();
    }), this._subscribeToCallback(this._rowsView.renderCompleted, () => {
      this._rowsView.scrollChanged.remove(t), this._rowsView.scrollChanged.add(t);
    });
    let n = this._rowsView.getScrollbarWidth() !== 0, s = 0;
    this._subscribeToCallback(this._tablePositionController.positionChanged, (o) => {
      if (this._isResizing && !this._rowsView.isResizing) {
        const r = this._rowsView.getScrollbarWidth() !== 0;
        n !== r || s && s !== o.height ? (n = r, s = o.height, this.component.updateDimensions()) : this._rowsView.updateFreeSpaceRowHeight();
      }
      s = o.height;
    });
  }
  isResizing() {
    return this._isResizing;
  }
  pointsByColumns(e) {
    if (e !== void 0)
      this._pointsByColumns = e;
    else
      return this._pointsByColumns || this._generatePointsByColumns(), this._pointsByColumns;
  }
}
class eJ extends Ue.ViewController {
  constructor(e) {
    super(e), this.positionChanged = Ie();
  }
  init() {
    super.init(), this._columnsResizerController = this.getController("columnsResizer"), this._columnHeadersView = this.getView("columnHeadersView"), this._rowsView = this.getView("rowsView"), this._pagerView = this.getView("pagerView"), this._rowsView.resizeCompleted.add(() => {
      if (this.option("allowColumnResizing")) {
        const e = this._columnsResizerController._targetPoint;
        this.update(e ? e.y : null);
      }
    });
  }
  update(e) {
    const t = {}, n = this._columnHeadersView.element(), s = n && n.offset(), o = s && s.top || 0, r = f(e) ? Math.abs(e - o) : 0, a = this._columnHeadersView ? this._columnHeadersView.getHeight() : 0, l = this._rowsView.getScrollbarWidth(!0), d = this._rowsView ? this._rowsView.height() - l : 0, u = this.component.getView("draggingHeaderView");
    t.height = a, (this._columnsResizerController.isResizing() || u.isDragging()) && (t.height += d - r), e !== null && n && n.length && (t.top = n[0].offsetTop + r), this.positionChanged.fire(t);
  }
}
class tJ extends Ue.ViewController {
  init() {
    super.init(), this._columnsController = this.getController("columns"), this._tablePositionController = this.getController("tablePosition"), this._columnHeadersView = this.getView("columnHeadersView"), this._columnsSeparatorView = this.getView("columnsSeparatorView"), this._draggingHeaderView = this.getView("draggingHeaderView"), this._rowsView = this.getView("rowsView"), this._blockSeparatorView = this.getView("blockSeparatorView"), this._headerPanelView = this.getView("headerPanel"), this._columnChooserView = this.getView("columnChooserView");
    const e = () => {
      if (this._draggingHeaderView) {
        const t = [this._columnChooserView, this._columnHeadersView, this._headerPanelView];
        this._unsubscribeFromEvents(this._draggingHeaderView, t), this._subscribeToEvents(this._draggingHeaderView, t);
      }
    };
    this._columnHeadersView.renderCompleted.add(e), this._headerPanelView && this._headerPanelView.renderCompleted.add(e), this._columnChooserView && this._columnChooserView.renderCompleted.add(e);
  }
  dispose() {
    this._draggingHeaderView && this._unsubscribeFromEvents(this._draggingHeaderView, [this._columnChooserView, this._columnHeadersView, this._headerPanelView]);
  }
  _generatePointsByColumns(e) {
    let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !1;
    return this.isCustomGroupColumnPosition = this.checkIsCustomGroupColumnPosition(e), F.getPointsByColumns(e.columnElements, (s) => this._pointCreated(s, e.columns, e.targetDraggingPanel.getName(), e.sourceColumn), e.isVerticalOrientation, e.startColumnIndex, t);
  }
  checkIsCustomGroupColumnPosition(e) {
    let t = !0;
    for (let n = 0; n < e.columns.length; n += 1) {
      const s = e.columns[n];
      if (s.command === "expand" && !t)
        return !0;
      s.command || (t = !1);
    }
    return !1;
  }
  _pointCreated(e, t, n, s) {
    const o = t[e.columnIndex], r = t[e.columnIndex - 1], a = r?.command === "expand", l = o?.command === "expand" && r?.command !== "expand", d = s && !s.allowReordering, u = !(o != null && o.allowReordering) && !(r != null && r.allowReordering);
    switch (n) {
      case "columnChooser":
        return !0;
      case "headers":
        if (d)
          return !0;
        if (!l)
          return a || u;
        if (this.isCustomGroupColumnPosition)
          return !1;
        for (; ((c = t[e.columnIndex]) === null || c === void 0 ? void 0 : c.command) === "expand"; ) {
          var c;
          e.columnIndex += 1;
        }
        return !1;
      default:
        return t.length === 0;
    }
  }
  _subscribeToEvents(e, t) {
    const n = this;
    y(t, (s, o) => {
      if (o) {
        let r;
        const a = o.getRowCount ? o.getRowCount() : 1, l = o.getName(), d = function(u, c) {
          if (!c)
            return;
          const h = p(c), g = r[u];
          g && o.allowDragging(g) && (h.addClass(n.addWidgetPrefix("drag-action")), _.on(h, R(Rl, Cn), n.createAction((m) => {
            const C = m.event, v = st(C);
            e.dragHeader({
              deltaX: v.x - p(C.currentTarget).offset().left,
              deltaY: v.y - p(C.currentTarget).offset().top,
              sourceColumn: g,
              index: g.index,
              columnIndex: u,
              columnElement: h,
              sourceLocation: l,
              draggingPanels: t,
              rowIndex: n._columnsController.getRowIndex(g.index, !0)
            });
          })), _.on(h, R(oa, Cn), {
            that: e
          }, n.createAction(e.moveHeader)), _.on(h, R(Fl, Cn), {
            that: e
          }, n.createAction(e.dropHeader)));
        };
        for (let u = 0; u < a; u++) {
          const c = o.getColumnElements(u) || [];
          c.length && (r = o.getColumns(u) || [], y(c, d));
        }
      }
    });
  }
  _unsubscribeFromEvents(e, t) {
    const n = this;
    y(t, (s, o) => {
      if (o) {
        const r = o.getColumnElements() || [];
        y(r, (a, l) => {
          const d = p(l);
          _.off(d, R(Rl, Cn)), _.off(d, R(oa, Cn)), _.off(d, R(Fl, Cn)), d.removeClass(n.addWidgetPrefix("drag-action"));
        });
      }
    });
  }
  _getSeparator(e) {
    return e === "headers" ? this._columnsSeparatorView : this._blockSeparatorView;
  }
  hideSeparators(e) {
    const t = this._blockSeparatorView, n = this._columnsSeparatorView;
    this._animationColumnIndex = void 0, t && t.hide(), e !== "block" && n && n.hide();
  }
  allowDrop(e) {
    return this._columnsController.allowMoveColumn(e.sourceColumnIndex, e.targetColumnIndex, e.sourceLocation, e.targetLocation);
  }
  drag(e) {
    const {
      sourceIndex: t
    } = e, {
      sourceLocation: n
    } = e, {
      sourceColumnElement: s
    } = e, o = this._columnHeadersView, r = this._rowsView;
    s && (s.addClass(this.addWidgetPrefix(gc.draggableColumn)), n === "headers" && (o && o.toggleDraggableColumnClass(t, !0), r && r.toggleDraggableColumnClass(t, !0)));
  }
  dock(e) {
    const t = this, n = X(e.targetColumnIndex) ? e.targetColumnIndex.columnIndex : e.targetColumnIndex, {
      sourceLocation: s
    } = e, {
      targetLocation: o
    } = e, r = t._getSeparator(o), a = n >= 0;
    t._columnHeadersView.element().find(".dx-header-row").toggleClass(t.addWidgetPrefix("drop-highlight"), s !== "headers" && o === "headers" && !a), r && (t.allowDrop(e) && a ? o === "group" || o === "columnChooser" ? function() {
      t._animationColumnIndex !== n && (t.hideSeparators(), r.element()[e.isLast ? "insertAfter" : "insertBefore"](e.targetColumnElement), t._animationColumnIndex = n, r.show(o));
    }() : (t.hideSeparators("block"), t._tablePositionController.update(e.posY), r.moveByX(e.posX - r.width()), r.show()) : t.hideSeparators());
  }
  drop(e) {
    const {
      sourceColumnElement: t
    } = e;
    if (t && (t.removeClass(this.addWidgetPrefix(gc.draggableColumn)), this._columnHeadersView.toggleDraggableColumnClass(e.sourceIndex, !1), this._rowsView.toggleDraggableColumnClass(e.sourceIndex, !1), this._columnHeadersView.element().find(".dx-header-row").removeClass(this.addWidgetPrefix("drop-highlight"))), this.allowDrop(e)) {
      const n = this._getSeparator(e.targetLocation);
      n && n.hide(), this._columnsController.moveColumn(e.sourceColumnIndex, e.targetColumnIndex, e.sourceLocation, e.targetLocation);
    }
  }
}
const nJ = (i) => class extends i {
  _needUpdateRowHeight(e) {
    const t = this.option("wordWrapEnabled"), n = this._columnsResizerController.isResizing();
    return super._needUpdateRowHeight.apply(this, arguments) || e > 0 && !!t && !!n;
  }
}, iJ = (i) => class extends i {
  renderFocusOverlay() {
    if (!this._columnsResizerController.isResizing())
      return super.renderFocusOverlay.apply(this, arguments);
  }
}, dr = {
  views: {
    columnsSeparatorView: XQ,
    blockSeparatorView: ZQ,
    draggingHeaderView: QQ,
    trackerView: YQ
  },
  controllers: {
    draggingHeader: tJ,
    tablePosition: eJ,
    columnsResizer: JQ
  },
  extenders: {
    views: {
      rowsView: nJ
    },
    controllers: {
      editorFactory: iJ
    }
  }
};
dr.views.draggingHeaderView;
dr.controllers.draggingHeader;
dr.views.columnsSeparatorView;
dr.controllers.tablePosition;
dr.controllers.columnsResizer;
dr.views.trackerView;
J.registerModule("columnsResizingReordering", dr);
const sJ = (i, e) => i.length === e.length && !Object.keys(i).some((t) => i[t] !== e[t]), oJ = (i, e) => He(i, e, {
  maxDepth: 4
}), rJ = (i, e, t, n) => {
  let s = i, o = e;
  return function() {
    for (var r = arguments.length, a = new Array(r), l = 0; l < r; l++)
      a[l] = arguments[l];
    return n(a, s) || (s = a, o = t(...s)), o;
  };
}, aJ = {
  compareType: "reference"
}, z0 = function(i) {
  let {
    compareType: e
  } = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : aJ, t = null;
  return function() {
    for (var n = arguments.length, s = new Array(n), o = 0; o < n; o++)
      s[o] = arguments[o];
    if (!t) {
      const r = i(...s);
      return t = rJ(s, r, i, e === "reference" ? sJ : oJ), r;
    }
    return t(...s);
  };
}, tf = {
  ariaColIndex: "aria-colindex",
  dragCell: "dx-drag-cell"
}, ag = "rowsview", lJ = "table", dJ = "edit-form", lF = "dx-data-row", uJ = "dx-group-row", cJ = "dx-header-row", hJ = "edit-form-item", dF = "dx-master-detail-row", uF = "dx-freespace-row", pJ = "dx-virtual-row", lg = "dx-master-detail-cell", gJ = "dx-dropdowneditor-overlay", lu = "dx-command-expand", mJ = "dx-command-adaptive", fJ = "dx-adaptive-item-text", cF = "dx-command-select", hF = "dx-command-edit", dg = "[class^=dx-command]", za = "dx-cell-focus-disabled", _J = "dxDateBox", K0 = "dx-state-focused", CJ = "dx-widget", vJ = "dx-revert-button", G0 = "dx-focused", ug = "delete", Qa = `
  input:not([type="hidden"]):not([disabled]),
  textarea:not([disabled]),
  a:not([disabled]),
  select:not([disabled]),
  button:not([disabled]),
  [tabindex]:not([disabled]),
  .dx-checkbox:not([disabled],.dx-state-readonly)
`, U0 = `${Qa}, .dx-dropdowneditor-icon`, j0 = "row", q0 = "cell", Y0 = "columnHeadersView", xJ = "rowsView", yJ = ["shift", "control", "alt"], bJ = (i) => i.attr(tf.dragCell) !== void 0, wJ = (i) => [`[${tf.ariaColIndex}="${i + 1}"]`, `:not([${tf.dragCell}])`, ":not([aria-hidden=true])"].join(""), SJ = (i, e) => i.filter(wJ(e)).first(), pF = {
  isDragCell: bJ,
  getCellToFocus: SJ
};
function Hr(i) {
  return i && i.hasClass(uJ);
}
function gF(i) {
  return i && i.hasClass("dx-datagrid-group-footer");
}
function EJ(i) {
  return i && i.hasClass(dF);
}
function IJ(i) {
  return i && i.hasClass(fJ);
}
function DJ(i) {
  return i && i.hasClass(dF) && i.hasClass(dJ);
}
function Ka(i) {
  return i && i.hasClass(lF);
}
function TJ(i) {
  return !i || i.hasClass(uF) || i.hasClass(pJ);
}
function X0(i, e) {
  return !i._isRowEditMode() && e && !e.hasClass(cF) && e.hasClass(bh);
}
function Pn(i) {
  return f(i) && i.length > 0;
}
function nf() {
  return z.current().deviceType !== "desktop";
}
function Z0(i) {
  return !!i.parent(`.${cJ}`).length;
}
function OJ(i, e) {
  return i.option("rtlEnabled") ? !(e.fixedPosition === "right" || f(e.command) && !f(e.fixedPosition)) : !(!f(e.fixedPosition) || e.fixedPosition === "left");
}
function AJ(i) {
  const e = i.getController("keyboardNavigation");
  return e._isVirtualScrolling() ? i.option("focusedRowIndex") === e.getRowIndex() : !1;
}
const RJ = (i) => class extends i {
  rowsViewFocusHandler(e) {
    const t = p(e.target);
    this.translateFocusIfNeed(e, t), super.rowsViewFocusHandler(e);
  }
  rowsViewFocusOutHandler() {
    super.rowsViewFocusOutHandler(), this.makeScrollableFocusableIfNeed();
  }
  translateFocusIfNeed(e, t) {
    const n = this.isScrollableNeedFocusable(), s = this._isFixedColumn(0);
    if (!n || !s)
      return;
    const o = this._rowsView.getCell({
      rowIndex: 0,
      columnIndex: 0
    }), r = !!o.attr("tabindex"), a = t.is(this._$firstNotFixedCell);
    r && a && (e.preventDefault(), this._focus(o));
  }
  rowsViewRenderCompleted(e) {
    this._$firstNotFixedCell = this.getFirstNotFixedCell(), this.makeScrollableFocusableIfNeed(), super.rowsViewRenderCompleted(e);
  }
  _focus(e, t, n) {
    super._focus(e, t, n), this.makeScrollableFocusableIfNeed();
  }
  _tabKeyHandler(e, t) {
    const s = !(f(this._focusedCellPosition) && !en(this._focusedCellPosition)) || !e.shift && this._isLastValidCell(this._focusedCellPosition) || e.shift && this._isFirstValidCell(this._focusedCellPosition), o = this.isScrollableNeedFocusable();
    if (s && o) {
      var r;
      (r = this._$firstNotFixedCell) === null || r === void 0 || r.removeAttr("tabIndex");
    }
    super._tabKeyHandler(e, t);
  }
  getFirstNotFixedCell() {
    var e;
    const n = this._columnsController.getVisibleColumns().findIndex((o) => {
      let {
        fixed: r
      } = o;
      return !r;
    }), s = (e = this._editingController) === null || e === void 0 ? void 0 : e.isEditing();
    return n === -1 || s ? void 0 : this._rowsView._getCellElement(0, n);
  }
  isScrollableNeedFocusable() {
    var e, t;
    const n = !!this._rowsView.getScrollable(), s = !!((e = this._rowsView._fixedTableElement) !== null && e !== void 0 && e.length), o = !!((t = this._rowsView.getCellElements(0)) !== null && t !== void 0 && t.length);
    return n && s && o;
  }
  makeScrollableFocusableIfNeed() {
    !this.isScrollableNeedFocusable() || !this._$firstNotFixedCell || this._applyTabIndexToElement(this._$firstNotFixedCell);
  }
};
class FJ extends Ue.ViewController {
  init() {
    if (this._dataController = this.getController("data"), this._selectionController = this.getController("selection"), this._editingController = this.getController("editing"), this._headerPanel = this.getView("headerPanel"), this._rowsView = this.getView("rowsView"), this._columnHeadersView = this.getView("columnHeadersView"), this._columnsController = this.getController("columns"), this._editorFactory = this.getController("editorFactory"), this._focusController = this.getController("focus"), this._adaptiveColumnsController = this.getController("adaptiveColumns"), this._columnResizerController = this.getController("columnsResizer"), this._memoFireFocusedCellChanged = z0(this._memoFireFocusedCellChanged.bind(this), {
      compareType: "value"
    }), this._memoFireFocusedRowChanged = z0(this._memoFireFocusedRowChanged.bind(this), {
      compareType: "value"
    }), this.focusedHandlerWithContext = this.focusedHandlerWithContext || this.focusedHandler.bind(this), this.columnHeadersViewRenderCompletedWithContext = this.columnHeadersViewRenderCompletedWithContext || this.columnHeadersViewRenderCompleted.bind(this), this.rowsViewRenderCompletedWithContext = this.rowsViewRenderCompletedWithContext || this.rowsViewRenderCompleted.bind(this), this.rowsViewFocusHandlerContext = this.rowsViewFocusHandlerContext || this.rowsViewFocusHandler.bind(this), this.rowsViewFocusOutHandlerContext = this.rowsViewFocusOutHandlerContext ?? this.rowsViewFocusOutHandler.bind(this), this._updateFocusTimeout = null, this._fastEditingStarted = !1, this._focusedCellPosition = {}, this._canceledCellPosition = null, this.isKeyboardEnabled()) {
      var e;
      gU(), (e = this._editorFactory) === null || e === void 0 || e.focused.add(this.focusedHandlerWithContext), this.createAction("onKeyDown");
    } else {
      var t;
      Vy(), (t = this._editorFactory) === null || t === void 0 || t.focused.remove(this.focusedHandlerWithContext);
    }
    this.initColumnHeadersViewHandler(), this.initRowsViewHandlers(), this.initDocumentHandlers();
  }
  dispose() {
    super.dispose(), this._resetFocusedView(), oi.off(this._rowsViewKeyDownListener), oi.off(this._columnHeadersViewKeyDownListener), _.off(O.getDocument(), R(ye.down, "dxDataGridKeyboardNavigation"), this._documentClickHandler), clearTimeout(this._updateFocusTimeout), Vy();
  }
  focusedHandler(e) {
    this.setupFocusedView(), this._isNeedScroll && e.is(":visible") && this._focusedView && this._focusedView.getScrollable() && (this._focusedView._scrollToElement(e), this._isNeedScroll = !1);
  }
  rowsViewFocusHandler(e) {
    const t = p(e.target), n = p(e.relatedTarget).closest(this._rowsView.element()).length, s = t.is("a");
    if (e.relatedTarget && s && !n && this._isEventInCurrentGrid(e)) {
      let a = this._getFocusedCell();
      a = Pn(a) ? a : this._rowsView.getCellElements(0).filter("[tabindex]").eq(0), t.closest(a).length || (e.preventDefault(), _.trigger(a, "focus"));
    }
    const o = t.is("td"), r = (this.option("focusedRowIndex") ?? -1) < 0;
    o && r && this._updateFocusedCellPosition(t);
  }
  rowsViewFocusOutHandler() {
    this._toggleInertAttr(!1);
  }
  subscribeToRowsViewFocusEvent() {
    var e;
    const t = (e = this._rowsView) === null || e === void 0 ? void 0 : e.element();
    _.on(t, "focusin", this.rowsViewFocusHandlerContext), _.on(t, "focusout", this.rowsViewFocusOutHandlerContext);
  }
  unsubscribeFromRowsViewFocusEvent() {
    var e;
    const t = (e = this._rowsView) === null || e === void 0 ? void 0 : e.element();
    _.off(t, "focusin", this.rowsViewFocusHandlerContext), _.off(t, "focusout", this.rowsViewFocusOutHandlerContext);
  }
  columnHeadersViewRenderCompleted() {
    this.initColumnHeadersViewKeyDownHandler();
  }
  rowsViewRenderCompleted(e) {
    const t = this._rowsView.element(), n = !e || e.changeType === "refresh", s = this._focusedView && this._focusedView.name === this._rowsView.name;
    let o = !1;
    const r = e && (e.changeType === "append" || e.changeType === "prepend"), l = p(O.getRootNode(t.get && t.get(0))).find(":focus"), d = this._isFocusedElementCorrect(l, t, e);
    if (this.unsubscribeFromRowsViewFocusEvent(), this.subscribeToRowsViewFocusEvent(), this.initPointerEventHandler(), this.initRowsViewKeyDownHandler(), this._setRowsViewAttributes(), s && d && (o = this._isNeedFocus ? !r : this._isHiddenFocus && n && !(e != null && e.virtualColumnsScrolling), o)) {
      var u;
      const c = !!(e != null && (u = e.event) !== null && u !== void 0 && u.type), h = e?.virtualColumnsScrolling && c;
      this._updateFocus(!0, h);
    }
  }
  _isFocusedElementCorrect(e, t, n) {
    if (e.length && !e.closest(t).length)
      return !1;
    if (!e.length && n !== null && n !== void 0 && n.virtualColumnsScrolling) {
      var s;
      const o = ((s = this._focusedCellPosition) === null || s === void 0 ? void 0 : s.columnIndex) ?? -1;
      return this._isColumnRendered(o);
    }
    return !0;
  }
  initColumnHeadersViewHandler() {
    var e;
    if (this.unsubscribeFromColumnHeadersViewKeyDownEvent(), (e = this._columnHeadersView) === null || e === void 0 || (e = e.renderCompleted) === null || e === void 0 || e.remove(this.columnHeadersViewRenderCompletedWithContext), this.isKeyboardEnabled()) {
      var t;
      (t = this._columnHeadersView) === null || t === void 0 || (t = t.renderCompleted) === null || t === void 0 || t.add(this.columnHeadersViewRenderCompletedWithContext);
    }
  }
  initRowsViewHandlers() {
    var e;
    this.unsubscribeFromRowsViewFocusEvent(), this.unsubscribeFromPointerEvent(), this.unsubscribeFromRowsViewKeyDownEvent(), (e = this._rowsView) === null || e === void 0 || (e = e.renderCompleted) === null || e === void 0 || e.remove(this.rowsViewRenderCompletedWithContext), this.isKeyboardEnabled() && this._rowsView.renderCompleted.add(this.rowsViewRenderCompletedWithContext);
  }
  initDocumentHandlers() {
    const e = O.getDocument();
    this._documentClickHandler = this._documentClickHandler || this.createAction((t) => {
      var n;
      const s = p(t.event.target), o = `.${this.addWidgetPrefix(lJ)}`, r = `.${this.addWidgetPrefix(ag)}`, a = `.${gJ}`;
      if (!!s.closest(o).length && !pa(s)) {
        t.event.preventDefault();
        return;
      }
      const d = this._isEventInCurrentGrid(t.event) && !!s.closest(r).length, u = !!s.closest(a).length, c = !!((n = this._columnResizerController) !== null && n !== void 0 && n.isResizing());
      !d && !u && !c && ((!this._focusedView || s.closest(this._focusedView.element()).length === 0) && this._resetFocusedCell(!0), this._resetFocusedView());
    }), _.off(e, R(ye.down, "dxDataGridKeyboardNavigation"), this._documentClickHandler), this.isKeyboardEnabled() && _.on(e, R(ye.down, "dxDataGridKeyboardNavigation"), this._documentClickHandler);
  }
  _setRowsViewAttributes() {
    const e = this._getRowsViewElement();
    !this._dataController.getVisibleRows().length && this._applyTabIndexToElement(e);
  }
  unsubscribeFromPointerEvent() {
    const e = nf() ? Te : ye.down, t = this._getRowsViewElement();
    this._pointerEventAction && _.off(t, R(e, "dxDataGridKeyboardNavigation"), this._pointerEventAction);
  }
  subscribeToPointerEvent() {
    const e = nf() ? Te : ye.down, t = this._getRowsViewElement(), n = `.${Fs} > td, .${Fs}`;
    _.on(t, R(e, "dxDataGridKeyboardNavigation"), n, this._pointerEventAction);
  }
  initPointerEventHandler() {
    this._pointerEventAction = this._pointerEventAction || this.createAction(this._pointerEventHandler), this.unsubscribeFromPointerEvent(), this.subscribeToPointerEvent();
  }
  unsubscribeFromColumnHeadersViewKeyDownEvent() {
    this._columnHeadersViewKeyDownListener && oi.off(this._columnHeadersViewKeyDownListener);
  }
  subscribeToColumnHeadersViewKeyDownEvent() {
    const e = this._columnHeadersView.element();
    this._columnHeadersViewKeyDownListener = oi.on(e, null, (t) => this._columnHeadersViewKeyDownHandler(t));
  }
  initColumnHeadersViewKeyDownHandler() {
    this.unsubscribeFromColumnHeadersViewKeyDownEvent(), this.subscribeToColumnHeadersViewKeyDownEvent();
  }
  unsubscribeFromRowsViewKeyDownEvent() {
    oi.off(this._rowsViewKeyDownListener);
  }
  subscribeToRowsViewKeyDownEvent() {
    const e = this._getRowsViewElement();
    this._rowsViewKeyDownListener = oi.on(e, null, (t) => this._rowsViewKeyDownHandler(t));
  }
  initRowsViewKeyDownHandler() {
    this._rowsViewKeyDownListener && this.unsubscribeFromRowsViewKeyDownEvent(), this.subscribeToRowsViewKeyDownEvent();
  }
  optionChanged(e) {
    switch (e.name) {
      case "keyboardNavigation":
        e.fullName === "keyboardNavigation.enabled" && this.init(), e.handled = !0;
        break;
      case "useLegacyKeyboardNavigation":
        this.init(), e.handled = !0;
        break;
      default:
        super.optionChanged(e);
    }
  }
  isRowFocusType() {
    return this.focusType === j0;
  }
  isCellFocusType() {
    return this.focusType === q0;
  }
  setRowFocusType() {
    this.option("focusedRowEnabled") && (this.focusType = j0);
  }
  setCellFocusType() {
    this.focusType = q0;
  }
  headerTabKeyHandler(e) {
  }
  _columnHeadersViewKeyDownHandler(e) {
    e.keyName === "tab" && this.headerTabKeyHandler(e);
  }
  _rowsViewKeyDownHandler(e) {
    var t;
    let n = !0;
    this._isNeedFocus = !0, this._isNeedScroll = !0;
    let s = this._processOnKeyDown(e);
    const o = (t = this._editingController) === null || t === void 0 ? void 0 : t.isEditing(), {
      originalEvent: r
    } = e;
    if (r.isDefaultPrevented()) {
      this._isNeedFocus = !1, this._isNeedScroll = !1;
      return;
    }
    if (!yJ.includes(e.keyName) && this._updateFocusedCellPositionByTarget(r.target), !s) {
      switch (e.keyName) {
        case "leftArrow":
        case "rightArrow":
          this._leftRightKeysHandler(e, o), s = !0;
          break;
        case "upArrow":
        case "downArrow":
          e.ctrl ? A_("rowsView", this, r) : this._upDownKeysHandler(e, o), s = !0;
          break;
        case "pageUp":
        case "pageDown":
          this._pageUpDownKeyHandler(e), s = !0;
          break;
        case "space":
          s = this._spaceKeyHandler(e, o);
          break;
        case "A":
          bt(e.originalEvent) ? (this._ctrlAKeyHandler(e, o), s = !0) : s = this._beginFastEditing(e.originalEvent);
          break;
        case "tab":
          this._tabKeyHandler(e, o), s = !0;
          break;
        case "enter":
          this._enterKeyHandler(e, o), s = !0;
          break;
        case "escape":
          s = this._escapeKeyHandler(e, o);
          break;
        case "F":
          bt(e.originalEvent) ? (this._ctrlFKeyHandler(e), s = !0) : s = this._beginFastEditing(e.originalEvent);
          break;
        case "F2":
          this._f2KeyHandler(), s = !0;
          break;
        case "del":
        case "backspace":
          this._isFastEditingAllowed() && !this._isFastEditingStarted() && (s = this._beginFastEditing(r, !0));
      }
      !s && !this._beginFastEditing(r) && (this._isNeedFocus = !1, this._isNeedScroll = !1, n = !1), n && r.stopPropagation();
    }
  }
  _processOnKeyDown(e) {
    const {
      originalEvent: t
    } = e, n = {
      handled: !1,
      event: t
    };
    return this.executeAction("onKeyDown", n), e.ctrl = t.ctrlKey, e.alt = t.altKey, e.shift = t.shiftKey, !!n.handled;
  }
  _closeEditCell() {
    const e = w();
    return setTimeout(() => {
      this._editingController.closeEditCell().always(e.resolve);
    }), e;
  }
  _leftRightKeysHandler(e, t) {
    const n = this.getVisibleRowIndex(), s = e.originalEvent, o = this._focusedView && this._focusedView.getRow(n), r = this._getDirectionCodeByKey(e.keyName), a = this._isFastEditingStarted();
    if ((!t || a) && Ka(o)) {
      this.setCellFocusType(), a && this._closeEditCell(), this._isVirtualColumnRender() && this._processVirtualHorizontalPosition(r);
      const d = this._getNextCell(r);
      Pn(d) && this._arrowKeysHandlerFocusCell(s, d, r), s && s.preventDefault();
    }
  }
  isInsideMasterDetail(e) {
    const t = e.closest(`.${lg}`);
    return !!t.get(0) && this.elementIsInsideGrid(t) && !e.is(t);
  }
  _upDownKeysHandler(e, t) {
    var n, s;
    const o = this.getVisibleRowIndex(), r = this._focusedView && this._focusedView.getRow(o), a = e.originalEvent, l = e.keyName === "upArrow", d = this._dataController.dataSource(), u = (n = this._editingController) === null || n === void 0 || (s = n.isEditRowByIndex) === null || s === void 0 ? void 0 : s.call(n, o), c = this._isFastEditingStarted(), h = this.isInsideMasterDetail(p(a?.target));
    if ((!u || !t || c) && r && !DJ(r) && !h) {
      if (c && this._closeEditCell(), !this._navigateNextCell(a, e.keyName) && this._isVirtualRowRender() && l && d && !d.isLoading()) {
        const m = he(r), C = this._focusedCellPosition.rowIndex - 1;
        this._scrollBy(0, -m, C, a);
      }
      a && a.preventDefault();
    }
  }
  _pageUpDownKeyHandler(e) {
    const t = this._dataController.pageIndex(), n = this._dataController.pageCount(), s = this.option("paging.enabled"), o = e.keyName === "pageUp", r = o ? -1 : 1, a = this._rowsView.getScrollable();
    s && !this._isVirtualScrolling() ? (o ? t > 0 : t < n - 1) && !this._isVirtualScrolling() && (this._dataController.pageIndex(t + r), e.originalEvent.preventDefault()) : a && le(a.container()) < le(a.$content()) && (this._scrollBy(0, le(a.container()) * r), e.originalEvent.preventDefault());
  }
  _spaceKeyHandler(e, t) {
    const n = this.getVisibleRowIndex(), s = p(e.originalEvent && e.originalEvent.target);
    if (this.option("selection") && this.option("selection").mode !== "none" && !t) {
      const o = this._getElementType(s) === "row" && this.isRowFocusType() && Ka(s);
      return s.hasClass(cF) && this.option("selection.showCheckBoxesMode") === "onClick" && this._selectionController.startSelectionWithCheckboxes(), o || s.parent().hasClass(lF) || s.hasClass(this.addWidgetPrefix(ag)) ? (this._selectionController.changeItemSelection(n, {
        shift: e.shift,
        control: e.ctrl
      }), e.originalEvent.preventDefault(), !0) : !1;
    }
    return this._beginFastEditing(e.originalEvent);
  }
  _ctrlAKeyHandler(e, t) {
    !t && !e.alt && this.option("selection.mode") === "multiple" && this.option("selection.allowSelectAll") && (this._selectionController.selectAll(), e.originalEvent.preventDefault());
  }
  _toggleInertAttr(e) {
  }
  _tabKeyHandler(e, t) {
    const n = this.option("editing"), s = e.shift ? "previous" : "next", o = f(this._focusedCellPosition) && !en(this._focusedCellPosition), r = e.shift && this._isFirstValidCell(this._focusedCellPosition), a = !e.shift && this._isLastValidCell(this._focusedCellPosition);
    let l = !o || r || a;
    const d = e.originalEvent.target, u = this._focusedView && this._focusedView.element();
    if (!this._handleTabKeyOnMasterDetailCell(d, s)) {
      if (p(u).addClass(K0), n && d && !l)
        if (p(d).hasClass(this.addWidgetPrefix(ag)) && this._resetFocusedCell(), this._isVirtualColumnRender() && this._processVirtualHorizontalPosition(s), t) {
          if (!this._editingCellTabHandler(e, s))
            return;
        } else
          this._targetCellTabHandler(e, s) && (l = !0);
      if (l) {
        const h = this._getFocusedCell().is(dg);
        a && !h && this._toggleInertAttr(!0), this._editorFactory.loseFocus(), this._editingController.isEditing() && !this._isRowEditMode() && (this._resetFocusedCell(!0), this._resetFocusedView(), this._closeEditCell());
      } else
        e.originalEvent.preventDefault();
    }
  }
  _getMaxHorizontalOffset() {
    const e = this.component.getScrollable();
    return e ? e.scrollWidth() - ne(this._rowsView.element()) : 0;
  }
  _isColumnRendered(e) {
    const t = this._columnsController.getVisibleColumns(null, !0), n = this._columnsController.getVisibleColumns(), s = t[e];
    let o = !1;
    return s && (o = n.indexOf(s) >= 0), o;
  }
  _isFixedColumn(e) {
    const n = this._columnsController.getVisibleColumns(null, !0)[e];
    return !!n && !!n.fixed;
  }
  _isColumnVirtual(e) {
    const t = e - this._columnsController.getColumnIndexOffset(), s = this._columnsController.getVisibleColumns()[t];
    return !!s && s.command === "virtual";
  }
  _processVirtualHorizontalPosition(e) {
    const t = this.component.getScrollable(), n = this.getColumnIndex();
    let s, o = 0, r = !1;
    switch (e) {
      case "next":
      case "nextInRow": {
        const a = this._getVisibleColumnCount();
        s = n + 1, o = this.option("rtlEnabled") ? this._getMaxHorizontalOffset() : 0, e === "next" ? r = a === s || this._isFixedColumn(n) && !this._isColumnRendered(s) : r = a > s && this._isFixedColumn(n) && !this._isColumnRendered(s);
        break;
      }
      case "previous":
      case "previousInRow":
        if (s = n - 1, o = this.option("rtlEnabled") ? 0 : this._getMaxHorizontalOffset(), e === "previous") {
          const a = this._columnsController.getColumnIndexOffset();
          r = s < 0 && a === 0 || this._isFixedColumn(n) && !this._isColumnRendered(s);
        } else
          r = s >= 0 && this._isFixedColumn(n) && !this._isColumnRendered(s);
    }
    r ? t.scrollTo({
      left: o
    }) : f(s) && f(e) && this._isColumnVirtual(s) && (o = this._getHorizontalScrollPositionOffset(e), o !== 0 && t.scrollBy({
      left: o,
      top: 0
    }));
  }
  _getHorizontalScrollPositionOffset(e) {
    let t = 0;
    const n = this._getCell(this._focusedCellPosition), s = n && Ee(n);
    if (s > 0) {
      const o = this.option("rtlEnabled") ? -1 : 1;
      t = e === "nextInRow" || e === "next" ? s * o : s * o * -1;
    }
    return t;
  }
  _editingCellTabHandler(e, t) {
    const n = e.originalEvent.target;
    let s = this._getCellElementFromTarget(n), o;
    const r = e.originalEvent, a = this._getElementType(n);
    if (s.is(dg))
      return !this._targetCellTabHandler(e, t);
    this._updateFocusedCellPosition(s);
    const l = this._getNextCellByTabKey(r, t, a);
    if (s = l.$cell, !s || this._handleTabKeyOnMasterDetailCell(s, t))
      return !1;
    const d = this._getColumnByCellElement(s), u = s.parent(), c = this._getRowIndex(u), h = this._dataController.items()[c], g = this._editingController;
    if (d && d.allowEditing) {
      const m = !h || h.rowType === "data";
      o = g.allowUpdating({
        row: h
      }) ? m : h && h.isNewRow;
    }
    return o || this._closeEditCell(), this._focusCell(s, !l.isHighlighted) && (!this._isRowEditMode() && o ? this._editFocusedCell() : this._focusInteractiveElement(s, e.shift)), !0;
  }
  _targetCellTabHandler(e, t) {
    const n = e.originalEvent;
    let s = n.target, o = this._getElementType(s), r = this._getCellElementFromTarget(s);
    const a = o === "cell" && this._getInteractiveElement(r, !e.shift);
    let l = !1;
    if (!X0(this, r) && a !== null && a !== void 0 && a.length && s !== a.get(0))
      l = !0;
    else {
      this._focusedCellPosition.rowIndex === void 0 && p(s).hasClass(Fs) && this._updateFocusedCellPosition(r), o = this._getElementType(s), this.isRowFocusType() && (this.setCellFocusType(), o === "row" && Ka(p(s)) && (s = this.getFirstValidCellInRow(p(s)), o = this._getElementType(s)));
      const d = this._getNextCellByTabKey(n, t, o);
      if (r = d.$cell, !r || (r = this._checkNewLineTransition(n, r), !r))
        return !1;
      this._focusCell(r, !d.isHighlighted), X0(this, r) || this._focusInteractiveElement(r, e.shift);
    }
    return l;
  }
  _getNextCellByTabKey(e, t, n) {
    let s = this._getNextCell(t, n);
    const o = s && this._fireFocusedCellChanging(e, s, !0);
    return !o || o.cancel ? {} : (o.$newCellElement && (s = o.$newCellElement), {
      $cell: s,
      isHighlighted: o.isHighlighted
    });
  }
  _checkNewLineTransition(e, t) {
    const n = this.getVisibleRowIndex(), s = t.parent();
    if (n !== this._getRowIndex(s)) {
      const o = this._getCellPosition(t), r = this._fireFocusedRowChanging(e, s);
      if (r.cancel)
        return;
      r.rowIndexChanged && o && (this.setFocusedColumnIndex(o.columnIndex), t = this._getFocusedCell());
    }
    return t;
  }
  _enterKeyHandler(e, t) {
    var n, s;
    const o = this.getVisibleRowIndex(), r = this._dataController.getKeyByRowIndex(o), a = (n = this._focusedView) === null || n === void 0 ? void 0 : n.getRow(o), l = this._getFocusedCell(), d = this.option("grouping.allowCollapsing") && Hr(a), u = this.option("masterDetail.enabled") && l?.hasClass(lu), c = l?.hasClass(mJ);
    if (d || u) {
      const h = this._dataController.items()[o], g = h?.data && !h.data.isContinuation;
      f(r) && g && this._dataController.changeRowExpand(r);
    } else
      c ? (this._adaptiveColumnsController.toggleExpandAdaptiveDetailRow(r), this._updateFocusedCellPosition(l)) : (s = this.getMasterDetailCell(l)) !== null && s !== void 0 && s.is(l) ? l.is(":focus") && this.focusFirstInteractiveElementInside(l) : l != null && l.hasClass(hF) || this._processEnterKeyForDataCell(e, t);
  }
  focusFirstInteractiveElementInside(e) {
    e.find(Qa).get(0).focus();
  }
  _processEnterKeyForDataCell(e, t) {
    const n = this._getEnterKeyDirection(e), s = this._allowEditingOnEnterKey();
    t || !s && n ? this._handleEnterKeyEditingCell(e.originalEvent).done(() => {
      n === "next" || n === "previous" ? this._targetCellTabHandler(e, n) : (n === "upArrow" || n === "downArrow") && this._navigateNextCell(e.originalEvent, n);
    }) : s && this._startEditing(e);
  }
  _getEnterKeyDirection(e) {
    const t = this.option("keyboardNavigation.enterKeyDirection"), n = e.shift;
    if (t === "column")
      return n ? "upArrow" : "downArrow";
    if (t === "row")
      return n ? "previous" : "next";
  }
  _handleEnterKeyEditingCell(e) {
    const t = w(), {
      target: n
    } = e, s = this._getCellElementFromTarget(n), o = this._isRowEditMode();
    return this._updateFocusedCellPosition(s), o ? (this._focusEditFormCell(s), setTimeout(this._editingController.saveEditData.bind(this._editingController)), t.resolve()) : (_.trigger(p(n), "change"), this._closeEditCell().always(t.resolve), e.preventDefault()), t;
  }
  _escapeKeyHandler(e, t) {
    const n = this._getCellElementFromTarget(e.originalEvent.target);
    if (t)
      return this._updateFocusedCellPosition(n), this._isRowEditMode() ? (this._focusEditFormCell(n), this._editingController.cancelEditData(), this._dataController.items().length === 0 && (this._resetFocusedCell(), this._editorFactory.loseFocus())) : this._editingController.getEditMode() === "cell" ? this._editingController.cancelEditData() : this._closeEditCell(), e.originalEvent.preventDefault(), !0;
    const s = this.getMasterDetailCell(n);
    return s ? (this._focusCell(s), !0) : !1;
  }
  _ctrlFKeyHandler(e) {
    if (this.option("searchPanel.visible")) {
      const t = this._headerPanel.getSearchTextEditor();
      t && (t.focus(), e.originalEvent.preventDefault());
    }
  }
  _f2KeyHandler() {
    const e = this._editingController.isEditing(), t = this.getVisibleRowIndex(), n = this._focusedView && this._focusedView.getRow(t);
    !e && Ka(n) && this._startEditing();
  }
  _navigateNextCell(e, t) {
    const n = this._getNextCell(t), s = this._getDirectionCodeByKey(t);
    return n && this._isCellValid(n) ? this._arrowKeysHandlerFocusCell(e, n, s) : !1;
  }
  _arrowKeysHandlerFocusCell(e, t, n) {
    const s = n === "prevRow" || n === "nextRow", o = this._fireFocusChangingEvents(e, t, s, !0);
    return t = o.$newCellElement, !o.cancel && this._isCellValid(t) ? (this._focus(t, !o.isHighlighted), !0) : !1;
  }
  _beginFastEditing(e, t) {
    if (!this._isFastEditingAllowed() || e.altKey || e.ctrlKey || this._editingController.isEditing())
      return !1;
    if (t)
      this._startEditing(e, ug);
    else {
      const {
        key: n
      } = e, s = e.keyCode || e.which, o = n || s && String.fromCharCode(s);
      o && (o.length === 1 || o === ug) && this._startEditing(e, o);
    }
    return !0;
  }
  _pointerEventHandler(e) {
    var t;
    const n = e.event || e;
    let s = p(n.currentTarget);
    const o = (t = this._rowsView) === null || t === void 0 ? void 0 : t.element(), r = s.parent(), a = p(n.target).is(Qa), l = !!p(n.target).closest(`.${vJ}`).length, d = s.hasClass(lu);
    this._isEventInCurrentGrid(n) && (!l && (this._isCellValid(s, !a) || d) ? (s = this._isInsideEditForm(s) ? p(n.target) : s, this._focusView(), p(o).removeClass(K0), r.hasClass(uF) ? (this._updateFocusedCellPosition(s), this._applyTabIndexToElement(this._focusedView.element()), this._focusedView.focus(!0)) : this.getMasterDetailCell(s) ? this._updateFocusedCellPosition(s) : this._clickTargetCellHandler(n, s)) : s.is("td") && this._resetFocusedCell());
  }
  _clickTargetCellHandler(e, t) {
    const n = this._getColumnByCellElement(t), s = this._isCellEditMode();
    this.setCellFocusType();
    const o = this._fireFocusChangingEvents(e, t, !0);
    if (t = o.$newCellElement, o.cancel)
      this.setRowFocusType(), this.setFocusedRowIndex(o.prevRowIndex), this._editingController.isEditing() && s && this._closeEditCell();
    else {
      if (o.resetFocusedRow) {
        this._focusController._resetFocusedRow();
        return;
      }
      if (o.rowIndexChanged && (t = this._getFocusedCell()), !o.isHighlighted && !s && this.setRowFocusType(), this._updateFocusedCellPosition(t), this._allowRowUpdating() && s && n && n.allowEditing)
        this._isNeedFocus = !1, this._isHiddenFocus = !1;
      else {
        t = this._getFocusedCell();
        const r = e && p(e.target).closest(`${U0}, td`), a = r && r.not(t).is(U0), d = !(!!n && !n.command && t.hasClass(bh)) && (!o.isHighlighted || a);
        this._focus(t, d, a);
      }
    }
  }
  _allowRowUpdating() {
    const e = this.getVisibleRowIndex(), t = this._dataController.items()[e];
    return this._editingController.allowUpdating({
      row: t
    }, "click");
  }
  focus(e) {
    let t;
    const n = this.option("focusedRowEnabled"), s = this._isCellElement(p(e));
    e || (t = ".dx-datagrid-rowsview .dx-row[tabindex]", n || (t += ", .dx-datagrid-rowsview .dx-row > td[tabindex]"), e = this.component.$element().find(t).first()), e && this._focusElement(p(e), s);
  }
  getFocusedView() {
    return this._focusedView;
  }
  setupFocusedView() {
    this.isKeyboardEnabled() && !f(this._focusedView) && this._focusView();
  }
  _focusElement(e, t) {
    const n = p(this._getRowsViewElement()), s = e.closest(n), o = this.isRowFocusType();
    let r = {};
    !s.length || this._isCellElement(e) && !this._isCellValid(e) || (this._focusView(), this._isNeedFocus = !0, this._isNeedScroll = !0, (this._isCellElement(e) || Hr(e)) && (this.setCellFocusType(), r = this._fireFocusChangingEvents(null, e, !0, t), e = r.$newCellElement, o && !r.isHighlighted && this.setRowFocusType()), r.cancel || (this._focus(e, !r.isHighlighted), this._focusInteractiveElement(e)));
  }
  _getFocusedViewByElement(e) {
    const t = this.getFocusedView(), n = t && p(t.element());
    return e && e.closest(n).length !== 0;
  }
  _focusView() {
    this._focusedView = this._rowsView;
  }
  _resetFocusedView() {
    this.setRowFocusType(), this._focusedView = null;
  }
  _focusInteractiveElement(e, t) {
    if (!e)
      return;
    const n = this._getInteractiveElement(e, t);
    F.focusAndSelectElement(this, n);
  }
  _focus(e, t, n) {
    const s = e && !e.hasClass(Fs) ? e.closest(`.${Fs}`) : e;
    if (s && TJ(s))
      return;
    const o = this._focusedView, r = o && o.element();
    let a;
    this._isHiddenFocus = t;
    const l = Hr(s) || gF(s) || this.isRowFocusType();
    l ? (a = s, o && this.setFocusedRowIndex(this._getRowIndex(s))) : this._isCellElement(e) && (a = e, this._updateFocusedCellPosition(e)), a && (r && r.find(".dx-row[tabindex], .dx-row > td[tabindex]").filter((d, u) => F.isElementInCurrentGrid(this, p(u))).not(a).removeClass(za).removeClass(G0).removeAttr("tabindex"), _.one(a, "blur", (d) => {
      d.relatedTarget && a.removeClass(za).removeClass(G0);
    }), n || (this._applyTabIndexToElement(a), _.trigger(a, "focus")), t ? (a.addClass(za), l && e.addClass(za)) : this._editorFactory.focus(a));
  }
  _updateFocus(e) {
    let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !1;
    this._updateFocusTimeout = setTimeout(() => {
      if (this._needFocusEditingCell()) {
        this._editingController._focusEditingCell();
        return;
      }
      let n = this._getFocusedCell();
      const s = this._editingController.isEditing();
      if (!this.getMasterDetailCell(n) || this._isRowEditMode()) {
        if (this._hasSkipRow(n.parent())) {
          const o = this._focusedCellPosition && this._focusedCellPosition.rowIndex > 0 ? "upArrow" : "downArrow";
          n = this._getNextCell(o);
        }
        if (Pn(n))
          if (n.is("td") || n.hasClass(this.addWidgetPrefix(hJ))) {
            const o = n.is(dg), r = n.find(":focus"), a = Pn(r), l = this._getColumnByCellElement(n);
            if ((e || !o) && this._editorFactory.focus()) {
              if (o && a) {
                F.focusAndSelectElement(this, r);
                return;
              }
              !a && this._focus(n, !1, t);
            } else
              !a && (this._isNeedFocus || this._isHiddenFocus) && this._focus(n, this._isHiddenFocus, t);
            s && !(l != null && l.showEditorAlways) && this._focusInteractiveElement.bind(this)(n);
          } else
            _.trigger(n, "focus");
      }
    });
  }
  _getColumnByCellElement(e) {
    const n = this._rowsView.getCellIndex(e) + this._columnsController.getColumnIndexOffset();
    return this._columnsController.getVisibleColumns(null, !0)[n];
  }
  _needFocusEditingCell() {
    const e = this._editingController.getEditMode() === Wm, t = this._editingController.getEditMode() === Hm, n = e && this._editingController.hasChanges(), s = t && this._editingController.isNewRowInEditMode(), o = this._getFocusedCell();
    return (o.children().length === 0 || o.find(vC).length > 0) && (n || s);
  }
  _getFocusedCell() {
    return p(this._getCell(this._focusedCellPosition));
  }
  _updateFocusedCellPositionByTarget(e) {
    var t;
    if (this._getElementType(e) === "row" && f((t = this._focusedCellPosition) === null || t === void 0 ? void 0 : t.columnIndex)) {
      const s = p(e);
      this._focusedView && Hr(s) && this.setFocusedRowIndex(this._getRowIndex(s));
    } else
      this._updateFocusedCellPosition(this._getCellElementFromTarget(e));
  }
  _updateFocusedCellPosition(e, t) {
    const n = this._getCellPosition(e, t);
    return n && (!e.length || n.rowIndex >= 0 && n.columnIndex >= 0) && this.setFocusedCellPosition(n.rowIndex, n.columnIndex), n;
  }
  _getFocusedColumnIndexOffset(e) {
    let t = 0;
    const n = this._columnsController.getVisibleColumns()[e];
    return n && n.fixed ? t = this._getFixedColumnIndexOffset(n) : e >= 0 && (t = this._columnsController.getColumnIndexOffset()), t;
  }
  _getFixedColumnIndexOffset(e) {
    return OJ(this, e) ? this._getVisibleColumnCount() - this._columnsController.getVisibleColumns().length : 0;
  }
  _getCellPosition(e, t) {
    let n;
    const s = Pn(e) && e.closest("tr");
    if (Pn(s)) {
      const o = this._getRowIndex(s);
      return n = this._rowsView.getCellIndex(e, o), n += this._getFocusedColumnIndexOffset(n), t && (n = t === "previous" ? n - 1 : n + 1, n = this._applyColumnIndexBoundaries(n)), {
        rowIndex: o,
        columnIndex: n
      };
    }
  }
  _focusCell(e, t) {
    if (this._isCellValid(e))
      return this._focus(e, t), !0;
  }
  _focusEditFormCell(e) {
    e.hasClass(lg) && this._editorFactory.focus(e, !0);
  }
  _resetFocusedCell(e) {
    var t;
    const n = this._getFocusedCell();
    Pn(n) && n.removeAttr("tabindex").removeClass(za), this._isNeedFocus = !1, this._isNeedScroll = !1, this._focusedCellPosition = {}, clearTimeout(this._updateFocusTimeout), (t = this._focusedView) === null || t === void 0 || t.renderFocusState({
      preventScroll: e
    });
  }
  restoreFocusableElement(e, t) {
    const n = this;
    let s, o;
    const r = f(e), a = this._rowsView.element(), {
      columnIndex: l
    } = n._focusedCellPosition, d = n._dataController.getRowIndexOffset();
    e = r ? e : this._rowsView.getTopVisibleItemIndex() + d, r ? (o = this._rowsView.getRow(e - d), s = n._fireFocusedRowChanging(t, o), !s.cancel && s.rowIndexChanged && (e = s.newRowIndex)) : (n._editorFactory.loseFocus(), n._applyTabIndexToElement(a), _.trigger(a, "focus")), (!r || !s.cancel) && n.setFocusedCellPosition(e, l), r && n._updateFocus();
  }
  _getNewPositionByCode(e, t, n) {
    let {
      columnIndex: s
    } = e, {
      rowIndex: o
    } = e, r;
    if (e.rowIndex === void 0 && n === "next")
      return {
        columnIndex: 0,
        rowIndex: 0
      };
    switch (n) {
      case "nextInRow":
      case "next":
        r = this._getVisibleColumnCount(), s < r - 1 && t !== "row" && this._hasValidCellAfterPosition({
          columnIndex: s,
          rowIndex: o
        }) ? s++ : !this._isLastRow(o) && n === "next" && (s = 0, o++);
        break;
      case "previousInRow":
      case "previous":
        s > 0 && t !== "row" && this._hasValidCellBeforePosition({
          columnIndex: s,
          rowIndex: o
        }) ? s-- : o > 0 && n === "previous" && (o--, r = this._getVisibleColumnCount(), s = r - 1);
        break;
      case "upArrow":
        o = o > 0 ? o - 1 : o;
        break;
      case "downArrow":
        o = this._isLastRow(o) ? o : o + 1;
    }
    return {
      columnIndex: s,
      rowIndex: o
    };
  }
  setFocusedCellPosition(e, t) {
    this.setFocusedRowIndex(e), this.setFocusedColumnIndex(t);
  }
  setFocusedRowIndex(e) {
    this._focusedCellPosition || (this._focusedCellPosition = {}), this._focusedCellPosition.rowIndex = e;
  }
  setFocusedColumnIndex(e) {
    this._focusedCellPosition || (this._focusedCellPosition = {}), this._focusedCellPosition.columnIndex = e;
  }
  getRowIndex() {
    return this._focusedCellPosition ? this._focusedCellPosition.rowIndex : -1;
  }
  getColumnIndex() {
    return this._focusedCellPosition ? this._focusedCellPosition.columnIndex : -1;
  }
  getVisibleRowIndex() {
    var e;
    const t = (e = this._focusedCellPosition) === null || e === void 0 ? void 0 : e.rowIndex;
    return !f(t) || t < 0 ? -1 : t - this._dataController.getRowIndexOffset();
  }
  getVisibleColumnIndex() {
    var e;
    const t = (e = this._focusedCellPosition) === null || e === void 0 ? void 0 : e.columnIndex;
    return f(t) ? t - this._columnsController.getColumnIndexOffset() : -1;
  }
  _applyColumnIndexBoundaries(e) {
    const t = this._getVisibleColumnCount();
    return e < 0 ? e = 0 : e >= t && (e = t - 1), e;
  }
  _isCellByPositionValid(e) {
    const t = p(this._getCell(e));
    return this._isCellValid(t);
  }
  _isLastRow(e) {
    const t = this._dataController;
    if (this._isVirtualRowRender())
      return e >= t.getMaxRowIndex();
    const n = Math.max(...t.items().map((s, o) => s.visible !== !1 ? o : -1));
    return e === n;
  }
  _isFirstValidCell(e) {
    let t = !1;
    return e.rowIndex === 0 && e.columnIndex >= 0 && (t = t || !this._hasValidCellBeforePosition(e)), t;
  }
  _hasValidCellBeforePosition(e) {
    let {
      columnIndex: t
    } = e, n = !1;
    for (; t > 0 && !n; ) {
      const s = {
        columnIndex: --t,
        rowIndex: e.rowIndex
      };
      n = this._isCellByPositionValid(s);
    }
    return n;
  }
  _hasValidCellAfterPosition(e) {
    let {
      columnIndex: t
    } = e, n = !1;
    const s = this._getVisibleColumnCount();
    for (; t < s - 1 && !n; ) {
      const o = {
        columnIndex: ++t,
        rowIndex: e.rowIndex
      };
      n = this._isCellByPositionValid(o);
    }
    return n;
  }
  _isLastValidCell(e) {
    const t = e.columnIndex >= 0 ? e.columnIndex + 1 : 0, {
      rowIndex: n
    } = e, s = {
      columnIndex: t,
      rowIndex: n
    }, o = this._dataController.getVisibleRows(), r = o && o[n];
    return this._isLastRow(n) ? (r?.rowType === "group" || r?.rowType === "groupFooter") && e.columnIndex > 0 || e.columnIndex === this._getVisibleColumnCount() - 1 ? !0 : this._isCellByPositionValid(s) ? !1 : this._isLastValidCell(s) : !1;
  }
  _isCellValid(e, t) {
    if (Pn(e)) {
      const n = e.parent(), s = this._rowsView.getCellIndex(e) + this._columnsController.getColumnIndexOffset(), o = this._getColumnByCellElement(e), r = this._getVisibleColumnCount(), a = this._editingController, l = EJ(n), d = o && o.showWhenGrouped, u = o && !e.hasClass(lu) && Ka(n), c = function() {
        return !l && o && (!f(o.groupIndex) || d && u) || parseInt(e.attr("colspan"), 10) > 1;
      };
      if (pF.isDragCell(e))
        return !1;
      if (this.getMasterDetailCell(e))
        return !0;
      if (r > s && c()) {
        const g = this._dataController.items(), m = this._rowsView.getRowIndex(n), C = g[m], v = a && this._isCellEditMode() && a.isEditing(), E = a && a.isEditRow(m), T = E || v;
        return o.command ? this._isLegacyNavigation() ? !T && o.command === "expand" : v ? !1 : E ? o.command !== "select" : !T : v && C && C.rowType !== "data" ? !1 : !T || o.allowEditing || t;
      }
    }
  }
  getFirstValidCellInRow(e, t) {
    const n = this, s = e.find("> td");
    let o, r;
    t = t || 0;
    for (let a = t; a < s.length; ++a)
      if (o = s.eq(a), n._isCellValid(o)) {
        r = o;
        break;
      }
    return r;
  }
  _getNextCell(e, t, n) {
    const s = n || this._focusedCellPosition, o = this.isRowFocusType(), r = o || ["next", "previous"].includes(e);
    let a, l;
    if (this._focusedView && s) {
      const d = this._getNewPositionByCode(s, t, e);
      a = p(this._getCell(d));
      const u = e === "previous" ? this._isFirstValidCell(d) : this._isLastValidCell(d);
      if (Pn(a) && !this._isCellValid(a) && this._isCellInRow(d, r) && !u && (o ? a = this.getFirstValidCellInRow(a.parent(), d.columnIndex) : a = this._getNextCell(e, "cell", d)), l = Pn(a) && a.parent(), this._hasSkipRow(l)) {
        const c = this._getRowIndex(l);
        if (!this._isLastRow(c))
          a = this._getNextCell(e, "row", {
            columnIndex: s.columnIndex,
            rowIndex: c
          });
        else
          return null;
      }
      return Pn(a) ? a : null;
    }
    return null;
  }
  _startEditing(e, t) {
    const n = this._focusedCellPosition, s = this.getVisibleRowIndex(), o = this.getVisibleColumnIndex(), r = this._dataController.items()[s], a = this._columnsController.getVisibleColumns()[o];
    this._isAllowEditing(r, a) && (this._isRowEditMode() ? this._editingController.editRow(s) : n && this._startEditCell(e, t));
  }
  _isAllowEditing(e, t) {
    return this._editingController.allowUpdating({
      row: e
    }) && t && t.allowEditing;
  }
  _editFocusedCell() {
    const e = this.getVisibleRowIndex(), t = this.getVisibleColumnIndex();
    return this._editingController.editCell(e, t);
  }
  _startEditCell(e, t) {
    this._fastEditingStarted = f(t);
    const n = this._editFocusedCell(), s = da(n);
    if (!this._isFastEditingStarted() || !s && !n)
      return;
    const r = s && t === ug ? "" : t, a = s ? n : w().resolve(), l = this._rowsView.waitAsyncTemplates(!0);
    W(a, l).done(() => {
      this._editingCellHandler(e, r);
    });
  }
  _editingCellHandler(e, t) {
    var n;
    const s = this._getFocusedCell().find(Qa).eq(0), o = s.get(0);
    if (!o)
      return;
    const r = $s(e, {
      type: "keydown",
      target: o
    }), a = $s(e, {
      type: "keypress",
      target: o
    }), l = $s(e, {
      type: "input",
      target: o
    });
    if (l.originalEvent && (l.originalEvent = $s(l.originalEvent, {
      data: t
    })), (n = o.select) === null || n === void 0 || n.call(o), _.trigger(s, r), !r.isDefaultPrevented() && (_.trigger(s, a), !a.isDefaultPrevented())) {
      const d = ze.mozilla ? 25 : 0;
      setTimeout(() => {
        const u = this._getKeyPressInputValue(s, t);
        s.val(u);
        const c = s.closest(`.${CJ}`);
        _.off(c, "focusout"), _.one(c, "focusout", () => {
          _.trigger(s, "change");
        }), _.trigger(s, l);
      }, d);
    }
  }
  _getKeyPressInputValue(e, t) {
    const n = e.val();
    return t === "-" && n === "-0" ? "-0" : t;
  }
  _fireFocusChangingEvents(e, t, n, s) {
    let o = {};
    const r = this._getCellPosition(t) ?? {};
    return this.isCellFocusType() && (o = this._fireFocusedCellChanging(e, t, s), o.cancel || (r.columnIndex = o.newColumnIndex, r.rowIndex = o.newRowIndex, s = o.isHighlighted, t = p(this._getCell(r)))), !o.cancel && n && t && (o = this._fireFocusedRowChanging(e, t.parent()), o.cancel || (r.rowIndex = o.newRowIndex, o.isHighlighted = s)), o.$newCellElement = p(this._getCell(r)), o.$newCellElement.length || (o.$newCellElement = t), o;
  }
  _fireFocusedCellChanging(e, t, n) {
    const s = this.option("focusedColumnIndex"), o = this.option("focusedRowIndex"), r = this._getCellPosition(t), a = r ? r.columnIndex : -1, l = r ? r.rowIndex : -1, d = this._dataController.getVisibleRows(), u = this._columnsController.getVisibleColumns(), c = {
      cellElement: t,
      prevColumnIndex: s,
      prevRowIndex: o,
      newColumnIndex: a,
      newRowIndex: l,
      rows: d,
      columns: u,
      event: e,
      isHighlighted: n || !1,
      cancel: !1
    };
    return this._canceledCellPosition = null, this.executeAction("onFocusedCellChanging", c), (c.newColumnIndex !== a || c.newRowIndex !== l) && (c.$newCellElement = p(this._getCell({
      columnIndex: c.newColumnIndex,
      rowIndex: c.newRowIndex
    }))), c.cancel && (this._canceledCellPosition = {
      rowIndex: l,
      columnIndex: a
    }), c;
  }
  _fireFocusedCellChanged(e) {
    const t = this._rowsView.getCellIndex(e), n = e?.parent().data("options"), s = n?.key;
    this._memoFireFocusedCellChanged(s, t);
  }
  _memoFireFocusedCellChanged(e, t) {
    const n = this._getFocusedCell(), s = this._getRowIndex(n?.parent()), o = Math.min(s - this._dataController.getRowIndexOffset(), this._dataController.items().length - 1);
    if (this._editingController.isEditCell(o, t))
      return;
    const a = this._dataController.items()[o], l = this._columnsController.getVisibleColumns()[t];
    this.executeAction("onFocusedCellChanged", {
      cellElement: n ? ee(n) : void 0,
      columnIndex: t,
      rowIndex: s,
      row: a,
      column: l
    });
  }
  _fireFocusedRowChanging(e, t) {
    const n = this._getRowIndex(t), s = this.option("focusedRowIndex"), o = this._dataController.loadingOperationTypes(), r = {
      rowElement: t,
      prevRowIndex: s,
      newRowIndex: n,
      event: e,
      rows: this._dataController.getVisibleRows(),
      cancel: !1
    }, a = o.sorting || o.grouping || o.filtering || o.paging;
    return !this._dataController || this._dataController.isLoading() && a ? (r.cancel = !0, r) : (this.option("focusedRowEnabled") && (this.executeAction("onFocusedRowChanging", r), !r.cancel && r.newRowIndex !== n && (r.resetFocusedRow = r.newRowIndex < 0, r.resetFocusedRow || this.setFocusedRowIndex(r.newRowIndex), r.rowIndexChanged = !0)), r);
  }
  _fireFocusedRowChanged() {
    var e;
    const t = this.option("focusedRowEnabled"), n = this.option("focusedRowKey"), s = (e = this._focusController) === null || e === void 0 ? void 0 : e.getFocusedRowIndexByKey(n);
    !t || f(n) && s < 0 || this._memoFireFocusedRowChanged(n, s);
  }
  _memoFireFocusedRowChanged(e, t) {
    const n = t - this._dataController.getRowIndexOffset();
    this.executeAction("onFocusedRowChanged", {
      rowElement: t < 0 ? void 0 : this._rowsView.getRowElement(n),
      rowIndex: t,
      row: t < 0 ? void 0 : this._dataController.getVisibleRows()[n]
    });
  }
  _isEventInCurrentGrid(e) {
    return F.isElementInCurrentGrid(this, p(e.target));
  }
  _isRowEditMode() {
    const e = this._editingController.getEditMode();
    return e === ul || e === xC;
  }
  _isCellEditMode() {
    const e = this._editingController.getEditMode();
    return e === Wm || e === Hm;
  }
  _isFastEditingAllowed() {
    return this._isCellEditMode() && this.option("keyboardNavigation.editOnKeyPress");
  }
  _getInteractiveElement(e, t) {
    const n = e.find(Qa).filter(":visible");
    return t ? n.last() : n.first();
  }
  _applyTabIndexToElement(e) {
    const t = this.option("tabIndex") ?? 0;
    e.attr("tabindex", t);
  }
  _getCell(e) {
    if (this._focusedView && e) {
      const t = this._dataController.getRowIndexOffset(), n = this._columnsController.getVisibleColumns(null, !0)[e.columnIndex], s = n && n.fixed ? this._getFixedColumnIndexOffset(n) : this._columnsController.getColumnIndexOffset(), o = e.rowIndex >= 0 ? e.rowIndex - t : -1, r = e.columnIndex >= 0 ? e.columnIndex - s : -1;
      return this._focusedView.getCell({
        rowIndex: o,
        columnIndex: r
      });
    }
  }
  _getRowIndex(e) {
    let t = this._rowsView.getRowIndex(e);
    return t >= 0 && (t += this._dataController.getRowIndexOffset()), t;
  }
  _hasSkipRow(e) {
    const t = e && e.get(0);
    return t && t.style.display === "none";
  }
  _allowEditingOnEnterKey() {
    return this.option("keyboardNavigation.enterKeyAction") === "startEdit";
  }
  _isLegacyNavigation() {
    return this.option("useLegacyKeyboardNavigation");
  }
  _getDirectionCodeByKey(e) {
    let t;
    switch (e) {
      case "upArrow":
        t = "prevRow";
        break;
      case "downArrow":
        t = "nextRow";
        break;
      case "leftArrow":
        t = this.option("rtlEnabled") ? "nextInRow" : "previousInRow";
        break;
      case "rightArrow":
        t = this.option("rtlEnabled") ? "previousInRow" : "nextInRow";
    }
    return t;
  }
  _isVirtualScrolling() {
    const e = this.option("scrolling.mode");
    return e === "virtual" || e === "infinite";
  }
  _isVirtualRowRender() {
    return this._isVirtualScrolling() || F.isVirtualRowRendering(this);
  }
  _isVirtualColumnRender() {
    return this.option("scrolling.columnRenderingMode") === "virtual";
  }
  _scrollBy(e, t, n, s) {
    const o = this, r = this._rowsView.getScrollable();
    if (o._focusedCellPosition) {
      const a = function() {
        r.off("scroll", a), setTimeout(o.restoreFocusableElement.bind(o, n, s));
      };
      r.on("scroll", a);
    }
    return r.scrollBy({
      left: e,
      top: t
    });
  }
  _isInsideEditForm(e) {
    const t = p(e).closest(`.${this.addWidgetPrefix(_C)}`);
    return t.length && this.elementIsInsideGrid(t);
  }
  getMasterDetailCell(e) {
    const t = p(e).closest(`.${lg}`);
    return t.length && this.elementIsInsideGrid(t) ? t : null;
  }
  _processNextCellInMasterDetail(e, t) {
    !this._isInsideEditForm(e) && e && this._applyTabIndexToElement(e);
  }
  _handleTabKeyOnMasterDetailCell(e, t) {
    if (this.getMasterDetailCell(e)) {
      this._updateFocusedCellPosition(p(e), t);
      const n = this._getNextCell(t, "row");
      return this._processNextCellInMasterDetail(n, p(e)), !0;
    }
    return !1;
  }
  _getElementType(e) {
    return p(e).is("tr") ? "row" : "cell";
  }
  _isFastEditingStarted() {
    return this._isFastEditingAllowed() && this._fastEditingStarted;
  }
  _getVisibleColumnCount() {
    return this._columnsController.getVisibleColumns(null, !0).length;
  }
  _isCellInRow(e, t) {
    const {
      columnIndex: n
    } = e, s = this._getVisibleColumnCount();
    return t ? n >= 0 && n <= s - 1 : n > 0 && n < s - 1;
  }
  _isCellElement(e) {
    return e.length && e[0].tagName === "TD";
  }
  _getCellElementFromTarget(e) {
    const t = this._getElementType(e), n = p(e);
    let s;
    return t === "cell" ? s = n.closest(`.${Fs} > td`) : s = n.children().not(`.${lu}`).first(), s;
  }
  _getRowsViewElement() {
    var e;
    return (e = this._rowsView) === null || e === void 0 ? void 0 : e.element();
  }
  isKeyboardEnabled() {
    return this.option("keyboardNavigation.enabled");
  }
  _processCanceledEditCellPosition(e, t) {
    if (this._canceledCellPosition) {
      const n = this._canceledCellPosition.rowIndex === e && this._canceledCellPosition.columnIndex === t;
      return this._canceledCellPosition = null, n;
    }
  }
  updateFocusedRowIndex() {
    const e = this._dataController, t = this.getVisibleRowIndex(), n = e.items(), s = n.length ? n.length - 1 : -1, o = e.getRowIndexOffset();
    s >= 0 && t > s && this.setFocusedRowIndex(s + o);
  }
}
const kJ = (i) => class extends i {
  _rowClick(e) {
    const t = this._editingController.getEditRowIndex(), n = this._keyboardNavigationController.isKeyboardEnabled();
    t === e.rowIndex && this._keyboardNavigationController.setCellFocusType(), (nf() || !n) && this.option("focusedRowEnabled") && this._triggerPointerDownEventHandler(e, !n), super._rowClick.apply(this, arguments);
  }
  _triggerPointerDownEventHandler(e, t) {
    const {
      originalEvent: n
    } = e.event;
    if (n) {
      const s = p(n.target), o = this.getCellIndex(s), r = this._columnsController.getVisibleColumns()[o], a = this._dataController.items()[e.rowIndex];
      if (this._keyboardNavigationController._isAllowEditing(a, r) || t) {
        const l = $s(n, {
          currentTarget: n.target
        });
        this._keyboardNavigationController._pointerEventHandler(l);
      }
    }
  }
  renderFocusState(e) {
    super.renderFocusState(e);
    const {
      preventScroll: t,
      pageSizeChanged: n
    } = e ?? {}, s = this.element();
    s && !qs(s) && s.attr("tabindex", null), n && this._keyboardNavigationController.updateFocusedRowIndex();
    let o = this._keyboardNavigationController.getVisibleRowIndex();
    (!f(o) || o < 0) && (o = 0);
    const r = this.getCellElements(o);
    this._keyboardNavigationController.isKeyboardEnabled() && r !== null && r !== void 0 && r.length && this.updateFocusElementTabIndex(r, t);
  }
  updateFocusElementTabIndex(e, t) {
    const n = e.eq(0).parent();
    if (Hr(n))
      this._keyboardNavigationController._applyTabIndexToElement(n);
    else {
      let s = this._keyboardNavigationController.getColumnIndex();
      (!f(s) || s < 0) && (s = 0), this._updateFocusedCellTabIndex(e, s);
    }
  }
  _updateFocusedCellTabIndex(e, t) {
    const n = this._keyboardNavigationController, s = e ? e.length : -1, o = function(a) {
      const l = !!n.getMasterDetailCell(a), d = n._isCellValid(a);
      if (!l && d && n._isCellElement(a))
        return n._applyTabIndexToElement(a), n.setCellFocusType(), !0;
    }, r = pF.getCellToFocus(e, t);
    if (r.length)
      o(r);
    else {
      s <= t && (t = s - 1);
      for (let a = t; a < s && !o(p(e[a])); ++a)
        ;
    }
  }
  renderDelayedTemplates(e) {
    super.renderDelayedTemplates.apply(this, arguments), this.waitAsyncTemplates().done(() => {
      this._renderFocusByChange(e);
    });
  }
  _renderFocusByChange(e) {
    var t;
    const {
      operationTypes: n,
      repaintChangesOnly: s
    } = e ?? {}, {
      fullReload: o,
      pageSize: r
    } = n ?? {}, a = !!(e != null && (t = e.changeTypes) !== null && t !== void 0 && t.find((l) => l === "insert" || l === "remove"));
    if (!e || !s || o || r || a) {
      const l = AJ(this);
      this.renderFocusState({
        preventScroll: l,
        pageSizeChanged: r
      });
    }
  }
  _renderCore(e) {
    const t = super._renderCore.apply(this, arguments);
    return this._renderFocusByChange(e), t;
  }
  _editCellPrepared(e) {
    var t;
    const n = this._getEditorInstance(e), s = (t = this._keyboardNavigationController) === null || t === void 0 ? void 0 : t._isFastEditingStarted();
    n && s && this._handleEditingNavigationMode(n), super._editCellPrepared.apply(this, arguments);
  }
  _handleEditingNavigationMode(e) {
    ["downArrow", "upArrow"].forEach((n) => {
      const s = e._supportedKeys()[n];
      e.registerKeyHandler(n, (o) => {
        if (e._input().attr("aria-expanded") === "true")
          return s && s.call(e, o);
      });
    }), e.registerKeyHandler("leftArrow", M), e.registerKeyHandler("rightArrow", M), e.NAME === _J && e.option("useMaskBehavior") && e.registerKeyHandler("enter", M);
  }
  _getEditorInstance(e) {
    const t = e.find(".dx-texteditor").eq(0);
    return F.getWidgetInstance(t);
  }
}, VJ = (i) => class extends i {
  editCell(e, t) {
    if (this._keyboardNavigationController._processCanceledEditCellPosition(e, t))
      return !1;
    const n = super.editCell(e, t);
    return n && this._keyboardNavigationController.setupFocusedView(), n;
  }
  editRow(e) {
    const t = this._keyboardNavigationController.getVisibleColumnIndex(), n = this._columnsController.getVisibleColumns()[t];
    (n && n.type || this.option("editing.mode") === xC) && this._keyboardNavigationController._resetFocusedCell(), super.editRow(e);
  }
  addRow(e) {
    return this._keyboardNavigationController.setupFocusedView(), this._keyboardNavigationController.setCellFocusType(), super.addRow.apply(this, arguments);
  }
  getFocusedCellInRow(e) {
    let t = super.getFocusedCellInRow(e);
    const n = this._dataController.getRowIndexOffset(), s = this._keyboardNavigationController._focusedCellPosition.rowIndex - n;
    if (this._keyboardNavigationController.isKeyboardEnabled() && s === e) {
      const o = this._keyboardNavigationController._getFocusedCell();
      Pn(o) && !o.hasClass(hF) && (t = o);
    }
    return t;
  }
  _processCanceledEditingCell() {
    this.closeEditCell().done(() => {
      this._keyboardNavigationController._updateFocus();
    });
  }
  closeEditCell() {
    const e = this._keyboardNavigationController;
    e._fastEditingStarted = !1;
    const t = super.closeEditCell.apply(this, arguments);
    return !!this._getFocusedElement().closest(`.${this.addWidgetPrefix(zX)}`).length || e._updateFocus(), t;
  }
  _getFocusedElement() {
    var e, t;
    return p((e = (t = this.component).element) === null || e === void 0 ? void 0 : e.call(t)).find(":focus");
  }
  _delayedInputFocus() {
    this._keyboardNavigationController._isNeedScroll = !0, super._delayedInputFocus.apply(this, arguments);
  }
  _isEditingStart() {
    const e = super._isEditingStart.apply(this, arguments);
    if (e && !this._keyboardNavigationController._isNeedFocus) {
      const t = this._keyboardNavigationController._getFocusedCell();
      this._keyboardNavigationController._focus(t, !0);
    }
    return e;
  }
}, PJ = (i) => class extends i {
  _correctRowIndices(e) {
    const t = this._keyboardNavigationController._focusedCellPosition;
    if (super._correctRowIndices.apply(this, arguments), t && t.rowIndex >= 0) {
      const n = e(t.rowIndex);
      n && (t.rowIndex += n, this._editorFactoryController.refocus());
    }
  }
  getMaxRowIndex() {
    let e = this.items().length - 1;
    const t = this.virtualItemsCount();
    if (t) {
      const n = this.getRowIndexOffset();
      e += n + t.end;
    }
    return e;
  }
}, MJ = (i) => class extends i {
  _showHiddenCellsInView(e) {
    let {
      viewName: t,
      $cells: n,
      isCommandColumn: s
    } = e;
    super._showHiddenCellsInView.apply(this, arguments), t === Y0 && !s && n.each((o, r) => {
      const a = p(r);
      Z0(a) && a.attr("tabindex", 0);
    });
  }
  _hideVisibleCellInView(e) {
    let {
      viewName: t,
      $cell: n,
      isCommandColumn: s
    } = e;
    super._hideVisibleCellInView.apply(this, arguments), t === Y0 && !s && Z0(n) && n.removeAttr("tabindex");
  }
  _hideVisibleColumnInView(e) {
    let {
      view: t,
      isCommandColumn: n,
      visibleIndex: s
    } = e;
    super._hideVisibleColumnInView({
      view: t,
      isCommandColumn: n,
      visibleIndex: s
    }), t.name === xJ && this._rowsView.renderFocusState(null);
  }
}, BJ = {
  defaultOptions: () => ({
    useLegacyKeyboardNavigation: !1,
    keyboardNavigation: {
      enabled: !0,
      enterKeyAction: "startEdit",
      enterKeyDirection: "none",
      editOnKeyPress: !1
    }
  }),
  controllers: {
    keyboardNavigation: FJ
  },
  extenders: {
    views: {
      rowsView: kJ
    },
    controllers: {
      editing: VJ,
      data: PJ,
      adaptiveColumns: MJ,
      keyboardNavigation: RJ
    }
  }
};
J.registerModule("keyboardNavigation", BJ);
function sf(i, e, t, n) {
  let s = 0;
  if (i < e)
    for (; s < t.items.length; s++)
      sf(i + 1, e, t.items[s], n);
  i === e && n(t);
}
function du(i, e) {
  let t;
  if ("map" in i)
    return i.map(e);
  const n = new Array(i.length);
  for (t in i)
    n[t] = e(i[t], t);
  return n;
}
function $J(i) {
  return i !== i || i === "" || i === null || i === void 0;
}
function NJ(i) {
  return i === k_.count;
}
function Q0(i) {
  const e = Be(i.selector), t = "skipEmptyValues" in i ? i.skipEmptyValues : !0;
  let {
    aggregator: n
  } = i;
  if (typeof n == "string" && (n = k_[n], !n))
    throw vt.Error("E4001", i.aggregator);
  return {
    selector: e,
    aggregator: n,
    skipEmptyValues: t
  };
}
class LJ {
  constructor(e) {
    this._data = e.data, this._groupLevel = e.groupLevel || 0, this._totalAggregates = du(e.totalAggregates || [], Q0), this._groupAggregates = du(e.groupAggregates || [], Q0), this._totals = [];
  }
  calculate() {
    this._totalAggregates.length && this._calculateTotals(0, {
      items: this._data
    }), this._groupAggregates.length && this._groupLevel > 0 && this._calculateGroups({
      items: this._data
    });
  }
  totalAggregates() {
    return this._totals;
  }
  _aggregate(e, t, n) {
    const s = t.items ? t.items.length : 0;
    for (let o = 0; o < e.length; o++) {
      if (NJ(e[o].aggregator)) {
        n[o] = (n[o] || 0) + s;
        continue;
      }
      for (let r = 0; r < s; r++)
        this._accumulate(o, e[o], n, t.items[r]);
    }
  }
  _calculateTotals(e, t) {
    if (e === 0 && (this._totals = this._seed(this._totalAggregates)), e === this._groupLevel)
      this._aggregate(this._totalAggregates, t, this._totals);
    else
      for (let n = 0; n < t.items.length; n++)
        this._calculateTotals(e + 1, t.items[n]);
    e === 0 && (this._totals = this._finalize(this._totalAggregates, this._totals));
  }
  _calculateGroups(e) {
    const t = this._groupLevel;
    let n = t + 1;
    const s = this._seed.bind(this, this._groupAggregates), o = this._aggregate.bind(this, this._groupAggregates), r = this._finalize.bind(this, this._groupAggregates);
    function a(l) {
      l.aggregates = s(n - 1), n === t ? o(l, l.aggregates) : sf(n, t, l, (d) => {
        o(d, l.aggregates);
      }), l.aggregates = r(l.aggregates);
    }
    for (; --n > 0; )
      sf(0, n, e, a);
  }
  _seed(e, t) {
    return du(e, (n) => {
      const {
        aggregator: s
      } = n;
      return "seed" in s ? B(s.seed) ? s.seed(t) : s.seed : NaN;
    });
  }
  _accumulate(e, t, n, s) {
    const o = t.selector(s), {
      aggregator: r
    } = t, {
      skipEmptyValues: a
    } = t;
    a && $J(o) || (n[e] !== n[e] ? n[e] = o : n[e] = r.step(n[e], o));
  }
  _finalize(e, t) {
    return du(e, (n, s) => {
      const o = n.aggregator.finalize;
      return o ? o(t[s]) : t[s];
    });
  }
}
const HJ = "dx-cell-focus-disabled", mF = function(i, e) {
  const t = p(i), {
    column: n
  } = e, {
    summaryItems: s
  } = e, o = [];
  if (!n.command && s) {
    for (let r = 0; r < s.length; r++) {
      const a = s[r], l = J.getSummaryText(a, e.summaryTexts);
      o.push(p("<div>").css("textAlign", a.alignment || n.alignment).addClass("dx-datagrid-summary-item").addClass("dx-datagrid-text-content").addClass(a.cssClass).toggleClass("dx-datagrid-group-text-content", e.rowType === "group").text(l).attr("aria-label", `${n.caption} ${l}`));
    }
    t.append(o);
  }
}, fF = function(i, e) {
  const t = i.option("summary.texts") || {};
  return {
    totalItem: e.row,
    summaryItems: e.row.summaryCells[e.columnIndex],
    summaryTexts: t
  };
}, cg = function(i) {
  return i.summary || i.aggregates || [];
}, AC = function(i) {
  return i.option("summary.recalculateWhileEditing");
}, _F = function(i, e, t, n) {
  n = n || [];
  for (let s = 0; s < i.length; s++)
    n.push(i[s].key), e === 1 ? t(n, i[s].items) : _F(i[s].items, e - 1, t, n), n.pop();
}, CF = function(i, e, t) {
  return t ? CF(i, e.map((n) => ({
    items: [n]
  }), t - 1)) : i.concat(e);
}, vF = function(i, e, t) {
  return t ? i.map((n) => {
    const s = {}, o = vF(n.items || [], e, t - 1);
    return Object.defineProperty(s, "aggregates", {
      get: () => n.aggregates,
      set: (r) => {
        n.aggregates = r;
      }
    }), x(s, n, {
      items: o
    });
  }) : i.filter((n) => e.indexOf(n) < 0);
}, xF = function(i, e, t) {
  if (!i || !e.length)
    return i;
  const n = e[0], s = t[0];
  let o;
  return n && s && s.length && (o = un(i), y(s, function(r) {
    r === 0 ? o = o.sortBy(this.selector, this.desc) : o = o.thenBy(this.selector, this.desc);
  }), o.enumerate().done((r) => {
    i = r;
  })), e = e.slice(1), t = t.slice(1), e.length && t.length && y(i, function() {
    this.items = xF(this.items, e, t);
  }), i;
}, J0 = function(i, e, t) {
  const n = t && t.sortByGroups && t.sortByGroups();
  return n && n.length ? xF(i, e, n) : i;
}, eS = function(i, e, t, n) {
  let s;
  if (AC(i)) {
    const o = i._editingController;
    if (o) {
      const r = o.getInsertedData();
      r.length && (t = CF(t, r, n));
      const a = o.getRemovedData();
      a.length && (t = vF(t, a, n));
    }
  }
  return e && (s = new LJ({
    totalAggregates: e.totalAggregates,
    groupAggregates: e.groupAggregates,
    data: t,
    groupLevel: n
  }), s.calculate()), s ? s.totalAggregates() : [];
};
class WJ extends Cd {
  _getRows() {
    return this._dataController.footerItems();
  }
  _getCellOptions(e) {
    return x(super._getCellOptions(e), fF(this, e));
  }
  _renderCellContent(e, t) {
    mF(e, t), super._renderCellContent.apply(this, arguments);
  }
  _renderCore(e) {
    let t = !1;
    const n = this._dataController.footerItems()[0];
    return (!e || !e.columnIndices) && (this.element().empty().addClass("dx-datagrid-total-footer").toggleClass("dx-datagrid-nowrap", !this.option("wordWrapEnabled")), t = !0), n && n.summaryCells && n.summaryCells.length && (this._updateContent(this._renderTable({
      change: e
    }), e), t && this._updateScrollLeftPosition()), super._renderCore(e);
  }
  _updateContent(e, t) {
    return t && t.changeType === "update" && t.columnIndices ? this.waitAsyncTemplates().done(() => {
      const n = this.getTableElement().find(".dx-row"), s = e.find(".dx-row");
      this._updateCells(n, s, t.columnIndices[0]);
    }) : super._updateContent.apply(this, arguments);
  }
  _rowClick(e) {
    const t = this._dataController.footerItems()[e.rowIndex] || {};
    this.executeAction("onRowClick", x({}, e, t));
  }
  _columnOptionChanged(e) {
    const {
      optionNames: t
    } = e;
    e.changeTypes.grouping || (t.width || t.visibleWidth) && super._columnOptionChanged(e);
  }
  _handleDataChanged(e) {
    const {
      changeType: t
    } = e;
    e.changeType === "update" && e.repaintChangesOnly ? e.totalColumnIndices ? e.totalColumnIndices.length && this.render(null, {
      changeType: "update",
      columnIndices: [e.totalColumnIndices]
    }) : this.render() : (t === "refresh" || t === "append" || t === "prepend") && this.render();
  }
  _createRow(e) {
    const t = super._createRow.apply(this, arguments);
    return e.rowType === "totalFooter" && (t.addClass("dx-footer-row"), t.addClass(HJ), t.attr("tabindex", 0)), t;
  }
  getHeight() {
    return this.getElementHeight();
  }
  isVisible() {
    return !!this._dataController.footerItems().length;
  }
}
const zJ = (i) => class extends i {
  init() {
    super.init.apply(this, arguments), this._editingController = this.getController("editing"), this._totalAggregates = [], this._summaryGetter = M;
  }
  summaryGetter(e) {
    if (!arguments.length)
      return this._summaryGetter;
    B(e) && (this._summaryGetter = e);
  }
  summary(e) {
    if (!arguments.length)
      return this._summaryGetter();
    this._summaryGetter = function() {
      return e;
    };
  }
  totalAggregates() {
    return this._totalAggregates;
  }
  isLastLevelGroupItemsPagingLocal() {
    const e = this.summary(), t = e?.sortByGroups();
    return t?.length;
  }
  sortLastLevelGroupItems(e, t, n) {
    const s = ps.multiLevelGroup(un(e), t).toArray();
    let o = [];
    return n.forEach((r) => {
      _F(s, t.length, (a, l) => {
        r.toString() === a.toString() && (o = o.concat(l));
      });
    }), o;
  }
  _customizeRemoteOperations(e) {
    const t = this.summary();
    t && (e.remoteOperations.summary ? (!e.isCustomLoading || e.storeLoadOptions.isLoadingAll) && (e.storeLoadOptions.group && (e.remoteOperations.grouping ? e.storeLoadOptions.groupSummary = t.groupAggregates : t.groupAggregates.length && (e.remoteOperations.paging = !1)), e.storeLoadOptions.totalSummary = t.totalAggregates) : (t.totalAggregates.length || t.groupAggregates.length && e.storeLoadOptions.group) && (e.remoteOperations.paging = !1)), super._customizeRemoteOperations.apply(this, arguments);
    const n = e.cachedData.extra;
    n != null && n.summary && !e.isCustomLoading && (e.storeLoadOptions.totalSummary = void 0);
  }
  _handleDataLoadedCore(e) {
    const t = hs(e.storeLoadOptions.group || e.loadOptions.group || []), n = e.remoteOperations || {}, s = this.summaryGetter()(n);
    if (!e.isCustomLoading || e.storeLoadOptions.isLoadingAll) {
      if (n.summary)
        !n.paging && t.length && s && (n.grouping || eS(this, {
          groupAggregates: s.groupAggregates
        }, e.data, t.length), e.data = J0(e.data, t, s));
      else if (!n.paging && s) {
        var o;
        const r = e.operationTypes || {};
        if (!Object.keys(r).some((l) => r[l]) || !((o = e.cachedData) !== null && o !== void 0 && (o = o.extra) !== null && o !== void 0 && o.summary) || t.length && s.groupAggregates.length) {
          const l = eS(this, s, e.data, t.length);
          e.extra = pe(e.extra) ? e.extra : {}, e.extra.summary = l, e.cachedData && (e.cachedData.extra = e.extra);
        }
        e.data = J0(e.data, t, s);
      }
    }
    e.isCustomLoading || (this._totalAggregates = e.extra && e.extra.summary || this._totalAggregates), super._handleDataLoadedCore(e);
  }
};
gh.extend(zJ);
const KJ = (i) => class extends i {
  _isDataColumn(e) {
    return e && (!f(e.groupIndex) || e.showWhenGrouped);
  }
  _isGroupFooterVisible() {
    const e = this.option("summary.groupItems") || [];
    for (let t = 0; t < e.length; t++) {
      const n = e[t], s = this._columnsController.columnOption(n.showInColumn || n.column);
      if (n.showInGroupFooter && this._isDataColumn(s))
        return !0;
    }
    return !1;
  }
  _processGroupItems(e, t, n) {
    const s = n && n.data, o = super._processGroupItems.apply(this, arguments);
    return n && (n.isGroupFooterVisible === void 0 && (n.isGroupFooterVisible = this._isGroupFooterVisible()), s && s.items && n.isGroupFooterVisible && (n.collectContinuationItems || !s.isContinuationOnNextPage) && o.push({
      rowType: "groupFooter",
      key: n.path.slice(),
      data: s,
      groupIndex: n.path.length - 1,
      values: []
    })), o;
  }
  _processGroupItem(e, t) {
    const n = this;
    if (t.summaryGroupItems || (t.summaryGroupItems = n.option("summary.groupItems") || []), e.rowType === "group") {
      let s = -1, o = -1;
      y(t.visibleColumns, function(r) {
        const a = t.visibleColumns[r - 1];
        e.groupIndex === this.groupIndex && (s = this.index), r > 0 && a.command === "expand" && this.command !== "expand" && (o = this.index);
      }), e.summaryCells = this._calculateSummaryCells(t.summaryGroupItems, cg(e.data), t.visibleColumns, (r, a) => r.showInGroupFooter ? -1 : r.alignByColumn && a && !f(a.groupIndex) && a.index !== o ? a.index : s, !0);
    }
    return e.rowType === "groupFooter" && (e.summaryCells = this._calculateSummaryCells(t.summaryGroupItems, cg(e.data), t.visibleColumns, (s, o) => s.showInGroupFooter && n._isDataColumn(o) ? o.index : -1)), e;
  }
  _calculateSummaryCells(e, t, n, s, o) {
    const r = this, a = [], l = {};
    return y(e, (d, u) => {
      const c = r._columnsController.columnOption(u.column), h = u.showInColumn && r._columnsController.columnOption(u.showInColumn) || c, g = s(u, h);
      if (g >= 0) {
        l[g] || (l[g] = []);
        const m = t[d];
        if (m === m) {
          let C;
          f(u.valueFormat) ? C = u.valueFormat : u.summaryType !== "count" && (C = J.getFormatByDataType(c && c.dataType)), l[g].push(x({}, u, {
            value: te(m) && c && c.deserializeValue ? c.deserializeValue(m) : m,
            valueFormat: C,
            columnCaption: c && c.index !== g ? c.caption : void 0
          }));
        }
      }
    }), en(l) || n.forEach((d, u) => {
      const c = n[u - 1], h = o && (c?.command === "expand" || d.command === "expand") ? c?.index : d.index;
      a.push(l[h] || []);
    }), a;
  }
  _getSummaryCells(e, t) {
    const n = this, s = n._columnsController;
    return n._calculateSummaryCells(e, t, s.getVisibleColumns(), (o, r) => n._isDataColumn(r) ? r.index : -1);
  }
  _updateItemsCore(e) {
    const t = this;
    let n;
    const s = t._dataSource, o = t._footerItems, r = o && o[0] && o[0].summaryCells, a = t.option("summary.totalItems");
    if (t._footerItems = [], s && a && a.length) {
      const l = s.totalAggregates();
      n = t._getSummaryCells(a, l), e && e.repaintChangesOnly && r && (e.totalColumnIndices = n.map((d, u) => JSON.stringify(d) !== JSON.stringify(r[u]) ? u : -1).filter((d) => d >= 0)), n.length && t._footerItems.push({
        rowType: "totalFooter",
        summaryCells: n
      });
    }
    super._updateItemsCore(e);
  }
  _prepareUnsavedDataSelector(e) {
    if (AC(this)) {
      const t = this._editingController;
      if (t)
        return function(n) {
          return n = t.getUpdatedData(n), e(n);
        };
    }
    return e;
  }
  _prepareAggregateSelector(e, t) {
    return e = this._prepareUnsavedDataSelector(e), t === "avg" || t === "sum" ? function(n) {
      const s = e(n);
      return f(s) ? Number(s) : s;
    } : e;
  }
  _getAggregates(e, t) {
    const n = this;
    let s = n.option("summary.calculateCustomSummary");
    const o = n.option("summary.skipEmptyValues");
    return mt(e || [], (r) => {
      const a = this._columnsController.columnOption(r.column), l = a && a.calculateCellValue ? a.calculateCellValue.bind(a) : Be(a ? a.dataField : r.column);
      let d = r.summaryType || "count";
      const u = f(r.skipEmptyValues) ? r.skipEmptyValues : o;
      if (t)
        return {
          selector: r.column,
          summaryType: d
        };
      const c = n._prepareAggregateSelector(l, d);
      if (d === "custom") {
        s || (_e.log("E1026"), s = function() {
        });
        const h = {
          component: n.component,
          name: r.name
        };
        s(h), h.summaryProcess = "calculate", d = {
          seed(g) {
            return h.summaryProcess = "start", h.totalValue = void 0, h.groupIndex = g, delete h.value, s(h), h.totalValue;
          },
          step(g, m) {
            return h.summaryProcess = "calculate", h.totalValue = g, h.value = m, s(h), h.totalValue;
          },
          finalize(g) {
            return h.summaryProcess = "finalize", h.totalValue = g, delete h.value, s(h), h.totalValue;
          }
        };
      }
      return {
        selector: c,
        aggregator: d,
        skipEmptyValues: u
      };
    });
  }
  _addSortInfo(e, t, n, s) {
    if (t) {
      const {
        groupIndex: o
      } = t;
      s = s || t.sortOrder, f(o) && (e[o] = e[o] || [], e[o].push({
        selector: n,
        desc: s === "desc"
      }));
    }
  }
  _findSummaryItem(e, t) {
    let n = -1;
    return f(t) && y(e || [], function(s) {
      if (this.name === t || s === t || this.summaryType === t || this.column === t || function(o) {
        const {
          summaryType: r
        } = o, {
          column: a
        } = o;
        return r && a && `${r}_${a}`;
      }(this) === t)
        return n = s, !1;
    }), n;
  }
  _getSummarySortByGroups(e, t) {
    const n = this, s = n._columnsController, o = s.getGroupColumns(), r = [];
    if (!(!t || !t.length))
      return y(e || [], function() {
        const {
          sortOrder: a
        } = this;
        let {
          groupColumn: l
        } = this;
        const d = n._findSummaryItem(t, this.summaryItem);
        if (d < 0)
          return;
        const u = function(c) {
          return cg(c)[d];
        };
        f(l) ? (l = s.columnOption(l), n._addSortInfo(r, l, u, a)) : y(o, (c, h) => {
          n._addSortInfo(r, h, u, a);
        });
      }), r;
  }
  _createDataSourceAdapterCore(e, t) {
    const n = this, s = super._createDataSourceAdapterCore(e, t);
    return s.summaryGetter((o) => n._getSummaryOptions(o || t)), s;
  }
  _getSummaryOptions(e) {
    const t = this, n = t.option("summary.groupItems"), s = t.option("summary.totalItems"), o = t.option("sortByGroupSummaryInfo"), r = t._getAggregates(n, e && e.grouping && e.summary), a = t._getAggregates(s, e && e.summary), l = function() {
      return t._getSummarySortByGroups(o, n);
    };
    if (r.length || a.length)
      return {
        groupAggregates: r,
        totalAggregates: a,
        sortByGroups: l
      };
  }
  publicMethods() {
    const e = super.publicMethods();
    return e.push("getTotalSummaryValue"), e;
  }
  getTotalSummaryValue(e) {
    const t = this._findSummaryItem(this.option("summary.totalItems"), e), n = this._dataSource.totalAggregates();
    if (n.length && t > -1)
      return n[t];
  }
  optionChanged(e) {
    (e.name === "summary" || e.name === "sortByGroupSummaryInfo") && (e.name = "dataSource"), super.optionChanged(e);
  }
  init() {
    this._footerItems = [], super.init();
  }
  footerItems() {
    return this._footerItems;
  }
}, GJ = (i) => class extends i {
  _refreshSummary() {
    AC(this) && !this.isSaving() && this._dataController.refresh({
      load: !0,
      changesOnly: !0
    });
  }
  _addChange(e) {
    const t = super._addChange.apply(this, arguments);
    return e.type && this._refreshSummary(), t;
  }
  _removeChange() {
    const e = super._removeChange.apply(this, arguments);
    return this._refreshSummary(), e;
  }
  cancelEditData() {
    const e = super.cancelEditData.apply(this, arguments);
    return this._refreshSummary(), e;
  }
}, UJ = (i) => class extends i {
  _createRow(e) {
    const t = super._createRow.apply(this, arguments);
    return e && t.addClass(e.rowType === "groupFooter" ? "dx-datagrid-group-footer" : ""), t;
  }
  _renderCells(e, t) {
    super._renderCells.apply(this, arguments), t.row.rowType === "group" && t.row.summaryCells && t.row.summaryCells.length && this._renderGroupSummaryCells(e, t);
  }
  _hasAlignByColumnSummaryItems(e, t) {
    return !f(t.columns[e].groupIndex) && t.row.summaryCells[e].length;
  }
  _getAlignByColumnCellCount(e, t) {
    let n = 0;
    for (let s = 1; s < e; s++) {
      const o = t.row.summaryCells.length - s;
      n = this._hasAlignByColumnSummaryItems(o, t) ? s : n;
    }
    return n;
  }
  _renderGroupSummaryCells(e, t) {
    const n = e.children().last(), s = Number(n.attr("colSpan")) || 1, o = this._getAlignByColumnCellCount(s, t);
    this._renderGroupSummaryCellsCore(n, t, s, o);
  }
  _renderGroupSummaryCellsCore(e, t, n, s) {
    if (s > 0) {
      e.attr("colSpan", n - s);
      for (let o = 0; o < s; o++) {
        const r = t.columns.length - s + o;
        this._renderCell(e.parent(), x({
          column: t.columns[r],
          columnIndex: this._getSummaryCellIndex(r, t.columns)
        }, t));
      }
    }
  }
  _getSummaryCellIndex(e, t) {
    return e;
  }
  _getCellTemplate(e) {
    return !e.column.command && !f(e.column.groupIndex) && e.summaryItems && e.summaryItems.length ? mF : super._getCellTemplate(e);
  }
  _getCellOptions(e) {
    const t = this, n = super._getCellOptions(e);
    return e.row.summaryCells ? x(n, fF(t, e)) : n;
  }
};
J.registerModule("summary", {
  defaultOptions: () => ({
    summary: {
      groupItems: void 0,
      totalItems: void 0,
      calculateCustomSummary: void 0,
      skipEmptyValues: !0,
      recalculateWhileEditing: !1,
      texts: {
        sum: S.format("dxDataGrid-summarySum"),
        sumOtherColumn: S.format("dxDataGrid-summarySumOtherColumn"),
        min: S.format("dxDataGrid-summaryMin"),
        minOtherColumn: S.format("dxDataGrid-summaryMinOtherColumn"),
        max: S.format("dxDataGrid-summaryMax"),
        maxOtherColumn: S.format("dxDataGrid-summaryMaxOtherColumn"),
        avg: S.format("dxDataGrid-summaryAvg"),
        avgOtherColumn: S.format("dxDataGrid-summaryAvgOtherColumn"),
        count: S.format("dxDataGrid-summaryCount")
      }
    },
    sortByGroupSummaryInfo: void 0
  }),
  views: {
    footerView: WJ
  },
  extenders: {
    controllers: {
      data: KJ,
      editing: GJ
    },
    views: {
      rowsView: UJ
    }
  }
});
const jJ = {
  detailRow: "dx-master-detail-row"
}, qJ = (i, e) => {
  i.addClass(e(Je.stickyColumnBorderLeft));
}, YJ = (i, e) => {
  i.addClass(e(Je.stickyColumnBorderRight));
}, XJ = (i, e, t) => {
  switch (e) {
    case je.Right:
      i.addClass(t(Je.stickyColumnRight));
      break;
    case je.Sticky:
      i.addClass(t(Je.stickyColumn));
      break;
    default:
      i.addClass(t(Je.stickyColumnLeft));
  }
}, ZJ = (i, e, t) => {
  i.toggleClass(t(Je.firstHeader), e);
}, QJ = (i, e, t) => {
  i.toggleClass(t(Je.columnNoBorder), e);
}, JJ = (i, e, t) => {
  i.toggleClass(t(Je.stickyColumns), e);
}, Dh = (i, e, t) => {
  if (!i.hasClass(t(Je.stickyColumn)))
    return !1;
  const s = parseFloat(i[0].style.left), o = Ge(i[0]), r = Ge(e[0]), a = o.left - r.left;
  return Math.round(s) >= Math.round(a);
}, bd = (i, e, t) => {
  if (!i.hasClass(t(Je.stickyColumn)))
    return !1;
  const s = parseFloat(i[0].style.right), o = Ge(i[0]), a = Ge(e[0]).right - o.right;
  return Math.round(s) >= Math.round(a);
}, eee = (i, e, t) => Dh(i, e, t) || bd(i, e, t), tee = (i, e, t) => i.hasClass(t(Je.stickyColumnRight)) || bd(i, e, t), yF = (i, e) => i.hasClass(e(Je.stickyColumnLeft)) && i.hasClass(e(Je.stickyColumnBorderRight)), bF = (i, e) => i.hasClass(e(Je.stickyColumnRight)) && i.hasClass(e(Je.stickyColumnBorderLeft)), nee = (i, e) => i.hasClass(e(Je.stickyColumn)), wF = (i, e) => i.hasClass(e(Je.stickyColumnLeft)) || i.hasClass(e(Je.stickyColumnRight)) || i.hasClass(e(Je.stickyColumn)), iee = (i, e) => i.filter((t, n) => p(n).hasClass(e(Je.stickyColumnLeft))), see = (i, e) => i.filter((t, n) => p(n).hasClass(e(Je.stickyColumnRight))), oee = (i, e) => i.filter((t, n) => p(n).hasClass(e(Je.stickyColumn)) || !wF(p(n), e)), ree = (i, e, t) => {
  const o = (e.css("direction") === "rtl" ? i.toArray() : i.toArray().reverse()).find((r) => Dh(p(r), e, t) || yF(p(r), t));
  return p(o ?? "");
}, aee = (i, e, t) => {
  const o = (e.css("direction") === "rtl" ? i.toArray().reverse() : i.toArray()).find((r) => bd(p(r), e, t) || bF(p(r), t));
  return p(o ?? "");
}, Th = (i, e, t) => {
  const n = Ge(e.get(0)), s = {
    left: n.left,
    right: n.right
  };
  if (i != null && i.length) {
    const o = ree(i, e, t), r = aee(i, e, t);
    o != null && o.length && (s.left = Math.round(Ge(o[0]).right)), r != null && r.length && (s.right = Math.round(Ge(r[0]).left));
  }
  return s;
}, lee = (i, e, t) => {
  let {
    point: n,
    column: s,
    nextColumn: o
  } = e;
  const {
    item: r,
    isLeftBoundary: a,
    isRightBoundary: l
  } = n, d = p(r), u = Math.round(n.x), c = i.option("rtlEnabled"), h = f(a) || f(l), g = p(i.getColumnElements() ?? ""), m = p(i.getContent()), C = s?.fixed && o?.fixed, v = Th(g, m, t);
  if (C || uO(n, s, o))
    return !1;
  if (h) {
    if (yF(d, t) || Dh(d, m, t))
      return a;
    if (bF(d, t) || bd(d, m, t))
      return l;
  }
  const E = u < v.left || u > v.right, T = u === v.left || u === v.right, V = c ? n.index === 0 : n.index === g.length;
  return E || !V && T;
}, dee = (i, e, t, n) => {
  const {
    item: s,
    isLeftBoundary: o,
    isRightBoundary: r
  } = i, a = p(s), l = Math.round(i.x), d = f(o) || f(r), u = Th(e, t, n);
  return Dh(a, t, n) ? d && !o : bd(a, t, n) ? d && !r : l < u.left || l > u.right;
}, uee = (i) => {
  const t = i.parent().children().filter((s) => s < i.index());
  return i.attr("colspan") - t.length === 1;
}, cee = (i, e, t) => {
  const n = Ge(e.get(0)), s = Th(i, e, t);
  return {
    left: s.left - n.left,
    right: n.right - s.right
  };
}, hee = (i, e, t, n) => {
  const s = Ge(i.get(0)), o = Math.round(s.left), r = Math.round(s.right), a = Th(e, t, n);
  return o < a.left || r > a.right;
}, pee = (i) => {
  if (!i.is("td"))
    return !1;
  const e = i.parent().children().last();
  return i[0] === e[0];
}, gee = (i) => !i.is("[tabindex]"), mee = function(i) {
  let e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "next", t = i, n = i.parent();
  do
    t = e === "next" ? t.next() : t.prev(), t.length || (n = e === "next" ? n.next() : n.prev(), n.length && (t = e === "next" ? n.children().first() : n.children().last()));
  while (t.length && gee(t));
  return t;
}, nt = {
  toggleFirstHeaderClass: ZJ,
  toggleColumnNoBorderClass: QJ,
  addStickyColumnClass: XJ,
  addStickyColumnBorderLeftClass: qJ,
  addStickyColumnBorderRightClass: YJ,
  doesGroupCellEndInFirstColumn: uee,
  toggleStickyColumnsClass: JJ,
  getLeftFixedCells: iee,
  getRightFixedCells: see,
  getNonFixedAndStickyCells: oee,
  getScrollPadding: cee,
  getNextHeaderCell: mee,
  noNeedToCreateResizingPoint: lee,
  isFixedCellPinnedToRight: tee,
  noNeedToCreateReorderingPoint: dee,
  isFixedCell: wF,
  isStickyCell: nee,
  isStickyCellPinned: eee,
  isOutsideVisibleArea: hee,
  isLastCell: pee
}, RC = (i) => class extends i {
  _addStickyColumnBorderLeftClass(e, t, n) {
    let s = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : !1, o = arguments.length > 4 ? arguments[4] : void 0;
    Uj(this._columnsController, t, n, s, o) && nt.addStickyColumnBorderLeftClass(e, this.addWidgetPrefix.bind(this));
  }
  _addStickyColumnBorderRightClass(e, t, n) {
    let s = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : !1, o = arguments.length > 4 ? arguments[4] : void 0;
    jj(this._columnsController, t, n, s, o) && nt.addStickyColumnBorderRightClass(e, this.addWidgetPrefix.bind(this));
  }
  updateBorderCellClasses(e, t, n) {
    const s = this._columnsController, o = this.name === "rowsView", r = Gj(s, t, n, o), a = s?.isFirstColumn(t, n);
    nt.toggleColumnNoBorderClass(e, r, this.addWidgetPrefix.bind(this)), nt.toggleFirstHeaderClass(e, a, this.addWidgetPrefix.bind(this));
  }
  _updateBorderClasses() {
    const e = this.name === "columnHeadersView";
    this._getRowElementsCore().not(`.${jJ.detailRow}`).toArray().forEach((n, s) => {
      const o = e ? s : null, r = p(n).children("td").toArray();
      let a = this.getColumns(o);
      a = sb(this._columnsController, a), r.forEach((l, d) => {
        const u = p(l), c = a[d];
        c.visibleWidth !== K_ && this.updateBorderCellClasses(u, c, o);
      });
    });
  }
  _renderCore(e) {
    const t = super._renderCore(e), n = this.element(), s = this.hasStickyColumns();
    return nt.toggleStickyColumnsClass(n, s, this.addWidgetPrefix.bind(this)), s ? t.done(() => {
      this.setStickyOffsets();
    }) : t;
  }
  _createCell(e) {
    const {
      column: t
    } = e, {
      rowType: n
    } = e, s = super._createCell(e), o = this.hasStickyColumns(), r = n === "header" ? e.rowIndex : null, a = n === "groupFooter" || n === "totalFooter" || n === "group", l = t.command && t.command === "expand";
    if (o && !G_(this._columnsController, t) && (this.updateBorderCellClasses(s, t, r), t.fixed)) {
      const d = ra(this._columnsController, t);
      if (nt.addStickyColumnClass(s, d, this.addWidgetPrefix.bind(this)), !a && !l)
        switch (d) {
          case je.Right:
            this._addStickyColumnBorderLeftClass(s, t, r, !1, je.Right);
            break;
          case je.Sticky:
            this._addStickyColumnBorderLeftClass(s, t, r, !0), this._addStickyColumnBorderRightClass(s, t, r, !0);
            break;
          default:
            this._addStickyColumnBorderRightClass(s, t, r, !1, je.Left);
        }
    }
    return s;
  }
  setStickyOffsets(e, t) {
    const n = this._columnsController, s = this.option("rtlEnabled"), o = this.option("showColumnHeaders");
    let r = this.getColumnWidths(void 0, e), a = this.getColumns(o ? e : void 0);
    a = sb(this._columnsController, a), s && (a = s ? [...a].reverse() : a, r = s ? [...r].reverse() : r), a.forEach((l, d) => {
      if (l.fixed) {
        const u = s ? a.length - d - 1 : d, c = lO(n, a, r, d, t);
        t && (t[l.index] = c);
        const h = dO(c);
        this.setCellProperties(h, u, e);
      }
    });
  }
  setColumnWidths(e) {
    const t = this.hasStickyColumns(), n = this.getController("columnsResizer"), s = n?.isResizing();
    super.setColumnWidths(e), t && s && this.setStickyOffsets();
  }
  _resizeCore() {
    const e = this.hasStickyColumns(), t = this.getController("adaptiveColumns"), n = t?.getHidingColumnsQueue();
    super._resizeCore.apply(this, arguments), e && (this.setStickyOffsets(), n != null && n.length && this._updateBorderClasses());
  }
  hasStickyColumns() {
    var e;
    const t = (e = this._columnsController) === null || e === void 0 ? void 0 : e.getStickyColumns();
    return this.option("columnFixing.legacyMode") !== !0 && !!t.length;
  }
}, fee = (i) => class extends RC(i) {
  setStickyOffsets() {
    const e = {}, t = this._getRows();
    for (let s = 0; s < t.length; s++) {
      var n;
      const o = (t == null || (n = t[s]) === null || n === void 0 ? void 0 : n.rowType) === "filter";
      super.setStickyOffsets(s, o ? void 0 : e);
    }
  }
  getContextMenuItems(e) {
    const {
      column: t
    } = e, n = this._columnsController, s = this.option("columnFixing");
    let o = super.getContextMenuItems(e);
    if (e.row && e.row.rowType === "header" && s.enabled === !0 && t && t.allowFixing) {
      const r = (l) => {
        switch (l.itemData.value) {
          case "none":
            this._columnsController.columnOption(t.index, "fixed", !1);
            break;
          case "left":
            this._columnsController.columnOption(t.index, {
              fixed: !0,
              fixedPosition: "left"
            });
            break;
          case "right":
            this._columnsController.columnOption(t.index, {
              fixed: !0,
              fixedPosition: "right"
            });
            break;
          case "sticky":
            this._columnsController.columnOption(t.index, {
              fixed: !0,
              fixedPosition: "sticky"
            });
        }
      }, a = [{
        text: s.texts.leftPosition,
        icon: s.icons.leftPosition,
        value: "left",
        disabled: t.fixed && (!t.fixedPosition || t.fixedPosition === "left"),
        onItemClick: r
      }, {
        text: s.texts.rightPosition,
        icon: s.icons.rightPosition,
        value: "right",
        disabled: t.fixed && t.fixedPosition === "right",
        onItemClick: r
      }];
      this.option("columnFixing.legacyMode") !== !0 && !n.isVirtualMode() && a.push({
        text: s.texts.stickyPosition,
        icon: s.icons.stickyPosition,
        value: "sticky",
        disabled: t.fixed && t.fixedPosition === je.Sticky,
        onItemClick: r
      }), o = o || [], o.push({
        text: s.texts.fix,
        icon: s.icons.fix,
        beginGroup: !0,
        items: a
      }, {
        text: s.texts.unfix,
        icon: s.icons.unfix,
        value: "none",
        disabled: !t.fixed,
        onItemClick: r
      });
    }
    return o;
  }
}, _ee = (i) => class extends RC(i) {
  _getMasterDetailWidth() {
    const e = ne(this.component.$element()) ?? 0, t = F.getComponentBorderWidth(this, this._$element);
    return e - t - this.getScrollbarWidth();
  }
  _renderMasterDetailCell(e, t, n) {
    const s = super._renderMasterDetailCell(e, t, n);
    return this.hasStickyColumns() && (s.addClass(this.addWidgetPrefix(Je.stickyColumnLeft)), xl(s, this._getMasterDetailWidth())), s;
  }
  _updateMasterDetailWidths() {
    const e = this._getMasterDetailWidth(), t = this._getRowElements().children(".dx-master-detail-cell");
    xl(t, `${e}px`);
  }
  setStickyOffsets(e, t) {
    super.setStickyOffsets(e, t), this.setStickyOffsetsForGroupCells();
  }
  setStickyOffsetsForGroupCells() {
    const e = this._columnsController.getGroupColumns();
    let t = this.getColumns(), n = this.getColumnWidths();
    const s = this._getColumnsCountBeforeGroups(t), o = this.option("rtlEnabled");
    o && (t = o ? [...t].reverse() : t, n = o ? [...n].reverse() : n);
    const r = this.getTableElement();
    e.forEach((a) => {
      const l = s + a.groupIndex + 1, d = o ? t.length - l - 1 : l, u = lO(this._columnsController, t, n, d), c = dO(u), h = r.children().children(".dx-group-row").find(`.dx-group-cell[aria-colindex='${l + 1}']`);
      for (let g = 0; g < h.length; g += 1) {
        const m = h.get(g), C = p(m).find(".dx-datagrid-group-row-container").get(0);
        Object.assign(m.style, c), Object.assign(C.style, c);
      }
    });
  }
  _resizeCore() {
    const e = this.hasStickyColumns();
    super._resizeCore.apply(this, arguments), e && this._updateMasterDetailWidths();
  }
  _renderCellContent(e, t, n) {
    if (!Mm(t) || !this.hasStickyColumns())
      return super._renderCellContent(e, t, n);
    const s = p("<div>").addClass(this.addWidgetPrefix(Je.groupRowContainer)).appendTo(e);
    return super._renderCellContent(s, t, n);
  }
  _renderGroupSummaryCellsCore(e, t, n, s) {
    super._renderGroupSummaryCellsCore(e, t, n, s);
    const o = `.${this.addWidgetPrefix(Je.stickyColumn)}`;
    e.parent().find(o).length && nt.doesGroupCellEndInFirstColumn(e) && nt.addStickyColumnBorderRightClass(e, this.addWidgetPrefix.bind(this));
  }
  _handleScroll(e) {
    const t = this.hasStickyColumns();
    if (super._handleScroll(e), t) {
      const n = this.getController("editorFactory");
      if (n.hasOverlayElements()) {
        const o = n.focus();
        n.focus(o);
      }
    }
  }
  _scrollToElement(e, t) {
    let n = t;
    const s = this.getScrollable();
    if (this.hasStickyColumns() && s) {
      const r = nt.isFixedCell(e, this.addWidgetPrefix.bind(this));
      if (!e.is("td") || r)
        return;
      const a = e?.closest("tr"), l = a?.children();
      n = nt.getScrollPadding(l, p(s.container()), this.addWidgetPrefix.bind(this));
    }
    super._scrollToElement(e, n);
  }
}, Cee = (i) => class extends RC(i) {
}, vee = (i) => class extends i {
  getSeparatorOffsetX(e) {
    var t;
    if ((t = this._columnHeadersView) === null || t === void 0 ? void 0 : t.hasStickyColumns()) {
      const o = p(this._columnHeadersView.getContent()), r = nt.isFixedCellPinnedToRight(e, o, this.addWidgetPrefix.bind(this));
      if (this.option("columnResizingMode") === "widget" && r) {
        var s;
        return ((s = e.offset()) === null || s === void 0 ? void 0 : s.left) ?? 0;
      }
    }
    return super.getSeparatorOffsetX(e);
  }
  _correctColumnIndexForPoint(e, t, n) {
    const s = this.option("rtlEnabled"), o = this.option("columnResizingMode") === "widget", r = Math.max(e.index - 1, 0), a = n[r], l = this._getNextColumnIndex(r), d = n[l];
    if (o && !uO(e, a, d)) {
      const u = p(this._columnHeadersView.getContent());
      if (nt.isFixedCellPinnedToRight(p(e.item), u, this.addWidgetPrefix.bind(this))) {
        e.columnIndex -= s ? 1 : 0;
        return;
      }
    }
    super._correctColumnIndexForPoint(e, t, n);
  }
  _needToInvertResizing(e) {
    const t = super._needToInvertResizing(e), n = this.option("columnResizingMode") === "widget";
    if (!t && n) {
      const s = p(this._columnHeadersView.getContent());
      return nt.isFixedCellPinnedToRight(e, s, this.addWidgetPrefix.bind(this));
    }
    return t;
  }
  _generatePointsByColumns() {
    var e;
    const t = (e = this._columnHeadersView) === null || e === void 0 ? void 0 : e.hasStickyColumns();
    super._generatePointsByColumns(t);
  }
  _pointCreated(e, t, n) {
    var s;
    const o = (s = this._columnHeadersView) === null || s === void 0 ? void 0 : s.hasStickyColumns(), r = super._pointCreated(e, t, n);
    if (o && t > 0 && !r) {
      const l = n[e.index - 1], d = this._getNextColumnIndex(e.index - 1), u = n[d];
      return nt.noNeedToCreateResizingPoint(this._columnHeadersView, {
        point: e,
        column: l,
        nextColumn: u
      }, this.addWidgetPrefix.bind(this));
    }
    return r;
  }
}, xee = (i) => class extends i {
  _generatePointsByColumns(e) {
    var t;
    const n = (t = this._columnHeadersView) === null || t === void 0 ? void 0 : t.hasStickyColumns(), {
      sourceLocation: s,
      sourceColumn: o,
      targetDraggingPanel: r
    } = e, a = s === "headers" && r?.getName() === "headers";
    if (n && a) {
      const l = ra(this._columnsController, o);
      switch (!0) {
        case (o.fixed && l === je.Left):
          e.columnElements = nt.getLeftFixedCells(e.columnElements, this.addWidgetPrefix.bind(this)), e.startColumnIndex = e.columnElements.eq(0).index();
          break;
        case (o.fixed && l === je.Right):
          e.columnElements = nt.getRightFixedCells(e.columnElements, this.addWidgetPrefix.bind(this)), e.startColumnIndex = e.columnElements.eq(0).index();
          break;
        default:
          e.columnElements = nt.getNonFixedAndStickyCells(e.columnElements, this.addWidgetPrefix.bind(this)), e.startColumnIndex = e.columnElements.eq(0).index();
      }
    }
    return super._generatePointsByColumns(e, n);
  }
  _pointCreated(e, t, n, s) {
    const o = this._columnHeadersView.hasStickyColumns(), r = this._columnHeadersView.getColumnElements(), a = o && n === "headers" && r?.length && (!s.fixed || s.fixedPosition === je.Sticky), l = super._pointCreated(e, t, n, s);
    return a && !l ? nt.noNeedToCreateReorderingPoint(e, r, p(this._columnHeadersView.getContent()), this.addWidgetPrefix.bind(this)) : l;
  }
}, yee = (i) => class extends i {
  getOverlayContainerIfNeeded(e) {
    const t = this._rowsView.hasStickyColumns(), n = nt.isFixedCell(e, this.addWidgetPrefix.bind(this));
    if (t && n)
      return e.closest(`.${this.addWidgetPrefix(Je.stickyColumns)}`);
  }
  updateFocusOverlaySize(e, t) {
    this._rowsView.hasStickyColumns() || super.updateFocusOverlaySize(e, t);
  }
  getFocusOverlaySize(e) {
    if (this._rowsView.hasStickyColumns()) {
      const n = Ge(e.get(0)), s = nt.isLastCell(e), o = nt.isFixedCell(e, this.addWidgetPrefix.bind(this));
      return {
        width: n.right - n.left + (s || o ? 0 : 1),
        height: n.bottom - n.top
      };
    }
    return super.getFocusOverlaySize(e);
  }
  getValidationMessageContainer(e) {
    return this.getOverlayContainerIfNeeded(e) ?? super.getValidationMessageContainer(e);
  }
  getRevertButtonContainer(e) {
    return this.getOverlayContainerIfNeeded(e) ?? super.getRevertButtonContainer(e);
  }
  getFocusOverlayContainer(e) {
    return this.getOverlayContainerIfNeeded(e) ?? super.getFocusOverlayContainer(e);
  }
  overlayPositionedHandler(e, t) {
    const n = this.getView("columnHeadersView"), s = n.hasStickyColumns();
    if (super.overlayPositionedHandler(e, t), s) {
      const o = p(e.element).closest("td");
      if (!nt.isFixedCell(o, this.addWidgetPrefix.bind(this))) {
        const r = e.component.$wrapper(), a = e.component.$content(), l = nt.isOutsideVisibleArea(a, p(n.getColumnElements()), p(n.getContent()), this.addWidgetPrefix.bind(this));
        r.css("zIndex", l ? 1 : (this === null || this === void 0 ? void 0 : this.getOverlayBaseZIndex()) ?? 0);
      }
    }
  }
  updateFocusOverlay(e) {
    let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !1;
    if (!t) {
      const n = nt.isFixedCell(e, this.addWidgetPrefix.bind(this));
      this._$focusOverlay.toggleClass(Je.focusedFixedElement, n);
      const s = Hr(e), o = gF(e), r = IJ(e);
      (n || s || o || r) && this._$focusOverlay.toggleClass(Je.focusedFixedElement, !0);
    }
    super.updateFocusOverlay(e, t);
  }
}, bee = (i) => class extends i {
  resize() {
    const e = super.resize();
    return this._columnHeadersView.hasStickyColumns() && this !== null && this !== void 0 && this.hasResizeTimeout() && this._rowsView.setStickyOffsets(), e;
  }
}, wee = (i) => class extends i {
  headerTabKeyHandler(e) {
    var t, n;
    let {
      originalEvent: s,
      shift: o
    } = e;
    const r = (t = this._columnHeadersView) === null || t === void 0 ? void 0 : t.hasStickyColumns(), a = (n = this._rowsView) === null || n === void 0 ? void 0 : n.getScrollable();
    if (r && a) {
      const l = p(s.target).closest("td"), d = nt.getNextHeaderCell(l, o ? "previous" : "next"), u = nt.isFixedCell(d, this.addWidgetPrefix.bind(this));
      if (d.length && !u) {
        const c = p(this._columnHeadersView.getColumnElements());
        if (nt.isOutsideVisibleArea(d, c, p(this._columnHeadersView.getContent()), this.addWidgetPrefix.bind(this))) {
          const g = nt.getScrollPadding(c, p(a.container()), this.addWidgetPrefix.bind(this)), m = OO(d[0], "horizontal", p(this._columnHeadersView.getContent())[0], a.scrollOffset(), g, this.addWidgetPrefix("table"));
          a.scrollTo({
            x: m
          });
        }
      }
    }
  }
}, See = {
  extenders: {
    views: {
      columnHeadersView: fee,
      rowsView: _ee,
      footerView: Cee
    },
    controllers: {
      columnsResizer: vee,
      draggingHeader: xee,
      editorFactory: yee,
      resizing: bee,
      keyboardNavigation: wee
    }
  }
};
J.registerModule("stickyColumns", See);
const Eee = "dx-master-detail-row", es = function(i) {
  let e = -1;
  return y(i, (t, n) => {
    if (n.command === "transparent")
      return e = t, !1;
  }), e;
}, SF = function(i, e, t) {
  let n = 0;
  if (i && e && t)
    for (let s = 0; s < i.length; s++)
      i[s].command === "transparent" ? n += i[s].colspan : (e[n] < t[s] && (e[n] = t[s]), n++);
  return e;
}, FC = (i) => class extends i {
  init() {
    super.init(), this._isFixedTableRendering = !1, this._isFixedColumns = !1;
  }
  _createCol(e) {
    return super._createCol(e).toggleClass("dx-col-fixed", !!(this._isFixedTableRendering && (e.fixed || e.command && e.command !== "transparent")));
  }
  isIndicesArray(e) {
    return Array.isArray(e) && e.length > 0;
  }
  _correctColumnIndicesForFixedColumns(e, t) {
    var n;
    const s = t?.columnIndices;
    if (!this.isIndicesArray(s))
      return;
    const o = es(e), r = e[o].colspan, a = o + r, l = t == null || (n = t.items) === null || n === void 0 ? void 0 : n.map((d) => {
      let {
        rowType: u
      } = d;
      return u;
    });
    t.columnIndices = s.map((d, u) => this.isIndicesArray(d) ? l && l[u] === "group" ? [...d] : d.reduce((h, g) => {
      switch (!0) {
        case g < o:
          h.push(g);
          break;
        case g >= a:
          h.push(g - r + 1);
      }
      return h;
    }, []) : d);
  }
  _partialUpdateFixedTable(e, t) {
    const n = this._fixedTableElement, s = this._getRowElementsCore(n);
    n.children("colgroup").replaceWith(this._createColGroup(e));
    for (let r = 0; r < t.length; r++)
      this._partialUpdateFixedRow(p(s[r]), e, t[r]);
  }
  _partialUpdateFixedRow(e, t, n) {
    const s = e.get(0).childNodes, o = es(t), r = t[o], a = this._columnsController.getColumnIndexOffset();
    let l, d = a + 1, {
      colspan: u
    } = r;
    if (e.hasClass(Eee)) {
      var c;
      s[0].setAttribute("colspan", (c = this._columnsController.getVisibleColumns()) === null || c === void 0 ? void 0 : c.length);
      return;
    }
    if (e.hasClass("dx-group-row"))
      if (l = this._getGroupCellOptions({
        row: n,
        columns: this._columnsController.getVisibleColumns()
      }), n.summaryCells.length > 0) {
        const g = this._getAlignByColumnCellCount(l.colspan, {
          columns: this._columnsController.getVisibleColumns(),
          row: n,
          isFixed: !0
        });
        u = l.colspan - g;
      } else
        u = l.colspan - Math.max(0, s.length - (l.columnIndex + 2));
    for (let h = 0; h < s.length; h++) {
      const g = l ? h === l.columnIndex + 1 : h === o;
      s[h].setAttribute("aria-colindex", d), g ? (s[h].setAttribute("colspan", u), d += u) : d++;
    }
  }
  _renderTable(e) {
    let t;
    const n = this.getFixedColumns();
    this._isFixedColumns = this.isFixedColumns();
    const s = super._renderTable(e);
    if (this._isFixedColumns) {
      var o;
      const a = e?.change, l = this._getRowElements(this._fixedTableElement), d = a?.virtualColumnsScrolling && l.length === (a == null || (o = a.items) === null || o === void 0 ? void 0 : o.length);
      if (this._isFixedTableRendering = !0, d && this.option("scrolling.legacyMode") !== !0) {
        var r;
        this._partialUpdateFixedTable(n, e == null || (r = e.change) === null || r === void 0 ? void 0 : r.items), this._isFixedTableRendering = !1;
      } else {
        const u = a?.columnIndices;
        this._correctColumnIndicesForFixedColumns(n, a), t = this._createTable(n), this._renderRows(t, x({}, e, {
          columns: n
        })), this._updateContent(t, a, !0), u && (a.columnIndices = u), this._isFixedTableRendering = !1;
      }
    } else
      this._fixedTableElement && this._fixedTableElement.parent().remove(), this._fixedTableElement = null;
    return s;
  }
  _renderRow(e, t) {
    let n, {
      cells: s
    } = t.row;
    if (super._renderRow.apply(this, arguments), this._isFixedTableRendering && s && s.length) {
      n = 0;
      const o = t.row.cells || [];
      s = s.slice(), t.row.cells = s;
      for (let r = 0; r < o.length; r++) {
        if (o[r].column && o[r].column.command === "transparent") {
          n = (o[r].column.colspan || 1) - 1;
          continue;
        }
        s[r + n] = o[r];
      }
    }
  }
  _createCell(e) {
    const t = this, {
      column: n
    } = e, s = n && n.command, {
      rowType: o
    } = e, r = super._createCell.apply(t, arguments);
    let a, l, d;
    (t._isFixedTableRendering || o === "filter") && (a = t.getFixedColumns(), d = es(a), l = a[d - 1]), t._isFixedTableRendering ? s === "transparent" && (r.addClass("dx-pointer-events-none").toggleClass("dx-first-cell", d === 0 || l && l.command === "expand").toggleClass("dx-last-cell", a.length && d === a.length - 1), o !== "freeSpace" && F.setEmptyText(r)) : o === "filter" && r.toggleClass("dx-first-cell", e.columnIndex === d);
    const u = t.option("rowAlternationEnabled") && e.isAltRow, c = t.option("selection.mode") === "multiple" && e.columnIndex === 0 && e.rowType === "header";
    return ze.mozilla && e.column.fixed && e.rowType !== "group" && !u && !c && r.addClass("dx-col-fixed"), r;
  }
  _wrapTableInScrollContainer(e, t) {
    const n = super._wrapTableInScrollContainer.apply(this, arguments);
    return (this._isFixedTableRendering || t) && n.addClass(this.addWidgetPrefix("content-fixed")), n;
  }
  _renderCellContent(e, t) {
    let n;
    const {
      column: s
    } = t, o = this._isFixedTableRendering, r = t.rowType === "group" && f(s.groupIndex);
    if (o && r && !s.command && !s.groupCellTemplate && e.css("pointerEvents", "none"), !o && this._isFixedColumns) {
      if (n = s.fixed || s.command && s.fixed !== !1, r && (n = !1, t.row.summaryCells && t.row.summaryCells.length)) {
        var a;
        const l = this._columnsController.getVisibleColumns(), d = ((a = this._getAlignByColumnCellCount) === null || a === void 0 ? void 0 : a.call(this, s.colspan, {
          columns: l,
          row: t.row,
          isFixed: !0
        })) ?? 0;
        if (d > 0) {
          const u = es(this._columnsController.getFixedColumns());
          n = l.length - d < u;
        }
      }
      if (n) {
        if (s.command && s.type !== "buttons" || t.rowType === "group") {
          e.html("&nbsp;").addClass(s.cssClass);
          return;
        }
        e.addClass("dx-hidden-cell");
      }
    }
    s.command !== "transparent" && super._renderCellContent.apply(this, arguments);
  }
  getContent(e) {
    var t;
    return e ? (t = this._fixedTableElement) === null || t === void 0 ? void 0 : t.parent() : super.getContent.apply(this, arguments);
  }
  _getCellElementsCore(e) {
    const t = super._getCellElementsCore.apply(this, arguments), n = t?.parent().hasClass("dx-group-row"), s = this.name === "columnHeadersView" ? e : void 0;
    if (this._fixedTableElement && t) {
      const o = this.getFixedColumns(s), r = this._getRowElements(this._fixedTableElement).eq(e).children("td");
      y(r, (a, l) => {
        if (n)
          t[a] && l.style.visibility !== "hidden" && (t[a] = l);
        else {
          const d = o[a];
          if (d)
            if (d.command === "transparent")
              r.eq(a).hasClass("dx-master-detail-cell") && (t[a] = l || t[a]);
            else {
              const u = this._columnsController.getVisibleIndexByColumn(d, s);
              t[u] = l || t[u];
            }
        }
      });
    }
    return t;
  }
  getColumnWidths(e, t) {
    const n = super.getColumnWidths(e, t), s = this.getFixedColumns(), o = this._fixedTableElement && n.length ? super.getColumnWidths(this._fixedTableElement) : void 0;
    return SF(s, n, o);
  }
  getTableElement(e) {
    return e = this._isFixedTableRendering || e, e ? this._fixedTableElement : super.getTableElement();
  }
  setTableElement(e, t) {
    this._isFixedTableRendering || t ? this._fixedTableElement = e.addClass("dx-pointer-events-none") : super.setTableElement(e);
  }
  getColumns(e) {
    const t = this.getTableElement();
    return this._isFixedTableRendering ? this.getFixedColumns(e) : super.getColumns(e, t);
  }
  getRowIndex(e) {
    const t = this._fixedTableElement;
    return t && t.find(e).length ? this._getRowElements(t).index(e) : super.getRowIndex(e);
  }
  getTableElements() {
    let e = super.getTableElements.apply(this, arguments);
    return this._fixedTableElement && (e = p([e.get(0), this._fixedTableElement.get(0)])), e;
  }
  getFixedColumns(e) {
    return this._columnsController.getFixedColumns(e);
  }
  getFixedColumnsOffset() {
    let e = {
      left: 0,
      right: 0
    }, t;
    if (this._fixedTableElement) {
      t = this.getTransparentColumnElement();
      const n = t.position();
      e = {
        left: n.left,
        right: Ee(this.element(), !0) - (Ee(t, !0) + n.left)
      };
    }
    return e;
  }
  getTransparentColumnElement() {
    return this._fixedTableElement && this._fixedTableElement.find(".dx-pointer-events-none").first();
  }
  getFixedTableElement() {
    return this._fixedTableElement;
  }
  _resizeCore() {
    super._resizeCore(), this.synchronizeRows();
  }
  setColumnWidths(e) {
    var t;
    const {
      widths: n
    } = e, s = this._columnsController.getVisibleColumns(), o = n?.length && s.some((d) => f(d.visibleWidth)), r = (t = e.optionNames) === null || t === void 0 ? void 0 : t.width;
    if (super.setColumnWidths(e), this._fixedTableElement) {
      const c = n?.some((h) => h === "auto" || !f(h)) && (!o || !this.isScrollbarVisible(!0)) ? s : this.getFixedColumns();
      this.setFixedTableColumnWidths(c, n);
    }
    const a = this.option("wordWrapEnabled");
    (o || r && a) && this.synchronizeRows();
  }
  setFixedTableColumnWidths(e, t) {
    if (!this._fixedTableElement || !t)
      return;
    const n = this._fixedTableElement.children("colgroup").children("col");
    n.toArray().forEach((o) => o.removeAttribute("style"));
    let s = 0;
    e.forEach((o) => {
      if (o.colspan) {
        s += o.colspan;
        return;
      }
      const r = iO(t[s]);
      f(r) && qg(n.eq(s), r), s += 1;
    });
  }
  _getClientHeight(e) {
    const t = e.getBoundingClientRect && Ge(e);
    return t && t.height ? t.height : e.clientHeight;
  }
  synchronizeRows() {
    const e = [], t = [];
    let n, s, o, r;
    this.waitAsyncTemplates(!0).done(() => {
      if (this._isFixedColumns && this._tableElement && this._fixedTableElement) {
        const a = this._getClientHeight(this._tableElement.get(0)), l = this._getClientHeight(this._fixedTableElement.get(0));
        if (s = this._getRowElements(this._tableElement), o = this._getRowElements(this._fixedTableElement), r = this._findContentElement(), a !== l) {
          for (r && r.css("height", a), s.css("height", ""), o.css("height", ""), n = 0; n < s.length; n++)
            e.push(this._getClientHeight(s.get(n))), t.push(this._getClientHeight(o.get(n)));
          for (n = 0; n < s.length; n++) {
            const d = e[n], u = t[n];
            d > u ? o.eq(n).css("height", d) : d < u && s.eq(n).css("height", u);
          }
          r && r.css("height", "");
        }
      }
    });
  }
  setScrollerSpacing(e, t) {
    const n = this.option("rtlEnabled");
    super.setScrollerSpacing(e), this.element().children(`.${this.addWidgetPrefix("content-fixed")}`).css({
      paddingLeft: n ? e : "",
      paddingRight: n ? "" : e
    });
  }
  isFixedColumns() {
    const e = this.getFixedColumns();
    return this.option("columnFixing.legacyMode") === !0 && !!e.length;
  }
}, Iee = (i) => class extends FC(i) {
  _getRowVisibleColumns(e) {
    return this._isFixedTableRendering ? this.getFixedColumns(e) : super._getRowVisibleColumns(e);
  }
  getFixedColumnElements(e) {
    const t = this;
    if (!this._isFixedColumns)
      return;
    if (f(e))
      return this._fixedTableElement && this._getRowElements(this._fixedTableElement).eq(e).children();
    const n = t.getColumnElements(), s = t.getTransparentColumnElement();
    if (n && s && s.length) {
      var o;
      const r = es(t.getFixedColumns());
      [].splice.apply(n, [r, (o = s.get(0)) === null || o === void 0 ? void 0 : o.colSpan, s.get(0)]);
    }
    return n;
  }
  getColumnWidths(e, t) {
    const n = this;
    let s;
    const o = super.getColumnWidths(e, t), r = n.getFixedColumnElements(), a = n.getFixedColumns();
    return n._fixedTableElement && (r && r.length ? s = n._getWidths(r) : s = super.getColumnWidths(n._fixedTableElement)), SF(a, o, s);
  }
}, Dee = (i) => class extends FC(i) {
  dispose() {
    super.dispose.apply(this, arguments), clearTimeout(this._fixedScrollTimeout);
  }
  optionChanged(e) {
    super.optionChanged(e), e.name === "hoverStateEnabled" && this._isFixedColumns && (e.value ? this._attachHoverEvents() : this._detachHoverEvents());
  }
  _detachHoverEvents() {
    const e = this.element();
    this._fixedTableElement && this._tableElement && _.off(e, "mouseover mouseout", ".dx-data-row");
  }
  _attachHoverEvents() {
    this._fixedTableElement && this._tableElement && _.on(this.element(), "mouseover mouseout", ".dx-data-row", this.createAction((e) => {
      const {
        event: t
      } = e, n = this.getRowIndex(p(t.target).closest(".dx-row")), s = t.type === "mouseover";
      n >= 0 && (this._tableElement && this._getRowElements(this._tableElement).eq(n).toggleClass("dx-state-hover", s), this._fixedTableElement && this._getRowElements(this._fixedTableElement).eq(n).toggleClass("dx-state-hover", s));
    }));
  }
  _getScrollDelay() {
    var e;
    return ((e = this._resizingController) === null || e === void 0 ? void 0 : e.hasResizeTimeout()) ? this.option("scrolling.updateTimeout") : ze.mozilla ? 60 : 0;
  }
  _findContentElement(e) {
    let t, n;
    const s = this.addWidgetPrefix("content"), o = this.element();
    if (e = this._isFixedTableRendering || e, o && e) {
      t = o.children(`.${s}`);
      const r = this.getScrollable();
      return !t.length && r && (t = p("<div>").addClass(s), _.on(t, "scroll", (a) => {
        const {
          target: l
        } = a, d = this._getScrollDelay();
        clearTimeout(this._fixedScrollTimeout), this._fixedScrollTimeout = setTimeout(() => {
          n = p(l).scrollTop(), r.scrollTo({
            y: n
          });
        }, d);
      }), _.on(t, sd, (a) => {
        const l = p(a.target).closest(".dx-scrollable");
        let d = !1;
        if (r && r.$element().is(l))
          d = !0;
        else {
          const u = l.length && Qt.getInstance(l.get(0)), c = u && u.scrollHeight() - u.clientHeight() > 0;
          d = u && !c;
        }
        if (d) {
          n = r.scrollTop(), r.scrollTo({
            y: n - a.delta
          });
          const u = r.scrollTop() + r.clientHeight(), c = r.scrollHeight() + this.getScrollbarWidth();
          if (r.scrollTop() > 0 && u < c)
            return !1;
        }
      }), t.appendTo(o)), t;
    }
    return super._findContentElement();
  }
  _updateScrollable() {
    super._updateScrollable();
    const e = this.getScrollable();
    if (e != null && e._disposed)
      return;
    const t = e && e.scrollOffset().top;
    this._updateFixedTablePosition(t);
  }
  _renderContent(e, t, n) {
    return this._isFixedTableRendering || n ? e.empty().addClass(`${this.addWidgetPrefix("content")} ${this.addWidgetPrefix("content-fixed")}`).append(t) : super._renderContent(e, t);
  }
  _getGroupCellOptions(e) {
    return this._isFixedTableRendering ? super._getGroupCellOptions(x({}, e, {
      columns: this._columnsController.getVisibleColumns()
    })) : super._getGroupCellOptions(e);
  }
  _renderGroupedCells(e, t) {
    return super._renderGroupedCells(e, x({}, t, {
      columns: this._columnsController.getVisibleColumns()
    }));
  }
  _renderGroupSummaryCells(e, t) {
    this._isFixedTableRendering ? super._renderGroupSummaryCells(e, x({}, t, {
      columns: this._columnsController.getVisibleColumns()
    })) : super._renderGroupSummaryCells(e, t);
  }
  _hasAlignByColumnSummaryItems(e, t) {
    const n = super._hasAlignByColumnSummaryItems.apply(this, arguments), s = t.columns[e];
    return t.isFixed ? s.fixed && (n || s.fixedPosition === "right") : n && (!this._isFixedColumns || !s.fixed);
  }
  _renderGroupSummaryCellsCore(e, t, n, s) {
    let o;
    if (this._isFixedTableRendering) {
      t.isFixed = !0, o = this._getAlignByColumnCellCount(n, t), t.isFixed = !1;
      const r = t.columns.length - o;
      t = x({}, t, {
        columns: this.getFixedColumns()
      });
      const a = es(t.columns);
      r < a ? (o -= t.columns[a].colspan - 1 || 0, n -= t.columns[a].colspan - 1 || 0) : s > 0 && e.css("visibility", "hidden"), s = o;
    }
    super._renderGroupSummaryCellsCore(e, t, n, s);
  }
  _getSummaryCellIndex(e, t) {
    if (this._isFixedTableRendering) {
      const n = es(t);
      return e > n && (e += t[n].colspan - 1), e;
    }
    return super._getSummaryCellIndex.apply(this, arguments);
  }
  _renderCore(e) {
    this._detachHoverEvents();
    const t = super._renderCore(e), n = this._isFixedColumns;
    return this.element().toggleClass("dx-fixed-columns", n), this.option("hoverStateEnabled") && n && this._attachHoverEvents(), t;
  }
  setAriaOwns(e, t, n) {
    if (n) {
      var s;
      const o = this.addWidgetPrefix("content-fixed"), r = (s = this.element()) === null || s === void 0 ? void 0 : s.children(`.${o}`), a = this.getFixedTableElement();
      r.length && a !== null && a !== void 0 && a.length && this.setAria("owns", `${e ?? ""} ${a.attr("id") ?? ""} ${t ?? ""}`.trim(), r);
    } else
      super.setAriaOwns.apply(this, arguments);
  }
  toggleDraggableColumnClass(e, t) {
    if (super.toggleDraggableColumnClass(e, t), this.isFixedColumns()) {
      const n = this._getRowElements(this._fixedTableElement);
      this._toggleDraggableSourceColumnClass(n, this.getFixedColumns(), e, t);
    }
  }
  getCellIndex(e) {
    const t = this._fixedTableElement;
    let n = 0;
    if (t && e.is("td") && e.closest(t).length) {
      const s = this.getFixedColumns();
      return y(s, (o, r) => {
        if (o === e[0].cellIndex)
          return !1;
        if (r.colspan) {
          n += r.colspan;
          return;
        }
        n++;
      }), n;
    }
    return super.getCellIndex.apply(this, arguments);
  }
  _updateFixedTablePosition(e, t) {
    if (this._fixedTableElement && this._tableElement) {
      let n;
      this._fixedTableElement.parent().scrollTop(e), t && this._editorFactoryController && (n = this._editorFactoryController.focus(), n && this._editorFactoryController.focus(n));
    }
  }
  setScrollerSpacing(e, t) {
    const n = this, s = {
      marginBottom: 0
    }, o = n.element().children(`.${this.addWidgetPrefix("content-fixed")}`);
    o.length && n._fixedTableElement && (o.css(s), n._fixedTableElement.css(s), s[n.option("rtlEnabled") ? "marginLeft" : "marginRight"] = e, s.marginBottom = t, (n._scrollable && n._scrollable.option("useNative") ? o : n._fixedTableElement).css(s));
  }
  _getElasticScrollTop(e) {
    let t = 0;
    if (e.scrollOffset.top < 0)
      t = -e.scrollOffset.top;
    else if (e.reachedBottom) {
      const n = p(e.component.content()), s = p(e.component.container()), o = Math.max(n.get(0).clientHeight - s.get(0).clientHeight, 0);
      t = Math.min(o - e.scrollOffset.top, 0);
    }
    return Math.floor(t);
  }
  _applyElasticScrolling(e) {
    if (this._fixedTableElement) {
      const t = this._getElasticScrollTop(e);
      Math.ceil(t) !== 0 ? Ot(this._fixedTableElement, {
        top: t
      }) : this._fixedTableElement.css("transform", "");
    }
  }
  _handleScroll(e) {
    this._updateFixedTablePosition(e.scrollOffset.top, !0), this._applyElasticScrolling(e), super._handleScroll(e);
  }
  _updateContentPosition(e) {
    super._updateContentPosition.apply(this, arguments), e || this._updateFixedTablePosition(this._scrollTop);
  }
  _afterRowPrepared(e) {
    this._isFixedTableRendering || super._afterRowPrepared(e);
  }
  _scrollToElement(e, t) {
    const n = this.isFixedColumns() ? this.getFixedColumnsOffset() : t;
    super._scrollToElement(e, n);
  }
}, Tee = (i) => class extends FC(i) {
}, Oee = function(i, e, t) {
  const n = es(e), s = i.length - e.length;
  return y(t, (o, r) => {
    r.index > n && (r.columnIndex += s, r.index += s);
  }), t;
}, Aee = (i) => class extends i {
  _generatePointsByColumns(e, t) {
    const n = e.columns, {
      targetDraggingPanel: s
    } = e;
    if (s && s.getName() === "headers" && s.isFixedColumns() && e.sourceColumn.fixed) {
      e.rowIndex || (e.columnElements = s.getFixedColumnElements(0)), e.columns = s.getFixedColumns(e.rowIndex);
      const o = super._generatePointsByColumns(e, t);
      return Oee(n, e.columns, o), o;
    }
    return super._generatePointsByColumns(e, t);
  }
  _pointCreated(e, t, n, s) {
    const o = super._pointCreated.apply(this, arguments), r = t[e.columnIndex], a = this._columnHeadersView.getTransparentColumnElement();
    if (!o && n === "headers" && a && a.length) {
      const l = Ge(a.get(0));
      return s && s.fixed ? s.fixedPosition === "right" ? e.x < l.right : e.x > l.left : r && r.fixed && r.fixedPosition !== "right" ? !0 : e.x < l.left || e.x > l.right;
    }
    return o;
  }
}, Ree = (i) => class extends i {
  _generatePointsByColumns(e) {
    const t = this, n = t._columnsController, s = n && t._columnsController.getVisibleColumns(), o = n && t._columnsController.getFixedColumns(), r = es(o), a = s.length - o.length, l = t._columnHeadersView.getFixedColumnElements();
    super._generatePointsByColumns(e), l && l.length > 0 && (t._pointsByFixedColumns = F.getPointsByColumns(l, (d) => (d.index > r && (d.columnIndex += a, d.index += a), t._pointCreated(d, s.length, s))));
  }
  _getTargetPoint(e, t, n) {
    const s = this._columnHeadersView.getTransparentColumnElement();
    if (s && s.length) {
      const o = Ge(s.get(0));
      if (t <= o.left || t >= o.right)
        return super._getTargetPoint(this._pointsByFixedColumns, t, n);
    }
    return super._getTargetPoint(e, t, n);
  }
}, Fee = (i) => class extends i {
  _setAriaOwns() {
    var e, t, n;
    super._setAriaOwns.apply(this, arguments);
    const s = (e = this._columnHeadersView) === null || e === void 0 ? void 0 : e.getFixedTableElement(), o = (t = this._footerView) === null || t === void 0 ? void 0 : t.getFixedTableElement();
    (n = this._rowsView) === null || n === void 0 || n.setAriaOwns(s?.attr("id"), o?.attr("id"), !0);
  }
}, kee = (i) => class extends i {
  _toggleInertAttr(e) {
    var t;
    const n = (t = this._rowsView) === null || t === void 0 ? void 0 : t.getFixedContentElement();
    e ? n?.attr("inert", !0) : n?.removeAttr("inert");
  }
}, Vee = (i) => class extends i {
  getValidationMessageContainer(e) {
    return this._rowsView.isFixedColumns() ? this._rowsView.element() : super.getValidationMessageContainer(e);
  }
}, Pee = {
  defaultOptions: () => ({
    columnFixing: {
      enabled: !1,
      legacyMode: !1,
      texts: {
        fix: S.format("dxDataGrid-columnFixingFix"),
        unfix: S.format("dxDataGrid-columnFixingUnfix"),
        leftPosition: S.format("dxDataGrid-columnFixingLeftPosition"),
        rightPosition: S.format("dxDataGrid-columnFixingRightPosition"),
        stickyPosition: S.format("dxDataGrid-columnFixingStickyPosition")
      },
      icons: {
        fix: "fix-column",
        unfix: "unfix-column",
        leftPosition: "fix-column-left",
        rightPosition: "fix-column-right",
        stickyPosition: "stick-column"
      }
    }
  }),
  extenders: {
    views: {
      columnHeadersView: Iee,
      rowsView: Dee,
      footerView: Tee
    },
    controllers: {
      draggingHeader: Aee,
      columnsResizer: Ree,
      resizing: Fee,
      keyboardNavigation: kee,
      editorFactory: Vee
    }
  }
};
J.registerModule("columnFixing", Pee);
const EF = "rowsView", Mee = "footerView", hg = ["columnHeadersView", EF, Mee], Bee = "dxDataGridAdaptivity", IF = "dxDataGrid-ariaAdaptiveExpand", $ee = "dxDataGrid-ariaAdaptiveCollapse", Nee = "scrolling.legacyMode";
function uu(i, e) {
  return i._columnsController.getColumnId(e);
}
function Lee(i) {
  return i.find("td:not(.dx-datagrid-hidden-column):not([class*='dx-command-'])");
}
function Hee(i, e) {
  let t;
  const n = p(i), s = e.component.getController("adaptiveColumns");
  e.rowType === "data" ? (t = p("<span>").addClass(s.addWidgetPrefix("adaptive-more")), _.on(t, R(Te, Bee), s.createAction(() => {
    s.toggleExpandAdaptiveDetailRow(e.key);
  })), t.appendTo(n)) : F.setEmptyText(n);
}
function of(i) {
  var e;
  const t = (e = i.data) === null || e === void 0 ? void 0 : e.$nextCell;
  _.off(t, "focus", of), _.trigger(t, "dxclick");
}
class Wee extends Ue.ViewController {
  init() {
    this._columnsController = this.getController("columns"), this._dataController = this.getController("data"), this._editingController = this.getController("editing"), this._keyboardNavigationController = this.getController("keyboardNavigation"), this._rowsView = this.getView("rowsView"), this._columnsController.addCommandColumn({
      type: "adaptive",
      command: "adaptive",
      visible: !0,
      adaptiveHidden: !0,
      cssClass: "dx-command-adaptive",
      alignment: "center",
      width: "auto",
      cellTemplate: Hee,
      fixedPosition: "right"
    }), this._columnsController.columnsChanged.add(() => {
      const e = !!this.updateHidingQueue(this._columnsController.getColumns()).length;
      this._columnsController.columnOption("command:adaptive", "adaptiveHidden", !e, !0);
    }), this._hidingColumnsQueue = [], this._hiddenColumns = [], this.createAction("onAdaptiveDetailRowPreparing"), super.init();
  }
  optionChanged(e) {
    e.name === "columnHidingEnabled" && this._columnsController.columnOption("command:adaptive", "adaptiveHidden", !e.value), super.optionChanged(e);
  }
  publicMethods() {
    return ["isAdaptiveDetailRowExpanded", "expandAdaptiveDetailRow", "collapseAdaptiveDetailRow"];
  }
  _isRowEditMode() {
    return this._getEditMode() === "row";
  }
  _isItemModified(e, t) {
    const n = this._columnsController.getVisibleIndex(e.column.index), s = this._dataController.getRowIndexByKey(t.key), o = this._dataController.items()[s + 1];
    return o && o.modifiedValues && f(o.modifiedValues[n]);
  }
  _renderFormViewTemplate(e, t, n) {
    const s = this, {
      column: o
    } = e, r = s.createAction(() => {
      s._editingController.isEditing() && _.trigger(n, Te);
    }), a = t.row.data, l = o.calculateCellValue(a), d = F.getDisplayValue(o, l, a, t.rowType), u = F.formatValue(d, o), c = this._editingController.isCellOrBatchEditMode(), h = s._rowsView;
    if (o.allowEditing && this._keyboardNavigationController.isKeyboardEnabled() && (n.attr("tabIndex", s.option("tabIndex")), c && (_.off(n, "focus", r), _.on(n, "focus", r))), o.cellTemplate) {
      const g = x({}, t, {
        value: l,
        displayValue: d,
        text: u,
        column: o
      });
      h.renderTemplate(n, o.cellTemplate, g, pa(n)).done(() => {
        h._cellPrepared(n, t);
      });
    } else {
      const g = n.get(0);
      o.encodeHtml ? g.textContent = u : g.innerHTML = u, n.addClass("dx-adaptive-item-text"), (!f(u) || u === "") && n.html("&nbsp;"), s._isRowEditMode() || s._isItemModified(e, t) && n.addClass("dx-item-modified"), h._cellPrepared(n, t);
    }
  }
  _getTemplate(e, t, n) {
    const s = this, {
      column: o
    } = e, r = this._editingController;
    return function(a, l) {
      const d = p(l), u = s._columnsController.getVisibleIndex(o.index), c = x({}, t), h = function() {
        const g = s._isItemEdited(e);
        c.value = t.row.values[u], g || o.showEditorAlways ? r.renderFormEditorTemplate(c, e, a, d, !g) : (c.column = o, c.columnIndex = u, s._renderFormViewTemplate(e, c, d));
      };
      if (h(), c.watch) {
        const g = c.watch(() => ({
          isItemEdited: s._isItemEdited(e),
          value: t.row.values[u]
        }), () => {
          d.contents().remove(), d.removeClass("dx-adaptive-item-text"), h();
        });
        _.on(d, On, g);
      }
    };
  }
  _isVisibleColumnsValid(e) {
    return !(e < 2 || e.length - function() {
      let t = 0;
      for (let n = 0; n < e.length; n++)
        e[n].command && t++;
      return t;
    }() <= 1);
  }
  _calculatePercentWidths(e, t) {
    const n = this;
    let s = 0;
    return t.forEach((o, r) => {
      e[r] !== "adaptiveHidden" && (s += n._getItemPercentWidth(o));
    }), s;
  }
  _isPercentWidth(e) {
    return te(e) && e.endsWith("%");
  }
  _isColumnHidden(e) {
    return this._hiddenColumns.filter((t) => t.index === e.index).length > 0;
  }
  _getAverageColumnsWidth(e, t, n) {
    const s = this;
    let o = 0, r = 0;
    return t.forEach((a) => {
      if (!s._isColumnHidden(a)) {
        const {
          width: l
        } = a;
        f(l) && !isNaN(parseFloat(l)) ? o += s._isPercentWidth(l) ? s._calculatePercentWidth({
          visibleIndex: a.visibleIndex,
          columnsCount: t.length,
          columnsCanFit: n,
          bestFitWidth: a.bestFitWidth,
          columnWidth: l,
          containerWidth: e
        }) : parseFloat(l) : r++;
      }
    }), (e - o) / r;
  }
  _calculateColumnWidth(e, t, n, s) {
    const o = uu(this, e), r = this._columnsController.columnOption(o, "width"), a = this._columnsController.columnOption(o, "bestFitWidth"), l = n.length;
    let d;
    if (r && r !== "auto")
      if (this._isPercentWidth(r))
        d = this._calculatePercentWidth({
          visibleIndex: e.visibleIndex,
          columnsCount: l,
          columnsCanFit: s,
          bestFitWidth: a,
          columnWidth: r,
          containerWidth: t
        });
      else
        return parseFloat(r);
    else
      d = this.option("columnAutoWidth") || e.command ? a : this._getAverageColumnsWidth(t, n, s);
    return d;
  }
  _calculatePercentWidth(e) {
    const t = e.visibleIndex < e.columnsCount - 1 && e.columnsCanFit, n = e.containerWidth * parseFloat(e.columnWidth) / 100, s = e.columnsCanFit && n < e.bestFitWidth ? e.bestFitWidth : n;
    return t ? e.containerWidth * parseFloat(e.columnWidth) / 100 : s;
  }
  _getNotTruncatedColumnWidth(e, t, n, s) {
    const o = uu(this, e), r = this._columnsController.columnOption(o, "width"), a = this._columnsController.columnOption(o, "bestFitWidth");
    if (r && r !== "auto" && !this._isPercentWidth(r))
      return parseFloat(r);
    const l = this._calculateColumnWidth(e, t, n, s);
    return l < a ? null : l;
  }
  _getItemPercentWidth(e) {
    let t = 0;
    return e.width && this._isPercentWidth(e.width) && (t = parseFloat(e.width)), t;
  }
  _getCommandColumnsWidth() {
    const e = this, t = e._columnsController.getVisibleColumns();
    let n = 0;
    return y(t, (s, o) => {
      (o.index < 0 || o.command) && (n += e._columnsController.columnOption(uu(e, o), "bestFitWidth") || 0);
    }), n;
  }
  _isItemEdited(e) {
    if (this.isFormOrPopupEditMode())
      return !1;
    if (this._isRowEditMode()) {
      const t = this.option("editing.editRowKey");
      if (He(t, this._dataController.adaptiveExpandedKey()))
        return !0;
    } else {
      const t = this._dataController.getRowIndexByKey(this._dataController.adaptiveExpandedKey()) + 1, n = this._columnsController.getVisibleIndex(e.column.index);
      return this._editingController.isEditCell(t, n);
    }
  }
  _getFormItemsByHiddenColumns(e) {
    const t = [];
    return y(e, (n, s) => {
      t.push({
        column: s,
        name: s.name,
        dataField: s.dataField,
        visibleIndex: s.visibleIndex
      });
    }), t;
  }
  _getAdaptiveColumnVisibleIndex(e) {
    for (let t = 0; t < e.length; t++)
      if (e[t].command === "adaptive")
        return t;
  }
  _hideAdaptiveColumn(e, t) {
    const n = this._getAdaptiveColumnVisibleIndex(t);
    f(n) && (e[n] = "adaptiveHidden", this._hideVisibleColumn({
      isCommandColumn: !0,
      visibleIndex: n
    }));
  }
  _showHiddenCellsInView(e) {
    let {
      $cells: t,
      isCommandColumn: n
    } = e, s = this.addWidgetPrefix("hidden-column");
    n ? (s = "dx-command-adaptive-hidden", t.attr({
      tabIndex: 0,
      "aria-hidden": null
    }).removeClass(s)) : t.removeClass(s);
  }
  _showHiddenColumns() {
    for (let e = 0; e < hg.length; e++) {
      const t = this.getView(hg[e]);
      if (t && t.isVisible() && t.element()) {
        const n = t.name, s = t.element().find(".dx-command-adaptive-hidden");
        this._showHiddenCellsInView({
          viewName: n,
          $cells: s,
          isCommandColumn: !0
        });
        const o = t.element().find(`.${this.addWidgetPrefix("hidden-column")}`);
        this._showHiddenCellsInView({
          viewName: n,
          $cells: o
        });
      }
    }
  }
  _isCellValid(e) {
    return e && e.length && !e.hasClass("dx-master-detail-cell") && !e.hasClass("dx-group-cell");
  }
  _hideVisibleColumn(e) {
    let {
      isCommandColumn: t,
      visibleIndex: n
    } = e;
    const s = this;
    hg.forEach((o) => {
      const r = s.getView(o);
      r && s._hideVisibleColumnInView({
        view: r,
        isCommandColumn: t,
        visibleIndex: n
      });
    });
  }
  _hideVisibleColumnInView(e) {
    let {
      view: t,
      isCommandColumn: n,
      visibleIndex: s
    } = e;
    const o = t.name;
    let r;
    const a = this._columnsController.getVisibleColumns()[s], l = this._editingController && this._editingController.getEditFormRowIndex();
    if (t && t.isVisible() && a) {
      const d = t.getRowsCount(), u = t._getRowElements();
      for (let c = 0; c < d; c++)
        if (!(c === l && o === EF && this.option("editing.mode") !== "popup")) {
          const g = o === "columnHeadersView" ? this._columnsController.getVisibleIndex(a.index, c) : s;
          if (g >= 0) {
            const m = u.eq(c);
            r = this._findCellElementInRow(m, g), this._isCellValid(r) && this._hideVisibleCellInView({
              viewName: o,
              isCommandColumn: n,
              $cell: r
            });
          }
        }
    }
  }
  _findCellElementInRow(e, t) {
    const n = e.children();
    let s = t, o = !1;
    if (e.hasClass("dx-group-row")) {
      const a = e.find(".dx-group-cell"), l = a.attr("colspan");
      if (a.length && f(l)) {
        const d = parseInt(l), u = a.index() + d - 1;
        t > u ? s = t - d + 1 : o = !0;
      }
    }
    return o ? void 0 : n.eq(s);
  }
  _hideVisibleCellInView(e) {
    let {
      $cell: t,
      isCommandColumn: n
    } = e;
    const s = n ? "dx-command-adaptive-hidden" : this.addWidgetPrefix("hidden-column");
    t.attr({
      tabIndex: -1,
      "aria-hidden": !0
    }).addClass(s);
  }
  _getEditMode() {
    return this._editingController.getEditMode();
  }
  isFormOrPopupEditMode() {
    const e = this._getEditMode();
    return e === "form" || e === "popup";
  }
  hideRedundantColumns(e, t, n) {
    const s = this;
    if (this._hiddenColumns = [], s._isVisibleColumnsValid(t) && n.length) {
      let o = 0;
      const r = s.component.$element();
      let a = ne(r) - s._getCommandColumnsWidth();
      const l = function() {
        return t.filter((m) => !m.command && this._hiddenColumns.filter((C) => C.index === m.index).length === 0);
      }.bind(this);
      let d = l();
      const u = d.length;
      let c, h, g;
      do {
        g = !1, o = 0;
        const m = s._calculatePercentWidths(e, t), C = m < 100 && m !== 0;
        for (c = 0; c < t.length; c++) {
          const v = t[c];
          let E = s._getNotTruncatedColumnWidth(v, a, d, C);
          const T = uu(s, v), V = s._columnsController.columnOption(T, "width"), $ = s._columnsController.columnOption(T, "minWidth"), G = s._columnsController.columnOption(T, "bestFitWidth");
          if (e[c] === "adaptiveHidden") {
            h = !0;
            continue;
          }
          if (!E && !v.command && !v.fixed) {
            g = !0;
            break;
          }
          (!V || V === "auto") && (E = Math.max(G || 0, $ || 0)), (v.command !== "adaptive" || h) && (o += E);
        }
        if (g = g || o > ne(r), g) {
          const v = n.pop(), E = s._columnsController.getVisibleIndex(v.index);
          a += s._calculateColumnWidth(v, a, d, C), s._hideVisibleColumn({
            visibleIndex: E
          }), e[E] = "adaptiveHidden", this._hiddenColumns.push(v), d = l();
        }
      } while (g && d.length > 1 && n.length);
      u === d.length && s._hideAdaptiveColumn(e, t);
    } else
      s._hideAdaptiveColumn(e, t);
  }
  getAdaptiveDetailItems() {
    return this._$itemContents;
  }
  getItemContentByColumnIndex(e) {
    let t;
    for (let n = 0; n < this._$itemContents.length; n++) {
      t = this._$itemContents.eq(n);
      const s = t.data("dx-form-item");
      if (s && s.column && this._columnsController.getVisibleIndex(s.column.index) === e)
        return t;
    }
  }
  toggleExpandAdaptiveDetailRow(e, t) {
    this.isFormOrPopupEditMode() && this._editingController.isEditing() || this._dataController.toggleExpandAdaptiveDetailRow(e, t);
  }
  createFormByHiddenColumns(e, t) {
    const n = this, s = p(e), o = {
      items: n._getFormItemsByHiddenColumns(n._hiddenColumns),
      formID: `dx-${new Xe()}`
    }, r = Zt() ? {
      colCount: 2
    } : {};
    this.executeAction("onAdaptiveDetailRowPreparing", {
      formOptions: o
    }), n._$itemContents = null, n._form = n._createComponent(p("<div>").appendTo(s), Eh, x(r, o, {
      customizeItem(a) {
        const l = a.column || n._columnsController.columnOption(a.name || a.dataField);
        l && (a.label = a.label || {}, a.label.text = a.label.text || l.caption, a.column = l, a.template = n._getTemplate(a, t, n.updateForm.bind(n))), o.customizeItem && o.customizeItem.call(this, a);
      },
      onContentReady(a) {
        o.onContentReady && o.onContentReady.call(this, a), n._$itemContents = s.find(".dx-field-item-content");
      }
    }));
  }
  hasAdaptiveDetailRowExpanded() {
    return f(this._dataController.adaptiveExpandedKey());
  }
  updateForm(e) {
    this.hasAdaptiveDetailRowExpanded() && this._form && f(this._form._contentReadyAction) && (e && e.length ? this._form.option("items", this._getFormItemsByHiddenColumns(e)) : this._form.repaint());
  }
  updateHidingQueue(e) {
    const t = this, n = e.filter((r) => r.visible && !r.type && !r.fixed && !(f(r.groupIndex) && r.groupIndex >= 0));
    let s, o;
    if (t._hidingColumnsQueue = [], t.option("allowColumnResizing") && t.option("columnResizingMode") === "widget")
      return t._hidingColumnsQueue;
    for (o = 0; o < n.length; o++)
      f(n[o].hidingPriority) && n[o].hidingPriority >= 0 && (s = !0, t._hidingColumnsQueue[n[o].hidingPriority] = n[o]);
    if (s)
      t._hidingColumnsQueue.reverse();
    else if (t.option("columnHidingEnabled"))
      for (o = 0; o < n.length; o++) {
        const r = t._columnsController.getVisibleIndex(n[o].index);
        t._hidingColumnsQueue[r] = n[o];
      }
    return t._hidingColumnsQueue = t._hidingColumnsQueue.filter(Object), t._hidingColumnsQueue;
  }
  getHiddenColumns() {
    return this._hiddenColumns;
  }
  hasHiddenColumns() {
    return this._hiddenColumns.length > 0;
  }
  getHidingColumnsQueue() {
    return this._hidingColumnsQueue;
  }
  isAdaptiveDetailRowExpanded(e) {
    const t = this._dataController;
    return t.adaptiveExpandedKey() && He(t.adaptiveExpandedKey(), e);
  }
  expandAdaptiveDetailRow(e) {
    this.hasAdaptiveDetailRowExpanded() || this.toggleExpandAdaptiveDetailRow(e);
  }
  collapseAdaptiveDetailRow() {
    this.hasAdaptiveDetailRowExpanded() && this.toggleExpandAdaptiveDetailRow();
  }
  updateCommandAdaptiveAriaLabel(e, t) {
    const n = this._dataController.getRowIndexByKey(e);
    if (n === -1)
      return;
    const s = p(this.component.getRowElement(n));
    this.setCommandAdaptiveAriaLabel(s, t);
  }
  setCommandAdaptiveAriaLabel(e, t) {
    e.find(".dx-command-adaptive").attr("aria-label", S.format(t));
  }
}
const zee = (i) => class extends i {
  _isCellValid(e, t) {
    return super._isCellValid(e, t) && !e.hasClass(this.addWidgetPrefix("hidden-column")) && !e.hasClass("dx-command-adaptive-hidden");
  }
  _processNextCellInMasterDetail(e, t) {
    super._processNextCellInMasterDetail(e, t);
    const n = this._editingController.isCellOrBatchEditMode();
    this._editingController.isEditing() && e && n && !this._isInsideEditForm(e) && (_.off(e, "focus", of), _.on(e, "focus", {
      $nextCell: e
    }, of), _.trigger(t, "focus"));
  }
  _isCellElement(e) {
    return super._isCellElement(e) || e.hasClass("dx-adaptive-item-text");
  }
}, Kee = (i) => class extends i {
  _getCellTemplate(e) {
    const t = this, {
      column: n
    } = e;
    return e.rowType === "detailAdaptive" && n.command === "detail" ? function(s, o) {
      t._adaptiveColumnsController.createFormByHiddenColumns(p(s), o);
    } : super._getCellTemplate(e);
  }
  _createRow(e) {
    const t = super._createRow.apply(this, arguments);
    return e && e.rowType === "detailAdaptive" && e.key === this._dataController.adaptiveExpandedKey() && t.addClass("dx-adaptive-detail-row"), t;
  }
  _renderCells(e, t) {
    super._renderCells(e, t);
    const n = this._adaptiveColumnsController, s = n.getHidingColumnsQueue().length, o = n.getHiddenColumns().length;
    s && !o && Lee(e).last().addClass("dx-last-data-cell"), t.row.rowType === "data" && n.setCommandAdaptiveAriaLabel(e, IF);
  }
  _getColumnIndexByElementCore(e) {
    const t = e.closest(".dx-field-item-content");
    if (t.length && t.closest(this.component.$element()).length) {
      const n = t.length ? t.first().data("dx-form-item") : null;
      return n && n.column && this._columnsController.getVisibleIndex(n.column.index);
    }
    return super._getColumnIndexByElementCore(e);
  }
  _cellPrepared(e, t) {
    super._cellPrepared.apply(this, arguments), t.row.rowType !== "detailAdaptive" && t.column.visibleWidth === "adaptiveHidden" && e.addClass(this.addWidgetPrefix("hidden-column"));
  }
  getCell(e, t) {
    const n = this._dataController.items()[e?.rowIndex];
    if (n?.rowType === "detailAdaptive") {
      const s = this._adaptiveColumnsController.getAdaptiveDetailItems();
      return super.getCell(e, t, s);
    }
    return super.getCell.apply(this, arguments);
  }
  _getCellElement(e, t) {
    const n = this._dataController.items()[e];
    return n && n.rowType === "detailAdaptive" ? this._adaptiveColumnsController.getItemContentByColumnIndex(t) : super._getCellElement.apply(this, arguments);
  }
  getContextMenuItems(e) {
    var t;
    if (e.row && e.row.rowType === "detailAdaptive") {
      const n = this._columnHeadersView, s = p(e.targetElement).closest(".dx-field-item-label").next().data("dx-form-item");
      return e.column = s ? s.column : e.column, n.getContextMenuItems && n.getContextMenuItems(e);
    }
    return (t = super.getContextMenuItems) === null || t === void 0 ? void 0 : t.call(this, e);
  }
  isClickableElement(e) {
    var t;
    return (((t = super.isClickableElement) === null || t === void 0 ? void 0 : t.call(this, e)) ?? !1) || !!e.closest(".dx-command-adaptive").length;
  }
}, Gee = (i) => class extends i {
  _updateColumnWidth(e, t) {
    super._updateColumnWidth(e, e.visibleWidth === "adaptiveHidden" ? e.bestFitWidth : t);
  }
}, Uee = (i) => class extends i {
  _pointCreated(e, t, n) {
    const s = super._pointCreated(e, t, n), o = n[e.columnIndex] || {}, r = this._getNextColumnIndex(e.columnIndex), a = n[r] || {}, l = r !== e.columnIndex + 1 && a.command, d = o.visibleWidth === "adaptiveHidden" || l;
    return s || d;
  }
  _getNextColumnIndex(e) {
    const t = this._columnsController.getVisibleColumns();
    let n = super._getNextColumnIndex(e);
    for (; t[n] && t[n].visibleWidth === "adaptiveHidden"; )
      n++;
    return n;
  }
}, jee = (i) => class extends i {
  _pointCreated(e, t, n, s) {
    const o = super._pointCreated(e, t, n, s), a = (t[e.columnIndex - 1] || {}).visibleWidth === "adaptiveHidden";
    return o || a;
  }
}, qee = (i) => class extends i {
  _isRowEditMode() {
    return this.getEditMode() === "row";
  }
  _getFormEditItemTemplate(e, t) {
    return this.getEditMode() !== "row" && e.rowType === "detailAdaptive" ? (e.columnIndex = this._columnsController.getVisibleIndex(t.index), this.getColumnTemplate(e)) : super._getFormEditItemTemplate(e, t);
  }
  _closeEditItem(e) {
    const t = e.closest(".dx-field-item-content"), n = this._dataController.getRowIndexByKey(this._dataController.adaptiveExpandedKey()) + 1, s = t.length ? t.first().data("dx-form-item") : null, o = s && s.column && this._columnsController.getVisibleIndex(s.column.index);
    this.isEditCell(n, o) || super._closeEditItem(e);
  }
  _beforeUpdateItems(e, t) {
    if (!this._adaptiveColumnsController.isFormOrPopupEditMode() && this._adaptiveColumnsController.hasHiddenColumns()) {
      const n = this._dataController.items(), s = n[t], o = F.getIndexByKey(this._dataController.adaptiveExpandedKey(), n);
      this._isForceRowAdaptiveExpand = !this._adaptiveColumnsController.hasAdaptiveDetailRowExpanded(), o >= 0 && e.push(o + 1), e.push(t + 1), this._dataController.adaptiveExpandedKey(s.key);
    }
  }
  _afterInsertRow(e) {
    super._afterInsertRow.apply(this, arguments), this._adaptiveColumnsController.hasHiddenColumns() && (this._adaptiveColumnsController.toggleExpandAdaptiveDetailRow(e, this.isRowEditMode()), this._isForceRowAdaptiveExpand = !0);
  }
  _collapseAdaptiveDetailRow() {
    this._isRowEditMode() && this._isForceRowAdaptiveExpand && (this._adaptiveColumnsController.collapseAdaptiveDetailRow(), this._isForceRowAdaptiveExpand = !1);
  }
  _cancelEditAdaptiveDetailRow() {
    this._adaptiveColumnsController.hasHiddenColumns() && this._collapseAdaptiveDetailRow();
  }
  _afterSaveEditData() {
    super._afterSaveEditData.apply(this, arguments);
    const e = new w();
    return this._isRowEditMode() && this._adaptiveColumnsController.hasHiddenColumns() ? W(this._validatingController.validate(!0)).done((t) => {
      t && this._cancelEditAdaptiveDetailRow(), e.resolve();
    }) : e.resolve(), e.promise();
  }
  _beforeCancelEditData() {
    super._beforeCancelEditData(), this._cancelEditAdaptiveDetailRow();
  }
  _getRowIndicesForCascadeUpdating(e) {
    const t = super._getRowIndicesForCascadeUpdating.apply(this, arguments);
    return this._adaptiveColumnsController.isAdaptiveDetailRowExpanded(e.key) && t.push(e.rowType === "detailAdaptive" ? e.rowIndex - 1 : e.rowIndex + 1), t;
  }
  _beforeCloseEditCellInBatchMode(e) {
    const t = this._dataController._adaptiveExpandedKey;
    if (t) {
      const n = F.getIndexByKey(t, this._dataController.items());
      n > -1 && e.unshift(n);
    }
  }
  editRow(e) {
    return this._adaptiveColumnsController.isFormOrPopupEditMode() && this._adaptiveColumnsController.collapseAdaptiveDetailRow(), super.editRow(e);
  }
  deleteRow(e) {
    const t = this._dataController.getKeyByRowIndex(e);
    this.getEditMode() === "batch" && this._adaptiveColumnsController.isAdaptiveDetailRowExpanded(t) && this._adaptiveColumnsController.collapseAdaptiveDetailRow(), super.deleteRow(e);
  }
}, Yee = (i) => class extends i {
  init() {
    super.init(), this._adaptiveExpandedKey = void 0;
  }
  _processItems(e, t) {
    const {
      changeType: n
    } = t;
    if (e = super._processItems.apply(this, arguments), n === "loadingAll" || !f(this._adaptiveExpandedKey))
      return e;
    const s = F.getIndexByKey(this._adaptiveExpandedKey, e), o = this.option(Nee) === !1;
    if (s >= 0) {
      const r = e[s];
      e.splice(s + 1, 0, {
        visible: !0,
        rowType: "detailAdaptive",
        key: r.key,
        data: r.data,
        node: r.node,
        modifiedValues: r.modifiedValues,
        isNewRow: r.isNewRow,
        values: r.values
      });
    } else
      n === "refresh" && !(o && t.repaintChangesOnly) && (this._adaptiveExpandedKey = void 0);
    return e;
  }
  _getRowIndicesForExpand(e) {
    const t = super._getRowIndicesForExpand.apply(this, arguments);
    if (this._adaptiveColumnsController.isAdaptiveDetailRowExpanded(e)) {
      const n = t[t.length - 1];
      t.push(n + 1);
    }
    return t;
  }
  adaptiveExpandedKey(e) {
    if (f(e))
      this._adaptiveExpandedKey = e;
    else
      return this._adaptiveExpandedKey;
  }
  toggleExpandAdaptiveDetailRow(e, t) {
    let n = F.getIndexByKey(this._adaptiveExpandedKey, this._items), s = F.getIndexByKey(e, this._items);
    n >= 0 && n === s && !t && (e = void 0, s = -1);
    const o = this._adaptiveExpandedKey;
    this._adaptiveExpandedKey = e, n >= 0 && n++, s >= 0 && s++;
    const r = this.getRowIndexDelta();
    this.updateItems({
      allowInvisibleRowIndices: !0,
      changeType: "update",
      rowIndices: [n - r, s - r]
    }), this._adaptiveColumnsController.updateCommandAdaptiveAriaLabel(e, $ee), this._adaptiveColumnsController.updateCommandAdaptiveAriaLabel(o, IF);
  }
}, Xee = (i) => class extends i {
  _needHideBorder(e) {
    return super._needHideBorder(e) || e?.hasClass("dx-field-item-content") && e?.find(".dx-checkbox").length;
  }
  _getFocusCellSelector() {
    return `${super._getFocusCellSelector()}, .dx-adaptive-detail-row .dx-field-item > .dx-field-item-content`;
  }
  _getRevertTooltipsSelector() {
    return `${super._getRevertTooltipsSelector()}, .dx-field-item-content .${this.addWidgetPrefix("revert-tooltip")}`;
  }
}, Zee = (i) => class extends i {
  _isColumnVisible(e) {
    return super._isColumnVisible(e) && !e.adaptiveHidden;
  }
  getVisibleDataColumnsByBandColumn(e) {
    return super.getVisibleDataColumnsByBandColumn(e).filter((t) => t.visibleWidth !== "adaptiveHidden");
  }
}, Qee = (i) => class extends i {
  dispose() {
    super.dispose.apply(this, arguments), clearTimeout(this._updateScrollableTimeoutID);
  }
  _needBestFit() {
    return super._needBestFit() || !!this._adaptiveColumnsController.getHidingColumnsQueue().length;
  }
  _correctColumnWidths(e, t) {
    const n = this._adaptiveColumnsController, s = n.getHiddenColumns(), o = n.updateHidingQueue(this._columnsController.getColumns());
    n.hideRedundantColumns(e, t, o);
    const r = n.getHiddenColumns();
    return n.hasAdaptiveDetailRowExpanded() && s.length !== r.length && n.updateForm(r), !r.length && n.collapseAdaptiveDetailRow(), super._correctColumnWidths.apply(this, arguments);
  }
  _toggleBestFitMode(e) {
    e && this._adaptiveColumnsController._showHiddenColumns(), super._toggleBestFitMode(e);
  }
  _needStretch() {
    const e = this._adaptiveColumnsController;
    return super._needStretch.apply(this, arguments) || e.getHidingColumnsQueue().length || e.hasHiddenColumns();
  }
}, Jee = {
  defaultOptions: () => ({
    columnHidingEnabled: !1,
    onAdaptiveDetailRowPreparing: null
  }),
  controllers: {
    adaptiveColumns: Wee
  },
  extenders: {
    views: {
      rowsView: Kee
    },
    controllers: {
      export: Gee,
      columnsResizer: Uee,
      draggingHeader: jee,
      editing: qee,
      resizing: Qee,
      data: Yee,
      editorFactory: Xee,
      columns: Zee,
      keyboardNavigation: zee
    }
  }
};
J.registerModule("adaptivity", Jee);
function DF(i, e, t, n, s, o) {
  t = t || 0, n = n || [], o = o || [], n[t] = n[t] || 0;
  const r = i[t], a = o[t] + 1 || 0;
  let l = 0, d;
  if (r) {
    for (d = a; d < r.length; d++) {
      const u = r[d], c = d + n[t], h = u.colspan || 1;
      if (DF(i, e, t + (u.rowspan || 1), n, h, o), n[t] += h - 1, l += h, u.rowspan)
        for (let g = t + 1; g < t + u.rowspan; g++)
          n[g] = n[g] || 0, n[g] += u.colspan || 1;
      if (e(u, c, t, d) === !1 || s !== void 0 && l >= s)
        break;
    }
    o[t] = d;
  }
}
function pg(i, e, t) {
  const n = [];
  DF(i, (s, o, r) => {
    let a = s, l;
    const d = a.colspan || 1, u = o + d - 1 >= e && o < t;
    if (n[r] = n[r] || [], u)
      o < e ? (l = d - (e - o), o = e) : l = d, o + l > t && (l = t - o), l !== d && (a = x({}, a, {
        colspan: l
      })), n[r].push(a);
    else if (o > t)
      return !1;
  });
  for (let s = 0; s < n.length; s++)
    n[s] = n[s] || [];
  return n;
}
const TF = (i) => class extends i {
  _needToSetCellWidths() {
    let e = super._needToSetCellWidths();
    return !e && this._columnsController.isVirtualMode() && (e = this._columnsController.getColumns().some((n) => n.width === "auto")), e;
  }
}, ete = (i) => class extends TF(i) {
  _resizeCore() {
    super._resizeCore.apply(this, arguments), this._columnsController.resize();
  }
  _handleScroll(e) {
    const t = this.getScrollable();
    let {
      left: n
    } = e.scrollOffset;
    super._handleScroll.apply(this, arguments), this.option("rtlEnabled") && t && (n = ne(t.$content()) - ne(t.$element()) - n), this._columnsController.setScrollPosition(n, e.event);
  }
  _renderCore(e) {
    if (e != null && e.virtualColumnsScrolling) {
      var t, n;
      const s = this._findContentElement(), o = (t = this._columnsController) === null || t === void 0 ? void 0 : t.getFixedColumns(), r = (n = this._scrollable) === null || n === void 0 ? void 0 : n.option("useNative"), a = this.option("columnFixing.legacyMode");
      if (o != null && o.length) {
        a && !r ? s.css({
          minHeight: F.getContentHeightLimit(ze)
        }) : s.css({
          minHeight: le(s)
        });
        const l = () => {
          this.resizeCompleted.remove(l), s.css({
            minHeight: ""
          });
        };
        this.resizeCompleted.add(l);
      }
    }
    return super._renderCore.apply(this, arguments);
  }
}, tte = (i) => class extends TF(i) {
  _renderCore() {
    const e = super._renderCore.apply(this, arguments);
    return this._columnsController.isVirtualMode() && this._updateScrollLeftPosition(), e;
  }
}, cu = function(i) {
  return i.map((e) => e.visibleWidth || parseFloat(e.width) || 50);
}, nte = (i) => class extends i {
  init() {
    super.init.apply(this, arguments), this._resizingController = this.getController("resizing"), this._beginPageIndex = null, this._endPageIndex = null, this._position ?? (this._position = 0), this._virtualVisibleColumns = {};
  }
  dispose() {
    clearTimeout(this._changedTimeout), super.dispose.apply(this, arguments);
  }
  resetColumnsCache() {
    super.resetColumnsCache(), this._virtualVisibleColumns = {};
  }
  getBeginPageIndex(e) {
    const t = this.getVisibleColumns(void 0, !0), n = cu(t);
    let s = 0;
    for (let o = 0; o < n.length; o++) {
      if (s >= e)
        return Math.floor(o / this.getColumnPageSize());
      s += n[o];
    }
    return 0;
  }
  getTotalWidth() {
    const e = this.option("width");
    return typeof e == "number" ? e : this._resizingController._lastWidth || Ee(this.component.$element());
  }
  getEndPageIndex(e) {
    const t = this.getVisibleColumns(void 0, !0), n = cu(t);
    let s = 0;
    e += this.getTotalWidth();
    for (let o = 0; o < n.length; o++) {
      if (s >= e)
        return Math.ceil(o / this.getColumnPageSize());
      s += n[o];
    }
    return Math.ceil(n.length / this.getColumnPageSize());
  }
  getColumnPageSize() {
    return this.option("scrolling.columnPageSize");
  }
  _fireColumnsChanged(e) {
    const t = /* @__PURE__ */ new Date();
    this.columnsChanged.fire({
      optionNames: {
        all: !0,
        length: 1
      },
      changeTypes: {
        columns: !0,
        virtualColumnsScrolling: !0,
        length: 2,
        event: e
      }
    }), this._renderTime = /* @__PURE__ */ new Date() - t;
  }
  getScrollingTimeout() {
    const e = this.option("scrolling.columnRenderingThreshold"), t = this.option("scrolling.renderAsync");
    let n = 0;
    return (!f(t) && this._renderTime > e || t) && (n = this.option("scrolling.timeout")), n;
  }
  setScrollPosition(e, t) {
    const n = this.getScrollingTimeout();
    n > 0 ? (clearTimeout(this._changedTimeout), this._changedTimeout = setTimeout(() => {
      this._setScrollPositionCore(e, t);
    }, n)) : this._setScrollPositionCore(e, t);
  }
  resize() {
    this._setScrollPositionCore(this._position);
  }
  _setScrollPositionCore(e, t) {
    const n = this;
    if (n.isVirtualMode()) {
      const s = n.getBeginPageIndex(e), o = n.getEndPageIndex(e), r = e < n._position ? n._beginPageIndex > s : n._endPageIndex < o;
      n._position = e, r && (n._beginPageIndex = s, n._endPageIndex = o, n._fireColumnsChanged(t));
    }
  }
  getFixedColumns(e, t) {
    const n = super.getFixedColumns(e);
    if (this.isVirtualMode() && !t && n.length) {
      const s = n.map((o) => o.command).indexOf("transparent");
      return n[s].colspan = this.getVisibleColumns().length - super.getFixedColumns().length + 1, n;
    }
    return n;
  }
  _compileVisibleColumns(e, t) {
    var n;
    if (t || !this.isVirtualMode() || !this._shouldReturnVisibleColumns())
      return super._compileVisibleColumns(e);
    (n = this._columns) !== null && n !== void 0 && n.length && !f(this._beginPageIndex) && !f(this._endPageIndex) && (this._beginPageIndex = this.getBeginPageIndex(this._position), this._endPageIndex = this.getEndPageIndex(this._position));
    const s = this._beginPageIndex, o = this._endPageIndex, r = `${e}-${s}-${o}`;
    if (this._virtualVisibleColumns[r])
      return this._virtualVisibleColumns[r];
    let a = super._compileVisibleColumns();
    const l = this.getRowCount(), d = this.getColumnPageSize();
    let u = s * d, c = o * d;
    const h = this.getFixedColumns(void 0, !0), g = h.map((H) => H.command).indexOf("transparent"), m = h.length ? g : 0;
    let C = a.slice(0, m);
    const v = a.slice(m, u), E = cu(v).reduce((H, ce) => H + ce, 0);
    E || (u = 0);
    const T = h.length ? h.length - g - 1 : 0;
    let V = a.slice(a.length - T);
    const $ = a.slice(c, a.length - T), G = cu($).reduce((H, ce) => H + ce, 0);
    if (G || (c = a.length), l > 1 && typeof e == "number") {
      const H = [];
      for (let ce = 0; ce <= l; ce++)
        H.push(super._compileVisibleColumns(ce));
      C = pg(H, 0, C.length)[e] || [], V = pg(H, a.length - V.length, a.length)[e] || [], a = pg(H, u, c)[e] || [];
    } else
      a = a.slice(u, c);
    return E && (a.unshift({
      command: "virtual",
      type: "virtual",
      width: E
    }), a = C.concat(a)), G && (a.push({
      command: "virtual",
      type: "virtual",
      width: G
    }), a = a.concat(V)), this._virtualVisibleColumns[r] = a, a;
  }
  getColumnIndexOffset() {
    let e = 0;
    if (this._beginPageIndex > 0) {
      const n = this.getFixedColumns().map((o) => o.command).indexOf("transparent"), s = n >= 0 ? n : 0;
      e = this._beginPageIndex * this.getColumnPageSize() - s - 1;
    }
    return e > 0 ? e : 0;
  }
  isVirtualMode() {
    return ae() && this.option("scrolling.columnRenderingMode") === "virtual";
  }
}, ite = {
  defaultOptions: () => ({
    scrolling: {
      columnRenderingMode: "standard",
      columnPageSize: 5,
      columnRenderingThreshold: 300
    }
  }),
  extenders: {
    controllers: {
      columns: nte
    },
    views: {
      columnHeadersView: tte,
      rowsView: ete
    }
  }
};
J.registerModule("virtualColumns", ite);
class ste {
  constructor(e, t) {
    let {
      key: n
    } = t;
    this._isSharedDataSource = !1, this._keyExpr = n, this.updateDataSource(e);
  }
  _updateDataSource(e) {
    if (e)
      if (e instanceof In)
        this._isSharedDataSource = !0, this._dataSource = e;
      else {
        const t = lo(e);
        this._dataSource = new In(x(!0, {}, {}, t));
      }
  }
  _updateDataSourceByItems(e) {
    this._dataSource = new In({
      store: new _d({
        key: this.key(),
        data: e
      }),
      pageSize: 0
    });
  }
  _disposeDataSource() {
    this._dataSource && (this._isSharedDataSource ? this._isSharedDataSource = !1 : this._dataSource.dispose(), delete this._dataSource);
  }
  load() {
    return this._dataSource.load();
  }
  loadSingle(e, t) {
    if (!this._dataSource)
      return new w().reject();
    let n = e, s = t;
    return arguments.length < 2 && (s = e, n = this.key()), this._dataSource.loadSingle(n, s);
  }
  loadFromStore(e) {
    return this.store().load(e);
  }
  loadNextPage() {
    return this.pageIndex(1 + this.pageIndex()), this.load();
  }
  loadOptions() {
    return this._dataSource.loadOptions();
  }
  userData() {
    return this._dataSource._userData;
  }
  cancel(e) {
    this._dataSource.cancel(e);
  }
  cancelAll() {
    this._dataSource.cancelAll();
  }
  filter(e) {
    return this._dataSource.filter(e);
  }
  addSearchFilter(e) {
    this._dataSource._addSearchFilter(e);
  }
  group(e) {
    return this._dataSource.group(e);
  }
  paginate() {
    return this._dataSource.paginate();
  }
  pageSize() {
    return this._dataSource._pageSize;
  }
  pageIndex(e) {
    return e === void 0 ? this._dataSource.pageIndex(void 0) : this._dataSource.pageIndex(e);
  }
  resetDataSource() {
    this._disposeDataSource();
  }
  resetDataSourcePageIndex() {
    this.pageIndex() && (this.pageIndex(0), this.load());
  }
  updateDataSource(e, t) {
    const n = e ?? this.items();
    t && (this._keyExpr = t), this._disposeDataSource(), Array.isArray(n) ? this._updateDataSourceByItems(n) : this._updateDataSource(n);
  }
  totalCount() {
    return this._dataSource.totalCount();
  }
  isLastPage() {
    return this._dataSource.isLastPage() || !this._dataSource._pageSize;
  }
  isLoading() {
    return this._dataSource.isLoading();
  }
  isLoaded() {
    return this._dataSource.isLoaded();
  }
  searchValue(e) {
    return this._dataSource.searchValue(e);
  }
  searchOperation(e) {
    return this._dataSource.searchOperation(e);
  }
  searchExpr(e) {
    return this._dataSource.searchExpr(e);
  }
  select() {
    for (var e = arguments.length, t = new Array(e), n = 0; n < e; n++)
      t[n] = arguments[n];
    return this._dataSource.select(t);
  }
  key() {
    var e;
    const t = (e = this._dataSource) === null || e === void 0 ? void 0 : e.key();
    return f(t) && this._keyExpr === "this" ? t : this._keyExpr;
  }
  keyOf(e) {
    return this.store().keyOf(e);
  }
  store() {
    return this._dataSource.store();
  }
  items() {
    var e;
    return (e = this._dataSource) === null || e === void 0 ? void 0 : e.items();
  }
  applyMapFunction(e) {
    return this._dataSource._applyMapFunction(e);
  }
  getDataSource() {
    return this._dataSource ?? null;
  }
  reload() {
    return this._dataSource.reload();
  }
  on(e, t) {
    this._dataSource.on(e, t);
  }
  off(e, t) {
    this._dataSource.off(e, t);
  }
}
const tS = "dx-buttongroup-item-has-width", gg = {
  contained: "dx-buttongroup-mode-contained",
  outlined: "dx-buttongroup-mode-outlined",
  text: "dx-buttongroup-mode-text"
};
class ote extends vd {
  _initTemplates() {
    super._initTemplates(), this._templateManager.addDefaultTemplates({
      item: new rr((e, t, n) => {
        this._prepareItemStyles(e);
        const s = this.option("buttonTemplate");
        this._createComponent(e, wt, x({}, n, t, this._getBasicButtonOptions(), {
          _templateData: this._hasCustomTemplate(s) ? n : {},
          template: n.template || s
        }));
      }, ["text", "type", "icon", "disabled", "visible", "hint"], this.option("integrationOptions.watchMethod"))
    });
  }
  _getBasicButtonOptions() {
    const {
      hoverStateEnabled: e,
      activeStateEnabled: t,
      stylingMode: n
    } = this.option();
    return {
      focusStateEnabled: !1,
      onClick: null,
      hoverStateEnabled: e,
      activeStateEnabled: t,
      stylingMode: n
    };
  }
  _getDefaultOptions() {
    return I({}, super._getDefaultOptions(), {
      itemTemplateProperty: null
    });
  }
  _hasCustomTemplate(e) {
    return B(e) || this.option("integrationOptions.templates")[e];
  }
  _selectedItemClass() {
    return "dx-item-selected dx-state-selected";
  }
  _prepareItemStyles(e) {
    const t = e.data("dxItemIndex");
    t === 0 && e.addClass("dx-buttongroup-first-item");
    const {
      items: n
    } = this.option();
    n && t === n.length - 1 && e.addClass("dx-buttongroup-last-item"), e.addClass("dx-shape-standard");
  }
  _renderItemContent(e) {
    return e.container = p(e.container).parent(), super._renderItemContent(e);
  }
  _setAriaSelectionAttribute(e, t) {
    this.setAria("pressed", t, e);
  }
  _renderItemContentByNode(e, t) {
    return e.container = p(e.container.children().first()), super._renderItemContentByNode(e, t);
  }
  _focusTarget() {
    return this.$element().parent();
  }
  _keyboardEventBindingTarget() {
    return this._focusTarget();
  }
  _refreshContent() {
    this._prepareContent(), this._renderContent();
  }
  _itemClass() {
    return "dx-buttongroup-item";
  }
  _itemSelectHandler(e) {
    const {
      selectionMode: t
    } = this.option();
    t === "single" && this.isItemSelected(e.currentTarget) || super._itemSelectHandler(e);
  }
}
class OF extends Rt {
  _getDefaultOptions() {
    return I({}, super._getDefaultOptions(), {
      hoverStateEnabled: !0,
      focusStateEnabled: !0,
      selectionMode: "single",
      selectedItems: [],
      selectedItemKeys: [],
      stylingMode: "contained",
      keyExpr: "text",
      items: [],
      buttonTemplate: "content",
      onSelectionChanged: null,
      onItemClick: null
    });
  }
  _init() {
    super._init(), this._createItemClickAction();
  }
  _createItemClickAction() {
    this._itemClickAction = this._createActionByOption("onItemClick");
  }
  _initMarkup() {
    this.setAria("role", "group"), this.$element().addClass("dx-buttongroup"), this._renderStylingMode(), this._renderButtons(), this._syncSelectionOptions(), super._initMarkup();
  }
  _renderStylingMode() {
    const {
      stylingMode: e
    } = this.option();
    for (const t in gg)
      this.$element().removeClass(gg[t]);
    this.$element().addClass(gg[e ?? "contained"]);
  }
  _fireSelectionChangeEvent(e, t) {
    this._createActionByOption("onSelectionChanged", {
      excludeValidators: ["disabled", "readOnly"]
    })({
      addedItems: e,
      removedItems: t
    });
  }
  _renderButtons() {
    const e = p("<div>").addClass("dx-buttongroup-wrapper").appendTo(this.$element()), {
      selectedItems: t
    } = this.option(), n = {
      selectionMode: this.option("selectionMode"),
      items: this.option("items"),
      keyExpr: this.option("keyExpr"),
      buttonTemplate: this.option("buttonTemplate"),
      scrollingEnabled: !1,
      selectedItemKeys: this.option("selectedItemKeys"),
      focusStateEnabled: this.option("focusStateEnabled"),
      hoverStateEnabled: this.option("hoverStateEnabled"),
      activeStateEnabled: this.option("activeStateEnabled"),
      stylingMode: this.option("stylingMode"),
      accessKey: this.option("accessKey"),
      tabIndex: this.option("tabIndex"),
      noDataText: "",
      selectionRequired: !1,
      onItemRendered: (s) => {
        const o = this.option("width");
        f(o) && p(s.itemElement).addClass(tS);
      },
      onSelectionChanged: (s) => {
        this._syncSelectionOptions(), this._fireSelectionChangeEvent(s.addedItems, s.removedItems);
      },
      onItemClick: (s) => {
        this._itemClickAction(s);
      }
    };
    f(t) && t.length && (n.selectedItems = t), this._buttonsCollection = this._createComponent(e, ote, n);
  }
  _syncSelectionOptions() {
    this._setOptionWithoutOptionChange("selectedItems", this._buttonsCollection.option("selectedItems")), this._setOptionWithoutOptionChange("selectedItemKeys", this._buttonsCollection.option("selectedItemKeys"));
  }
  _optionChanged(e) {
    switch (e.name) {
      case "stylingMode":
      case "selectionMode":
      case "keyExpr":
      case "buttonTemplate":
      case "items":
      case "activeStateEnabled":
      case "focusStateEnabled":
      case "hoverStateEnabled":
      case "tabIndex":
        this._invalidate();
        break;
      case "selectedItemKeys":
      case "selectedItems":
        this._buttonsCollection.option(e.name, e.value);
        break;
      case "onItemClick":
        this._createItemClickAction();
        break;
      case "onSelectionChanged":
        break;
      case "width":
        super._optionChanged(e), this._buttonsCollection.itemElements().toggleClass(tS, !!e.value);
        break;
      default:
        super._optionChanged(e);
    }
  }
}
xe("dxButtonGroup", OF);
const rte = "dx-dropdownbutton-content";
class ate extends Rt {
  _getDefaultOptions() {
    return I({}, super._getDefaultOptions(), {
      itemTemplate: "item",
      keyExpr: "this",
      selectedItem: null,
      selectedItemKey: null,
      stylingMode: "outlined",
      deferRendering: !0,
      noDataText: S.format("dxCollectionWidget-noDataText"),
      useSelectMode: !1,
      splitButton: !1,
      showArrowIcon: !0,
      template: null,
      text: "",
      type: "normal",
      onButtonClick: null,
      onSelectionChanged: null,
      onItemClick: null,
      opened: !1,
      items: null,
      dataSource: null,
      focusStateEnabled: !0,
      hoverStateEnabled: !0,
      dropDownOptions: {},
      dropDownContentTemplate: "content",
      wrapItemText: !1,
      useItemTextAsTitle: !0,
      grouped: !1,
      groupTemplate: "group",
      buttonGroupOptions: {}
    });
  }
  _setOptionsByReference() {
    super._setOptionsByReference(), x(this._optionsByReference, {
      selectedItem: !0
    });
  }
  _init() {
    super._init(), this._createItemClickAction(), this._createActionClickAction(), this._createSelectionChangedAction(), this._initDataController(), this._compileKeyGetter(), this._compileDisplayGetter(), this._options.cache("buttonGroupOptions", this.option("buttonGroupOptions")), this._options.cache("dropDownOptions", this.option("dropDownOptions"));
  }
  _initDataController() {
    const e = this.option("dataSource");
    this._dataController = new ste(e ?? this.option("items"), {
      key: this.option("keyExpr")
    });
  }
  _initTemplates() {
    this._templateManager.addDefaultTemplates({
      content: new sa((e) => {
        const t = p(e.container), n = p("<div>").appendTo(t);
        this._list = this._createComponent(n, fa, this._listOptions()), this._list.registerKeyHandler("escape", this._escHandler.bind(this)), this._list.registerKeyHandler("tab", this._escHandler.bind(this)), this._list.registerKeyHandler("leftArrow", this._escHandler.bind(this)), this._list.registerKeyHandler("rightArrow", this._escHandler.bind(this));
      })
    }), super._initTemplates();
  }
  _compileKeyGetter() {
    this._keyGetter = Be(this._dataController.key());
  }
  _compileDisplayGetter() {
    const {
      displayExpr: e
    } = this.option();
    this._displayGetter = Be(e);
  }
  _initMarkup() {
    super._initMarkup(), this.$element().addClass("dx-dropdownbutton"), this._renderButtonGroup(), this._updateArrowClass(), f(this.option("selectedItemKey")) && this._loadSelectedItem().done(this._updateActionButton.bind(this));
  }
  _renderFocusTarget() {
  }
  _render() {
    (!this.option("deferRendering") || this.option("opened")) && this._renderPopup(), super._render();
  }
  _renderContentImpl() {
    return this._popup && this._renderPopupContent(), super._renderContentImpl();
  }
  _loadSelectedItem() {
    var e;
    (e = this._loadSingleDeferred) === null || e === void 0 || e.reject();
    const t = w();
    if (this._list && this._lastSelectedItemData !== void 0) {
      const s = this.option("useSelectMode") ? this._list.option("selectedItem") : this._lastSelectedItemData;
      return t.resolve(s);
    }
    this._lastSelectedItemData = void 0;
    const n = this.option("selectedItemKey");
    return this._dataController.loadSingle(n).done(t.resolve).fail(() => {
      t.reject(null);
    }), this._loadSingleDeferred = t, t.promise();
  }
  _createActionClickAction() {
    this._actionClickAction = this._createActionByOption("onButtonClick");
  }
  _createSelectionChangedAction() {
    this._selectionChangedAction = this._createActionByOption("onSelectionChanged");
  }
  _createItemClickAction() {
    this._itemClickAction = this._createActionByOption("onItemClick");
  }
  _fireSelectionChangedAction(e) {
    let {
      previousValue: t,
      value: n
    } = e;
    this._selectionChangedAction({
      item: n,
      previousItem: t
    });
  }
  _fireItemClickAction(e) {
    let {
      event: t,
      itemElement: n,
      itemData: s
    } = e;
    return this._itemClickAction({
      event: t,
      itemElement: n,
      itemData: this._actionItem || s
    });
  }
  _getButtonTemplate() {
    const {
      template: e,
      splitButton: t,
      showArrowIcon: n
    } = this.option();
    return e || (t || !n ? "content" : (s, o) => {
      let {
        text: r,
        icon: a
      } = s;
      const l = cs(a), d = r ? p("<span>").text(r).addClass("dx-button-text") : void 0, u = cs("spindown").addClass("dx-icon-right");
      p(o).append(l, d, u);
    });
  }
  _getActionButtonConfig() {
    const {
      icon: e,
      text: t,
      type: n,
      splitButton: s
    } = this.option(), o = {
      text: t,
      icon: e,
      type: n,
      template: this._getButtonTemplate(),
      elementAttr: {
        class: "dx-dropdownbutton-action"
      }
    };
    return s && (o.elementAttr.role = "menuitem"), o;
  }
  _getSpinButtonConfig() {
    const {
      type: e
    } = this.option();
    return {
      type: e,
      icon: "spindown",
      elementAttr: {
        class: "dx-dropdownbutton-toggle",
        role: "menuitem"
      }
    };
  }
  _getButtonGroupItems() {
    const {
      splitButton: e
    } = this.option(), t = [this._getActionButtonConfig()];
    return e && t.push(this._getSpinButtonConfig()), t;
  }
  _buttonGroupItemClick(e) {
    let {
      event: t,
      itemData: n
    } = e;
    const s = n.elementAttr.class === "dx-dropdownbutton-action";
    n.elementAttr.class === "dx-dropdownbutton-toggle" ? this.toggle() : s && (this._actionClickAction({
      event: t,
      selectedItem: this.option("selectedItem")
    }), this.option("splitButton") || this.toggle());
  }
  _getButtonGroupOptions() {
    const {
      accessKey: e,
      focusStateEnabled: t,
      hoverStateEnabled: n,
      splitButton: s,
      stylingMode: o,
      tabIndex: r
    } = this.option();
    return I({
      items: this._getButtonGroupItems(),
      width: "100%",
      height: "100%",
      selectionMode: "none",
      focusStateEnabled: t,
      hoverStateEnabled: n,
      stylingMode: o,
      accessKey: e,
      tabIndex: r,
      elementAttr: {
        role: s ? "menu" : "group"
      },
      onItemClick: this._buttonGroupItemClick.bind(this),
      onKeyboardHandled: (l) => this._keyboardHandler(l)
    }, this._options.cache("buttonGroupOptions"));
  }
  _renderPopupContent() {
    const e = this._popup.$content(), t = this._getTemplateByOption("dropDownContentTemplate");
    return e.empty(), this._popupContentId = `dx-${new Xe()}`, this.setAria("id", this._popupContentId, e), t.render({
      container: ee(e),
      model: this.option("items") || this._dataController.getDataSource()
    });
  }
  _popupOptions() {
    const e = this.option("rtlEnabled") ? "right" : "left";
    return x({
      dragEnabled: !1,
      focusStateEnabled: !1,
      deferRendering: this.option("deferRendering"),
      hideOnOutsideClick: (t) => {
        const n = this.$element();
        return !p(t.target).closest(".dx-dropdownbutton").is(n);
      },
      showTitle: !1,
      animation: {
        show: {
          type: "fade",
          duration: 0,
          from: 0,
          to: 1
        },
        hide: {
          type: "fade",
          duration: 400,
          from: 1,
          to: 0
        }
      },
      _ignoreFunctionValueDeprecation: !0,
      width: () => Ec(this.$element()),
      height: "auto",
      shading: !1,
      position: {
        of: this.$element(),
        collision: "flipfit",
        my: `${e} top`,
        at: `${e} bottom`
      },
      _wrapperClassExternal: "dx-dropdowneditor-overlay"
    }, this._options.cache("dropDownOptions"), {
      visible: this.option("opened")
    });
  }
  _listOptions() {
    const e = this.option("selectedItemKey"), t = this.option("useSelectMode");
    return {
      selectionMode: t ? "single" : "none",
      wrapItemText: this.option("wrapItemText"),
      focusStateEnabled: this.option("focusStateEnabled"),
      hoverStateEnabled: this.option("hoverStateEnabled"),
      useItemTextAsTitle: this.option("useItemTextAsTitle"),
      onContentReady: () => this._fireContentReadyAction(),
      selectedItemKeys: f(e) && t ? [e] : [],
      grouped: this.option("grouped"),
      groupTemplate: this.option("groupTemplate"),
      keyExpr: this._dataController.key(),
      noDataText: this.option("noDataText"),
      displayExpr: this.option("displayExpr"),
      itemTemplate: this.option("itemTemplate"),
      items: this.option("items"),
      dataSource: this._dataController.getDataSource(),
      onItemClick: (n) => {
        this.option("useSelectMode") || (this._lastSelectedItemData = n.itemData), this.option("selectedItemKey", this._keyGetter(n.itemData)), this._fireItemClickAction(n) !== !1 && (this.toggle(!1), this._buttonGroup.focus());
      }
    };
  }
  _upDownKeyHandler() {
    var e;
    return (e = this._popup) !== null && e !== void 0 && e.option("visible") && this._list ? this._list.focus() : this.open(), !0;
  }
  _escHandler() {
    return this.close(), this._buttonGroup.focus(), !0;
  }
  _tabHandler() {
    return this.close(), !0;
  }
  _renderPopup() {
    const e = p("<div>");
    this.$element().append(e), this._popup = this._createComponent(e, pi, this._popupOptions()), this._popup.$content().addClass(rte), this._popup.$wrapper().addClass("dx-dropdownbutton-popup-wrapper"), this._popup.$overlayContent().attr("aria-label", "Dropdown"), this._popup.on("hiding", this._popupHidingHandler.bind(this)), this._popup.on("showing", this._popupShowingHandler.bind(this)), this._bindInnerWidgetOptions(this._popup, "dropDownOptions");
  }
  _popupHidingHandler() {
    this.option("opened", !1), this._updateAriaAttributes(!1);
  }
  _popupOptionChanged(e) {
    const t = Rt.getOptionsFromContainer(e);
    this._setPopupOption(t);
    const n = Object.keys(t);
    (n.includes("width") || n.includes("height")) && this._dimensionChanged();
  }
  _dimensionChanged() {
    pC(this.option("dropDownOptions.width")) === void 0 && this._setPopupOption("width", () => Ec(this.$element()));
  }
  _setPopupOption(e, t) {
    this._setWidgetOption("_popup", arguments);
  }
  _popupShowingHandler() {
    this.option("opened", !0), this._updateAriaAttributes(!0);
  }
  _setElementAria(e) {
    const t = {
      owns: e ? this._popupContentId : void 0
    };
    this.setAria(t, this.$element());
  }
  _setButtonsAria(e) {
    const t = {
      expanded: e,
      haspopup: "listbox"
    }, n = {};
    this.option("text") || (n.label = "dropdownbutton"), this._getButtons().each((s, o) => {
      s === 0 ? this.setAria(I({}, n, t), p(o)) : this.setAria(t, p(o));
    });
  }
  _updateAriaAttributes(e) {
    this._setElementAria(e), this._setButtonsAria(e);
  }
  _getButtons() {
    return this._buttonGroup.$element().find(".dx-button");
  }
  _renderButtonGroup() {
    var e;
    const t = ((e = this._buttonGroup) === null || e === void 0 ? void 0 : e.$element()) || p("<div>");
    this._buttonGroup || this.$element().append(t), this._buttonGroup = this._createComponent(t, OF, this._getButtonGroupOptions()), this._buttonGroup.registerKeyHandler("downArrow", this._upDownKeyHandler.bind(this)), this._buttonGroup.registerKeyHandler("tab", this._tabHandler.bind(this)), this._buttonGroup.registerKeyHandler("upArrow", this._upDownKeyHandler.bind(this)), this._buttonGroup.registerKeyHandler("escape", this._escHandler.bind(this)), this._bindInnerWidgetOptions(this._buttonGroup, "buttonGroupOptions"), this._updateAriaAttributes(this.option("opened"));
  }
  _updateArrowClass() {
    const e = this.option("splitButton") || this.option("showArrowIcon");
    this.$element().toggleClass("dx-dropdownbutton-has-arrow", e);
  }
  toggle(e) {
    var t;
    return this._popup || (this._renderPopup(), this._renderContent()), (t = this._popup) === null || t === void 0 ? void 0 : t.toggle(e);
  }
  open() {
    return this.toggle(!0);
  }
  close() {
    return this.toggle(!1);
  }
  _setListOption(e, t) {
    var n;
    (n = this._list) === null || n === void 0 || n.option(e, t);
  }
  _getDisplayValue(e) {
    const n = !X(e) ? e : this._displayGetter(e);
    return X(n) ? "" : String(Qe(n, ""));
  }
  _updateActionButton(e) {
    this.option("useSelectMode") && this.option({
      text: this._getDisplayValue(e),
      icon: pe(e) ? e.icon : void 0
    }), this._setOptionWithoutOptionChange("selectedItem", e), this._setOptionWithoutOptionChange("selectedItemKey", this._keyGetter(e));
  }
  _clean() {
    var e, t;
    (e = this._list) === null || e === void 0 || e.$element().remove(), (t = this._popup) === null || t === void 0 || t.$element().remove();
  }
  _selectedItemKeyChanged(e) {
    this._setListOption("selectedItemKeys", this.option("useSelectMode") && f(e) ? [e] : []);
    const t = this.option("selectedItem");
    this._loadSelectedItem().always((n) => {
      this._updateActionButton(n), this._displayGetter(t) !== this._displayGetter(n) && this._fireSelectionChangedAction({
        previousValue: t,
        value: n
      });
    });
  }
  _updateButtonGroup(e, t) {
    this._buttonGroup.option(e, t), this._updateAriaAttributes(this.option("opened"));
  }
  _actionButtonOptionChanged(e) {
    let {
      name: t,
      value: n
    } = e;
    const s = {};
    s[t] = n, this._updateButtonGroup("items[0]", x({}, this._getActionButtonConfig(), s)), this._popup && this._popup.repaint();
  }
  _selectModeChanged(e) {
    if (e) {
      this._setListOption("selectionMode", "single");
      const t = this.option("selectedItemKey");
      this._setListOption("selectedItemKeys", f(t) ? [t] : []), this._selectedItemKeyChanged(this.option("selectedItemKey"));
    } else
      this._setListOption("selectionMode", "none"), this.option({
        selectedItemKey: void 0,
        selectedItem: void 0
      }), this._actionButtonOptionChanged({
        text: this.option("text")
      });
  }
  _updateItemCollection(e) {
    const t = this.option("selectedItemKey");
    this._setListOption("selectedItem", null), this._setWidgetOption("_list", [e]), f(t) && this._loadSelectedItem().done((n) => {
      this._setListOption("selectedItemKeys", [t]), this._setListOption("selectedItem", n);
    }).fail((n) => {
      this._setListOption("selectedItemKeys", []);
    }).always(this._updateActionButton.bind(this));
  }
  _updateDataController(e) {
    this._dataController.updateDataSource(e, this.option("keyExpr")), this._updateKeyExpr();
  }
  _updateKeyExpr() {
    this._compileKeyGetter(), this._setListOption("keyExpr", this._dataController.key());
  }
  focus() {
    this._buttonGroup.focus();
  }
  _optionChanged(e) {
    var t;
    const {
      name: n,
      value: s
    } = e;
    switch (n) {
      case "useSelectMode":
        this._selectModeChanged(s);
        break;
      case "splitButton":
        this._updateArrowClass(), this._renderButtonGroup();
        break;
      case "displayExpr":
        this._compileDisplayGetter(), this._setListOption(n, s), this._updateActionButton(this.option("selectedItem"));
        break;
      case "keyExpr":
        this._updateDataController();
        break;
      case "buttonGroupOptions":
        this._innerWidgetOptionChanged(this._buttonGroup, e);
        break;
      case "dropDownOptions":
        if (e.fullName === "dropDownOptions.visible")
          break;
        e.value.visible !== void 0 && delete e.value.visible, this._popupOptionChanged(e), this._innerWidgetOptionChanged(this._popup, e);
        break;
      case "opened":
        this.toggle(s);
        break;
      case "focusStateEnabled":
      case "hoverStateEnabled":
        this._setListOption(n, s), this._updateButtonGroup(n, s), super._optionChanged(e);
        break;
      case "items":
        this._updateDataController(this.option("items")), this._updateItemCollection(n);
        break;
      case "dataSource":
        this._dataController.updateDataSource(s), this._updateKeyExpr(), this._updateItemCollection(n);
        break;
      case "icon":
      case "text":
        this._actionButtonOptionChanged(e);
        break;
      case "showArrowIcon":
        this._updateArrowClass(), this._renderButtonGroup(), this._popup && this._popup.repaint();
        break;
      case "width":
      case "height":
        super._optionChanged(e), (t = this._popup) === null || t === void 0 || t.repaint();
        break;
      case "stylingMode":
      case "tabIndex":
        this._updateButtonGroup(n, s);
        break;
      case "type":
        this._updateButtonGroup("items", this._getButtonGroupItems());
        break;
      case "itemTemplate":
      case "grouped":
      case "noDataText":
      case "groupTemplate":
      case "wrapItemText":
      case "useItemTextAsTitle":
        this._setListOption(n, s);
        break;
      case "dropDownContentTemplate":
        this._renderContent();
        break;
      case "selectedItemKey":
        this._selectedItemKeyChanged(s);
        break;
      case "selectedItem":
        break;
      case "onItemClick":
        this._createItemClickAction();
        break;
      case "onButtonClick":
        this._createActionClickAction();
        break;
      case "onSelectionChanged":
        this._createSelectionChangedAction();
        break;
      case "deferRendering": {
        const {
          opened: o
        } = this.option();
        this.toggle(o);
        break;
      }
      case "template":
        this._renderButtonGroup();
        break;
      default:
        super._optionChanged(e);
    }
  }
  getDataSource() {
    return this._dataController.getDataSource();
  }
}
xe("dxDropDownButton", ate);
function lte(i, e) {
  const t = (d) => d || 1, n = [], s = (i[0] || []).reduce((d, u) => d + t(u.colspan), 0), o = ((d) => {
    let u = 0, c = 0;
    return () => {
      const h = d[u] || [], g = h[c++];
      return c >= h.length && (u++, c = 0), g && (g.colspan = t(g.colspan), g.rowspan = t(g.rowspan)), g;
    };
  })(i), r = (d, u, c) => {
    const h = n[d] = n[d] || [];
    if (h[u] = c, c.colspan > 1 || c.rowspan > 1) {
      const g = ((m) => x({}, m, e))(c);
      for (let m = 1; m < c.colspan; m++)
        r(d, u + m, g);
      for (let m = 1; m < c.rowspan; m++)
        for (let C = 0; C < c.colspan; C++)
          r(d + m, u + C, g);
    }
  };
  let a = o(), l = 0;
  for (; a; ) {
    for (let d = 0; d < s && a; d++)
      n[l] && n[l][d] || (r(l, d, a), d += a.colspan - 1, a = o());
    l++;
  }
  return n;
}
class dte {
  constructor(e, t, n) {
    this._exportController = e, this._initialColumnWidthsByColumnIndex = t, this._selectedRowsOnly = n;
  }
  _getGroupValue(e) {
    const {
      key: t,
      data: n,
      rowType: s,
      groupIndex: o,
      summaryCells: r
    } = e, a = this._options.groupColumns[o], l = J.getDisplayValue(a, a.deserializeValue ? a.deserializeValue(t[o]) : t[o], n, s);
    let d = `${a.caption}: ${J.formatValue(l, a)}`;
    return r && r[0] && r[0].length && (d += ` ${J.getGroupRowSummaryText(r[0], this._options.summaryTexts)}`), d;
  }
  _correctCellIndex(e) {
    return e;
  }
  _initOptions() {
    const e = this._exportController, t = e._columnsController.getGroupColumns();
    this._options = {
      columns: e._getColumns(this._initialColumnWidthsByColumnIndex),
      groupColumns: t,
      items: this._selectedRowsOnly || e._selectionOnly ? e._getSelectedItems() : e._getAllItems(),
      isHeadersVisible: e.option("showColumnHeaders"),
      summaryTexts: e.option("summary.texts"),
      rtlEnabled: e.option("rtlEnabled")
    };
  }
  getHeaderStyles() {
    return [{
      bold: !0,
      alignment: "center"
    }, {
      bold: !0,
      alignment: "left"
    }, {
      bold: !0,
      alignment: "right"
    }];
  }
  getGroupRowStyle() {
    return {
      bold: !0,
      alignment: ro(this._options.rtlEnabled)
    };
  }
  getColumnStyles() {
    const e = [];
    return this.getColumns().forEach((t) => {
      e.push({
        alignment: t.alignment || "left",
        format: t.format,
        dataType: t.dataType
      });
    }), e;
  }
  getStyles() {
    return [...this.getHeaderStyles(), ...this.getColumnStyles(), this.getGroupRowStyle()];
  }
  _getTotalCellStyleId(e) {
    var t;
    const n = ((t = this.getColumns()[e]) === null || t === void 0 ? void 0 : t.alignment) || "right";
    return this.getHeaderStyles().map((s) => s.alignment).indexOf(n);
  }
  getStyleId(e, t) {
    return e < this.getHeaderRowCount() ? 0 : this.isTotalCell(e - this.getHeaderRowCount(), t) ? this._getTotalCellStyleId(t) : this.isGroupRow(e - this.getHeaderRowCount()) ? this.getHeaderStyles().length + this.getColumns().length : t + this.getHeaderStyles().length;
  }
  getColumns(e) {
    const {
      columns: t
    } = this._options;
    return e ? t : t[t.length - 1];
  }
  getColumnsWidths() {
    const e = this.getColumns();
    return f(e) ? e.map((t) => t.width) : void 0;
  }
  getRowsCount() {
    return this._options.items.length + this.getHeaderRowCount();
  }
  getHeaderRowCount() {
    return this.isHeadersVisible() ? this._options.columns.length - 1 : 0;
  }
  isGroupRow(e) {
    return e < this._options.items.length && this._options.items[e].rowType === "group";
  }
  getGroupLevel(e) {
    const t = this._options.items[e - this.getHeaderRowCount()], n = t && t.groupIndex;
    return t && t.rowType === "totalFooter" ? 0 : f(n) ? n : this._options.groupColumns.length;
  }
  getCellType(e, t) {
    const n = this.getColumns();
    if (e < this.getHeaderRowCount())
      return "string";
    if (e -= this.getHeaderRowCount(), t < n.length) {
      const s = this._options.items.length && this._options.items[e], o = n[t];
      return s && s.rowType === "data" && isFinite(s.values[this._correctCellIndex(t)]) && !f(o.customizeText) ? f(o.lookup) ? o.lookup.dataType : o.dataType : "string";
    }
  }
  ready() {
    this._initOptions();
    const e = this._options;
    return W(e.items).done((t) => {
      e.items = t;
    }).fail(() => {
      e.items = [];
    });
  }
  _convertFromGridGroupSummaryItems(e) {
    if (f(e) && e.length > 0)
      return e.map((t) => ({
        value: t.value,
        name: t.name
      }));
  }
  getCellData(e, t, n) {
    let s, o;
    const r = {
      cellSourceData: {},
      value: s
    }, a = this.getColumns(), l = this._correctCellIndex(t);
    if (e < this.getHeaderRowCount())
      o = this.getColumns(!0)[e][t], r.cellSourceData.rowType = "header", r.cellSourceData.column = o && o.gridColumn, r.value = o && o.caption;
    else {
      e -= this.getHeaderRowCount();
      const d = this._options.items.length && this._options.items[e];
      if (d) {
        const u = d.values;
        switch (r.cellSourceData.rowType = d.rowType, r.cellSourceData.column = a[t] && a[t].gridColumn, d.rowType) {
          case "groupFooter":
          case "totalFooter":
            l < u.length && (s = u[l], f(s) ? (r.cellSourceData.value = s.value, r.cellSourceData.totalSummaryItemName = s.name, r.value = J.getSummaryText(s, this._options.summaryTexts)) : r.cellSourceData.value = void 0);
            break;
          case "group":
            if (r.cellSourceData.groupIndex = d.groupIndex, t < 1)
              r.cellSourceData.column = this._options.groupColumns[d.groupIndex], r.cellSourceData.value = d.key[d.groupIndex], r.cellSourceData.groupSummaryItems = this._convertFromGridGroupSummaryItems(d.summaryCells[0]), r.value = this._getGroupValue(d);
            else {
              const c = d.values[l];
              if (Array.isArray(c)) {
                r.cellSourceData.groupSummaryItems = this._convertFromGridGroupSummaryItems(c), s = "";
                for (let h = 0; h < c.length; h++)
                  s += (h > 0 ? n ? `
` : ` 
 ` : "") + J.getSummaryText(c[h], this._options.summaryTexts);
                r.value = s;
              } else
                r.cellSourceData.value = void 0;
            }
            break;
          default:
            if (o = a[t], o) {
              const c = u[l], h = J.getDisplayValue(o, c, d.data, d.rowType);
              !isFinite(h) || f(o.customizeText) ? n && f(o.customizeText) && o.customizeText === this._exportController._columnsController.getCustomizeTextByDataType("boolean") ? r.value = h : r.value = J.formatValue(h, o) : r.value = h, r.cellSourceData.value = c;
            }
            r.cellSourceData.data = d.data;
        }
      }
    }
    return r;
  }
  isHeadersVisible() {
    return this._options.isHeadersVisible;
  }
  isTotalCell(e, t) {
    const {
      items: n
    } = this._options, s = n[e], o = this._correctCellIndex(t), r = s.summaryCells && s.summaryCells[o] && s.summaryCells[o].length > 0 && s.summaryCells[o][0].alignByColumn;
    return s && s.rowType === "groupFooter" || s.rowType === "totalFooter" || r;
  }
  getCellMerging(e, t) {
    const {
      columns: n
    } = this._options, s = n[e] && n[e][t];
    return s ? {
      colspan: (s.exportColspan || 1) - 1,
      rowspan: (s.rowspan || 1) - 1
    } : {
      colspan: 0,
      rowspan: 0
    };
  }
  getFrozenArea() {
    return {
      x: 0,
      y: this.getHeaderRowCount()
    };
  }
}
class ute extends J.ViewController {
  init() {
    this.throwWarningIfNoOnExportingEvent(), this._columnsController = this.getController("columns"), this._dataController = this.getController("data"), this._selectionController = this.getController("selection"), this._rowsView = this.getView("rowsView"), this._headersView = this.getView("columnHeadersView"), this.createAction("onExporting", {
      excludeValidators: ["disabled", "readOnly"]
    });
  }
  _getEmptyCell() {
    return {
      caption: "",
      colspan: 1,
      rowspan: 1
    };
  }
  _updateColumnWidth(e, t) {
    e.width = t;
  }
  _getColumns(e) {
    let t = [], n, s;
    const o = this._columnsController, r = o.getRowCount();
    for (n = 0; n <= r; n++) {
      const a = [];
      s = o.getVisibleColumns(n, !0);
      let l;
      if (n === r)
        if (this._updateLockCount)
          l = e;
        else {
          const d = this._getColumnWidths(this._headersView, this._rowsView);
          if (d && d.length) {
            l = {};
            for (let u = 0; u < s.length; u++)
              l[s[u].index] = d[u];
          }
        }
      for (let d = 0; d < s.length; d++) {
        const u = x({}, s[d], {
          dataType: s[d].dataType === "datetime" ? "date" : s[d].dataType,
          gridColumn: s[d]
        });
        if (this._needColumnExporting(u)) {
          const c = this._calculateExportColspan(u);
          f(c) && (u.exportColspan = c), l && this._updateColumnWidth(u, l[u.index]), a.push(u);
        }
      }
      t.push(a);
    }
    return s = t[r], t = lte(t.slice(0, -1), this._getEmptyCell()), t.push(s), t;
  }
  _calculateExportColspan(e) {
    if (!e.isBand)
      return;
    const t = this._columnsController.getChildrenByBandColumn(e.index, !0);
    if (f(t))
      return t.reduce((n, s) => this._needColumnExporting(s) ? n + (this._calculateExportColspan(s) || 1) : n, 0);
  }
  _needColumnExporting(e) {
    return !e.command && (e.allowExporting || e.allowExporting === void 0);
  }
  _getFooterSummaryItems(e, t) {
    const n = [];
    let s = 1, o = 0;
    do {
      const r = [];
      for (let a = 0; a < e.length; a++) {
        const l = e[a], d = l.length;
        s < d && (s = d), r.push(l[o]);
      }
      n.push({
        values: r,
        rowType: t ? "totalFooter" : "groupFooter"
      });
    } while (o++ < s - 1);
    return n;
  }
  _hasSummaryGroupFooters() {
    const e = this.option("summary.groupItems");
    if (f(e)) {
      for (let t = 0; t < e.length; t++)
        if (e[t].showInGroupFooter)
          return !0;
    }
    return !1;
  }
  _getItemsWithSummaryGroupFooters(e) {
    let t = [], n = [], s = [];
    for (let o = 0; o < e.length; o++) {
      const r = e[o];
      r.rowType === "groupFooter" ? (s = this._getFooterSummaryItems(r.summaryCells), t = t.concat(n, s), n = []) : n.push(r);
    }
    return t.length ? t : n;
  }
  _updateGroupValuesWithSummaryByColumn(e) {
    let t = [];
    for (let n = 0; n < e.length; n++) {
      const s = e[n], {
        summaryCells: o
      } = s;
      if (s.rowType === "group" && o && o.length > 1) {
        const r = s.values.length;
        for (let a = 1; a < o.length; a++)
          for (let l = 0; l < o[a].length; l++) {
            const d = o[a][l];
            d && d.alignByColumn && (Array.isArray(t[a - r]) || (t[a - r] = []), t[a - r].push(d));
          }
        t.length > 0 && (s.values.push(...t), t = []);
      }
    }
  }
  _processUnExportedItems(e) {
    const t = this._columnsController.getVisibleColumns(null, !0), n = this._columnsController.getGroupColumns();
    let s, o;
    for (let r = 0; r < e.length; r++) {
      const a = e[r];
      let l = !1;
      s = [], o = [];
      for (let d = 0; d < t.length; d++) {
        const u = t[d];
        if (l || (l = ["detailExpand", "buttons"].includes(u.type)), this._needColumnExporting(u) && (a.values && (a.rowType === "group" && !s.length ? s.push(a.key[a.groupIndex]) : s.push(a.values[d])), a.summaryCells))
          if (a.rowType === "group" && !o.length) {
            const c = d - n.length + a.groupIndex;
            o.push(a.summaryCells[l ? c : c + 1]);
          } else
            o.push(a.summaryCells[d]);
      }
      s.length && (a.values = s), o.length && (a.summaryCells = o);
    }
  }
  _getAllItems(e) {
    let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !1;
    const n = this, s = new w(), o = this._dataController.footerItems(), r = o.length && o[0], a = n.option("summary.totalItems");
    let l;
    return W(e).done((d) => {
      this._dataController.loadAll(d, t).done((u, c) => {
        n._updateGroupValuesWithSummaryByColumn(u), n._hasSummaryGroupFooters() && (u = n._getItemsWithSummaryGroupFooters(u)), l = r && r.summaryCells, f(c) && a && (l = n._getSummaryCells(a, c));
        const h = r && n._getFooterSummaryItems(l, !0);
        h && (u = u.concat(h)), n._processUnExportedItems(u), s.resolve(u);
      }).fail(s.reject);
    }).fail(s.reject), s;
  }
  _getSummaryCells(e, t) {
    return this._dataController._calculateSummaryCells(e, t, this._columnsController.getVisibleColumns(null, !0), (n, s) => this._dataController._isDataColumn(s) ? s.index : -1);
  }
  _getSelectedItems() {
    return this.needLoadItemsOnExportingSelectedItems() ? this._getAllItems(this._selectionController.loadSelectedItemsWithFilter(), !0) : this._getAllItems(this._selectionController.getSelectedRowsData());
  }
  _getColumnWidths(e, t) {
    return e && e.isVisible() ? e.getColumnWidths() : t.getColumnWidths();
  }
  throwWarningIfNoOnExportingEvent() {
    var e, t;
    const n = (e = (t = this.component).hasActionSubscription) === null || e === void 0 ? void 0 : e.call(t, "onExporting");
    this.option("export.enabled") && !n && _e.log("W1024");
  }
  callbackNames() {
    return ["selectionOnlyChanged"];
  }
  getDataProvider(e) {
    const t = this._getColumnWidths(this._headersView, this._rowsView);
    let n;
    if (t && t.length) {
      n = {};
      const s = this._columnsController.getVisibleColumns(this._columnsController.getRowCount(), !0);
      for (let o = 0; o < s.length; o++)
        n[s[o].index] = t[o];
    }
    return new dte(this, n, e);
  }
  exportTo(e, t) {
    this._selectionOnly = e;
    const n = this.getAction("onExporting"), s = {
      rtlEnabled: this.option("rtlEnabled"),
      selectedRowsOnly: !!e,
      format: t,
      fileName: "DataGrid",
      cancel: !1
    };
    B(n) && n(s);
  }
  publicMethods() {
    return ["getDataProvider"];
  }
  selectionOnly(e) {
    if (f(e))
      this._isSelectedRows = e, this.selectionOnlyChanged.fire();
    else
      return this._isSelectedRows;
  }
  optionChanged(e) {
    super.optionChanged(e), e.name === "export" && this.throwWarningIfNoOnExportingEvent();
  }
  needLoadItemsOnExportingSelectedItems() {
    return this.option("loadItemsOnExportingSelectedItems") ?? this._dataController._dataSource.remoteOperations().filtering;
  }
}
const cte = (i) => class extends i {
  callbackNames() {
    const e = super.callbackNames();
    return f(e) ? e.push("editingButtonsUpdated") : ["editingButtonsUpdated"];
  }
  _updateEditButtons() {
    super._updateEditButtons(), this.editingButtonsUpdated.fire();
  }
}, hte = (i) => class extends i {
  _getToolbarItems() {
    const e = super._getToolbarItems(), t = this._getExportToolbarButton();
    return t && (e.push(t), this._correctItemsPosition(e)), e;
  }
  _getExportToolbarButton() {
    const e = this._getExportToolbarItems();
    if (e.length === 0)
      return null;
    const t = this._needDisableExportButton(), n = {
      name: "exportButton",
      location: "after",
      locateInMenu: "auto",
      sortIndex: 30,
      options: {
        items: e
      },
      disabled: t
    };
    if (e.length === 1) {
      const s = I({}, e[0], {
        hint: e[0].text,
        elementAttr: {
          class: "dx-datagrid-export-button"
        }
      });
      n.widget = "dxButton", n.showText = "inMenu", n.options = s;
    } else {
      const s = {
        icon: "export",
        displayExpr: "text",
        items: e,
        hint: this.option("export.texts.exportTo"),
        elementAttr: {
          class: "dx-datagrid-export-button"
        },
        dropDownOptions: {
          width: "auto",
          _wrapperClassExternal: "dx-datagrid-export-menu"
        }
      };
      n.options = s, n.widget = "dxDropDownButton", n.menuItemTemplate = (o, r, a) => {
        this._createComponent(p(a), fa, {
          items: e
        });
      };
    }
    return n;
  }
  _getExportToolbarItems() {
    const e = this.option("export"), t = this.option("export.texts"), n = this.option("export.formats") ?? [];
    if (!e.enabled)
      return [];
    const s = [];
    return n.forEach((o) => {
      let r = o.toUpperCase(), a = "export";
      o === "xlsx" && (r = "Excel", a = "xlsxfile"), o === "pdf" && (a = "pdffile"), s.push({
        text: Fi(t.exportAll, r),
        icon: a,
        onClick: () => {
          this._exportController.exportTo(!1, o);
        }
      }), e.allowExportSelectedData && s.push({
        text: Fi(t.exportSelectedRows, r),
        icon: "exportselected",
        onClick: () => {
          this._exportController.exportTo(!0, o);
        }
      });
    }), s;
  }
  _correctItemsPosition(e) {
    e.sort((t, n) => t.sortIndex - n.sortIndex);
  }
  _isExportButtonVisible() {
    return this.option("export.enabled");
  }
  optionChanged(e) {
    super.optionChanged(e), e.name === "export" && (e.handled = !0, this._invalidate());
  }
  _needDisableExportButton() {
    const e = !this._columnsController.hasVisibleDataColumns(), t = this._editingController.hasChanges();
    return e || t;
  }
  _columnOptionChanged(e) {
    if (super._columnOptionChanged(e), J.checkChanges(e.optionNames, ["groupIndex", "visible", "all"])) {
      const n = this._needDisableExportButton();
      this.setToolbarItemDisabled("exportButton", n);
    }
  }
  init() {
    super.init(), this._exportController = this.getController("export"), this._editingController.editingButtonsUpdated.add(() => {
      const e = this._needDisableExportButton();
      this.setToolbarItemDisabled("exportButton", e);
    });
  }
};
J.registerModule("export", {
  defaultOptions: () => ({
    export: {
      enabled: !1,
      fileName: "DataGrid",
      formats: ["xlsx"],
      allowExportSelectedData: !1,
      texts: {
        exportTo: S.format("dxDataGrid-exportTo"),
        exportAll: S.format("dxDataGrid-exportAll"),
        exportSelectedRows: S.format("dxDataGrid-exportSelectedRows")
      }
    }
  }),
  controllers: {
    export: ute
  },
  extenders: {
    controllers: {
      editing: cte
    },
    views: {
      headerPanel: hte
    }
  }
});
const pte = (i, e, t) => {
  let {
    isRemoteFiltering: n,
    dateSerializationFormat: s,
    getSelector: o
  } = t;
  const {
    selector: r
  } = i, a = B(r) ? r : o(r), l = a ? a(e) : e[r], d = n && cn(l) ? pt.serializeDate(l, s) : l;
  return {
    getter: a,
    rawValue: l,
    safeValue: d
  };
}, gte = {
  getSortFilterValue: pte
}, mte = ".dx-row.dx-row-focused";
class fte extends Ue.ViewController {
  getKeyboardController() {
    return this.getController("keyboardNavigation");
  }
  getDataController() {
    return this.getController("data");
  }
  init() {
    this.component._optionsByReference.focusedRowKey = !0;
  }
  optionChanged(e) {
    const {
      name: t,
      value: n,
      previousValue: s
    } = e;
    switch (t) {
      case "focusedRowIndex":
        this._focusRowByIndex(n), this.getKeyboardController()._fireFocusedRowChanged(), e.handled = !0;
        break;
      case "focusedRowKey":
        if (Array.isArray(n) && JSON.stringify(n) === JSON.stringify(s))
          return;
        this._focusRowByKey(n), this.getKeyboardController()._fireFocusedRowChanged(), e.handled = !0;
        break;
      case "focusedColumnIndex":
      case "focusedRowEnabled":
      case "autoNavigateToFocusedRow":
        e.handled = !0;
        break;
      default:
        super.optionChanged(e);
    }
  }
  publicMethods() {
    return ["navigateToRow", "isRowFocused"];
  }
  isAutoNavigateToFocusedRow() {
    return this.option("scrolling.mode") !== "infinite" && this.option("autoNavigateToFocusedRow");
  }
  _focusRowByIndex(e, t) {
    if (!this.option("focusedRowEnabled"))
      return;
    const n = this.getDataController().isEmpty(), s = this._getCurrentFocusRowIndex(n, e);
    s < 0 ? (n || this.isAutoNavigateToFocusedRow()) && this._resetFocusedRow() : this._focusRowByIndexCore(s, t);
  }
  _getCurrentFocusRowIndex(e, t) {
    let n = t;
    return n === void 0 && (e ? n = -1 : n = this.option("focusedRowIndex")), n;
  }
  _focusRowByIndexCore(e, t) {
    const n = this.getDataController().pageSize(), s = () => {
      if (this._isValidFocusedRowIndex(e)) {
        let o = e - this.getDataController().getRowIndexOffset(!0);
        if (!t || t.paging && !t.filtering) {
          const a = this.getDataController()._getLastItemIndex();
          o = Math.min(o, a);
        }
        const r = this.getDataController().getKeyByRowIndex(o, !0);
        f(r) && !this.isRowFocused(r) && this.option("focusedRowKey", r);
      }
    };
    if (n >= 0)
      if (this._isLocalRowIndex(e))
        s();
      else {
        const o = Math.floor(e / this.getDataController().pageSize());
        W(this.getDataController().pageIndex(o), this.getDataController().waitReady()).done(() => {
          s();
        });
      }
  }
  _isLocalRowIndex(e) {
    if (this.getKeyboardController()._isVirtualScrolling()) {
      const n = Math.floor(e / this.getDataController().pageSize()), s = this.getDataController().virtualItemsCount(), o = s ? s.begin : -1, r = this.getDataController().getVisibleRows().length + this.getDataController().getRowIndexOffset(), a = Math.ceil(r / this.getDataController().pageSize());
      return o <= e && a > n;
    }
    return !0;
  }
  _setFocusedRowKeyByIndex(e) {
    if (this._isValidFocusedRowIndex(e)) {
      const t = Math.min(e - this.getDataController().getRowIndexOffset(), this.getDataController().items().length - 1), n = this.getDataController().getKeyByRowIndex(t);
      f(n) && !this.isRowFocused(n) && this.option("focusedRowKey", n);
    }
  }
  _focusRowByKey(e) {
    f(e) ? this._navigateToRow(e, !0) : this._resetFocusedRow();
  }
  _resetFocusedRow() {
    const e = this.option("focusedRowKey"), t = f(e);
    !t && this.option("focusedRowIndex") < 0 || (t && this.option("focusedRowKey", null), this.getKeyboardController().setFocusedRowIndex(-1), this.option("focusedRowIndex", -1), this.getDataController().updateItems({
      changeType: "updateFocusedRow",
      focusedRowKey: null
    }), this.getKeyboardController()._fireFocusedRowChanged());
  }
  _isValidFocusedRowIndex(e) {
    const t = this.getDataController().getVisibleRows()[e];
    return !t || t.rowType === "data" || t.rowType === "group";
  }
  navigateToRow(e) {
    return this.isAutoNavigateToFocusedRow() || this.option("focusedRowIndex", -1), this._navigateToRow(e);
  }
  _navigateToRow(e, t) {
    const n = this, s = n.isAutoNavigateToFocusedRow(), o = new w(), r = this.getView("rowsView");
    if (e === void 0 || !this.getDataController().dataSource())
      return o.reject().promise();
    const a = n.getFocusedRowIndexByKey(e);
    return !s && t || a >= 0 ? n._navigateTo(e, o, t) : this.getDataController().getPageIndexByKey(e).done((l) => {
      if (l < 0) {
        o.resolve(-1);
        return;
      }
      l === this.getDataController().pageIndex() ? this.getDataController().reload().done(() => {
        n.isRowFocused(e) && this.getDataController().getRowIndexByKey(e) >= 0 ? o.resolve(n.getFocusedRowIndexByKey(e)) : n._navigateTo(e, o, t);
      }).fail(o.reject) : this.getDataController().pageIndex(l).done(() => {
        r.waitAsyncTemplates(!0).done(() => {
          n._navigateTo(e, o, t);
        });
      }).fail(o.reject);
    }).fail(o.reject), o.promise();
  }
  _navigateTo(e, t, n) {
    const s = this.getDataController().getRowIndexByKey(e), o = F.isVirtualRowRendering(this);
    this.isAutoNavigateToFocusedRow() && o && s < 0 ? this._navigateToVirtualRow(e, t, n) : this._navigateToVisibleRow(e, t, n);
  }
  _navigateToVisibleRow(e, t, n) {
    if (n)
      this._triggerUpdateFocusedRow(e, t);
    else {
      const s = this.getFocusedRowIndexByKey(e);
      this.getView("rowsView").scrollToRowElement(e, t).done(() => {
        t.resolve(s);
      });
    }
  }
  _navigateToVirtualRow(e, t, n) {
    const s = this.getDataController()._rowsScrollController, o = F.getIndexByKey(e, this.getDataController().items(!0)), r = this.getView("rowsView").getScrollable();
    if (s && r && o >= 0) {
      const a = o + this.getDataController().getRowIndexOffset(!0), l = s.getItemOffset(a), d = () => {
        this.getDataController().totalCount() && !this.getDataController().items().length || (this.component.off("contentReady", d), n ? this._triggerUpdateFocusedRow(e, t) : t.resolve(a));
      };
      this.component.on("contentReady", d), this.getView("rowsView").scrollTopPosition(l);
    } else
      t.resolve(-1);
  }
  _triggerUpdateFocusedRow(e, t) {
    const n = this.getFocusedRowIndexByKey(e);
    if (this._isValidFocusedRowIndex(n)) {
      let s;
      this.option("focusedRowEnabled") ? this.getDataController().updateItems({
        changeType: "updateFocusedRow",
        focusedRowKey: e
      }) : s = this.getView("rowsView").scrollToRowElement(e), W(s).done(() => {
        this.getKeyboardController().setFocusedRowIndex(n), t && t.resolve(n);
      });
    } else
      t && t.resolve(-1);
  }
  getFocusedRowIndexByKey(e) {
    const t = this.getDataController().getRowIndexByKey(e, !0);
    return t >= 0 ? t + this.getDataController().getRowIndexOffset(!0) : -1;
  }
  _focusRowByKeyOrIndex() {
    const e = this.option("focusedRowKey");
    let t = this.option("focusedRowIndex");
    if (f(e)) {
      const n = this.getDataController().getRowIndexByKey(e);
      n >= 0 ? (this.getKeyboardController()._isVirtualScrolling() && (t = n + this.getDataController().getRowIndexOffset()), this.getKeyboardController().setFocusedRowIndex(t), this._triggerUpdateFocusedRow(e)) : this._navigateToRow(e, !0).done((s) => {
        t >= 0 && s < 0 ? this._focusRowByIndex() : t < 0 && s >= 0 && this.getKeyboardController().setFocusedRowIndex(s);
      });
    } else
      t >= 0 && this._focusRowByIndex(t);
  }
  isRowFocused(e) {
    const t = this.option("focusedRowKey");
    if (f(t))
      return He(e, this.option("focusedRowKey"));
  }
  updateFocusedRow(e) {
    const t = this, n = t.getDataController().getRowIndexByKey(e.focusedRowKey), s = t.getView("rowsView");
    let o, r;
    y(s.getTableElements(), (a, l) => {
      const d = a === 0;
      o = p(l), t._clearPreviousFocusedRow(o, n);
      const u = t._prepareFocusedRow({
        changedItem: t.getDataController().getVisibleRows()[n],
        $tableElement: o,
        focusedRowIndex: n
      });
      d && (r = u);
    }), !e.preventScroll && r && s.scrollToElementVertically(r);
  }
  _clearPreviousFocusedRow(e, t) {
    const n = e.find(mte).filter((s, o) => {
      const r = p(o).closest(`.${this.addWidgetPrefix("table")}`);
      return e.is(r);
    });
    n.removeClass("dx-row-focused").removeClass("dx-cell-focus-disabled").removeAttr("tabindex"), n.children("td").removeAttr("tabindex"), t !== 0 && p(this.getView("rowsView").getRowElement(0)).removeClass("dx-cell-focus-disabled").removeAttr("tabIndex");
  }
  _prepareFocusedRow(e) {
    let t;
    const {
      changedItem: n
    } = e;
    if (n && (n.rowType === "data" || n.rowType === "group")) {
      const {
        focusedRowIndex: s
      } = e, {
        $tableElement: o
      } = e, r = this.option("tabindex") || 0, a = this.getView("rowsView");
      t = p(a._getRowElements(o).eq(s)), t.addClass("dx-row-focused").attr("tabindex", r);
    }
    return t;
  }
}
const _te = (i) => class extends i {
  init() {
    const e = this.option("focusedRowIndex"), t = this.option("focusedColumnIndex");
    this.createAction("onFocusedRowChanging", {
      excludeValidators: ["disabled", "readOnly"]
    }), this.createAction("onFocusedRowChanged", {
      excludeValidators: ["disabled", "readOnly"]
    }), this.createAction("onFocusedCellChanging", {
      excludeValidators: ["disabled", "readOnly"]
    }), this.createAction("onFocusedCellChanged", {
      excludeValidators: ["disabled", "readOnly"]
    }), super.init(), this.setRowFocusType(), this._focusedCellPosition = {}, f(e) && e >= 0 && (this._focusedCellPosition.rowIndex = e), f(t) && t >= 0 && (this._focusedCellPosition.columnIndex = t);
  }
  setFocusedRowIndex(e) {
    super.setFocusedRowIndex(e), this.option("focusedRowIndex", e);
  }
  setFocusedColumnIndex(e) {
    super.setFocusedColumnIndex(e), this.option("focusedColumnIndex", e);
  }
  _escapeKeyHandler(e, t) {
    return t || !this.option("focusedRowEnabled") ? super._escapeKeyHandler(e, t) : this.isCellFocusType() ? (this.setRowFocusType(), this._focus(this._getCellElementFromTarget(e.originalEvent.target), !0), !0) : !1;
  }
  _updateFocusedCellPosition(e, t) {
    const n = super._updateFocusedCellPosition(e, t);
    return n && n.columnIndex >= 0 && this._fireFocusedCellChanged(e), n;
  }
}, Cte = (i) => class extends i {
  renderFocusOverlay(e, t) {
    var n;
    const s = this.option("focusedRowEnabled");
    let o;
    !s || !((n = this._keyboardNavigationController) !== null && n !== void 0 && n.isRowFocusType()) || this._editingController.isEditing() ? super.renderFocusOverlay(e, t) : s && this._keyboardNavigationController._getElementType(e) === "row" && !e.hasClass("dx-row-focused") && (o = this._keyboardNavigationController.getFirstValidCellInRow(e), this._keyboardNavigationController.focus(o));
  }
}, vte = (i) => class extends i {
  getSortDataSourceParameters(e, t) {
    let n = super.getSortDataSourceParameters.apply(this, arguments);
    const s = this._dataController._dataSource, o = this._dataController.store();
    let r = o && o.key();
    const a = s && s.remoteOperations() || {}, l = Object.keys(a).every((d) => !a[d]);
    if (r && (this.option("focusedRowEnabled") && this._focusController.isAutoNavigateToFocusedRow() !== !1 || t)) {
      r = Array.isArray(r) ? r : [r];
      const d = r.filter((u) => !this.columnOption(u, "sortOrder"));
      d.length && (n = n || [], l ? n.push({
        selector: s.getDataIndexGetter(),
        desc: !1
      }) : d.forEach((u) => n.push({
        selector: u,
        desc: !1
      })));
    }
    return n;
  }
}, xte = (i) => class extends i {
  constructor() {
    super(...arguments), this._needToUpdateFocusedRowByIndex = !1;
  }
  _applyChange(e) {
    if (!(e && e.changeType === "updateFocusedRow"))
      return super._applyChange.apply(this, arguments);
  }
  _fireChanged(e) {
    if (super._fireChanged(e), this.option("focusedRowEnabled") && this._dataSource) {
      const n = e.changeType === "update" && e.repaintChangesOnly && e.changeTypes && e.changeTypes.indexOf("remove") >= 0;
      this._needToUpdateFocusedRowByIndex ? (this._needToUpdateFocusedRowByIndex = !1, this._focusController._focusRowByIndex()) : e.changeType === "refresh" && e.items.length || n ? (this._updatePageIndexes(), this._updateFocusedRow(e)) : e.changeType === "append" || e.changeType === "prepend" ? this._updatePageIndexes() : e.changeType === "update" && e.repaintChangesOnly && this._updateFocusedRow(e);
    }
  }
  _handleDataPushed(e) {
    super._handleDataPushed(e);
    const t = this.option("focusedRowKey");
    this._needToUpdateFocusedRowByIndex = e?.some((n) => n.type === "remove" && He(n.key, t));
  }
  _updatePageIndexes() {
    const e = this._lastRenderingPageIndex || 0, t = this._rowsScrollController ? this._rowsScrollController.pageIndex() : 0;
    this._lastRenderingPageIndex = t, this._isPagingByRendering = t !== e;
  }
  isPagingByRendering() {
    return this._isPagingByRendering;
  }
  _updateFocusedRow(e) {
    const t = e.operationTypes || {}, {
      reload: n,
      fullReload: s,
      pageIndex: o,
      paging: r
    } = t, a = this._keyboardNavigationController._isVirtualScrolling(), l = r && !a, d = this.option("focusedRowKey"), u = this._focusController.isAutoNavigateToFocusedRow();
    if (n && o === !1 && !s && f(d))
      this._focusController._navigateToRow(d, !0).done((h) => {
        h < 0 && this._focusController._focusRowByIndex(void 0, t);
      });
    else if (l && u) {
      const h = this.getRowIndexByKey(d), g = this.option("focusedRowIndex"), m = h >= 0;
      g >= 0 && (g === h || !m) && this._focusController._focusRowByIndex(g, t);
    } else
      l && !u && this.getRowIndexByKey(d) < 0 ? this.option("focusedRowIndex", -1) : t.fullReload && this._focusController._focusRowByKeyOrIndex();
  }
  getPageIndexByKey(e) {
    const t = this, n = new w();
    return t.getGlobalRowIndexByKey(e).done((s) => {
      n.resolve(s >= 0 ? Math.floor(s / t.pageSize()) : -1);
    }).fail(n.reject), n.promise();
  }
  getGlobalRowIndexByKey(e) {
    return this._dataSource.group() ? this._calculateGlobalRowIndexByGroupedData(e) : this._calculateGlobalRowIndexByFlatData(e);
  }
  _calculateGlobalRowIndexByFlatData(e, t, n) {
    const s = this, o = new w(), r = s._dataSource;
    if (Array.isArray(e) || QX(e))
      return o.resolve(-1).promise();
    let a = s._generateFilterByKey(e);
    return r.load({
      filter: s._concatWithCombinedFilter(a),
      skip: 0,
      take: 1
    }).done((l) => {
      l.length > 0 ? (a = s._generateOperationFilterByKey(e, l[0], n), r.load({
        filter: s._concatWithCombinedFilter(a, t),
        skip: 0,
        take: 1,
        requireTotalCount: !0
      }).done((d, u) => {
        o.resolve(u.totalCount);
      })) : o.resolve(-1);
    }), o.promise();
  }
  _concatWithCombinedFilter(e, t) {
    const n = this.getCombinedFilter();
    return F.combineFilters([e, n, t]);
  }
  _generateBooleanFilter(e, t, n) {
    const {
      desc: s
    } = n;
    switch (!0) {
      case (t === !1 && s):
        return [e, "=", !0];
      case (t === !1 && !s):
        return [e, "=", null];
      case (t === !0 && !s):
      case (!Zr(t) && s):
        return [e, "<>", t];
      default:
        return;
    }
  }
  _generateOperationFilterByKey(e, t, n) {
    const s = this, o = s.option("dateSerializationFormat"), r = s._dataSource.remoteOperations().filtering, a = s._dataSource.remoteOperations().sorting;
    let l = s._generateFilterByKey(e, "<"), d = s._columnsController.getSortDataSourceParameters(!r, !0);
    if (n) {
      const u = s._columnsController.getGroupDataSourceParameters(!r);
      u && (d = d ? u.concat(d) : u);
    }
    return d && d.slice().reverse().forEach((u) => {
      const {
        selector: c,
        desc: h,
        compare: g
      } = u, {
        getter: m,
        rawValue: C,
        safeValue: v
      } = gte.getSortFilterValue(u, t, {
        isRemoteFiltering: r,
        dateSerializationFormat: o,
        getSelector: (E) => s._columnsController.columnOption(E, "selector")
      });
      if (l = [
        [c, "=", v],
        "and",
        l
      ], C === null || Zr(C)) {
        const E = s._generateBooleanFilter(c, v, h);
        E && (l = [E, "or", l]);
      } else {
        const E = h ? ">" : "<";
        let T;
        g && !a ? T = (V) => E === "<" ? g(C, m(V)) >= 1 : g(C, m(V)) <= -1 : (T = [c, E, v], h || (T = [T, "or", [c, "=", null]])), l = [T, "or", l];
      }
    }), l;
  }
  _generateFilterByKey(e, t) {
    const n = this._dataSource.key();
    let s = [];
    if (t || (t = "="), Array.isArray(n))
      for (let o = 0; o < n.length; ++o) {
        const r = e[n[o]];
        r && (s.length > 0 && s.push("and"), s.push([n[o], t, r]));
      }
    else
      s = [n, t, e];
    return s;
  }
  _getLastItemIndex() {
    return this.items(!0).length - 1;
  }
}, yte = (i) => class extends i {
  _deleteRowCore(e) {
    const t = super._deleteRowCore.apply(this, arguments), n = this._dataController.getKeyByRowIndex(e);
    t.done(() => {
      const s = this._dataController.getRowIndexByKey(n), o = this._dataController.getVisibleRows();
      s === -1 && !o.length && this._focusController._resetFocusedRow();
    });
  }
}, bte = (i) => class extends i {
  _createRow(e) {
    const t = super._createRow.apply(this, arguments);
    return this.option("focusedRowEnabled") && e && this._focusController.isRowFocused(e.key) && t.addClass("dx-row-focused"), t;
  }
  _checkRowKeys(e) {
    if (super._checkRowKeys.apply(this, arguments), this.option("focusedRowEnabled") && this.option("dataSource")) {
      const t = this._dataController.store();
      t && !t.key() && this._dataController.fireError("E1042", "Row focusing");
    }
  }
  _update(e) {
    e.changeType === "updateFocusedRow" ? this.option("focusedRowEnabled") && this._focusController.updateFocusedRow(e) : super._update(e);
  }
  updateFocusElementTabIndex(e, t) {
    this.option("focusedRowEnabled") ? this._setFocusedRowElementTabIndex(t) : super.updateFocusElementTabIndex(e);
  }
  _setFocusedRowElementTabIndex(e) {
    const t = this.option("focusedRowKey"), n = this.option("tabIndex") ?? 0, s = this._columnsController;
    let o = this._dataController.getRowIndexByKey(t), r = this.option("focusedColumnIndex");
    const a = this._findRowElementForTabIndex(), l = this._dataController.dataSource(), d = l?.operationTypes(), u = !d || d.paging;
    f(this._scrollToFocusOnResize) || (this._scrollToFocusOnResize = () => {
      this.scrollToElementVertically(this._findRowElementForTabIndex()), this.resizeCompleted.remove(this._scrollToFocusOnResize);
    }), a.attr("tabIndex", n);
    const c = this.option("focusedRowIndex") - this._dataController.getRowIndexOffset(!0);
    !u && o < 0 && c >= 0 && this._focusController.updateFocusedRow({
      focusedRowKey: t,
      preventScroll: e
    }), o >= 0 && !e && (r < 0 && (r = 0), o += this._dataController.getRowIndexOffset(), r += s.getColumnIndexOffset(), this._keyboardNavigationController.setFocusedCellPosition(o, r), this._focusController.isAutoNavigateToFocusedRow() && !u && !this._dataController.isPagingByRendering() && (this.resizeCompleted.remove(this._scrollToFocusOnResize), this.resizeCompleted.add(this._scrollToFocusOnResize)));
  }
  _findRowElementForTabIndex() {
    const e = this.option("focusedRowKey"), t = this._dataController.getRowIndexByKey(e);
    return p(this.getRowElement(t >= 0 ? t : 0));
  }
  scrollToRowElement(e) {
    const t = this._dataController.getRowIndexByKey(e), n = p(this.getRow(t));
    return this.scrollToElementVertically(n);
  }
  scrollToElementVertically(e) {
    const t = this.getScrollable();
    if (t && e.length) {
      const n = t.getScrollElementPosition(e, "vertical");
      return this.scrollTopPosition(n);
    }
    return new w().resolve();
  }
  scrollTopPosition(e) {
    const t = new w(), n = this.getScrollable();
    if (n) {
      const s = n.scrollTop(), o = () => {
        n.off("scroll", o), t.resolve();
      };
      if (e !== s)
        return n.on("scroll", o), this._dataController.resetFilterApplying(), n.scrollTo({
          top: e
        }), t.promise();
    }
    return t.resolve();
  }
}, Wu = {
  defaultOptions: () => ({
    focusedRowEnabled: !1,
    autoNavigateToFocusedRow: !0,
    focusedRowKey: null,
    focusedRowIndex: -1,
    focusedColumnIndex: -1
  }),
  controllers: {
    focus: fte
  },
  extenders: {
    controllers: {
      keyboardNavigation: _te,
      editorFactory: Cte,
      columns: vte,
      data: xte,
      editing: yte
    },
    views: {
      rowsView: bte
    }
  }
}, wte = Number.MAX_SAFE_INTEGER || 9007199254740991, Ste = (i) => class extends Wu.extenders.controllers.data(i) {
  changeRowExpand(e, t) {
    return this.option("focusedRowEnabled") && Array.isArray(e) && this.isRowExpanded(e) && (!t || !this._keyboardNavigationController.isKeyboardEnabled()) && this._isFocusedRowInsideGroup(e) && this.option("focusedRowKey", e), super.changeRowExpand(e, t);
  }
  _isFocusedRowInsideGroup(e) {
    const t = this.option("focusedRowKey"), n = this.getRowIndexByKey(t), s = n >= 0 && this.getVisibleRows()[n], o = this._columnsController.getGroupDataSourceParameters(!0);
    if (s) {
      for (let r = 0; r < e.length; ++r)
        if (Be(o[r] && o[r].selector)(s.data) !== e[r])
          return !1;
    }
    return !0;
  }
  _getGroupPath(e, t) {
    const n = [];
    let s = [e];
    for (; s && s[0] && t; ) {
      const o = s[0];
      o.key !== void 0 && n.push(o.key), s = o.items, t--;
    }
    return n;
  }
  _expandGroupByPath(e, t, n) {
    const s = new w();
    return n++, e.expandRow(t.slice(0, n)).done(() => {
      n === t.length ? s.resolve() : e._expandGroupByPath(e, t, n).done(s.resolve).fail(s.reject);
    }).fail(s.reject), s.promise();
  }
  _calculateGlobalRowIndexByGroupedData(e) {
    const t = this, n = t._dataSource, s = t._generateFilterByKey(e), o = new w(), r = Array.isArray(e), a = n.group();
    return r ? o.resolve(-1).promise() : n._grouping._updatePagingOptions ? (n.load({
      filter: t._concatWithCombinedFilter(s),
      group: a
    }).done((l) => {
      if (!l || l.length === 0 || !f(l[0].key) || l[0].key === -1)
        return o.resolve(-1).promise();
      const d = t._getGroupPath(l[0], a.length);
      t._expandGroupByPath(t, d, 0).done(() => {
        t._calculateExpandedRowGlobalIndex(o, e, d, a);
      }).fail(o.reject);
    }).fail(o.reject), o.promise()) : (t._calculateGlobalRowIndexByFlatData(e, null, !0).done(o.resolve).fail(o.reject), o);
  }
  _calculateExpandedRowGlobalIndex(e, t, n, s) {
    const o = Zo(n, {
      group: s
    }), r = this._dataSource, a = this.option("scrolling.mode"), l = a === "virtual" || a === "infinite", d = r.pageSize();
    let u;
    r._grouping._updatePagingOptions({
      skip: 0,
      take: wte
    }, (c, h) => {
      He(c.path, n) && (u = h);
    }), this._calculateGlobalRowIndexByFlatData(t, o).done((c) => {
      let h, g;
      if (c < 0) {
        e.resolve(-1);
        return;
      }
      h = (u % d || d) + c - n.length, l ? g = 0 : g = Math.floor(h / (d - n.length)) * n.length, h = u + c + g, e.resolve(h);
    }).fail(e.reject);
  }
};
J.registerModule("focus", I({}, Wu, {
  extenders: I({}, Wu.extenders, {
    controllers: I({}, Wu.extenders.controllers, {
      data: Ste
    })
  })
}));
const nS = fe(), Pi = "dxDraggable", Ete = R(Rl, Pi), Ite = R(oa, Pi), Dte = R(Fl, Pi), Tte = R(uh, Pi), Ote = R(ch, Pi), Ate = R(ye.down, Pi), Rte = R("keydown", Pi);
let mg, hu;
const rf = (i) => ({
  x: i.pageX - p(nS).scrollLeft(),
  y: i.pageY - p(nS).scrollTop()
});
class iS {
  constructor(e, t) {
    this._$scrollableAtPointer = null, this._preventScroll = !0, this._component = t, e === "vertical" ? (this._scrollValue = "scrollTop", this._overFlowAttr = "overflowY", this._sizeAttr = "height", this._scrollSizeProp = "scrollHeight", this._clientSizeProp = "clientHeight", this._limitProps = {
      start: "top",
      end: "bottom"
    }) : (this._scrollValue = "scrollLeft", this._overFlowAttr = "overflowX", this._sizeAttr = "width", this._scrollSizeProp = "scrollWidth", this._clientSizeProp = "clientWidth", this._limitProps = {
      start: "left",
      end: "right"
    });
  }
  updateScrollable(e, t) {
    let n = !1;
    e.some((s) => {
      const o = p(s), r = o.hasClass("dx-overlay-wrapper"), a = o.hasClass("dx-overlay-content");
      return r || a ? !0 : (n = this._trySetScrollable(s, t), n);
    }), n || (this._$scrollableAtPointer = null, this._scrollSpeed = 0);
  }
  isScrolling() {
    return !!this._scrollSpeed;
  }
  isScrollable(e) {
    return (e.css(this._overFlowAttr) === "auto" || e.hasClass("dx-scrollable-container")) && e.prop(this._scrollSizeProp) > Math.ceil(this._sizeAttr === "width" ? ne(e) : le(e));
  }
  _trySetScrollable(e, t) {
    const n = this, s = p(e);
    let o;
    const r = n._component.option("scrollSensitivity");
    let a = n.isScrollable(s);
    return a && (o = n._calculateDistanceToBorders(s, t), r > o[n._limitProps.start] ? n._preventScroll || (n._scrollSpeed = -n._calculateScrollSpeed(o[n._limitProps.start]), n._$scrollableAtPointer = s) : r > o[n._limitProps.end] ? n._preventScroll || (n._scrollSpeed = n._calculateScrollSpeed(o[n._limitProps.end]), n._$scrollableAtPointer = s) : (a = !1, n._preventScroll = !1)), a;
  }
  _calculateDistanceToBorders(e, t) {
    const n = e.get(0);
    let s;
    return n ? (s = Ge(n), {
      left: t.x - s.left,
      top: t.y - s.top,
      right: s.right - t.x,
      bottom: s.bottom - t.y
    }) : {};
  }
  _calculateScrollSpeed(e) {
    const t = this._component, n = t.option("scrollSensitivity"), s = t.option("scrollSpeed");
    return Math.ceil(((n - e) / n) ** 2 * s);
  }
  scrollByStep() {
    const e = this;
    if (e._$scrollableAtPointer && e._scrollSpeed) {
      if (e._$scrollableAtPointer.hasClass("dx-scrollable-container")) {
        const n = e._$scrollableAtPointer.closest(".dx-scrollable"), s = n.data("dxScrollable") || n.data("dxScrollView");
        if (s) {
          const o = s.scrollOffset()[e._limitProps.start] + e._scrollSpeed;
          s.scrollTo({
            [e._limitProps.start]: o
          });
        }
      } else {
        const n = e._$scrollableAtPointer[e._scrollValue]() + e._scrollSpeed;
        e._$scrollableAtPointer[e._scrollValue](n);
      }
      const t = e._component._dragMoveArgs;
      t && e._component._dragMoveHandler(t);
    }
  }
  reset() {
    this._$scrollableAtPointer = null, this._scrollSpeed = 0, this._preventScroll = !0;
  }
  isOutsideScrollable(e, t) {
    if (!e)
      return !1;
    const n = Ge(e.get(0)), s = n[this._limitProps.start], o = n[this._sizeAttr], r = rf(t), a = this._sizeAttr === "width" ? r.x : r.y;
    return a < s || a > s + o;
  }
}
class Fte extends FO {
  ctor(e) {
    super.ctor(), this._strategy = e;
  }
  _step() {
    const e = this._strategy._horizontalScrollHelper, t = this._strategy._verticalScrollHelper;
    e?.scrollByStep(), t?.scrollByStep();
  }
}
class AF extends ui {
  reset() {
  }
  dragMove(e) {
  }
  dragEnter() {
  }
  dragLeave() {
  }
  dragEnd(e) {
    return this._getSourceDraggable()._fireRemoveEvent(e), w().resolve();
  }
  _fireRemoveEvent(e) {
  }
  _getDefaultOptions() {
    return I({}, super._getDefaultOptions(), {
      onDragStart: null,
      onDragMove: null,
      onDragEnd: null,
      onDragEnter: null,
      onDragLeave: null,
      onDragCancel: null,
      onCancelByEsc: !1,
      onDrop: null,
      immediate: !0,
      dragDirection: "both",
      boundOffset: 0,
      allowMoveByClick: !1,
      itemData: null,
      contentTemplate: "content",
      handle: "",
      filter: "",
      clone: !1,
      autoScroll: !0,
      scrollSpeed: 30,
      scrollSensitivity: 60
    });
  }
  _setOptionsByReference() {
    super._setOptionsByReference.apply(this, arguments), x(this._optionsByReference, {
      component: !0,
      group: !0,
      itemData: !0,
      data: !0
    });
  }
  _init() {
    super._init(), this._attachEventHandlers(), this._scrollAnimator = new Fte(this), this._horizontalScrollHelper = new iS("horizontal", this), this._verticalScrollHelper = new iS("vertical", this), this._initScrollTop = 0, this._initScrollLeft = 0;
  }
  _normalizeCursorOffset(e) {
    return X(e) && (e = {
      h: e.x,
      v: e.y
    }), e = er(e).map((t) => parseFloat(t)), {
      left: e[0],
      top: e.length === 1 ? e[0] : e[1]
    };
  }
  _getNormalizedCursorOffset(e, t) {
    return B(e) && (e = e.call(this, t)), this._normalizeCursorOffset(e);
  }
  _calculateElementOffset(e) {
    let t, n;
    const {
      event: s
    } = e, o = p(e.itemElement), r = p(e.dragElement), a = this._dragElementIsCloned(), l = this.option("cursorOffset");
    let d = {
      left: 0,
      top: 0
    };
    const u = this._initialLocate = Nn(r);
    return (a || e.initialOffset || l) && (t = e.initialOffset || o.offset(), l && (d = this._getNormalizedCursorOffset(l, e), isFinite(d.left) && (t.left = s.pageX), isFinite(d.top) && (t.top = s.pageY)), n = r.offset(), t.top -= n.top + (d.top || 0) - u.top, t.left -= n.left + (d.left || 0) - u.left), t;
  }
  _initPosition(e) {
    const t = p(e.dragElement), n = this._calculateElementOffset(e);
    n && this._move(n, t), this._startPosition = Nn(t);
  }
  _startAnimator() {
    this._scrollAnimator.inProgress() || this._scrollAnimator.start();
  }
  _stopAnimator() {
    this._scrollAnimator.stop();
  }
  _addWidgetPrefix(e) {
    const t = this.NAME;
    return Hl(t) + (e ? `-${e}` : "");
  }
  _getItemsSelector() {
    return this.option("filter") || "";
  }
  _$content() {
    const e = this.$element(), t = e.children(".dx-template-wrapper");
    return t.length ? t : e;
  }
  _attachEventHandlers() {
    if (this.option("disabled"))
      return;
    let e = this._$content(), t = this._getItemsSelector();
    const n = this.option("allowMoveByClick"), s = {
      direction: this.option("dragDirection"),
      immediate: this.option("immediate"),
      checkDropTarget: (o, r) => {
        const a = this.option("group"), l = this._getSourceDraggable().option("group"), d = this._getScrollable(o);
        return this._verticalScrollHelper.isOutsideScrollable(d, r) || this._horizontalScrollHelper.isOutsideScrollable(d, r) ? !1 : l && l === a;
      }
    };
    n && (e = this._getArea(), _.on(e, Ate, s, this._pointerDownHandler.bind(this))), t[0] === ">" && (t = t.slice(1)), _.on(e, Ete, t, s, this._dragStartHandler.bind(this)), _.on(e, Ite, s, this._dragMoveHandler.bind(this)), _.on(e, Dte, s, this._dragEndHandler.bind(this)), _.on(e, Tte, s, this._dragEnterHandler.bind(this)), _.on(e, Ote, s, this._dragLeaveHandler.bind(this)), this.option("onCancelByEsc") && _.on(e, Rte, this._keydownHandler.bind(this));
  }
  _dragElementIsCloned() {
    var e;
    return (e = this._$dragElement) === null || e === void 0 ? void 0 : e.hasClass(this._addWidgetPrefix("clone"));
  }
  _getDragTemplateArgs(e, t) {
    return {
      container: ee(t),
      model: {
        itemData: this.option("itemData"),
        itemElement: ee(e)
      }
    };
  }
  _createDragElement(e) {
    let t = e;
    const n = this.option("clone"), s = this._getContainer();
    let o = this.option("dragTemplate");
    return o ? (o = this._getTemplate(o), t = p("<div>").appendTo(s), o.render(this._getDragTemplateArgs(e, t))) : n && (t = p("<div>").appendTo(s), e.clone().css({
      width: e.css("width"),
      height: e.css("height")
    }).appendTo(t)), t.toggleClass(this._addWidgetPrefix("clone"), t.get(0) !== e.get(0)).toggleClass("dx-rtl", this.option("rtlEnabled"));
  }
  _resetDragElement() {
    if (this._dragElementIsCloned()) {
      var e;
      (e = this._$dragElement) === null || e === void 0 || e.remove();
    } else
      this._toggleDraggingClass(!1);
    this._$dragElement = null;
  }
  _resetSourceElement() {
    this._toggleDragSourceClass(!1), this._$sourceElement = null;
  }
  _detachEventHandlers() {
    _.off(this._$content(), `.${Pi}`), _.off(this._getArea(), `.${Pi}`);
  }
  _move(e, t) {
    Ot(t || this._$dragElement, e);
  }
  _getDraggableElement(e) {
    const t = this._getSourceElement();
    if (t)
      return t;
    if (this.option("allowMoveByClick"))
      return this.$element();
    let s = p(e?.target);
    const o = this._getItemsSelector();
    if (o[0] === ">") {
      const r = this._$content().find(o);
      r.is(s) || (s = s.closest(r));
    }
    return s;
  }
  _getSourceElement() {
    return this._getSourceDraggable()._$sourceElement;
  }
  _pointerDownHandler(e) {
    if (NI(e))
      return;
    const t = {}, n = this.$element(), {
      dragDirection: s
    } = this.option();
    (s === "horizontal" || s === "both") && (t.left = e.pageX - n.offset().left + Nn(n).left - ne(n) / 2), (s === "vertical" || s === "both") && (t.top = e.pageY - n.offset().top + Nn(n).top - le(n) / 2), this._move(t, n), this._getAction("onDragMove")(this._getEventArgs(e));
  }
  _isValidElement(e, t) {
    var n;
    const {
      handle: s
    } = this.option(), o = p((n = e.originalEvent) === null || n === void 0 ? void 0 : n.target);
    return s && !o.closest(s).length || !t.length ? !1 : !t.is(".dx-state-disabled, .dx-state-disabled *");
  }
  _dragStartHandler(e) {
    const t = this._getDraggableElement(e);
    if (this.dragInProgress = !0, !this._isValidElement(e, t)) {
      e.cancel = !0;
      return;
    }
    if (this._$sourceElement)
      return;
    const n = this._getDragStartArgs(e, t);
    if (this._getAction("onDragStart")(n), n.cancel) {
      e.cancel = !0;
      return;
    }
    this.option("itemData", n.itemData), this._setSourceDraggable(), this._$sourceElement = t;
    let s = t.offset();
    !this._hasClonedDraggable() && this.option("autoScroll") && (this._initScrollTop = this._getScrollableScrollTop(), this._initScrollLeft = this._getScrollableScrollLeft(), s = this._getDraggableElementOffset(s.left, s.top));
    const o = this._$dragElement = this._createDragElement(t);
    this._toggleDraggingClass(!0), this._toggleDragSourceClass(!0), this._setGestureCoverCursor(o.children());
    const r = o.css("position") === "fixed";
    this._initPosition(x({}, n, {
      dragElement: o.get(0),
      initialOffset: r && s
    })), this._getAction("onDraggableElementShown")(I({}, n, {
      dragElement: o
    }));
    const a = this._getArea(), l = this._getAreaOffset(a), d = this._getBoundOffset(), u = Ee(a), c = he(a), h = ne(o), g = le(o), m = o.offset().left - l.left, C = o.offset().top - l.top;
    a.length && (e.maxLeftOffset = m - d.left, e.maxRightOffset = u - m - h - d.right, e.maxTopOffset = C - d.top, e.maxBottomOffset = c - C - g - d.bottom), this.option("autoScroll") && this._startAnimator();
  }
  _getAreaOffset(e) {
    return e && Un.offset(e) || {
      left: 0,
      top: 0
    };
  }
  _toggleDraggingClass(e) {
    var t;
    (t = this._$dragElement) === null || t === void 0 || t.toggleClass(this._addWidgetPrefix("dragging"), e);
  }
  _toggleDragSourceClass(e, t) {
    const n = t || this._$sourceElement;
    n?.toggleClass(this._addWidgetPrefix("source"), e);
  }
  _setGestureCoverCursor(e) {
    p(".dx-gesture-cover").css("cursor", e.css("cursor"));
  }
  _getBoundOffset() {
    let e = this.option("boundOffset");
    return B(e) && (e = e.call(this)), DN(e);
  }
  _getArea() {
    let e = this.option("boundary");
    return B(e) && (e = e.call(this)), p(e);
  }
  _getContainer() {
    let {
      container: e
    } = this.option();
    return e === void 0 && (e = Ys()), p(e);
  }
  _getDraggableElementOffset(e, t) {
    var n, s;
    const o = this._initScrollTop, r = this._initScrollLeft, a = this._getScrollableScrollTop(), l = this._getScrollableScrollLeft(), u = p(this.element()).css("position") === "fixed", c = {
      left: (((n = this._startPosition) === null || n === void 0 ? void 0 : n.left) ?? 0) + e,
      top: (((s = this._startPosition) === null || s === void 0 ? void 0 : s.top) ?? 0) + t
    };
    return u || this._hasClonedDraggable() ? c : {
      left: $e(l) ? c.left + l - r : c.left,
      top: $e(a) ? c.top + a - o : c.top
    };
  }
  _hasClonedDraggable() {
    return this.option("clone") || this.option("dragTemplate");
  }
  _dragMoveHandler(e) {
    if (this._dragMoveArgs = e, !this._$dragElement) {
      e.cancel = !0;
      return;
    }
    const t = this._getDraggableElementOffset(e.offset.x, e.offset.y);
    this._move(t), this._updateScrollable(e);
    const n = this._getEventArgs(e);
    if (this._getAction("onDragMove")(n), n.cancel === !0)
      return;
    this._getTargetDraggable().dragMove(e, scrollBy);
  }
  _updateScrollable(e) {
    const t = this;
    if (t.option("autoScroll")) {
      const n = rf(e), s = O.elementsFromPoint(n.x, n.y, this.$element().get(0));
      t._verticalScrollHelper.updateScrollable(s, n), t._horizontalScrollHelper.updateScrollable(s, n);
    }
  }
  _getScrollable(e) {
    let t;
    return e.parents().toArray().some((n) => {
      const s = p(n);
      return this._horizontalScrollHelper.isScrollable(s) || this._verticalScrollHelper.isScrollable(s) ? (t = s, !0) : !1;
    }), t;
  }
  _getScrollableScrollTop() {
    var e;
    return ((e = this._getScrollable(p(this.element()))) === null || e === void 0 ? void 0 : e.scrollTop()) ?? 0;
  }
  _getScrollableScrollLeft() {
    var e;
    return ((e = this._getScrollable(p(this.element()))) === null || e === void 0 ? void 0 : e.scrollLeft()) ?? 0;
  }
  _defaultActionArgs() {
    const e = super._defaultActionArgs.apply(this, arguments), t = this.option("component");
    return t && (e.component = t, e.element = t.element()), e;
  }
  _getEventArgs(e) {
    const t = this._getSourceDraggable(), n = this._getTargetDraggable();
    return {
      event: e,
      itemData: t.option("itemData"),
      itemElement: ee(t._$sourceElement),
      fromComponent: t.option("component") || t,
      toComponent: n.option("component") || n,
      fromData: t.option("data"),
      toData: n.option("data")
    };
  }
  _getDragStartArgs(e, t) {
    const n = this._getEventArgs(e);
    return {
      event: n.event,
      itemData: n.itemData,
      itemElement: t,
      fromData: n.fromData
    };
  }
  _revertItemToInitialPosition() {
    !this._dragElementIsCloned() && this._move(this._initialLocate, this._$sourceElement);
  }
  _dragEndHandler(e) {
    const t = w(), n = this._getEventArgs(e), s = this._getEventArgs(e), o = this._getTargetDraggable();
    let r = !0;
    this.dragInProgress = !1;
    try {
      this._getAction("onDragEnd")(n);
    } finally {
      W(It(n.cancel)).done((a) => {
        if (!a && (o !== this && o._getAction("onDrop")(s), !s.cancel)) {
          r = !1, W(It(o.dragEnd(n))).always(t.resolve);
          return;
        }
        t.resolve();
      }).fail(t.resolve), t.done(() => {
        r && this._revertItemToInitialPosition(), this._resetDragOptions(o);
      });
    }
  }
  _isTargetOverAnotherDraggable(e) {
    const t = this._getSourceDraggable();
    if (this === t)
      return !1;
    const n = t._$dragElement, s = t.$element(), o = this.$element(), r = rf(e), l = O.elementsFromPoint(r.x, r.y, this.element()).filter((h) => {
      const g = p(h);
      return g.hasClass(this._addWidgetPrefix()) ? !g.closest(n).length : !1;
    })[0], d = this._getSourceElement(), u = l === s.get(0), c = p(l).closest(d).length;
    return !l || l === o.get(0) && !u && !c;
  }
  _dragEnterHandler(e) {
    this._fireDragEnterEvent(e), this._isTargetOverAnotherDraggable(e) && this._setTargetDraggable(), this._getSourceDraggable().dragEnter(e);
  }
  _dragLeaveHandler(e) {
    this._fireDragLeaveEvent(e), this._resetTargetDraggable(), this !== this._getSourceDraggable() && this.reset(), this._getSourceDraggable().dragLeave(e);
  }
  _keydownHandler(e) {
    this.dragInProgress && e.key === "Escape" && this._keydownEscapeHandler(e);
  }
  _keydownEscapeHandler(e) {
    var t;
    if (!this._getSourceElement())
      return;
    const s = this._getEventArgs(e);
    if (this._getAction("onDragCancel")(s), s.cancel)
      return;
    this.dragInProgress = !1, (t = hu) === null || t === void 0 || t._toggleDraggingClass(!1), this._detachEventHandlers(), this._revertItemToInitialPosition();
    const o = this._getTargetDraggable();
    this._resetDragOptions(o), this._attachEventHandlers();
  }
  _getAction(e) {
    return this[`_${e}Action`] || this._createActionByOption(e);
  }
  _getAnonymousTemplateName() {
    return "content";
  }
  _initTemplates() {
    this.option("contentTemplate") && (this._templateManager.addDefaultTemplates({
      content: new Lo()
    }), super._initTemplates.apply(this, arguments));
  }
  _render() {
    super._render(), this.$element().addClass(this._addWidgetPrefix());
    const e = this._templateManager.anonymousTemplateName === this.option("contentTemplate"), t = this._getTemplateByOption("contentTemplate");
    t && p(t.render({
      container: this.element(),
      transclude: e
    }));
  }
  _optionChanged(e) {
    const {
      name: t
    } = e;
    switch (t) {
      case "onDragStart":
      case "onDragMove":
      case "onDragEnd":
      case "onDrop":
      case "onDragEnter":
      case "onDragLeave":
      case "onDragCancel":
      case "onDraggableElementShown":
        this[`_${t}Action`] = this._createActionByOption(t);
        break;
      case "dragTemplate":
      case "contentTemplate":
      case "container":
      case "clone":
      case "scrollSensitivity":
      case "scrollSpeed":
      case "boundOffset":
      case "handle":
      case "group":
      case "data":
      case "itemData":
        break;
      case "allowMoveByClick":
      case "dragDirection":
      case "disabled":
      case "boundary":
      case "filter":
      case "immediate":
        this._resetDragElement(), this._detachEventHandlers(), this._attachEventHandlers();
        break;
      case "onCancelByEsc":
        this._keydownHandler();
        break;
      case "autoScroll":
        this._verticalScrollHelper.reset(), this._horizontalScrollHelper.reset();
        break;
      default:
        super._optionChanged(e);
    }
  }
  _getTargetDraggable() {
    return mg || this;
  }
  _getSourceDraggable() {
    return hu || this;
  }
  _setTargetDraggable() {
    const e = this.option("group"), t = this._getSourceDraggable();
    e && e === t.option("group") && (mg = this);
  }
  _setSourceDraggable() {
    hu = this;
  }
  _resetSourceDraggable() {
    hu = null;
  }
  _resetTargetDraggable() {
    mg = null;
  }
  _resetDragOptions(e) {
    this.reset(), e.reset(), this._stopAnimator(), this._horizontalScrollHelper.reset(), this._verticalScrollHelper.reset(), this._resetDragElement(), this._resetSourceElement(), this._resetTargetDraggable(), this._resetSourceDraggable();
  }
  _dispose() {
    super._dispose(), this._detachEventHandlers(), this._resetDragElement(), this._resetTargetDraggable(), this._resetSourceDraggable(), this._$sourceElement = null, this._stopAnimator();
  }
  _fireDragEnterEvent(e) {
    const t = this._getEventArgs(e);
    this._getAction("onDragEnter")(t);
  }
  _fireDragLeaveEvent(e) {
    const t = this._getEventArgs(e);
    this._getAction("onDragLeave")(t);
  }
}
xe(Pi, AF);
const sS = fe(), kte = "dxSortable", oS = (i) => p(i).is(":visible"), Vte = (i, e) => {
  var t, n;
  if (!i)
    return;
  const s = ((t = e.to) === null || t === void 0 ? void 0 : t.left) || 0, o = ((n = e.to) === null || n === void 0 ? void 0 : n.top) || 0;
  i.style.transform = `translate(${s}px,${o}px)`, i.style.transition = `transform ${e.duration}ms ${e.easing}`;
}, Pte = (i) => {
  i && (i.style.transform = "", i.style.transition = "");
};
function Mte(i) {
  const e = i.offset(), {
    style: t
  } = i[0], n = parseFloat(t.paddingLeft) || 0, s = parseFloat(t.paddingRight) || 0, o = parseFloat(t.paddingTop) || 0, r = i[0].clientWidth - (n + s), a = le(i), l = e.left + n, d = e.top + o;
  return {
    left: l,
    right: l + r,
    top: d,
    bottom: d + a
  };
}
class RF extends AF {
  _init() {
    super._init(), this._sourceScrollHandler = this._handleSourceScroll.bind(this), this._sourceScrollableInfo = null;
  }
  _getDefaultOptions() {
    return I({}, super._getDefaultOptions(), {
      clone: !0,
      filter: "> *",
      itemOrientation: "vertical",
      dropFeedbackMode: "push",
      allowDropInsideItem: !1,
      allowReordering: !0,
      moveItemOnDrop: !1,
      onDragChange: null,
      onAdd: null,
      onRemove: null,
      onReorder: null,
      onPlaceholderPrepared: null,
      animation: {
        type: "slide",
        duration: 300,
        easing: "ease"
      },
      fromIndex: null,
      toIndex: null,
      dropInsideItem: !1,
      itemPoints: null,
      fromIndexOffset: 0,
      offset: 0,
      autoUpdate: !1,
      draggableElementSize: 0
    });
  }
  reset() {
    this.option({
      dropInsideItem: !1,
      toIndex: null,
      fromIndex: null,
      itemPoints: null,
      fromIndexOffset: 0,
      draggableElementSize: 0
    }), this._$placeholderElement && this._$placeholderElement.remove(), this._$placeholderElement = null, !this._isIndicateMode() && this._$modifiedItem && (this._$modifiedItem.css("marginBottom", this._modifiedItemMargin), this._$modifiedItem = null);
  }
  _getPrevVisibleItem(e, t) {
    return e.slice(0, t).reverse().filter(oS)[0];
  }
  _dragStartHandler(e) {
    if (super._dragStartHandler.apply(this, arguments), e.cancel === !0)
      return;
    const t = this._getSourceElement();
    this._updateItemPoints(), this._subscribeToSourceScroll(e), this.option("fromIndex", this._getElementIndex(t)), this.option("fromIndexOffset", this.option("offset"));
  }
  _subscribeToSourceScroll(e) {
    const t = this._getScrollable(p(e.target));
    t && (this._sourceScrollableInfo = {
      element: t,
      scrollLeft: t.scrollLeft(),
      scrollTop: t.scrollTop()
    }, _.off(t, "scroll", this._sourceScrollHandler), _.on(t, "scroll", this._sourceScrollHandler));
  }
  _unsubscribeFromSourceScroll() {
    this._sourceScrollableInfo && (_.off(this._sourceScrollableInfo.element, "scroll", this._sourceScrollHandler), this._sourceScrollableInfo = null);
  }
  _handleSourceScroll(e) {
    const t = this._sourceScrollableInfo;
    t && ["scrollLeft", "scrollTop"].forEach((n) => {
      if (e.target[n] !== t[n]) {
        const s = e.target[n] - t[n];
        this._correctItemPoints(s), this._movePlaceholder(), t[n] = e.target[n];
      }
    });
  }
  _dragEnterHandler(e) {
    if (super._dragEnterHandler.apply(this, arguments), this !== this._getSourceDraggable() && (this._subscribeToSourceScroll(e), this._updateItemPoints(), this.option("fromIndex", -1), !this._isIndicateMode())) {
      const t = this.option("itemPoints"), n = t[t.length - 1];
      if (n) {
        const s = this.$element(), o = this._getSourceElement(), r = this._isVerticalOrientation(), a = r ? he(o, !0) : Ee(o, !0), l = s.get(0)[r ? "scrollHeight" : "scrollWidth"], d = s.get(0)[r ? "scrollTop" : "scrollLeft"], u = r ? "top" : "left", c = n[u], g = s.offset()[u] + l - d - c;
        if (g < a && r) {
          const m = this._getItems(), C = p(this._getPrevVisibleItem(m));
          this._$modifiedItem = C, this._modifiedItemMargin = C.get(0).style.marginBottom, C.css("marginBottom", a - g);
          const v = C.closest(".dx-sortable"), E = v.data("dxScrollable") || v.data("dxScrollView");
          E?.update();
        }
      }
    }
  }
  _dragLeaveHandler() {
    super._dragLeaveHandler.apply(this, arguments), this !== this._getSourceDraggable() && this._unsubscribeFromSourceScroll();
  }
  dragEnter() {
    this !== this._getTargetDraggable() && this.option("toIndex", -1);
  }
  dragLeave() {
    this !== this._getTargetDraggable() && this.option("toIndex", this.option("fromIndex"));
  }
  _allowDrop(e) {
    const n = this._getTargetDraggable().$element(), s = this._getScrollable(n);
    if (s) {
      const {
        left: o,
        right: r,
        top: a,
        bottom: l
      } = Mte(s), d = this.option("toIndex"), u = this.option("itemPoints"), c = u?.filter((h) => h.index === d)[0];
      if (c && c.top !== void 0)
        return this._isVerticalOrientation() ? a <= Math.ceil(c.top) && Math.floor(c.top) <= l : o <= Math.ceil(c.left) && Math.floor(c.left) <= r;
    }
    return !0;
  }
  dragEnd(e) {
    this._unsubscribeFromSourceScroll();
    const t = this._getSourceElement(), n = this._getSourceDraggable(), s = n.NAME !== this.NAME, o = this.option("toIndex"), {
      event: r
    } = e, a = this._allowDrop(r);
    if (o !== null && o >= 0 && a) {
      let l, d;
      if (n !== this && (l = this._fireAddEvent(r), l || (d = this._fireRemoveEvent(r))), s && id(t), this.option("moveItemOnDrop") && !l && this._moveItem(t, o, d), n === this)
        return this._fireReorderEvent(r);
    }
    return w().resolve();
  }
  dragMove(e) {
    const t = this.option("itemPoints");
    if (!t)
      return;
    const n = this._isVerticalOrientation(), s = n ? "top" : "left", o = n ? e.pageY : e.pageX, r = this.option("rtlEnabled");
    let a;
    for (let l = t.length - 1; l >= 0; l--) {
      const d = t[l + 1] && (t[l][s] + t[l + 1][s]) / 2;
      if ((!n && r ? o > d : d > o) || d === void 0)
        a = t[l];
      else
        break;
    }
    a && (this._updatePlaceholderPosition(e, a), this._verticalScrollHelper.isScrolling() && this._isIndicateMode() && this._movePlaceholder());
  }
  _isIndicateMode() {
    return this.option("dropFeedbackMode") === "indicate" || this.option("allowDropInsideItem");
  }
  _createPlaceholder() {
    let e;
    return this._isIndicateMode() && (e = p("<div>").addClass(this._addWidgetPrefix("placeholder")).insertBefore(this._getSourceDraggable()._$dragElement)), this._$placeholderElement = e, e;
  }
  _getItems() {
    const e = this._getItemsSelector();
    return this._$content().find(e).not(`.${this._addWidgetPrefix("placeholder")}`).not(`.${this._addWidgetPrefix("clone")}`).toArray();
  }
  _allowReordering() {
    const e = this._getSourceDraggable(), t = this._getTargetDraggable();
    return e !== t || this.option("allowReordering");
  }
  _isValidPoint(e, t, n) {
    const s = this.option("allowDropInsideItem");
    return !(n || this._allowReordering()) && (e !== 0 || !s) ? !1 : this._isIndicateMode() ? t === -1 || e !== t && (n || e !== t + 1) : !0;
  }
  _getItemPoints() {
    const e = this;
    let t = [], n, s, o;
    const {
      rtlEnabled: r
    } = e.option(), a = e._isVerticalOrientation(), l = e._getItems(), d = l.filter(oS), u = d.length, c = this._getDraggableElement(), h = d.indexOf(c.get(0));
    if (u) {
      for (let g = 0; g <= u; g++) {
        const m = !a && r ^ g === u, C = a && g === u;
        g < u && (n = p(d[g]), s = n.offset(), o = Ee(n)), t.push({
          dropInsideItem: !1,
          left: s.left + (m ? o : 0),
          top: s.top + (C ? t[g - 1].height : 0),
          index: g === u ? l.length : l.indexOf(n.get(0)),
          $item: n,
          width: Ee(n),
          height: he(n),
          isValid: e._isValidPoint(g, h)
        });
      }
      if (this.option("allowDropInsideItem")) {
        const g = t;
        t = [];
        for (let m = 0; m < g.length; m++)
          t.push(g[m]), g[m + 1] && t.push(x({}, g[m], {
            dropInsideItem: !0,
            top: Math.floor((g[m].top + g[m + 1].top) / 2),
            left: Math.floor((g[m].left + g[m + 1].left) / 2),
            isValid: this._isValidPoint(m, h, !0)
          }));
      }
    } else
      t.push({
        dropInsideItem: !1,
        index: 0,
        isValid: !0
      });
    return t;
  }
  _updateItemPoints(e) {
    (e || this.option("autoUpdate") || !this.option("itemPoints")) && this.option("itemPoints", this._getItemPoints());
  }
  _correctItemPoints(e) {
    const t = this.option("itemPoints");
    if (e && t && !this.option("autoUpdate")) {
      const s = this._isVerticalOrientation() ? "top" : "left";
      t.forEach((o) => {
        o[s] -= e;
      });
    }
  }
  _getElementIndex(e) {
    return this._getItems().indexOf(e.get(0));
  }
  _getDragTemplateArgs(e) {
    const t = super._getDragTemplateArgs.apply(this, arguments);
    return t.model.fromIndex = this._getElementIndex(e), t;
  }
  _togglePlaceholder(e) {
    var t;
    (t = this._$placeholderElement) === null || t === void 0 || t.toggle(e);
  }
  _isVerticalOrientation() {
    const {
      itemOrientation: e
    } = this.option();
    return e === "vertical";
  }
  _normalizeToIndex(e, t) {
    const n = this._getSourceDraggable() !== this._getTargetDraggable(), s = this._getActualFromIndex();
    return e === null ? s : Math.max(n || s >= e || t ? e : e - 1, 0);
  }
  _updatePlaceholderPosition(e, t) {
    const n = this._getSourceDraggable(), s = this._normalizeToIndex(t.index, t.dropInsideItem), o = x(this._getEventArgs(e), {
      toIndex: s,
      dropInsideItem: t.dropInsideItem
    });
    if (t.isValid && this._getAction("onDragChange")(o), o.cancel || !t.isValid) {
      t.isValid || this.option({
        dropInsideItem: !1,
        toIndex: null
      });
      return;
    }
    this.option({
      dropInsideItem: t.dropInsideItem,
      toIndex: t.index
    }), this._getAction("onPlaceholderPrepared")(x(this._getEventArgs(e), {
      placeholderElement: ee(this._$placeholderElement),
      dragElement: ee(n._$dragElement)
    })), this._updateItemPoints();
  }
  _makeWidthCorrection(e, t) {
    if (this._$scrollable = this._getScrollable(e), this._$scrollable) {
      const n = ne(this._$scrollable), s = this._$scrollable.offset().left - e.offset().left, o = Ee(e) - s - n;
      s > 0 && (t -= s), o > 0 && (t -= o);
    }
    return t;
  }
  _updatePlaceholderSizes(e, t) {
    const n = this.option("dropInsideItem"), s = p(t), o = this._isVerticalOrientation();
    let r = "", a = "";
    e.toggleClass(this._addWidgetPrefix("placeholder-inside"), n), (o || n) && (r = Ee(s)), (!o || n) && (a = he(s)), r = this._makeWidthCorrection(s, r), e.css({
      width: r,
      height: a
    });
  }
  _moveItem(e, t, n) {
    let s;
    const o = this._getItems(), r = o[t], a = this._getSourceDraggable();
    n && (e = e.clone(), a._toggleDragSourceClass(!1, e)), r || (s = o[t - 1]), this._moveItemCore(e, r, s);
  }
  _moveItemCore(e, t, n) {
    !t && !n ? e.appendTo(this.$element()) : n ? e.insertAfter(p(n)) : e.insertBefore(p(t));
  }
  _getDragStartArgs(e, t) {
    return x(super._getDragStartArgs.apply(this, arguments), {
      fromIndex: this._getElementIndex(t)
    });
  }
  _getEventArgs(e) {
    const t = this._getSourceDraggable(), n = this._getTargetDraggable(), s = n.option("dropInsideItem");
    return x(super._getEventArgs.apply(this, arguments), {
      fromIndex: t.option("fromIndex"),
      toIndex: this._normalizeToIndex(n.option("toIndex"), s),
      dropInsideItem: s
    });
  }
  _optionChanged(e) {
    const {
      name: t
    } = e;
    switch (t) {
      case "onDragChange":
      case "onPlaceholderPrepared":
      case "onAdd":
      case "onRemove":
      case "onReorder":
        this[`_${t}Action`] = this._createActionByOption(t);
        break;
      case "itemOrientation":
      case "allowDropInsideItem":
      case "moveItemOnDrop":
      case "dropFeedbackMode":
      case "itemPoints":
      case "animation":
      case "allowReordering":
      case "fromIndexOffset":
      case "offset":
      case "draggableElementSize":
      case "autoUpdate":
        break;
      case "fromIndex":
        [!1, !0].forEach((n) => {
          const s = n ? e.value : e.previousValue;
          if (s !== null) {
            const o = p(this._getItems()[s]);
            this._toggleDragSourceClass(n, o);
          }
        });
        break;
      case "dropInsideItem":
        this._optionChangedDropInsideItem(e);
        break;
      case "toIndex":
        this._optionChangedToIndex(e);
        break;
      default:
        super._optionChanged(e);
    }
  }
  _optionChangedDropInsideItem() {
    this._isIndicateMode() && this._$placeholderElement && this._movePlaceholder();
  }
  _isPositionVisible(e) {
    const t = this.$element();
    let n;
    if (t.css("overflow") !== "hidden" ? n = t.get(0) : t.parents().each(function() {
      if (p(this).css("overflow") !== "visible")
        return n = this, !1;
    }), n) {
      const s = Ge(n), o = this._isVerticalOrientation(), r = o ? "top" : "left", a = o ? "bottom" : "right", l = o ? sS.pageYOffset : sS.pageXOffset;
      if (e[r] < s[r] + l || e[r] > s[a] + l)
        return !1;
    }
    return !0;
  }
  _optionChangedToIndex(e) {
    const t = e.value;
    if (this._isIndicateMode()) {
      const n = t !== null && t >= 0;
      this._togglePlaceholder(n), n && this._movePlaceholder();
    } else
      this._moveItems(e.previousValue, e.value, e.fullUpdate);
  }
  update() {
    if (this.option("fromIndex") === null && this.option("toIndex") === null)
      return;
    this._updateItemPoints(!0), this._updateDragSourceClass();
    const e = this.option("toIndex");
    this._optionChangedToIndex({
      value: e,
      fullUpdate: !0
    });
  }
  _updateDragSourceClass() {
    const e = this._getActualFromIndex(), t = p(this._getItems()[e]);
    t.length && (this._$sourceElement = t, this._toggleDragSourceClass(!0, t));
  }
  _makeLeftCorrection(e) {
    const t = this._$scrollable;
    if (t && this._isVerticalOrientation()) {
      const n = t.offset().left - e;
      n > 0 && (e += n);
    }
    return e;
  }
  _movePlaceholder() {
    const e = this, t = e._$placeholderElement || e._createPlaceholder();
    if (!t)
      return;
    const n = e._getItems(), s = e.option("toIndex"), o = e._isVerticalOrientation(), r = this.option("rtlEnabled"), a = e.option("dropInsideItem");
    let l = null, d = n[s];
    if (d) {
      const u = p(d);
      l = u.offset(), !o && r && !a && (l.left += Ee(u, !0));
    } else {
      const u = d = this._getPrevVisibleItem(n, s);
      u && (l = p(u).offset(), o ? l.top += he(u, !0) : r || (l.left += Ee(u, !0)));
    }
    if (e._updatePlaceholderSizes(t, d), l && !e._isPositionVisible(l) && (l = null), l) {
      const u = o && s === n.length, c = he(t);
      l.left = e._makeLeftCorrection(l.left), l.top = u && l.top >= c ? l.top - c : l.top, e._move(l, t);
    }
    t.toggle(!!l);
  }
  _getPositions(e, t, n, s) {
    const o = [];
    for (let r = 0; r < e.length; r++) {
      let a = 0;
      if (s === null || n === null) {
        o.push(a);
        continue;
      }
      n === -1 ? r >= s && (a = t) : s === -1 ? r > n && (a = -t) : n < s ? r > n && r < s && (a = -t) : n > s && r >= s && r < n && (a = t), o.push(a);
    }
    return o;
  }
  _getDraggableElementSize(e) {
    const t = this._getDraggableElement();
    let n = this.option("draggableElementSize");
    return n || (n = e ? (he(t) + he(t, !0)) / 2 : (Ee(t) + Ee(t, !0)) / 2, this.option("autoUpdate") || this.option("draggableElementSize", n)), n;
  }
  _getActualFromIndex() {
    const {
      fromIndex: e,
      fromIndexOffset: t,
      offset: n
    } = this.option();
    return e == null ? null : e + t - n;
  }
  _moveItems(e, t, n) {
    const s = this._getActualFromIndex(), o = this._isVerticalOrientation(), r = o ? "top" : "left", a = this._getDraggableElementSize(o), l = this._getItems(), d = this._getPositions(l, a, s, e), u = this._getPositions(l, a, s, t), c = this.option("animation"), h = this.option("rtlEnabled");
    for (let g = 0; g < l.length; g++) {
      const m = l[g], C = d[g], v = u[g];
      t === null || s === null ? Pte(m) : (C !== v || n && f(v)) && Vte(m, x({}, c, {
        to: {
          [r]: !o && h ? -v : v
        }
      }));
    }
  }
  _toggleDragSourceClass(e, t) {
    const n = t || this._$sourceElement;
    super._toggleDragSourceClass.apply(this, arguments), this._isIndicateMode() || n?.toggleClass(this._addWidgetPrefix("source-hidden"), e);
  }
  _dispose() {
    this.reset(), super._dispose();
  }
  _fireAddEvent(e) {
    const t = this._getEventArgs(e);
    return this._getAction("onAdd")(t), t.cancel;
  }
  _fireRemoveEvent(e) {
    const t = this._getSourceDraggable(), n = this._getEventArgs(e);
    return t._getAction("onRemove")(n), n.cancel;
  }
  _fireReorderEvent(e) {
    const t = this._getEventArgs(e);
    return this._getAction("onReorder")(t), t.promise || w().resolve();
  }
}
xe(kte, RF);
const Bte = {
  dragCell: "dx-drag-cell"
}, wo = {
  cellFocusDisabled: "dx-cell-focus-disabled",
  handleIcon: "drag-icon",
  commandDrag: "dx-command-drag",
  sortableWithoutHandle: "dx-sortable-without-handle",
  rowsView: "rowsview",
  dragView: "dragview"
}, $te = (i) => (e, t) => {
  const n = p(e);
  if (t.rowType === "data")
    return n.addClass(wo.cellFocusDisabled), p("<span>").addClass(i(wo.handleIcon));
  F.setEmptyText(n);
}, Nte = {
  createHandleTemplateFunc: $te
}, Lte = (i) => class extends i {
  init() {
    super.init.apply(this, arguments), this._updateHandleColumn();
  }
  optionChanged(e) {
    e.name === "rowDragging" && (this._updateHandleColumn(), this._invalidate(!0, !0), e.handled = !0), super.optionChanged.apply(this, arguments);
  }
  _allowReordering() {
    const e = this.option("rowDragging");
    return !!(e && (e.allowReordering || e.allowDropInsideItem || e.group));
  }
  _updateHandleColumn() {
    const e = this.option("rowDragging"), t = this._allowReordering(), n = this._columnsController, s = t && e.showDragIcons;
    n?.addCommandColumn({
      type: "drag",
      command: "drag",
      visibleIndex: -2,
      alignment: "center",
      elementAttr: [{
        name: Bte.dragCell,
        value: ""
      }],
      cssClass: wo.commandDrag,
      width: "auto",
      cellTemplate: this._getHandleTemplate(),
      visible: s
    }), n?.columnOption("type:drag", "visible", s);
  }
  _renderContent() {
    const e = this.option("rowDragging"), t = this._allowReordering(), n = super._renderContent.apply(this, arguments), s = this._isFixedTableRendering, o = s ? "_sortableFixed" : "_sortable", r = s ? "_sortable" : "_sortableFixed", a = (u) => {
      var c;
      (c = this._sortableFixed) === null || c === void 0 || c.$element().css("pointerEvents", u ? "auto" : "");
    }, l = ".dx-row:not(.dx-freespace-row):not(.dx-virtual-row):not(.dx-header-row):not(.dx-footer-row)", d = this.option("dataRowTemplate") ? `> table > tbody${l}` : `> table > tbody > ${l}`;
    return (t || this[o]) && n.length && (this[o] = this._createComponent(n, RF, x({
      component: this.component,
      contentTemplate: null,
      filter: d,
      cursorOffset: (u) => {
        const {
          event: c
        } = u, h = p(this.element()).offset();
        return {
          x: c.pageX - h.left
        };
      },
      onDraggableElementShown: (u) => {
        if (e.dragTemplate)
          return;
        const h = p(u.dragElement).children(".dx-widget").data(this.component.NAME);
        this._synchronizeScrollLeftPosition(h);
      },
      dragTemplate: this._getDraggableRowTemplate(),
      handle: e.showDragIcons && `.${wo.commandDrag}`,
      dropFeedbackMode: "indicate"
    }, e, {
      onDragStart: (u) => {
        var c, h;
        (c = this.getController("keyboardNavigation")) === null || c === void 0 || c._resetFocusedCell();
        const g = u.component.getVisibleRows()[u.fromIndex];
        u.itemData = g && g.data;
        const m = g && g.rowType === "data";
        u.cancel = !t || !m, (h = e.onDragStart) === null || h === void 0 || h.call(e, u);
      },
      onDragEnter: (u) => {
        u.fromComponent !== u.toComponent && a(!0);
      },
      onDragLeave: () => {
        a(!1);
      },
      onDragEnd: (u) => {
        var c;
        a(!1), (c = e.onDragEnd) === null || c === void 0 || c.call(e, u);
      },
      onAdd: (u) => {
        var c;
        a(!1), (c = e.onAdd) === null || c === void 0 || c.call(e, u);
      },
      dropFeedbackMode: e.dropFeedbackMode,
      onOptionChanged: (u) => {
        this._sortableFixed && (u.name === "fromIndex" || u.name === "toIndex") && this[r].option(u.name, u.value);
      }
    })), n.toggleClass("dx-scrollable-container", s), n.toggleClass(wo.sortableWithoutHandle, t && !e.showDragIcons)), n;
  }
  _renderCore(e) {
    super._renderCore.apply(this, arguments), e && e.changeType === "update" && e.repaintChangesOnly && F.isVirtualRowRendering(this) && qt(() => {
      this._updateSortable();
    });
  }
  _updateSortable() {
    const e = this._dataController.getRowIndexOffset(), t = e - this._previousOffset;
    [this._sortable, this._sortableFixed].forEach((n) => {
      const s = n?.option("toIndex");
      f(s) && f(this._previousOffset) && n?.option("toIndex", s - t), n?.option("offset", e), n?.update();
    }), this._previousOffset = e;
  }
  _resizeCore() {
    super._resizeCore.apply(this, arguments), this._updateSortable();
  }
  _getDraggableGridOptions(e) {
    const t = this.option(), n = this.getColumns(), s = p(this.getRowElement(e.rowIndex));
    return {
      dataSource: [{
        id: 1,
        parentId: 0
      }],
      showBorders: !0,
      showColumnHeaders: !1,
      scrolling: {
        useNative: !1,
        showScrollbar: "never"
      },
      pager: {
        visible: !1
      },
      loadingTimeout: null,
      columnFixing: t.columnFixing,
      columnAutoWidth: t.columnAutoWidth,
      showColumnLines: t.showColumnLines,
      columns: n.map((o) => ({
        width: o.width || o.visibleWidth,
        fixed: o.fixed,
        fixedPosition: o.fixedPosition
      })),
      isDragging: !0,
      onRowPrepared: (o) => {
        const r = o.component.getView("rowsView");
        p(o.rowElement).replaceWith(s.eq(r._isFixedTableRendering ? 1 : 0).clone());
      }
    };
  }
  _synchronizeScrollLeftPosition(e) {
    const t = e?.getScrollable();
    t?.scrollTo({
      x: this._scrollLeft
    });
  }
  _getDraggableRowTemplate() {
    return (e) => {
      const t = this.component.$element(), n = p("<div>");
      xl(n, ne(t));
      const s = this._dataController.items(), o = s && s[e.fromIndex], r = this._getDraggableGridOptions(o);
      return this._createComponent(n, this.component.NAME, r), n.find(".dx-gridbase-container").children(`:not(.${this.addWidgetPrefix(wo.rowsView)})`).hide(), n.addClass(this.addWidgetPrefix(wo.dragView)), n;
    };
  }
  _getHandleTemplate() {
    return Nte.createHandleTemplateFunc((e) => this.addWidgetPrefix(e));
  }
}, Hte = {
  defaultOptions: () => ({
    rowDragging: {
      showDragIcons: !0,
      dropFeedbackMode: "indicate",
      allowReordering: !1,
      allowDropInsideItem: !1
    }
  }),
  extenders: {
    views: {
      rowsView: Lte
    }
  }
};
J.registerModule("rowDragging", Hte);
/*!
 * devextreme-vue
 * Version: 24.2.7
 * Build date: Mon Apr 28 2025
 *
 * Copyright (c) 2012 - 2025 Developer Express Inc. ALL RIGHTS RESERVED
 *
 * This software may be modified and distributed under the terms
 * of the MIT license. See the LICENSE file in the root of the project for details.
 *
 * https://github.com/DevExpress/devextreme-vue
 */
const FF = {
  props: {
    accessKey: String,
    activeStateEnabled: Boolean,
    allowColumnReordering: Boolean,
    allowColumnResizing: Boolean,
    autoNavigateToFocusedRow: Boolean,
    cacheEnabled: Boolean,
    cellHintEnabled: Boolean,
    columnAutoWidth: Boolean,
    columnChooser: Object,
    columnFixing: Object,
    columnHidingEnabled: Boolean,
    columnMinWidth: Number,
    columnResizingMode: String,
    columns: Array,
    columnWidth: [String, Number],
    customizeColumns: Function,
    dataRowTemplate: {},
    dataSource: [Array, Object, String],
    dateSerializationFormat: String,
    disabled: Boolean,
    editing: Object,
    elementAttr: Object,
    errorRowEnabled: Boolean,
    export: Object,
    filterBuilder: Object,
    filterBuilderPopup: Object,
    filterPanel: Object,
    filterRow: Object,
    filterSyncEnabled: [Boolean, String],
    filterValue: [Array, Function, String],
    focusedColumnIndex: Number,
    focusedRowEnabled: Boolean,
    focusedRowIndex: Number,
    focusedRowKey: {},
    grouping: Object,
    groupPanel: Object,
    headerFilter: Object,
    height: [Function, Number, String],
    highlightChanges: Boolean,
    hint: String,
    hoverStateEnabled: Boolean,
    keyboardNavigation: Object,
    keyExpr: [Array, String],
    loadPanel: Object,
    masterDetail: Object,
    noDataText: String,
    onAdaptiveDetailRowPreparing: Function,
    onCellClick: Function,
    onCellDblClick: Function,
    onCellHoverChanged: Function,
    onCellPrepared: Function,
    onContentReady: Function,
    onContextMenuPreparing: Function,
    onDataErrorOccurred: Function,
    onDisposing: Function,
    onEditCanceled: Function,
    onEditCanceling: Function,
    onEditingStart: Function,
    onEditorPrepared: Function,
    onEditorPreparing: Function,
    onExporting: Function,
    onFocusedCellChanged: Function,
    onFocusedCellChanging: Function,
    onFocusedRowChanged: Function,
    onFocusedRowChanging: Function,
    onInitialized: Function,
    onInitNewRow: Function,
    onKeyDown: Function,
    onOptionChanged: Function,
    onRowClick: Function,
    onRowCollapsed: Function,
    onRowCollapsing: Function,
    onRowDblClick: Function,
    onRowExpanded: Function,
    onRowExpanding: Function,
    onRowInserted: Function,
    onRowInserting: Function,
    onRowPrepared: Function,
    onRowRemoved: Function,
    onRowRemoving: Function,
    onRowUpdated: Function,
    onRowUpdating: Function,
    onRowValidating: Function,
    onSaved: Function,
    onSaving: Function,
    onSelectionChanged: Function,
    onToolbarPreparing: Function,
    pager: Object,
    paging: Object,
    remoteOperations: [Boolean, String, Object],
    renderAsync: Boolean,
    repaintChangesOnly: Boolean,
    rowAlternationEnabled: Boolean,
    rowDragging: Object,
    rowTemplate: {},
    rtlEnabled: Boolean,
    scrolling: Object,
    searchPanel: Object,
    selectedRowKeys: Array,
    selection: Object,
    selectionFilter: [Array, Function, String],
    showBorders: Boolean,
    showColumnHeaders: Boolean,
    showColumnLines: Boolean,
    showRowLines: Boolean,
    sortByGroupSummaryInfo: Array,
    sorting: Object,
    stateStoring: Object,
    summary: Object,
    syncLookupFilterValues: Boolean,
    tabIndex: Number,
    toolbar: Object,
    twoWayBindingEnabled: Boolean,
    visible: Boolean,
    width: [Function, Number, String],
    wordWrapEnabled: Boolean
  },
  emits: {
    "update:isActive": null,
    "update:hoveredElement": null,
    "update:accessKey": null,
    "update:activeStateEnabled": null,
    "update:allowColumnReordering": null,
    "update:allowColumnResizing": null,
    "update:autoNavigateToFocusedRow": null,
    "update:cacheEnabled": null,
    "update:cellHintEnabled": null,
    "update:columnAutoWidth": null,
    "update:columnChooser": null,
    "update:columnFixing": null,
    "update:columnHidingEnabled": null,
    "update:columnMinWidth": null,
    "update:columnResizingMode": null,
    "update:columns": null,
    "update:columnWidth": null,
    "update:customizeColumns": null,
    "update:dataRowTemplate": null,
    "update:dataSource": null,
    "update:dateSerializationFormat": null,
    "update:disabled": null,
    "update:editing": null,
    "update:elementAttr": null,
    "update:errorRowEnabled": null,
    "update:export": null,
    "update:filterBuilder": null,
    "update:filterBuilderPopup": null,
    "update:filterPanel": null,
    "update:filterRow": null,
    "update:filterSyncEnabled": null,
    "update:filterValue": null,
    "update:focusedColumnIndex": null,
    "update:focusedRowEnabled": null,
    "update:focusedRowIndex": null,
    "update:focusedRowKey": null,
    "update:grouping": null,
    "update:groupPanel": null,
    "update:headerFilter": null,
    "update:height": null,
    "update:highlightChanges": null,
    "update:hint": null,
    "update:hoverStateEnabled": null,
    "update:keyboardNavigation": null,
    "update:keyExpr": null,
    "update:loadPanel": null,
    "update:masterDetail": null,
    "update:noDataText": null,
    "update:onAdaptiveDetailRowPreparing": null,
    "update:onCellClick": null,
    "update:onCellDblClick": null,
    "update:onCellHoverChanged": null,
    "update:onCellPrepared": null,
    "update:onContentReady": null,
    "update:onContextMenuPreparing": null,
    "update:onDataErrorOccurred": null,
    "update:onDisposing": null,
    "update:onEditCanceled": null,
    "update:onEditCanceling": null,
    "update:onEditingStart": null,
    "update:onEditorPrepared": null,
    "update:onEditorPreparing": null,
    "update:onExporting": null,
    "update:onFocusedCellChanged": null,
    "update:onFocusedCellChanging": null,
    "update:onFocusedRowChanged": null,
    "update:onFocusedRowChanging": null,
    "update:onInitialized": null,
    "update:onInitNewRow": null,
    "update:onKeyDown": null,
    "update:onOptionChanged": null,
    "update:onRowClick": null,
    "update:onRowCollapsed": null,
    "update:onRowCollapsing": null,
    "update:onRowDblClick": null,
    "update:onRowExpanded": null,
    "update:onRowExpanding": null,
    "update:onRowInserted": null,
    "update:onRowInserting": null,
    "update:onRowPrepared": null,
    "update:onRowRemoved": null,
    "update:onRowRemoving": null,
    "update:onRowUpdated": null,
    "update:onRowUpdating": null,
    "update:onRowValidating": null,
    "update:onSaved": null,
    "update:onSaving": null,
    "update:onSelectionChanged": null,
    "update:onToolbarPreparing": null,
    "update:pager": null,
    "update:paging": null,
    "update:remoteOperations": null,
    "update:renderAsync": null,
    "update:repaintChangesOnly": null,
    "update:rowAlternationEnabled": null,
    "update:rowDragging": null,
    "update:rowTemplate": null,
    "update:rtlEnabled": null,
    "update:scrolling": null,
    "update:searchPanel": null,
    "update:selectedRowKeys": null,
    "update:selection": null,
    "update:selectionFilter": null,
    "update:showBorders": null,
    "update:showColumnHeaders": null,
    "update:showColumnLines": null,
    "update:showRowLines": null,
    "update:sortByGroupSummaryInfo": null,
    "update:sorting": null,
    "update:stateStoring": null,
    "update:summary": null,
    "update:syncLookupFilterValues": null,
    "update:tabIndex": null,
    "update:toolbar": null,
    "update:twoWayBindingEnabled": null,
    "update:visible": null,
    "update:width": null,
    "update:wordWrapEnabled": null
  },
  computed: {
    instance() {
      return this.$_instance;
    }
  },
  beforeCreate() {
    this.$_WidgetClass = rA, this.$_hasAsyncTemplate = !1, this.$_expectedChildren = {
      column: { isCollectionItem: !0, optionName: "columns" },
      columnChooser: { isCollectionItem: !1, optionName: "columnChooser" },
      columnFixing: { isCollectionItem: !1, optionName: "columnFixing" },
      dataGridHeaderFilter: { isCollectionItem: !1, optionName: "headerFilter" },
      dataGridSelection: { isCollectionItem: !1, optionName: "selection" },
      editing: { isCollectionItem: !1, optionName: "editing" },
      export: { isCollectionItem: !1, optionName: "export" },
      filterBuilder: { isCollectionItem: !1, optionName: "filterBuilder" },
      filterBuilderPopup: { isCollectionItem: !1, optionName: "filterBuilderPopup" },
      filterPanel: { isCollectionItem: !1, optionName: "filterPanel" },
      filterRow: { isCollectionItem: !1, optionName: "filterRow" },
      grouping: { isCollectionItem: !1, optionName: "grouping" },
      groupPanel: { isCollectionItem: !1, optionName: "groupPanel" },
      headerFilter: { isCollectionItem: !1, optionName: "headerFilter" },
      keyboardNavigation: { isCollectionItem: !1, optionName: "keyboardNavigation" },
      loadPanel: { isCollectionItem: !1, optionName: "loadPanel" },
      masterDetail: { isCollectionItem: !1, optionName: "masterDetail" },
      pager: { isCollectionItem: !1, optionName: "pager" },
      paging: { isCollectionItem: !1, optionName: "paging" },
      remoteOperations: { isCollectionItem: !1, optionName: "remoteOperations" },
      rowDragging: { isCollectionItem: !1, optionName: "rowDragging" },
      scrolling: { isCollectionItem: !1, optionName: "scrolling" },
      searchPanel: { isCollectionItem: !1, optionName: "searchPanel" },
      selection: { isCollectionItem: !1, optionName: "selection" },
      sortByGroupSummaryInfo: { isCollectionItem: !0, optionName: "sortByGroupSummaryInfo" },
      sorting: { isCollectionItem: !1, optionName: "sorting" },
      stateStoring: { isCollectionItem: !1, optionName: "stateStoring" },
      summary: { isCollectionItem: !1, optionName: "summary" },
      toolbar: { isCollectionItem: !1, optionName: "toolbar" }
    };
  }
};
io(FF);
const cie = /* @__PURE__ */ A(FF), kF = {
  emits: {
    "update:isActive": null,
    "update:hoveredElement": null,
    "update:hide": null,
    "update:show": null
  },
  props: {
    hide: [Object, Number, String],
    show: [Object, Number, String]
  }
};
k(kF);
const VF = /* @__PURE__ */ A(kF);
VF.$_optionName = "animation";
VF.$_expectedChildren = {
  hide: { isCollectionItem: !1, optionName: "hide" },
  show: { isCollectionItem: !1, optionName: "show" }
};
const PF = {
  emits: {
    "update:isActive": null,
    "update:hoveredElement": null,
    "update:ignoreEmptyValue": null,
    "update:message": null,
    "update:reevaluate": null,
    "update:type": null,
    "update:validationCallback": null
  },
  props: {
    ignoreEmptyValue: Boolean,
    message: String,
    reevaluate: Boolean,
    type: String,
    validationCallback: Function
  }
};
k(PF);
const kC = /* @__PURE__ */ A(PF);
kC.$_optionName = "validationRules";
kC.$_isCollectionItem = !0;
kC.$_predefinedProps = {
  type: "async"
};
const MF = {
  emits: {
    "update:isActive": null,
    "update:hoveredElement": null,
    "update:x": null,
    "update:y": null
  },
  props: {
    x: String,
    y: String
  }
};
k(MF);
const Wte = /* @__PURE__ */ A(MF);
Wte.$_optionName = "at";
const BF = {
  emits: {
    "update:isActive": null,
    "update:hoveredElement": null,
    "update:x": null,
    "update:y": null
  },
  props: {
    x: Number,
    y: Number
  }
};
k(BF);
const zte = /* @__PURE__ */ A(BF);
zte.$_optionName = "boundaryOffset";
const $F = {
  emits: {
    "update:isActive": null,
    "update:hoveredElement": null,
    "update:cssClass": null,
    "update:disabled": null,
    "update:hint": null,
    "update:icon": null,
    "update:name": null,
    "update:onClick": null,
    "update:template": null,
    "update:text": null,
    "update:visible": null
  },
  props: {
    cssClass: String,
    disabled: [Boolean, Function],
    hint: String,
    icon: String,
    name: String,
    onClick: Function,
    template: {},
    text: String,
    visible: [Boolean, Function]
  }
};
k($F);
const NF = /* @__PURE__ */ A($F);
NF.$_optionName = "buttons";
NF.$_isCollectionItem = !0;
const LF = {
  emits: {
    "update:isActive": null,
    "update:hoveredElement": null,
    "update:data": null,
    "update:insertAfterKey": null,
    "update:insertBeforeKey": null,
    "update:type": null
  },
  props: {
    data: {},
    insertAfterKey: {},
    insertBeforeKey: {},
    type: String
  }
};
k(LF);
const HF = /* @__PURE__ */ A(LF);
HF.$_optionName = "changes";
HF.$_isCollectionItem = !0;
const WF = {
  emits: {
    "update:isActive": null,
    "update:hoveredElement": null,
    "update:lg": null,
    "update:md": null,
    "update:sm": null,
    "update:xs": null
  },
  props: {
    lg: Number,
    md: Number,
    sm: Number,
    xs: Number
  }
};
k(WF);
const Kte = /* @__PURE__ */ A(WF);
Kte.$_optionName = "colCountByScreen";
const zF = {
  emits: {
    "update:isActive": null,
    "update:hoveredElement": null,
    "update:x": null,
    "update:y": null
  },
  props: {
    x: String,
    y: String
  }
};
k(zF);
const Gte = /* @__PURE__ */ A(zF);
Gte.$_optionName = "collision";
const KF = {
  emits: {
    "update:isActive": null,
    "update:hoveredElement": null,
    "update:alignment": null,
    "update:allowEditing": null,
    "update:allowExporting": null,
    "update:allowFiltering": null,
    "update:allowFixing": null,
    "update:allowGrouping": null,
    "update:allowHeaderFiltering": null,
    "update:allowHiding": null,
    "update:allowReordering": null,
    "update:allowResizing": null,
    "update:allowSearch": null,
    "update:allowSorting": null,
    "update:autoExpandGroup": null,
    "update:buttons": null,
    "update:calculateCellValue": null,
    "update:calculateDisplayValue": null,
    "update:calculateFilterExpression": null,
    "update:calculateGroupValue": null,
    "update:calculateSortValue": null,
    "update:caption": null,
    "update:cellTemplate": null,
    "update:columns": null,
    "update:cssClass": null,
    "update:customizeText": null,
    "update:dataField": null,
    "update:dataType": null,
    "update:editCellTemplate": null,
    "update:editorOptions": null,
    "update:encodeHtml": null,
    "update:falseText": null,
    "update:filterOperations": null,
    "update:filterType": null,
    "update:filterValue": null,
    "update:filterValues": null,
    "update:fixed": null,
    "update:fixedPosition": null,
    "update:format": null,
    "update:formItem": null,
    "update:groupCellTemplate": null,
    "update:groupIndex": null,
    "update:headerCellTemplate": null,
    "update:headerFilter": null,
    "update:hidingPriority": null,
    "update:isBand": null,
    "update:lookup": null,
    "update:minWidth": null,
    "update:name": null,
    "update:ownerBand": null,
    "update:renderAsync": null,
    "update:selectedFilterOperation": null,
    "update:setCellValue": null,
    "update:showEditorAlways": null,
    "update:showInColumnChooser": null,
    "update:showWhenGrouped": null,
    "update:sortIndex": null,
    "update:sortingMethod": null,
    "update:sortOrder": null,
    "update:trueText": null,
    "update:type": null,
    "update:validationRules": null,
    "update:visible": null,
    "update:visibleIndex": null,
    "update:width": null
  },
  props: {
    alignment: String,
    allowEditing: Boolean,
    allowExporting: Boolean,
    allowFiltering: Boolean,
    allowFixing: Boolean,
    allowGrouping: Boolean,
    allowHeaderFiltering: Boolean,
    allowHiding: Boolean,
    allowReordering: Boolean,
    allowResizing: Boolean,
    allowSearch: Boolean,
    allowSorting: Boolean,
    autoExpandGroup: Boolean,
    buttons: Array,
    calculateCellValue: Function,
    calculateDisplayValue: [Function, String],
    calculateFilterExpression: Function,
    calculateGroupValue: [Function, String],
    calculateSortValue: [Function, String],
    caption: String,
    cellTemplate: {},
    columns: Array,
    cssClass: String,
    customizeText: Function,
    dataField: String,
    dataType: String,
    editCellTemplate: {},
    editorOptions: {},
    encodeHtml: Boolean,
    falseText: String,
    filterOperations: Array,
    filterType: String,
    filterValue: {},
    filterValues: Array,
    fixed: Boolean,
    fixedPosition: String,
    format: [Object, String, Function],
    formItem: Object,
    groupCellTemplate: {},
    groupIndex: Number,
    headerCellTemplate: {},
    headerFilter: Object,
    hidingPriority: Number,
    isBand: Boolean,
    lookup: Object,
    minWidth: Number,
    name: String,
    ownerBand: Number,
    renderAsync: Boolean,
    selectedFilterOperation: String,
    setCellValue: Function,
    showEditorAlways: Boolean,
    showInColumnChooser: Boolean,
    showWhenGrouped: Boolean,
    sortIndex: Number,
    sortingMethod: Function,
    sortOrder: String,
    trueText: String,
    type: String,
    validationRules: Array,
    visible: Boolean,
    visibleIndex: Number,
    width: [Number, String]
  }
};
k(KF);
const VC = /* @__PURE__ */ A(KF);
VC.$_optionName = "columns";
VC.$_isCollectionItem = !0;
VC.$_expectedChildren = {
  AsyncRule: { isCollectionItem: !0, optionName: "validationRules" },
  button: { isCollectionItem: !0, optionName: "buttons" },
  columnHeaderFilter: { isCollectionItem: !1, optionName: "headerFilter" },
  columnLookup: { isCollectionItem: !1, optionName: "lookup" },
  CompareRule: { isCollectionItem: !0, optionName: "validationRules" },
  CustomRule: { isCollectionItem: !0, optionName: "validationRules" },
  EmailRule: { isCollectionItem: !0, optionName: "validationRules" },
  format: { isCollectionItem: !1, optionName: "format" },
  formItem: { isCollectionItem: !1, optionName: "formItem" },
  headerFilter: { isCollectionItem: !1, optionName: "headerFilter" },
  lookup: { isCollectionItem: !1, optionName: "lookup" },
  NumericRule: { isCollectionItem: !0, optionName: "validationRules" },
  PatternRule: { isCollectionItem: !0, optionName: "validationRules" },
  RangeRule: { isCollectionItem: !0, optionName: "validationRules" },
  RequiredRule: { isCollectionItem: !0, optionName: "validationRules" },
  StringLengthRule: { isCollectionItem: !0, optionName: "validationRules" },
  validationRule: { isCollectionItem: !0, optionName: "validationRules" }
};
const GF = {
  emits: {
    "update:isActive": null,
    "update:hoveredElement": null,
    "update:allowSearch": null,
    "update:container": null,
    "update:emptyPanelText": null,
    "update:enabled": null,
    "update:height": null,
    "update:mode": null,
    "update:position": null,
    "update:search": null,
    "update:searchTimeout": null,
    "update:selection": null,
    "update:sortOrder": null,
    "update:title": null,
    "update:width": null
  },
  props: {
    allowSearch: Boolean,
    container: {},
    emptyPanelText: String,
    enabled: Boolean,
    height: [Number, String],
    mode: String,
    position: Object,
    search: Object,
    searchTimeout: Number,
    selection: Object,
    sortOrder: String,
    title: String,
    width: [Number, String]
  }
};
k(GF);
const UF = /* @__PURE__ */ A(GF);
UF.$_optionName = "columnChooser";
UF.$_expectedChildren = {
  columnChooserSearch: { isCollectionItem: !1, optionName: "search" },
  columnChooserSelection: { isCollectionItem: !1, optionName: "selection" },
  position: { isCollectionItem: !1, optionName: "position" },
  search: { isCollectionItem: !1, optionName: "search" },
  selection: { isCollectionItem: !1, optionName: "selection" }
};
const jF = {
  emits: {
    "update:isActive": null,
    "update:hoveredElement": null,
    "update:editorOptions": null,
    "update:enabled": null,
    "update:timeout": null
  },
  props: {
    editorOptions: {},
    enabled: Boolean,
    timeout: Number
  }
};
k(jF);
const Ute = /* @__PURE__ */ A(jF);
Ute.$_optionName = "search";
const qF = {
  emits: {
    "update:isActive": null,
    "update:hoveredElement": null,
    "update:allowSelectAll": null,
    "update:recursive": null,
    "update:selectByClick": null
  },
  props: {
    allowSelectAll: Boolean,
    recursive: Boolean,
    selectByClick: Boolean
  }
};
k(qF);
const jte = /* @__PURE__ */ A(qF);
jte.$_optionName = "selection";
const YF = {
  emits: {
    "update:isActive": null,
    "update:hoveredElement": null,
    "update:enabled": null,
    "update:icons": null,
    "update:texts": null
  },
  props: {
    enabled: Boolean,
    icons: Object,
    texts: Object
  }
};
k(YF);
const XF = /* @__PURE__ */ A(YF);
XF.$_optionName = "columnFixing";
XF.$_expectedChildren = {
  columnFixingTexts: { isCollectionItem: !1, optionName: "texts" },
  icons: { isCollectionItem: !1, optionName: "icons" },
  texts: { isCollectionItem: !1, optionName: "texts" }
};
const ZF = {
  emits: {
    "update:isActive": null,
    "update:hoveredElement": null,
    "update:fix": null,
    "update:leftPosition": null,
    "update:rightPosition": null,
    "update:stickyPosition": null,
    "update:unfix": null
  },
  props: {
    fix: String,
    leftPosition: String,
    rightPosition: String,
    stickyPosition: String,
    unfix: String
  }
};
k(ZF);
const qte = /* @__PURE__ */ A(ZF);
qte.$_optionName = "texts";
const QF = {
  emits: {
    "update:isActive": null,
    "update:hoveredElement": null,
    "update:allowSearch": null,
    "update:allowSelectAll": null,
    "update:dataSource": null,
    "update:groupInterval": null,
    "update:height": null,
    "update:search": null,
    "update:searchMode": null,
    "update:width": null
  },
  props: {
    allowSearch: Boolean,
    allowSelectAll: Boolean,
    dataSource: [Array, Object, Function],
    groupInterval: [String, Number],
    height: [Number, String],
    search: Object,
    searchMode: String,
    width: [Number, String]
  }
};
k(QF);
const JF = /* @__PURE__ */ A(QF);
JF.$_optionName = "headerFilter";
JF.$_expectedChildren = {
  columnHeaderFilterSearch: { isCollectionItem: !1, optionName: "search" },
  search: { isCollectionItem: !1, optionName: "search" }
};
const ek = {
  emits: {
    "update:isActive": null,
    "update:hoveredElement": null,
    "update:editorOptions": null,
    "update:enabled": null,
    "update:mode": null,
    "update:searchExpr": null,
    "update:timeout": null
  },
  props: {
    editorOptions: {},
    enabled: Boolean,
    mode: String,
    searchExpr: [Array, Function, String],
    timeout: Number
  }
};
k(ek);
const Yte = /* @__PURE__ */ A(ek);
Yte.$_optionName = "search";
const tk = {
  emits: {
    "update:isActive": null,
    "update:hoveredElement": null,
    "update:allowClearing": null,
    "update:calculateCellValue": null,
    "update:dataSource": null,
    "update:displayExpr": null,
    "update:valueExpr": null
  },
  props: {
    allowClearing: Boolean,
    calculateCellValue: Function,
    dataSource: [Array, Object, Function],
    displayExpr: [Function, String],
    valueExpr: String
  }
};
k(tk);
const Xte = /* @__PURE__ */ A(tk);
Xte.$_optionName = "lookup";
const nk = {
  emits: {
    "update:isActive": null,
    "update:hoveredElement": null,
    "update:comparisonTarget": null,
    "update:comparisonType": null,
    "update:ignoreEmptyValue": null,
    "update:message": null,
    "update:type": null
  },
  props: {
    comparisonTarget: Function,
    comparisonType: String,
    ignoreEmptyValue: Boolean,
    message: String,
    type: String
  }
};
k(nk);
const PC = /* @__PURE__ */ A(nk);
PC.$_optionName = "validationRules";
PC.$_isCollectionItem = !0;
PC.$_predefinedProps = {
  type: "compare"
};
const ik = {
  emits: {
    "update:isActive": null,
    "update:hoveredElement": null,
    "update:x": null,
    "update:y": null
  },
  props: {
    x: Number,
    y: Number
  }
};
k(ik);
const Zte = /* @__PURE__ */ A(ik);
Zte.$_optionName = "cursorOffset";
const sk = {
  emits: {
    "update:isActive": null,
    "update:hoveredElement": null,
    "update:calculateFilterExpression": null,
    "update:caption": null,
    "update:customizeText": null,
    "update:dataTypes": null,
    "update:editorTemplate": null,
    "update:hasValue": null,
    "update:icon": null,
    "update:name": null
  },
  props: {
    calculateFilterExpression: Function,
    caption: String,
    customizeText: Function,
    dataTypes: Array,
    editorTemplate: {},
    hasValue: Boolean,
    icon: String,
    name: String
  }
};
k(sk);
const ok = /* @__PURE__ */ A(sk);
ok.$_optionName = "customOperations";
ok.$_isCollectionItem = !0;
const rk = {
  emits: {
    "update:isActive": null,
    "update:hoveredElement": null,
    "update:ignoreEmptyValue": null,
    "update:message": null,
    "update:reevaluate": null,
    "update:type": null,
    "update:validationCallback": null
  },
  props: {
    ignoreEmptyValue: Boolean,
    message: String,
    reevaluate: Boolean,
    type: String,
    validationCallback: Function
  }
};
k(rk);
const MC = /* @__PURE__ */ A(rk);
MC.$_optionName = "validationRules";
MC.$_isCollectionItem = !0;
MC.$_predefinedProps = {
  type: "custom"
};
const ak = {
  emits: {
    "update:isActive": null,
    "update:hoveredElement": null,
    "update:allowSearch": null,
    "update:allowSelectAll": null,
    "update:height": null,
    "update:search": null,
    "update:searchTimeout": null,
    "update:texts": null,
    "update:visible": null,
    "update:width": null
  },
  props: {
    allowSearch: Boolean,
    allowSelectAll: Boolean,
    height: [Number, String],
    search: Object,
    searchTimeout: Number,
    texts: Object,
    visible: Boolean,
    width: [Number, String]
  }
};
k(ak);
const lk = /* @__PURE__ */ A(ak);
lk.$_optionName = "headerFilter";
lk.$_expectedChildren = {
  dataGridHeaderFilterSearch: { isCollectionItem: !1, optionName: "search" },
  dataGridHeaderFilterTexts: { isCollectionItem: !1, optionName: "texts" },
  search: { isCollectionItem: !1, optionName: "search" },
  texts: { isCollectionItem: !1, optionName: "texts" }
};
const dk = {
  emits: {
    "update:isActive": null,
    "update:hoveredElement": null,
    "update:editorOptions": null,
    "update:enabled": null,
    "update:mode": null,
    "update:timeout": null
  },
  props: {
    editorOptions: {},
    enabled: Boolean,
    mode: String,
    timeout: Number
  }
};
k(dk);
const Qte = /* @__PURE__ */ A(dk);
Qte.$_optionName = "search";
const uk = {
  emits: {
    "update:isActive": null,
    "update:hoveredElement": null,
    "update:cancel": null,
    "update:emptyValue": null,
    "update:ok": null
  },
  props: {
    cancel: String,
    emptyValue: String,
    ok: String
  }
};
k(uk);
const Jte = /* @__PURE__ */ A(uk);
Jte.$_optionName = "texts";
const ck = {
  emits: {
    "update:isActive": null,
    "update:hoveredElement": null,
    "update:allowSelectAll": null,
    "update:deferred": null,
    "update:mode": null,
    "update:selectAllMode": null,
    "update:sensitivity": null,
    "update:showCheckBoxesMode": null
  },
  props: {
    allowSelectAll: Boolean,
    deferred: Boolean,
    mode: String,
    selectAllMode: String,
    sensitivity: String,
    showCheckBoxesMode: String
  }
};
k(ck);
const ene = /* @__PURE__ */ A(ck);
ene.$_optionName = "selection";
const hk = {
  emits: {
    "update:isActive": null,
    "update:hoveredElement": null,
    "update:allowAdding": null,
    "update:allowDeleting": null,
    "update:allowUpdating": null,
    "update:changes": null,
    "update:confirmDelete": null,
    "update:editColumnName": null,
    "update:editRowKey": null,
    "update:form": null,
    "update:mode": null,
    "update:newRowPosition": null,
    "update:popup": null,
    "update:refreshMode": null,
    "update:selectTextOnEditStart": null,
    "update:startEditAction": null,
    "update:texts": null,
    "update:useIcons": null
  },
  props: {
    allowAdding: Boolean,
    allowDeleting: [Boolean, Function],
    allowUpdating: [Boolean, Function],
    changes: Array,
    confirmDelete: Boolean,
    editColumnName: String,
    editRowKey: {},
    form: Object,
    mode: String,
    newRowPosition: String,
    popup: Object,
    refreshMode: String,
    selectTextOnEditStart: Boolean,
    startEditAction: String,
    texts: {},
    useIcons: Boolean
  }
};
k(hk);
const pk = /* @__PURE__ */ A(hk);
pk.$_optionName = "editing";
pk.$_expectedChildren = {
  change: { isCollectionItem: !0, optionName: "changes" },
  editingTexts: { isCollectionItem: !1, optionName: "texts" },
  form: { isCollectionItem: !1, optionName: "form" },
  popup: { isCollectionItem: !1, optionName: "popup" },
  texts: { isCollectionItem: !1, optionName: "texts" }
};
const gk = {
  emits: {
    "update:isActive": null,
    "update:hoveredElement": null,
    "update:addRow": null,
    "update:cancelAllChanges": null,
    "update:cancelRowChanges": null,
    "update:confirmDeleteMessage": null,
    "update:confirmDeleteTitle": null,
    "update:deleteRow": null,
    "update:editRow": null,
    "update:saveAllChanges": null,
    "update:saveRowChanges": null,
    "update:undeleteRow": null,
    "update:validationCancelChanges": null
  },
  props: {
    addRow: String,
    cancelAllChanges: String,
    cancelRowChanges: String,
    confirmDeleteMessage: String,
    confirmDeleteTitle: String,
    deleteRow: String,
    editRow: String,
    saveAllChanges: String,
    saveRowChanges: String,
    undeleteRow: String,
    validationCancelChanges: String
  }
};
k(gk);
const tne = /* @__PURE__ */ A(gk);
tne.$_optionName = "texts";
const mk = {
  emits: {
    "update:isActive": null,
    "update:hoveredElement": null,
    "update:ignoreEmptyValue": null,
    "update:message": null,
    "update:type": null
  },
  props: {
    ignoreEmptyValue: Boolean,
    message: String,
    type: String
  }
};
k(mk);
const BC = /* @__PURE__ */ A(mk);
BC.$_optionName = "validationRules";
BC.$_isCollectionItem = !0;
BC.$_predefinedProps = {
  type: "email"
};
const fk = {
  emits: {
    "update:isActive": null,
    "update:hoveredElement": null,
    "update:allowExportSelectedData": null,
    "update:enabled": null,
    "update:formats": null,
    "update:texts": null
  },
  props: {
    allowExportSelectedData: Boolean,
    enabled: Boolean,
    formats: Array,
    texts: Object
  }
};
k(fk);
const _k = /* @__PURE__ */ A(fk);
_k.$_optionName = "export";
_k.$_expectedChildren = {
  exportTexts: { isCollectionItem: !1, optionName: "texts" },
  texts: { isCollectionItem: !1, optionName: "texts" }
};
const Ck = {
  emits: {
    "update:isActive": null,
    "update:hoveredElement": null,
    "update:exportAll": null,
    "update:exportSelectedRows": null,
    "update:exportTo": null
  },
  props: {
    exportAll: String,
    exportSelectedRows: String,
    exportTo: String
  }
};
k(Ck);
const nne = /* @__PURE__ */ A(Ck);
nne.$_optionName = "texts";
const vk = {
  emits: {
    "update:isActive": null,
    "update:hoveredElement": null,
    "update:calculateFilterExpression": null,
    "update:caption": null,
    "update:customizeText": null,
    "update:dataField": null,
    "update:dataType": null,
    "update:editorOptions": null,
    "update:editorTemplate": null,
    "update:falseText": null,
    "update:filterOperations": null,
    "update:format": null,
    "update:lookup": null,
    "update:name": null,
    "update:trueText": null
  },
  props: {
    calculateFilterExpression: Function,
    caption: String,
    customizeText: Function,
    dataField: String,
    dataType: String,
    editorOptions: {},
    editorTemplate: {},
    falseText: String,
    filterOperations: Array,
    format: [Object, String, Function],
    lookup: Object,
    name: String,
    trueText: String
  }
};
k(vk);
const $C = /* @__PURE__ */ A(vk);
$C.$_optionName = "fields";
$C.$_isCollectionItem = !0;
$C.$_expectedChildren = {
  fieldLookup: { isCollectionItem: !1, optionName: "lookup" },
  format: { isCollectionItem: !1, optionName: "format" },
  lookup: { isCollectionItem: !1, optionName: "lookup" }
};
const xk = {
  emits: {
    "update:isActive": null,
    "update:hoveredElement": null,
    "update:allowClearing": null,
    "update:dataSource": null,
    "update:displayExpr": null,
    "update:valueExpr": null
  },
  props: {
    allowClearing: Boolean,
    dataSource: [Array, Object],
    displayExpr: [Function, String],
    valueExpr: [Function, String]
  }
};
k(xk);
const ine = /* @__PURE__ */ A(xk);
ine.$_optionName = "lookup";
const yk = {
  emits: {
    "update:isActive": null,
    "update:hoveredElement": null,
    "update:accessKey": null,
    "update:activeStateEnabled": null,
    "update:allowHierarchicalFields": null,
    "update:bindingOptions": null,
    "update:customOperations": null,
    "update:disabled": null,
    "update:elementAttr": null,
    "update:fields": null,
    "update:filterOperationDescriptions": null,
    "update:focusStateEnabled": null,
    "update:groupOperationDescriptions": null,
    "update:groupOperations": null,
    "update:height": null,
    "update:hint": null,
    "update:hoverStateEnabled": null,
    "update:maxGroupLevel": null,
    "update:onContentReady": null,
    "update:onDisposing": null,
    "update:onEditorPrepared": null,
    "update:onEditorPreparing": null,
    "update:onInitialized": null,
    "update:onOptionChanged": null,
    "update:onValueChanged": null,
    "update:rtlEnabled": null,
    "update:tabIndex": null,
    "update:value": null,
    "update:visible": null,
    "update:width": null
  },
  props: {
    accessKey: String,
    activeStateEnabled: Boolean,
    allowHierarchicalFields: Boolean,
    bindingOptions: Object,
    customOperations: Array,
    disabled: Boolean,
    elementAttr: Object,
    fields: Array,
    filterOperationDescriptions: Object,
    focusStateEnabled: Boolean,
    groupOperationDescriptions: Object,
    groupOperations: Array,
    height: [Function, Number, String],
    hint: String,
    hoverStateEnabled: Boolean,
    maxGroupLevel: Number,
    onContentReady: Function,
    onDisposing: Function,
    onEditorPrepared: Function,
    onEditorPreparing: Function,
    onInitialized: Function,
    onOptionChanged: Function,
    onValueChanged: Function,
    rtlEnabled: Boolean,
    tabIndex: Number,
    value: [Array, Function, String],
    visible: Boolean,
    width: [Function, Number, String]
  }
};
k(yk);
const bk = /* @__PURE__ */ A(yk);
bk.$_optionName = "filterBuilder";
bk.$_expectedChildren = {
  customOperation: { isCollectionItem: !0, optionName: "customOperations" },
  field: { isCollectionItem: !0, optionName: "fields" },
  filterOperationDescriptions: { isCollectionItem: !1, optionName: "filterOperationDescriptions" },
  groupOperationDescriptions: { isCollectionItem: !1, optionName: "groupOperationDescriptions" }
};
const wk = {
  emits: {
    "update:isActive": null,
    "update:hoveredElement": null,
    "update:accessKey": null,
    "update:animation": null,
    "update:bindingOptions": null,
    "update:closeOnOutsideClick": null,
    "update:container": null,
    "update:contentTemplate": null,
    "update:deferRendering": null,
    "update:disabled": null,
    "update:dragAndResizeArea": null,
    "update:dragEnabled": null,
    "update:dragOutsideBoundary": null,
    "update:enableBodyScroll": null,
    "update:focusStateEnabled": null,
    "update:fullScreen": null,
    "update:height": null,
    "update:hideOnOutsideClick": null,
    "update:hideOnParentScroll": null,
    "update:hint": null,
    "update:hoverStateEnabled": null,
    "update:maxHeight": null,
    "update:maxWidth": null,
    "update:minHeight": null,
    "update:minWidth": null,
    "update:onContentReady": null,
    "update:onDisposing": null,
    "update:onHidden": null,
    "update:onHiding": null,
    "update:onInitialized": null,
    "update:onOptionChanged": null,
    "update:onResize": null,
    "update:onResizeEnd": null,
    "update:onResizeStart": null,
    "update:onShowing": null,
    "update:onShown": null,
    "update:onTitleRendered": null,
    "update:position": null,
    "update:resizeEnabled": null,
    "update:restorePosition": null,
    "update:rtlEnabled": null,
    "update:shading": null,
    "update:shadingColor": null,
    "update:showCloseButton": null,
    "update:showTitle": null,
    "update:tabIndex": null,
    "update:title": null,
    "update:titleTemplate": null,
    "update:toolbarItems": null,
    "update:visible": null,
    "update:width": null,
    "update:wrapperAttr": null
  },
  props: {
    accessKey: String,
    animation: Object,
    bindingOptions: Object,
    closeOnOutsideClick: [Boolean, Function],
    container: {},
    contentTemplate: {},
    deferRendering: Boolean,
    disabled: Boolean,
    dragAndResizeArea: {},
    dragEnabled: Boolean,
    dragOutsideBoundary: Boolean,
    enableBodyScroll: Boolean,
    focusStateEnabled: Boolean,
    fullScreen: Boolean,
    height: [Function, Number, String],
    hideOnOutsideClick: [Boolean, Function],
    hideOnParentScroll: Boolean,
    hint: String,
    hoverStateEnabled: Boolean,
    maxHeight: [Function, Number, String],
    maxWidth: [Function, Number, String],
    minHeight: [Function, Number, String],
    minWidth: [Function, Number, String],
    onContentReady: Function,
    onDisposing: Function,
    onHidden: Function,
    onHiding: Function,
    onInitialized: Function,
    onOptionChanged: Function,
    onResize: Function,
    onResizeEnd: Function,
    onResizeStart: Function,
    onShowing: Function,
    onShown: Function,
    onTitleRendered: Function,
    position: [Function, String, Object],
    resizeEnabled: Boolean,
    restorePosition: Boolean,
    rtlEnabled: Boolean,
    shading: Boolean,
    shadingColor: String,
    showCloseButton: Boolean,
    showTitle: Boolean,
    tabIndex: Number,
    title: String,
    titleTemplate: {},
    toolbarItems: Array,
    visible: Boolean,
    width: [Function, Number, String],
    wrapperAttr: {}
  }
};
k(wk);
const Sk = /* @__PURE__ */ A(wk);
Sk.$_optionName = "filterBuilderPopup";
Sk.$_expectedChildren = {
  animation: { isCollectionItem: !1, optionName: "animation" },
  position: { isCollectionItem: !1, optionName: "position" },
  toolbarItem: { isCollectionItem: !0, optionName: "toolbarItems" }
};
const Ek = {
  emits: {
    "update:isActive": null,
    "update:hoveredElement": null,
    "update:between": null,
    "update:contains": null,
    "update:endsWith": null,
    "update:equal": null,
    "update:greaterThan": null,
    "update:greaterThanOrEqual": null,
    "update:isBlank": null,
    "update:isNotBlank": null,
    "update:lessThan": null,
    "update:lessThanOrEqual": null,
    "update:notContains": null,
    "update:notEqual": null,
    "update:startsWith": null
  },
  props: {
    between: String,
    contains: String,
    endsWith: String,
    equal: String,
    greaterThan: String,
    greaterThanOrEqual: String,
    isBlank: String,
    isNotBlank: String,
    lessThan: String,
    lessThanOrEqual: String,
    notContains: String,
    notEqual: String,
    startsWith: String
  }
};
k(Ek);
const sne = /* @__PURE__ */ A(Ek);
sne.$_optionName = "filterOperationDescriptions";
const Ik = {
  emits: {
    "update:isActive": null,
    "update:hoveredElement": null,
    "update:customizeText": null,
    "update:filterEnabled": null,
    "update:texts": null,
    "update:visible": null
  },
  props: {
    customizeText: Function,
    filterEnabled: Boolean,
    texts: Object,
    visible: Boolean
  }
};
k(Ik);
const Dk = /* @__PURE__ */ A(Ik);
Dk.$_optionName = "filterPanel";
Dk.$_expectedChildren = {
  filterPanelTexts: { isCollectionItem: !1, optionName: "texts" },
  texts: { isCollectionItem: !1, optionName: "texts" }
};
const Tk = {
  emits: {
    "update:isActive": null,
    "update:hoveredElement": null,
    "update:clearFilter": null,
    "update:createFilter": null,
    "update:filterEnabledHint": null
  },
  props: {
    clearFilter: String,
    createFilter: String,
    filterEnabledHint: String
  }
};
k(Tk);
const one = /* @__PURE__ */ A(Tk);
one.$_optionName = "texts";
const Ok = {
  emits: {
    "update:isActive": null,
    "update:hoveredElement": null,
    "update:applyFilter": null,
    "update:applyFilterText": null,
    "update:betweenEndText": null,
    "update:betweenStartText": null,
    "update:operationDescriptions": null,
    "update:resetOperationText": null,
    "update:showAllText": null,
    "update:showOperationChooser": null,
    "update:visible": null
  },
  props: {
    applyFilter: String,
    applyFilterText: String,
    betweenEndText: String,
    betweenStartText: String,
    operationDescriptions: Object,
    resetOperationText: String,
    showAllText: String,
    showOperationChooser: Boolean,
    visible: Boolean
  }
};
k(Ok);
const Ak = /* @__PURE__ */ A(Ok);
Ak.$_optionName = "filterRow";
Ak.$_expectedChildren = {
  operationDescriptions: { isCollectionItem: !1, optionName: "operationDescriptions" }
};
const Rk = {
  emits: {
    "update:isActive": null,
    "update:hoveredElement": null,
    "update:accessKey": null,
    "update:activeStateEnabled": null,
    "update:alignItemLabels": null,
    "update:alignItemLabelsInAllGroups": null,
    "update:bindingOptions": null,
    "update:colCount": null,
    "update:colCountByScreen": null,
    "update:customizeItem": null,
    "update:disabled": null,
    "update:elementAttr": null,
    "update:focusStateEnabled": null,
    "update:formData": null,
    "update:height": null,
    "update:hint": null,
    "update:hoverStateEnabled": null,
    "update:isDirty": null,
    "update:items": null,
    "update:labelLocation": null,
    "update:labelMode": null,
    "update:minColWidth": null,
    "update:onContentReady": null,
    "update:onDisposing": null,
    "update:onEditorEnterKey": null,
    "update:onFieldDataChanged": null,
    "update:onInitialized": null,
    "update:onOptionChanged": null,
    "update:optionalMark": null,
    "update:readOnly": null,
    "update:requiredMark": null,
    "update:requiredMessage": null,
    "update:rtlEnabled": null,
    "update:screenByWidth": null,
    "update:scrollingEnabled": null,
    "update:showColonAfterLabel": null,
    "update:showOptionalMark": null,
    "update:showRequiredMark": null,
    "update:showValidationSummary": null,
    "update:tabIndex": null,
    "update:validationGroup": null,
    "update:visible": null,
    "update:width": null
  },
  props: {
    accessKey: String,
    activeStateEnabled: Boolean,
    alignItemLabels: Boolean,
    alignItemLabelsInAllGroups: Boolean,
    bindingOptions: Object,
    colCount: [String, Number],
    colCountByScreen: Object,
    customizeItem: Function,
    disabled: Boolean,
    elementAttr: Object,
    focusStateEnabled: Boolean,
    formData: {},
    height: [Function, Number, String],
    hint: String,
    hoverStateEnabled: Boolean,
    isDirty: Boolean,
    items: Array,
    labelLocation: String,
    labelMode: String,
    minColWidth: Number,
    onContentReady: Function,
    onDisposing: Function,
    onEditorEnterKey: Function,
    onFieldDataChanged: Function,
    onInitialized: Function,
    onOptionChanged: Function,
    optionalMark: String,
    readOnly: Boolean,
    requiredMark: String,
    requiredMessage: String,
    rtlEnabled: Boolean,
    screenByWidth: Function,
    scrollingEnabled: Boolean,
    showColonAfterLabel: Boolean,
    showOptionalMark: Boolean,
    showRequiredMark: Boolean,
    showValidationSummary: Boolean,
    tabIndex: Number,
    validationGroup: String,
    visible: Boolean,
    width: [Function, Number, String]
  }
};
k(Rk);
const Fk = /* @__PURE__ */ A(Rk);
Fk.$_optionName = "form";
Fk.$_expectedChildren = {
  colCountByScreen: { isCollectionItem: !1, optionName: "colCountByScreen" }
};
const kk = {
  emits: {
    "update:isActive": null,
    "update:hoveredElement": null,
    "update:currency": null,
    "update:formatter": null,
    "update:parser": null,
    "update:precision": null,
    "update:type": null,
    "update:useCurrencyAccountingStyle": null
  },
  props: {
    currency: String,
    formatter: Function,
    parser: Function,
    precision: Number,
    type: String,
    useCurrencyAccountingStyle: Boolean
  }
};
k(kk);
const rne = /* @__PURE__ */ A(kk);
rne.$_optionName = "format";
const Vk = {
  emits: {
    "update:isActive": null,
    "update:hoveredElement": null,
    "update:colSpan": null,
    "update:cssClass": null,
    "update:dataField": null,
    "update:editorOptions": null,
    "update:editorType": null,
    "update:helpText": null,
    "update:isRequired": null,
    "update:itemType": null,
    "update:label": null,
    "update:name": null,
    "update:template": null,
    "update:validationRules": null,
    "update:visible": null,
    "update:visibleIndex": null
  },
  props: {
    colSpan: Number,
    cssClass: String,
    dataField: String,
    editorOptions: {},
    editorType: String,
    helpText: String,
    isRequired: Boolean,
    itemType: String,
    label: Object,
    name: String,
    template: {},
    validationRules: Array,
    visible: Boolean,
    visibleIndex: Number
  }
};
k(Vk);
const Pk = /* @__PURE__ */ A(Vk);
Pk.$_optionName = "formItem";
Pk.$_expectedChildren = {
  AsyncRule: { isCollectionItem: !0, optionName: "validationRules" },
  CompareRule: { isCollectionItem: !0, optionName: "validationRules" },
  CustomRule: { isCollectionItem: !0, optionName: "validationRules" },
  EmailRule: { isCollectionItem: !0, optionName: "validationRules" },
  label: { isCollectionItem: !1, optionName: "label" },
  NumericRule: { isCollectionItem: !0, optionName: "validationRules" },
  PatternRule: { isCollectionItem: !0, optionName: "validationRules" },
  RangeRule: { isCollectionItem: !0, optionName: "validationRules" },
  RequiredRule: { isCollectionItem: !0, optionName: "validationRules" },
  StringLengthRule: { isCollectionItem: !0, optionName: "validationRules" },
  validationRule: { isCollectionItem: !0, optionName: "validationRules" }
};
const Mk = {
  emits: {
    "update:isActive": null,
    "update:hoveredElement": null,
    "update:left": null,
    "update:opacity": null,
    "update:position": null,
    "update:scale": null,
    "update:top": null
  },
  props: {
    left: Number,
    opacity: Number,
    position: Object,
    scale: Number,
    top: Number
  }
};
k(Mk);
const Bk = /* @__PURE__ */ A(Mk);
Bk.$_optionName = "from";
Bk.$_expectedChildren = {
  position: { isCollectionItem: !1, optionName: "position" }
};
const $k = {
  emits: {
    "update:isActive": null,
    "update:hoveredElement": null,
    "update:allowCollapsing": null,
    "update:autoExpandAll": null,
    "update:contextMenuEnabled": null,
    "update:expandMode": null,
    "update:texts": null
  },
  props: {
    allowCollapsing: Boolean,
    autoExpandAll: Boolean,
    contextMenuEnabled: Boolean,
    expandMode: String,
    texts: Object
  }
};
k($k);
const Nk = /* @__PURE__ */ A($k);
Nk.$_optionName = "grouping";
Nk.$_expectedChildren = {
  groupingTexts: { isCollectionItem: !1, optionName: "texts" },
  texts: { isCollectionItem: !1, optionName: "texts" }
};
const Lk = {
  emits: {
    "update:isActive": null,
    "update:hoveredElement": null,
    "update:groupByThisColumn": null,
    "update:groupContinuedMessage": null,
    "update:groupContinuesMessage": null,
    "update:ungroup": null,
    "update:ungroupAll": null
  },
  props: {
    groupByThisColumn: String,
    groupContinuedMessage: String,
    groupContinuesMessage: String,
    ungroup: String,
    ungroupAll: String
  }
};
k(Lk);
const ane = /* @__PURE__ */ A(Lk);
ane.$_optionName = "texts";
const Hk = {
  emits: {
    "update:isActive": null,
    "update:hoveredElement": null,
    "update:alignByColumn": null,
    "update:column": null,
    "update:customizeText": null,
    "update:displayFormat": null,
    "update:name": null,
    "update:showInColumn": null,
    "update:showInGroupFooter": null,
    "update:skipEmptyValues": null,
    "update:summaryType": null,
    "update:valueFormat": null
  },
  props: {
    alignByColumn: Boolean,
    column: String,
    customizeText: Function,
    displayFormat: String,
    name: String,
    showInColumn: String,
    showInGroupFooter: Boolean,
    skipEmptyValues: Boolean,
    summaryType: String,
    valueFormat: [Object, String, Function]
  }
};
k(Hk);
const NC = /* @__PURE__ */ A(Hk);
NC.$_optionName = "groupItems";
NC.$_isCollectionItem = !0;
NC.$_expectedChildren = {
  valueFormat: { isCollectionItem: !1, optionName: "valueFormat" }
};
const Wk = {
  emits: {
    "update:isActive": null,
    "update:hoveredElement": null,
    "update:and": null,
    "update:notAnd": null,
    "update:notOr": null,
    "update:or": null
  },
  props: {
    and: String,
    notAnd: String,
    notOr: String,
    or: String
  }
};
k(Wk);
const lne = /* @__PURE__ */ A(Wk);
lne.$_optionName = "groupOperationDescriptions";
const zk = {
  emits: {
    "update:isActive": null,
    "update:hoveredElement": null,
    "update:allowColumnDragging": null,
    "update:emptyPanelText": null,
    "update:visible": null
  },
  props: {
    allowColumnDragging: Boolean,
    emptyPanelText: String,
    visible: [Boolean, String]
  }
};
k(zk);
const dne = /* @__PURE__ */ A(zk);
dne.$_optionName = "groupPanel";
const Kk = {
  emits: {
    "update:isActive": null,
    "update:hoveredElement": null,
    "update:allowSearch": null,
    "update:allowSelectAll": null,
    "update:dataSource": null,
    "update:groupInterval": null,
    "update:height": null,
    "update:search": null,
    "update:searchMode": null,
    "update:searchTimeout": null,
    "update:texts": null,
    "update:visible": null,
    "update:width": null
  },
  props: {
    allowSearch: Boolean,
    allowSelectAll: Boolean,
    dataSource: [Array, Object, Function],
    groupInterval: [String, Number],
    height: [Number, String],
    search: Object,
    searchMode: String,
    searchTimeout: Number,
    texts: Object,
    visible: Boolean,
    width: [Number, String]
  }
};
k(Kk);
const Gk = /* @__PURE__ */ A(Kk);
Gk.$_optionName = "headerFilter";
Gk.$_expectedChildren = {
  columnHeaderFilterSearch: { isCollectionItem: !1, optionName: "search" },
  dataGridHeaderFilterSearch: { isCollectionItem: !1, optionName: "search" },
  dataGridHeaderFilterTexts: { isCollectionItem: !1, optionName: "texts" }
};
const Uk = {
  emits: {
    "update:isActive": null,
    "update:hoveredElement": null,
    "update:complete": null,
    "update:delay": null,
    "update:direction": null,
    "update:duration": null,
    "update:easing": null,
    "update:from": null,
    "update:staggerDelay": null,
    "update:start": null,
    "update:to": null,
    "update:type": null
  },
  props: {
    complete: Function,
    delay: Number,
    direction: String,
    duration: Number,
    easing: String,
    from: Object,
    staggerDelay: Number,
    start: Function,
    to: Object,
    type: String
  }
};
k(Uk);
const jk = /* @__PURE__ */ A(Uk);
jk.$_optionName = "hide";
jk.$_expectedChildren = {
  from: { isCollectionItem: !1, optionName: "from" },
  to: { isCollectionItem: !1, optionName: "to" }
};
const qk = {
  emits: {
    "update:isActive": null,
    "update:hoveredElement": null,
    "update:fix": null,
    "update:leftPosition": null,
    "update:rightPosition": null,
    "update:stickyPosition": null,
    "update:unfix": null
  },
  props: {
    fix: String,
    leftPosition: String,
    rightPosition: String,
    stickyPosition: String,
    unfix: String
  }
};
k(qk);
const une = /* @__PURE__ */ A(qk);
une.$_optionName = "icons";
const Yk = {
  emits: {
    "update:isActive": null,
    "update:hoveredElement": null,
    "update:cssClass": null,
    "update:disabled": null,
    "update:html": null,
    "update:locateInMenu": null,
    "update:location": null,
    "update:menuItemTemplate": null,
    "update:name": null,
    "update:options": null,
    "update:showText": null,
    "update:template": null,
    "update:text": null,
    "update:visible": null,
    "update:widget": null
  },
  props: {
    cssClass: String,
    disabled: Boolean,
    html: String,
    locateInMenu: String,
    location: String,
    menuItemTemplate: {},
    name: String,
    options: {},
    showText: String,
    template: {},
    text: String,
    visible: Boolean,
    widget: String
  }
};
k(Yk);
const Xk = /* @__PURE__ */ A(Yk);
Xk.$_optionName = "items";
Xk.$_isCollectionItem = !0;
const Zk = {
  emits: {
    "update:isActive": null,
    "update:hoveredElement": null,
    "update:editOnKeyPress": null,
    "update:enabled": null,
    "update:enterKeyAction": null,
    "update:enterKeyDirection": null
  },
  props: {
    editOnKeyPress: Boolean,
    enabled: Boolean,
    enterKeyAction: String,
    enterKeyDirection: String
  }
};
k(Zk);
const cne = /* @__PURE__ */ A(Zk);
cne.$_optionName = "keyboardNavigation";
const Qk = {
  emits: {
    "update:isActive": null,
    "update:hoveredElement": null,
    "update:alignment": null,
    "update:location": null,
    "update:showColon": null,
    "update:template": null,
    "update:text": null,
    "update:visible": null
  },
  props: {
    alignment: String,
    location: String,
    showColon: Boolean,
    template: {},
    text: String,
    visible: Boolean
  }
};
k(Qk);
const hne = /* @__PURE__ */ A(Qk);
hne.$_optionName = "label";
const Jk = {
  emits: {
    "update:isActive": null,
    "update:hoveredElement": null,
    "update:enabled": null,
    "update:height": null,
    "update:indicatorSrc": null,
    "update:shading": null,
    "update:shadingColor": null,
    "update:showIndicator": null,
    "update:showPane": null,
    "update:text": null,
    "update:width": null
  },
  props: {
    enabled: [Boolean, String],
    height: [Number, String],
    indicatorSrc: String,
    shading: Boolean,
    shadingColor: String,
    showIndicator: Boolean,
    showPane: Boolean,
    text: String,
    width: [Number, String]
  }
};
k(Jk);
const pne = /* @__PURE__ */ A(Jk);
pne.$_optionName = "loadPanel";
const eV = {
  emits: {
    "update:isActive": null,
    "update:hoveredElement": null,
    "update:allowClearing": null,
    "update:calculateCellValue": null,
    "update:dataSource": null,
    "update:displayExpr": null,
    "update:valueExpr": null
  },
  props: {
    allowClearing: Boolean,
    calculateCellValue: Function,
    dataSource: [Array, Object, Function],
    displayExpr: [Function, String],
    valueExpr: [String, Function]
  }
};
k(eV);
const gne = /* @__PURE__ */ A(eV);
gne.$_optionName = "lookup";
const tV = {
  emits: {
    "update:isActive": null,
    "update:hoveredElement": null,
    "update:autoExpandAll": null,
    "update:enabled": null,
    "update:template": null
  },
  props: {
    autoExpandAll: Boolean,
    enabled: Boolean,
    template: {}
  }
};
k(tV);
const mne = /* @__PURE__ */ A(tV);
mne.$_optionName = "masterDetail";
const nV = {
  emits: {
    "update:isActive": null,
    "update:hoveredElement": null,
    "update:x": null,
    "update:y": null
  },
  props: {
    x: String,
    y: String
  }
};
k(nV);
const fne = /* @__PURE__ */ A(nV);
fne.$_optionName = "my";
const iV = {
  emits: {
    "update:isActive": null,
    "update:hoveredElement": null,
    "update:ignoreEmptyValue": null,
    "update:message": null,
    "update:type": null
  },
  props: {
    ignoreEmptyValue: Boolean,
    message: String,
    type: String
  }
};
k(iV);
const LC = /* @__PURE__ */ A(iV);
LC.$_optionName = "validationRules";
LC.$_isCollectionItem = !0;
LC.$_predefinedProps = {
  type: "numeric"
};
const sV = {
  emits: {
    "update:isActive": null,
    "update:hoveredElement": null,
    "update:x": null,
    "update:y": null
  },
  props: {
    x: Number,
    y: Number
  }
};
k(sV);
const _ne = /* @__PURE__ */ A(sV);
_ne.$_optionName = "offset";
const oV = {
  emits: {
    "update:isActive": null,
    "update:hoveredElement": null,
    "update:between": null,
    "update:contains": null,
    "update:endsWith": null,
    "update:equal": null,
    "update:greaterThan": null,
    "update:greaterThanOrEqual": null,
    "update:lessThan": null,
    "update:lessThanOrEqual": null,
    "update:notContains": null,
    "update:notEqual": null,
    "update:startsWith": null
  },
  props: {
    between: String,
    contains: String,
    endsWith: String,
    equal: String,
    greaterThan: String,
    greaterThanOrEqual: String,
    lessThan: String,
    lessThanOrEqual: String,
    notContains: String,
    notEqual: String,
    startsWith: String
  }
};
k(oV);
const Cne = /* @__PURE__ */ A(oV);
Cne.$_optionName = "operationDescriptions";
const rV = {
  emits: {
    "update:isActive": null,
    "update:hoveredElement": null,
    "update:allowedPageSizes": null,
    "update:displayMode": null,
    "update:infoText": null,
    "update:label": null,
    "update:showInfo": null,
    "update:showNavigationButtons": null,
    "update:showPageSizeSelector": null,
    "update:visible": null
  },
  props: {
    allowedPageSizes: [Array, String],
    displayMode: String,
    infoText: String,
    label: String,
    showInfo: Boolean,
    showNavigationButtons: Boolean,
    showPageSizeSelector: Boolean,
    visible: [Boolean, String]
  }
};
k(rV);
const vne = /* @__PURE__ */ A(rV);
vne.$_optionName = "pager";
const aV = {
  emits: {
    "update:isActive": null,
    "update:hoveredElement": null,
    "update:enabled": null,
    "update:pageIndex": null,
    "update:pageSize": null
  },
  props: {
    enabled: Boolean,
    pageIndex: Number,
    pageSize: Number
  }
};
k(aV);
const xne = /* @__PURE__ */ A(aV);
xne.$_optionName = "paging";
const lV = {
  emits: {
    "update:isActive": null,
    "update:hoveredElement": null,
    "update:ignoreEmptyValue": null,
    "update:message": null,
    "update:pattern": null,
    "update:type": null
  },
  props: {
    ignoreEmptyValue: Boolean,
    message: String,
    pattern: [RegExp, String],
    type: String
  }
};
k(lV);
const HC = /* @__PURE__ */ A(lV);
HC.$_optionName = "validationRules";
HC.$_isCollectionItem = !0;
HC.$_predefinedProps = {
  type: "pattern"
};
const dV = {
  emits: {
    "update:isActive": null,
    "update:hoveredElement": null,
    "update:accessKey": null,
    "update:animation": null,
    "update:bindingOptions": null,
    "update:closeOnOutsideClick": null,
    "update:container": null,
    "update:contentTemplate": null,
    "update:deferRendering": null,
    "update:disabled": null,
    "update:dragAndResizeArea": null,
    "update:dragEnabled": null,
    "update:dragOutsideBoundary": null,
    "update:enableBodyScroll": null,
    "update:focusStateEnabled": null,
    "update:fullScreen": null,
    "update:height": null,
    "update:hideOnOutsideClick": null,
    "update:hideOnParentScroll": null,
    "update:hint": null,
    "update:hoverStateEnabled": null,
    "update:maxHeight": null,
    "update:maxWidth": null,
    "update:minHeight": null,
    "update:minWidth": null,
    "update:onContentReady": null,
    "update:onDisposing": null,
    "update:onHidden": null,
    "update:onHiding": null,
    "update:onInitialized": null,
    "update:onOptionChanged": null,
    "update:onResize": null,
    "update:onResizeEnd": null,
    "update:onResizeStart": null,
    "update:onShowing": null,
    "update:onShown": null,
    "update:onTitleRendered": null,
    "update:position": null,
    "update:resizeEnabled": null,
    "update:restorePosition": null,
    "update:rtlEnabled": null,
    "update:shading": null,
    "update:shadingColor": null,
    "update:showCloseButton": null,
    "update:showTitle": null,
    "update:tabIndex": null,
    "update:title": null,
    "update:titleTemplate": null,
    "update:toolbarItems": null,
    "update:visible": null,
    "update:width": null,
    "update:wrapperAttr": null
  },
  props: {
    accessKey: String,
    animation: Object,
    bindingOptions: Object,
    closeOnOutsideClick: [Boolean, Function],
    container: {},
    contentTemplate: {},
    deferRendering: Boolean,
    disabled: Boolean,
    dragAndResizeArea: {},
    dragEnabled: Boolean,
    dragOutsideBoundary: Boolean,
    enableBodyScroll: Boolean,
    focusStateEnabled: Boolean,
    fullScreen: Boolean,
    height: [Function, Number, String],
    hideOnOutsideClick: [Boolean, Function],
    hideOnParentScroll: Boolean,
    hint: String,
    hoverStateEnabled: Boolean,
    maxHeight: [Function, Number, String],
    maxWidth: [Function, Number, String],
    minHeight: [Function, Number, String],
    minWidth: [Function, Number, String],
    onContentReady: Function,
    onDisposing: Function,
    onHidden: Function,
    onHiding: Function,
    onInitialized: Function,
    onOptionChanged: Function,
    onResize: Function,
    onResizeEnd: Function,
    onResizeStart: Function,
    onShowing: Function,
    onShown: Function,
    onTitleRendered: Function,
    position: [Function, String, Object],
    resizeEnabled: Boolean,
    restorePosition: Boolean,
    rtlEnabled: Boolean,
    shading: Boolean,
    shadingColor: String,
    showCloseButton: Boolean,
    showTitle: Boolean,
    tabIndex: Number,
    title: String,
    titleTemplate: {},
    toolbarItems: Array,
    visible: Boolean,
    width: [Function, Number, String],
    wrapperAttr: {}
  }
};
k(dV);
const uV = /* @__PURE__ */ A(dV);
uV.$_optionName = "popup";
uV.$_expectedChildren = {
  animation: { isCollectionItem: !1, optionName: "animation" },
  position: { isCollectionItem: !1, optionName: "position" },
  toolbarItem: { isCollectionItem: !0, optionName: "toolbarItems" }
};
const cV = {
  emits: {
    "update:isActive": null,
    "update:hoveredElement": null,
    "update:at": null,
    "update:boundary": null,
    "update:boundaryOffset": null,
    "update:collision": null,
    "update:my": null,
    "update:of": null,
    "update:offset": null
  },
  props: {
    at: [Object, String],
    boundary: {},
    boundaryOffset: [Object, String],
    collision: [String, Object],
    my: [Object, String],
    of: {},
    offset: [Object, String]
  }
};
k(cV);
const hV = /* @__PURE__ */ A(cV);
hV.$_optionName = "position";
hV.$_expectedChildren = {
  at: { isCollectionItem: !1, optionName: "at" },
  boundaryOffset: { isCollectionItem: !1, optionName: "boundaryOffset" },
  collision: { isCollectionItem: !1, optionName: "collision" },
  my: { isCollectionItem: !1, optionName: "my" },
  offset: { isCollectionItem: !1, optionName: "offset" }
};
const pV = {
  emits: {
    "update:isActive": null,
    "update:hoveredElement": null,
    "update:ignoreEmptyValue": null,
    "update:max": null,
    "update:message": null,
    "update:min": null,
    "update:reevaluate": null,
    "update:type": null
  },
  props: {
    ignoreEmptyValue: Boolean,
    max: [Date, Number, String],
    message: String,
    min: [Date, Number, String],
    reevaluate: Boolean,
    type: String
  }
};
k(pV);
const WC = /* @__PURE__ */ A(pV);
WC.$_optionName = "validationRules";
WC.$_isCollectionItem = !0;
WC.$_predefinedProps = {
  type: "range"
};
const gV = {
  emits: {
    "update:isActive": null,
    "update:hoveredElement": null,
    "update:filtering": null,
    "update:grouping": null,
    "update:groupPaging": null,
    "update:paging": null,
    "update:sorting": null,
    "update:summary": null
  },
  props: {
    filtering: Boolean,
    grouping: Boolean,
    groupPaging: Boolean,
    paging: Boolean,
    sorting: Boolean,
    summary: Boolean
  }
};
k(gV);
const yne = /* @__PURE__ */ A(gV);
yne.$_optionName = "remoteOperations";
const mV = {
  emits: {
    "update:isActive": null,
    "update:hoveredElement": null,
    "update:message": null,
    "update:trim": null,
    "update:type": null
  },
  props: {
    message: String,
    trim: Boolean,
    type: String
  }
};
k(mV);
const zC = /* @__PURE__ */ A(mV);
zC.$_optionName = "validationRules";
zC.$_isCollectionItem = !0;
zC.$_predefinedProps = {
  type: "required"
};
const fV = {
  emits: {
    "update:isActive": null,
    "update:hoveredElement": null,
    "update:allowDropInsideItem": null,
    "update:allowReordering": null,
    "update:autoScroll": null,
    "update:boundary": null,
    "update:container": null,
    "update:cursorOffset": null,
    "update:data": null,
    "update:dragDirection": null,
    "update:dragTemplate": null,
    "update:dropFeedbackMode": null,
    "update:filter": null,
    "update:group": null,
    "update:handle": null,
    "update:onAdd": null,
    "update:onDragChange": null,
    "update:onDragEnd": null,
    "update:onDragMove": null,
    "update:onDragStart": null,
    "update:onRemove": null,
    "update:onReorder": null,
    "update:scrollSensitivity": null,
    "update:scrollSpeed": null,
    "update:showDragIcons": null
  },
  props: {
    allowDropInsideItem: Boolean,
    allowReordering: Boolean,
    autoScroll: Boolean,
    boundary: {},
    container: {},
    cursorOffset: [Object, String],
    data: {},
    dragDirection: String,
    dragTemplate: {},
    dropFeedbackMode: String,
    filter: String,
    group: String,
    handle: String,
    onAdd: Function,
    onDragChange: Function,
    onDragEnd: Function,
    onDragMove: Function,
    onDragStart: Function,
    onRemove: Function,
    onReorder: Function,
    scrollSensitivity: Number,
    scrollSpeed: Number,
    showDragIcons: Boolean
  }
};
k(fV);
const _V = /* @__PURE__ */ A(fV);
_V.$_optionName = "rowDragging";
_V.$_expectedChildren = {
  cursorOffset: { isCollectionItem: !1, optionName: "cursorOffset" }
};
const CV = {
  emits: {
    "update:isActive": null,
    "update:hoveredElement": null,
    "update:columnRenderingMode": null,
    "update:mode": null,
    "update:preloadEnabled": null,
    "update:renderAsync": null,
    "update:rowRenderingMode": null,
    "update:scrollByContent": null,
    "update:scrollByThumb": null,
    "update:showScrollbar": null,
    "update:useNative": null
  },
  props: {
    columnRenderingMode: String,
    mode: String,
    preloadEnabled: Boolean,
    renderAsync: Boolean,
    rowRenderingMode: String,
    scrollByContent: Boolean,
    scrollByThumb: Boolean,
    showScrollbar: String,
    useNative: [Boolean, String]
  }
};
k(CV);
const bne = /* @__PURE__ */ A(CV);
bne.$_optionName = "scrolling";
const vV = {
  emits: {
    "update:isActive": null,
    "update:hoveredElement": null,
    "update:editorOptions": null,
    "update:enabled": null,
    "update:mode": null,
    "update:searchExpr": null,
    "update:timeout": null
  },
  props: {
    editorOptions: {},
    enabled: Boolean,
    mode: String,
    searchExpr: [Array, Function, String],
    timeout: Number
  }
};
k(vV);
const wne = /* @__PURE__ */ A(vV);
wne.$_optionName = "search";
const xV = {
  emits: {
    "update:isActive": null,
    "update:hoveredElement": null,
    "update:highlightCaseSensitive": null,
    "update:highlightSearchText": null,
    "update:placeholder": null,
    "update:searchVisibleColumnsOnly": null,
    "update:text": null,
    "update:visible": null,
    "update:width": null
  },
  props: {
    highlightCaseSensitive: Boolean,
    highlightSearchText: Boolean,
    placeholder: String,
    searchVisibleColumnsOnly: Boolean,
    text: String,
    visible: Boolean,
    width: [Number, String]
  }
};
k(xV);
const Sne = /* @__PURE__ */ A(xV);
Sne.$_optionName = "searchPanel";
const yV = {
  emits: {
    "update:isActive": null,
    "update:hoveredElement": null,
    "update:allowSelectAll": null,
    "update:deferred": null,
    "update:mode": null,
    "update:recursive": null,
    "update:selectAllMode": null,
    "update:selectByClick": null,
    "update:sensitivity": null,
    "update:showCheckBoxesMode": null
  },
  props: {
    allowSelectAll: Boolean,
    deferred: Boolean,
    mode: String,
    recursive: Boolean,
    selectAllMode: String,
    selectByClick: Boolean,
    sensitivity: String,
    showCheckBoxesMode: String
  }
};
k(yV);
const Ene = /* @__PURE__ */ A(yV);
Ene.$_optionName = "selection";
const bV = {
  emits: {
    "update:isActive": null,
    "update:hoveredElement": null,
    "update:complete": null,
    "update:delay": null,
    "update:direction": null,
    "update:duration": null,
    "update:easing": null,
    "update:from": null,
    "update:staggerDelay": null,
    "update:start": null,
    "update:to": null,
    "update:type": null
  },
  props: {
    complete: Function,
    delay: Number,
    direction: String,
    duration: Number,
    easing: String,
    from: Object,
    staggerDelay: Number,
    start: Function,
    to: Object,
    type: String
  }
};
k(bV);
const wV = /* @__PURE__ */ A(bV);
wV.$_optionName = "show";
wV.$_expectedChildren = {
  from: { isCollectionItem: !1, optionName: "from" },
  to: { isCollectionItem: !1, optionName: "to" }
};
const SV = {
  emits: {
    "update:isActive": null,
    "update:hoveredElement": null,
    "update:groupColumn": null,
    "update:sortOrder": null,
    "update:summaryItem": null
  },
  props: {
    groupColumn: String,
    sortOrder: String,
    summaryItem: [Number, String]
  }
};
k(SV);
const EV = /* @__PURE__ */ A(SV);
EV.$_optionName = "sortByGroupSummaryInfo";
EV.$_isCollectionItem = !0;
const IV = {
  emits: {
    "update:isActive": null,
    "update:hoveredElement": null,
    "update:ascendingText": null,
    "update:clearText": null,
    "update:descendingText": null,
    "update:mode": null,
    "update:showSortIndexes": null
  },
  props: {
    ascendingText: String,
    clearText: String,
    descendingText: String,
    mode: String,
    showSortIndexes: Boolean
  }
};
k(IV);
const Ine = /* @__PURE__ */ A(IV);
Ine.$_optionName = "sorting";
const DV = {
  emits: {
    "update:isActive": null,
    "update:hoveredElement": null,
    "update:customLoad": null,
    "update:customSave": null,
    "update:enabled": null,
    "update:savingTimeout": null,
    "update:storageKey": null,
    "update:type": null
  },
  props: {
    customLoad: Function,
    customSave: Function,
    enabled: Boolean,
    savingTimeout: Number,
    storageKey: String,
    type: String
  }
};
k(DV);
const Dne = /* @__PURE__ */ A(DV);
Dne.$_optionName = "stateStoring";
const TV = {
  emits: {
    "update:isActive": null,
    "update:hoveredElement": null,
    "update:ignoreEmptyValue": null,
    "update:max": null,
    "update:message": null,
    "update:min": null,
    "update:trim": null,
    "update:type": null
  },
  props: {
    ignoreEmptyValue: Boolean,
    max: Number,
    message: String,
    min: Number,
    trim: Boolean,
    type: String
  }
};
k(TV);
const KC = /* @__PURE__ */ A(TV);
KC.$_optionName = "validationRules";
KC.$_isCollectionItem = !0;
KC.$_predefinedProps = {
  type: "stringLength"
};
const OV = {
  emits: {
    "update:isActive": null,
    "update:hoveredElement": null,
    "update:calculateCustomSummary": null,
    "update:groupItems": null,
    "update:recalculateWhileEditing": null,
    "update:skipEmptyValues": null,
    "update:texts": null,
    "update:totalItems": null
  },
  props: {
    calculateCustomSummary: Function,
    groupItems: Array,
    recalculateWhileEditing: Boolean,
    skipEmptyValues: Boolean,
    texts: Object,
    totalItems: Array
  }
};
k(OV);
const AV = /* @__PURE__ */ A(OV);
AV.$_optionName = "summary";
AV.$_expectedChildren = {
  groupItem: { isCollectionItem: !0, optionName: "groupItems" },
  summaryTexts: { isCollectionItem: !1, optionName: "texts" },
  texts: { isCollectionItem: !1, optionName: "texts" },
  totalItem: { isCollectionItem: !0, optionName: "totalItems" }
};
const RV = {
  emits: {
    "update:isActive": null,
    "update:hoveredElement": null,
    "update:avg": null,
    "update:avgOtherColumn": null,
    "update:count": null,
    "update:max": null,
    "update:maxOtherColumn": null,
    "update:min": null,
    "update:minOtherColumn": null,
    "update:sum": null,
    "update:sumOtherColumn": null
  },
  props: {
    avg: String,
    avgOtherColumn: String,
    count: String,
    max: String,
    maxOtherColumn: String,
    min: String,
    minOtherColumn: String,
    sum: String,
    sumOtherColumn: String
  }
};
k(RV);
const Tne = /* @__PURE__ */ A(RV);
Tne.$_optionName = "texts";
const FV = {
  emits: {
    "update:isActive": null,
    "update:hoveredElement": null,
    "update:addRow": null,
    "update:avg": null,
    "update:avgOtherColumn": null,
    "update:cancel": null,
    "update:cancelAllChanges": null,
    "update:cancelRowChanges": null,
    "update:clearFilter": null,
    "update:confirmDeleteMessage": null,
    "update:confirmDeleteTitle": null,
    "update:count": null,
    "update:createFilter": null,
    "update:deleteRow": null,
    "update:editRow": null,
    "update:emptyValue": null,
    "update:exportAll": null,
    "update:exportSelectedRows": null,
    "update:exportTo": null,
    "update:filterEnabledHint": null,
    "update:fix": null,
    "update:groupByThisColumn": null,
    "update:groupContinuedMessage": null,
    "update:groupContinuesMessage": null,
    "update:leftPosition": null,
    "update:max": null,
    "update:maxOtherColumn": null,
    "update:min": null,
    "update:minOtherColumn": null,
    "update:ok": null,
    "update:rightPosition": null,
    "update:saveAllChanges": null,
    "update:saveRowChanges": null,
    "update:stickyPosition": null,
    "update:sum": null,
    "update:sumOtherColumn": null,
    "update:undeleteRow": null,
    "update:unfix": null,
    "update:ungroup": null,
    "update:ungroupAll": null,
    "update:validationCancelChanges": null
  },
  props: {
    addRow: String,
    avg: String,
    avgOtherColumn: String,
    cancel: String,
    cancelAllChanges: String,
    cancelRowChanges: String,
    clearFilter: String,
    confirmDeleteMessage: String,
    confirmDeleteTitle: String,
    count: String,
    createFilter: String,
    deleteRow: String,
    editRow: String,
    emptyValue: String,
    exportAll: String,
    exportSelectedRows: String,
    exportTo: String,
    filterEnabledHint: String,
    fix: String,
    groupByThisColumn: String,
    groupContinuedMessage: String,
    groupContinuesMessage: String,
    leftPosition: String,
    max: String,
    maxOtherColumn: String,
    min: String,
    minOtherColumn: String,
    ok: String,
    rightPosition: String,
    saveAllChanges: String,
    saveRowChanges: String,
    stickyPosition: String,
    sum: String,
    sumOtherColumn: String,
    undeleteRow: String,
    unfix: String,
    ungroup: String,
    ungroupAll: String,
    validationCancelChanges: String
  }
};
k(FV);
const One = /* @__PURE__ */ A(FV);
One.$_optionName = "texts";
const kV = {
  emits: {
    "update:isActive": null,
    "update:hoveredElement": null,
    "update:left": null,
    "update:opacity": null,
    "update:position": null,
    "update:scale": null,
    "update:top": null
  },
  props: {
    left: Number,
    opacity: Number,
    position: Object,
    scale: Number,
    top: Number
  }
};
k(kV);
const VV = /* @__PURE__ */ A(kV);
VV.$_optionName = "to";
VV.$_expectedChildren = {
  position: { isCollectionItem: !1, optionName: "position" }
};
const PV = {
  emits: {
    "update:isActive": null,
    "update:hoveredElement": null,
    "update:disabled": null,
    "update:items": null,
    "update:visible": null
  },
  props: {
    disabled: Boolean,
    items: Array,
    visible: Boolean
  }
};
k(PV);
const MV = /* @__PURE__ */ A(PV);
MV.$_optionName = "toolbar";
MV.$_expectedChildren = {
  item: { isCollectionItem: !0, optionName: "items" }
};
const BV = {
  emits: {
    "update:isActive": null,
    "update:hoveredElement": null,
    "update:cssClass": null,
    "update:disabled": null,
    "update:html": null,
    "update:locateInMenu": null,
    "update:location": null,
    "update:menuItemTemplate": null,
    "update:options": null,
    "update:showText": null,
    "update:template": null,
    "update:text": null,
    "update:toolbar": null,
    "update:visible": null,
    "update:widget": null
  },
  props: {
    cssClass: String,
    disabled: Boolean,
    html: String,
    locateInMenu: String,
    location: String,
    menuItemTemplate: {},
    options: {},
    showText: String,
    template: {},
    text: String,
    toolbar: String,
    visible: Boolean,
    widget: String
  }
};
k(BV);
const $V = /* @__PURE__ */ A(BV);
$V.$_optionName = "toolbarItems";
$V.$_isCollectionItem = !0;
const NV = {
  emits: {
    "update:isActive": null,
    "update:hoveredElement": null,
    "update:alignment": null,
    "update:column": null,
    "update:cssClass": null,
    "update:customizeText": null,
    "update:displayFormat": null,
    "update:name": null,
    "update:showInColumn": null,
    "update:skipEmptyValues": null,
    "update:summaryType": null,
    "update:valueFormat": null
  },
  props: {
    alignment: String,
    column: String,
    cssClass: String,
    customizeText: Function,
    displayFormat: String,
    name: String,
    showInColumn: String,
    skipEmptyValues: Boolean,
    summaryType: String,
    valueFormat: [Object, String, Function]
  }
};
k(NV);
const GC = /* @__PURE__ */ A(NV);
GC.$_optionName = "totalItems";
GC.$_isCollectionItem = !0;
GC.$_expectedChildren = {
  valueFormat: { isCollectionItem: !1, optionName: "valueFormat" }
};
const LV = {
  emits: {
    "update:isActive": null,
    "update:hoveredElement": null,
    "update:comparisonTarget": null,
    "update:comparisonType": null,
    "update:ignoreEmptyValue": null,
    "update:max": null,
    "update:message": null,
    "update:min": null,
    "update:pattern": null,
    "update:reevaluate": null,
    "update:trim": null,
    "update:type": null,
    "update:validationCallback": null
  },
  props: {
    comparisonTarget: Function,
    comparisonType: String,
    ignoreEmptyValue: Boolean,
    max: [Date, Number, String],
    message: String,
    min: [Date, Number, String],
    pattern: [RegExp, String],
    reevaluate: Boolean,
    trim: Boolean,
    type: String,
    validationCallback: Function
  }
};
k(LV);
const UC = /* @__PURE__ */ A(LV);
UC.$_optionName = "validationRules";
UC.$_isCollectionItem = !0;
UC.$_predefinedProps = {
  type: "required"
};
const HV = {
  emits: {
    "update:isActive": null,
    "update:hoveredElement": null,
    "update:currency": null,
    "update:formatter": null,
    "update:parser": null,
    "update:precision": null,
    "update:type": null,
    "update:useCurrencyAccountingStyle": null
  },
  props: {
    currency: String,
    formatter: Function,
    parser: Function,
    precision: Number,
    type: String,
    useCurrencyAccountingStyle: Boolean
  }
};
k(HV);
const Ane = /* @__PURE__ */ A(HV);
Ane.$_optionName = "valueFormat";
const {
  getActiveElement: Rne
} = O;
class jC extends vh {
  _supportedKeys() {
    return I({}, super._supportedKeys(), {
      tab(e) {
        if (!this.option("opened"))
          return;
        const t = this._getTabbableElements(), n = e.shiftKey ? t.last() : t.first();
        n && _.trigger(n, "focus"), e.preventDefault();
      }
    });
  }
  _getTabbableElements() {
    return this._getElements().filter(tm);
  }
  _getElements() {
    return p(this.content()).find("*");
  }
  _getDefaultOptions() {
    return I({}, super._getDefaultOptions(), {
      acceptCustomValue: !1,
      contentTemplate: "content",
      openOnFieldClick: !0,
      displayValueFormatter: (e) => Array.isArray(e) ? e.join(", ") : e,
      useHiddenSubmitElement: !0
    });
  }
  _getAnonymousTemplateName() {
    return "content";
  }
  _initTemplates() {
    super._initTemplates();
  }
  _initMarkup() {
    this._initDataExpressions(), this.$element().addClass("dx-dropdownbox"), super._initMarkup();
  }
  _setSubmitValue() {
    const e = this.option("value"), t = this._shouldUseDisplayValue(e) ? this._displayGetter(e) : e;
    this._getSubmitElement().val(t);
  }
  _shouldUseDisplayValue(e) {
    return this.option("valueExpr") === "this" && X(e);
  }
  _sortValuesByKeysOrder(e, t) {
    return t.sort((s, o) => e.indexOf(s.itemKey) - e.indexOf(o.itemKey)).map((s) => s.itemDisplayValue);
  }
  _renderInputValue() {
    let {
      renderOnly: e
    } = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    this._rejectValueLoading();
    const t = [];
    if (!this._dataSource)
      return super._renderInputValue({
        renderOnly: e,
        value: t
      }), w().resolve();
    let s = this._getCurrentValue() ?? [];
    s = Array.isArray(s) ? s : [s];
    const o = mt(s, (a) => {
      const l = w();
      return this._loadItem(a).always((d) => {
        const u = this._displayGetter(d);
        f(u) ? t.push({
          itemKey: a,
          itemDisplayValue: u
        }) : this.option("acceptCustomValue") && t.push({
          itemKey: a,
          itemDisplayValue: a
        }), l.resolve();
      }), l;
    }), r = super._renderInputValue.bind(this);
    return W.apply(this, o).always(() => {
      const a = this._sortValuesByKeysOrder(s, t);
      this.option("displayValue", a), r({
        renderOnly: e,
        value: t.length && a
      });
    });
  }
  _loadItem(e) {
    const t = w(), n = this, s = Wt(this.option("items") || [], (o) => this._isValueEquals(this._valueGetter(o), e))[0];
    return s !== void 0 ? t.resolve(s) : this._loadValue(e).done((o) => {
      t.resolve(o);
    }).fail((o) => {
      o != null && o.shouldSkipCallback || (n.option("acceptCustomValue") ? t.resolve(e) : t.reject());
    }), t.promise();
  }
  _popupTabHandler(e) {
    if (Ye(e) !== "tab")
      return;
    const t = this._getTabbableElements().first().get(0), n = this._getTabbableElements().last().get(0), s = e.target, o = !!(s === t && e.shiftKey), r = s === n && !e.shiftKey;
    (o || r) && (this.close(), _.trigger(this._input(), "focus"), o && e.preventDefault());
  }
  _renderPopupContent() {
    if (this.option("contentTemplate") === "content")
      return;
    const e = this._getTemplateByOption("contentTemplate");
    if (!(e && this.option("contentTemplate")))
      return;
    const t = this._popup.$content(), n = {
      value: this._fieldRenderData(),
      component: this
    };
    t.empty(), e.render({
      container: ee(t),
      model: n
    });
  }
  _canShowVirtualKeyboard() {
    return z.real().mac;
  }
  _isNestedElementActive() {
    const e = Rne();
    return e && this._popup.$content().get(0).contains(e);
  }
  _shouldHideOnParentScroll() {
    return z.real().deviceType === "desktop" && this._canShowVirtualKeyboard() && this._isNestedElementActive();
  }
  _popupHiddenHandler() {
    super._popupHiddenHandler(), this._popupPosition = void 0;
  }
  _popupPositionedHandler(e) {
    super._popupPositionedHandler(e), this._popupPosition = e.position;
  }
  _getDefaultPopupPosition(e) {
    const {
      my: t,
      at: n
    } = super._getDefaultPopupPosition(e);
    return {
      my: t,
      at: n,
      offset: {
        v: -1
      },
      collision: "flipfit"
    };
  }
  _popupConfig() {
    const {
      focusStateEnabled: e
    } = this.option();
    return I({}, super._popupConfig(), {
      tabIndex: -1,
      dragEnabled: !1,
      focusStateEnabled: e,
      contentTemplate: "content",
      hideOnParentScroll: this._shouldHideOnParentScroll.bind(this),
      position: x(this.option("popupPosition"), {
        of: this.$element()
      }),
      _ignoreFunctionValueDeprecation: !0,
      maxHeight: function() {
        var t;
        const n = (t = this._popupPosition) === null || t === void 0 ? void 0 : t.v.location;
        return bC(this.$element(), n);
      }.bind(this)
    });
  }
  _popupShownHandler() {
    super._popupShownHandler();
    const e = this._getTabbableElements().first();
    _.trigger(e, "focus");
  }
  _setCollectionWidgetOption() {
  }
  _optionChanged(e) {
    switch (this._dataExpressionOptionChanged(e), e.name) {
      case "dataSource":
        this._renderInputValue();
        break;
      case "displayValue":
        this.option("text", e.value);
        break;
      case "displayExpr":
        this._renderValue();
        break;
      case "contentTemplate":
        this._invalidate();
        break;
      default:
        super._optionChanged(e);
    }
  }
}
jC.include(hC);
xe("dxDropDownBox", jC);
/*!
 * devextreme-vue
 * Version: 24.2.7
 * Build date: Mon Apr 28 2025
 *
 * Copyright (c) 2012 - 2025 Developer Express Inc. ALL RIGHTS RESERVED
 *
 * This software may be modified and distributed under the terms
 * of the MIT license. See the LICENSE file in the root of the project for details.
 *
 * https://github.com/DevExpress/devextreme-vue
 */
const WV = {
  props: {
    acceptCustomValue: Boolean,
    accessKey: String,
    activeStateEnabled: Boolean,
    buttons: Array,
    contentTemplate: {},
    dataSource: [Array, Object, String],
    deferRendering: Boolean,
    disabled: Boolean,
    displayExpr: [Function, String],
    displayValueFormatter: Function,
    dropDownButtonTemplate: {},
    dropDownOptions: Object,
    elementAttr: Object,
    fieldTemplate: {},
    focusStateEnabled: Boolean,
    height: [Function, Number, String],
    hint: String,
    hoverStateEnabled: Boolean,
    inputAttr: {},
    isDirty: Boolean,
    isValid: Boolean,
    items: Array,
    label: String,
    labelMode: String,
    maxLength: [Number, String],
    name: String,
    onChange: Function,
    onClosed: Function,
    onCopy: Function,
    onCut: Function,
    onDisposing: Function,
    onEnterKey: Function,
    onFocusIn: Function,
    onFocusOut: Function,
    onInitialized: Function,
    onInput: Function,
    onKeyDown: Function,
    onKeyUp: Function,
    onOpened: Function,
    onOptionChanged: Function,
    onPaste: Function,
    onValueChanged: Function,
    opened: Boolean,
    openOnFieldClick: Boolean,
    placeholder: String,
    readOnly: Boolean,
    rtlEnabled: Boolean,
    showClearButton: Boolean,
    showDropDownButton: Boolean,
    stylingMode: String,
    tabIndex: Number,
    text: String,
    validationError: {},
    validationErrors: Array,
    validationMessageMode: String,
    validationMessagePosition: String,
    validationStatus: String,
    value: {},
    valueChangeEvent: String,
    valueExpr: [Function, String],
    visible: Boolean,
    width: [Function, Number, String]
  },
  emits: {
    "update:isActive": null,
    "update:hoveredElement": null,
    "update:acceptCustomValue": null,
    "update:accessKey": null,
    "update:activeStateEnabled": null,
    "update:buttons": null,
    "update:contentTemplate": null,
    "update:dataSource": null,
    "update:deferRendering": null,
    "update:disabled": null,
    "update:displayExpr": null,
    "update:displayValueFormatter": null,
    "update:dropDownButtonTemplate": null,
    "update:dropDownOptions": null,
    "update:elementAttr": null,
    "update:fieldTemplate": null,
    "update:focusStateEnabled": null,
    "update:height": null,
    "update:hint": null,
    "update:hoverStateEnabled": null,
    "update:inputAttr": null,
    "update:isDirty": null,
    "update:isValid": null,
    "update:items": null,
    "update:label": null,
    "update:labelMode": null,
    "update:maxLength": null,
    "update:name": null,
    "update:onChange": null,
    "update:onClosed": null,
    "update:onCopy": null,
    "update:onCut": null,
    "update:onDisposing": null,
    "update:onEnterKey": null,
    "update:onFocusIn": null,
    "update:onFocusOut": null,
    "update:onInitialized": null,
    "update:onInput": null,
    "update:onKeyDown": null,
    "update:onKeyUp": null,
    "update:onOpened": null,
    "update:onOptionChanged": null,
    "update:onPaste": null,
    "update:onValueChanged": null,
    "update:opened": null,
    "update:openOnFieldClick": null,
    "update:placeholder": null,
    "update:readOnly": null,
    "update:rtlEnabled": null,
    "update:showClearButton": null,
    "update:showDropDownButton": null,
    "update:stylingMode": null,
    "update:tabIndex": null,
    "update:text": null,
    "update:validationError": null,
    "update:validationErrors": null,
    "update:validationMessageMode": null,
    "update:validationMessagePosition": null,
    "update:validationStatus": null,
    "update:value": null,
    "update:valueChangeEvent": null,
    "update:valueExpr": null,
    "update:visible": null,
    "update:width": null
  },
  model: { prop: "value", event: "update:value" },
  computed: {
    instance() {
      return this.$_instance;
    }
  },
  beforeCreate() {
    this.$_WidgetClass = jC, this.$_hasAsyncTemplate = !0, this.$_expectedChildren = {
      button: { isCollectionItem: !0, optionName: "buttons" },
      dropDownOptions: { isCollectionItem: !1, optionName: "dropDownOptions" }
    };
  }
};
io(WV);
const hie = /* @__PURE__ */ A(WV), zV = {
  emits: {
    "update:isActive": null,
    "update:hoveredElement": null,
    "update:hide": null,
    "update:show": null
  },
  props: {
    hide: [Object, Number, String],
    show: [Object, Number, String]
  }
};
k(zV);
const KV = /* @__PURE__ */ A(zV);
KV.$_optionName = "animation";
KV.$_expectedChildren = {
  hide: { isCollectionItem: !1, optionName: "hide" },
  show: { isCollectionItem: !1, optionName: "show" }
};
const GV = {
  emits: {
    "update:isActive": null,
    "update:hoveredElement": null,
    "update:x": null,
    "update:y": null
  },
  props: {
    x: String,
    y: String
  }
};
k(GV);
const Fne = /* @__PURE__ */ A(GV);
Fne.$_optionName = "at";
const UV = {
  emits: {
    "update:isActive": null,
    "update:hoveredElement": null,
    "update:x": null,
    "update:y": null
  },
  props: {
    x: Number,
    y: Number
  }
};
k(UV);
const kne = /* @__PURE__ */ A(UV);
kne.$_optionName = "boundaryOffset";
const jV = {
  emits: {
    "update:isActive": null,
    "update:hoveredElement": null,
    "update:location": null,
    "update:name": null,
    "update:options": null
  },
  props: {
    location: String,
    name: String,
    options: Object
  }
};
k(jV);
const qC = /* @__PURE__ */ A(jV);
qC.$_optionName = "buttons";
qC.$_isCollectionItem = !0;
qC.$_expectedChildren = {
  options: { isCollectionItem: !1, optionName: "options" }
};
const qV = {
  emits: {
    "update:isActive": null,
    "update:hoveredElement": null,
    "update:x": null,
    "update:y": null
  },
  props: {
    x: String,
    y: String
  }
};
k(qV);
const Vne = /* @__PURE__ */ A(qV);
Vne.$_optionName = "collision";
const YV = {
  emits: {
    "update:isActive": null,
    "update:hoveredElement": null,
    "update:accessKey": null,
    "update:animation": null,
    "update:bindingOptions": null,
    "update:closeOnOutsideClick": null,
    "update:container": null,
    "update:contentTemplate": null,
    "update:deferRendering": null,
    "update:disabled": null,
    "update:dragAndResizeArea": null,
    "update:dragEnabled": null,
    "update:dragOutsideBoundary": null,
    "update:enableBodyScroll": null,
    "update:focusStateEnabled": null,
    "update:fullScreen": null,
    "update:height": null,
    "update:hideOnOutsideClick": null,
    "update:hideOnParentScroll": null,
    "update:hint": null,
    "update:hoverStateEnabled": null,
    "update:maxHeight": null,
    "update:maxWidth": null,
    "update:minHeight": null,
    "update:minWidth": null,
    "update:onContentReady": null,
    "update:onDisposing": null,
    "update:onHidden": null,
    "update:onHiding": null,
    "update:onInitialized": null,
    "update:onOptionChanged": null,
    "update:onResize": null,
    "update:onResizeEnd": null,
    "update:onResizeStart": null,
    "update:onShowing": null,
    "update:onShown": null,
    "update:onTitleRendered": null,
    "update:position": null,
    "update:resizeEnabled": null,
    "update:restorePosition": null,
    "update:rtlEnabled": null,
    "update:shading": null,
    "update:shadingColor": null,
    "update:showCloseButton": null,
    "update:showTitle": null,
    "update:tabIndex": null,
    "update:title": null,
    "update:titleTemplate": null,
    "update:toolbarItems": null,
    "update:visible": null,
    "update:width": null,
    "update:wrapperAttr": null
  },
  props: {
    accessKey: String,
    animation: Object,
    bindingOptions: Object,
    closeOnOutsideClick: [Boolean, Function],
    container: {},
    contentTemplate: {},
    deferRendering: Boolean,
    disabled: Boolean,
    dragAndResizeArea: {},
    dragEnabled: Boolean,
    dragOutsideBoundary: Boolean,
    enableBodyScroll: Boolean,
    focusStateEnabled: Boolean,
    fullScreen: Boolean,
    height: [Function, Number, String],
    hideOnOutsideClick: [Boolean, Function],
    hideOnParentScroll: Boolean,
    hint: String,
    hoverStateEnabled: Boolean,
    maxHeight: [Function, Number, String],
    maxWidth: [Function, Number, String],
    minHeight: [Function, Number, String],
    minWidth: [Function, Number, String],
    onContentReady: Function,
    onDisposing: Function,
    onHidden: Function,
    onHiding: Function,
    onInitialized: Function,
    onOptionChanged: Function,
    onResize: Function,
    onResizeEnd: Function,
    onResizeStart: Function,
    onShowing: Function,
    onShown: Function,
    onTitleRendered: Function,
    position: [Function, String, Object],
    resizeEnabled: Boolean,
    restorePosition: Boolean,
    rtlEnabled: Boolean,
    shading: Boolean,
    shadingColor: String,
    showCloseButton: Boolean,
    showTitle: Boolean,
    tabIndex: Number,
    title: String,
    titleTemplate: {},
    toolbarItems: Array,
    visible: Boolean,
    width: [Function, Number, String],
    wrapperAttr: {}
  }
};
k(YV);
const XV = /* @__PURE__ */ A(YV);
XV.$_optionName = "dropDownOptions";
XV.$_expectedChildren = {
  animation: { isCollectionItem: !1, optionName: "animation" },
  position: { isCollectionItem: !1, optionName: "position" },
  toolbarItem: { isCollectionItem: !0, optionName: "toolbarItems" }
};
const ZV = {
  emits: {
    "update:isActive": null,
    "update:hoveredElement": null,
    "update:left": null,
    "update:opacity": null,
    "update:position": null,
    "update:scale": null,
    "update:top": null
  },
  props: {
    left: Number,
    opacity: Number,
    position: Object,
    scale: Number,
    top: Number
  }
};
k(ZV);
const QV = /* @__PURE__ */ A(ZV);
QV.$_optionName = "from";
QV.$_expectedChildren = {
  position: { isCollectionItem: !1, optionName: "position" }
};
const JV = {
  emits: {
    "update:isActive": null,
    "update:hoveredElement": null,
    "update:complete": null,
    "update:delay": null,
    "update:direction": null,
    "update:duration": null,
    "update:easing": null,
    "update:from": null,
    "update:staggerDelay": null,
    "update:start": null,
    "update:to": null,
    "update:type": null
  },
  props: {
    complete: Function,
    delay: Number,
    direction: String,
    duration: Number,
    easing: String,
    from: Object,
    staggerDelay: Number,
    start: Function,
    to: Object,
    type: String
  }
};
k(JV);
const eP = /* @__PURE__ */ A(JV);
eP.$_optionName = "hide";
eP.$_expectedChildren = {
  from: { isCollectionItem: !1, optionName: "from" },
  to: { isCollectionItem: !1, optionName: "to" }
};
const tP = {
  emits: {
    "update:isActive": null,
    "update:hoveredElement": null,
    "update:x": null,
    "update:y": null
  },
  props: {
    x: String,
    y: String
  }
};
k(tP);
const Pne = /* @__PURE__ */ A(tP);
Pne.$_optionName = "my";
const nP = {
  emits: {
    "update:isActive": null,
    "update:hoveredElement": null,
    "update:x": null,
    "update:y": null
  },
  props: {
    x: Number,
    y: Number
  }
};
k(nP);
const Mne = /* @__PURE__ */ A(nP);
Mne.$_optionName = "offset";
const iP = {
  emits: {
    "update:isActive": null,
    "update:hoveredElement": null,
    "update:accessKey": null,
    "update:activeStateEnabled": null,
    "update:bindingOptions": null,
    "update:disabled": null,
    "update:elementAttr": null,
    "update:focusStateEnabled": null,
    "update:height": null,
    "update:hint": null,
    "update:hoverStateEnabled": null,
    "update:icon": null,
    "update:onClick": null,
    "update:onContentReady": null,
    "update:onDisposing": null,
    "update:onInitialized": null,
    "update:onOptionChanged": null,
    "update:rtlEnabled": null,
    "update:stylingMode": null,
    "update:tabIndex": null,
    "update:template": null,
    "update:text": null,
    "update:type": null,
    "update:useSubmitBehavior": null,
    "update:validationGroup": null,
    "update:visible": null,
    "update:width": null
  },
  props: {
    accessKey: String,
    activeStateEnabled: Boolean,
    bindingOptions: Object,
    disabled: Boolean,
    elementAttr: Object,
    focusStateEnabled: Boolean,
    height: [Function, Number, String],
    hint: String,
    hoverStateEnabled: Boolean,
    icon: String,
    onClick: Function,
    onContentReady: Function,
    onDisposing: Function,
    onInitialized: Function,
    onOptionChanged: Function,
    rtlEnabled: Boolean,
    stylingMode: String,
    tabIndex: Number,
    template: {},
    text: String,
    type: String,
    useSubmitBehavior: Boolean,
    validationGroup: String,
    visible: Boolean,
    width: [Function, Number, String]
  }
};
k(iP);
const Bne = /* @__PURE__ */ A(iP);
Bne.$_optionName = "options";
const sP = {
  emits: {
    "update:isActive": null,
    "update:hoveredElement": null,
    "update:at": null,
    "update:boundary": null,
    "update:boundaryOffset": null,
    "update:collision": null,
    "update:my": null,
    "update:of": null,
    "update:offset": null
  },
  props: {
    at: [Object, String],
    boundary: {},
    boundaryOffset: [Object, String],
    collision: [String, Object],
    my: [Object, String],
    of: {},
    offset: [Object, String]
  }
};
k(sP);
const oP = /* @__PURE__ */ A(sP);
oP.$_optionName = "position";
oP.$_expectedChildren = {
  at: { isCollectionItem: !1, optionName: "at" },
  boundaryOffset: { isCollectionItem: !1, optionName: "boundaryOffset" },
  collision: { isCollectionItem: !1, optionName: "collision" },
  my: { isCollectionItem: !1, optionName: "my" },
  offset: { isCollectionItem: !1, optionName: "offset" }
};
const rP = {
  emits: {
    "update:isActive": null,
    "update:hoveredElement": null,
    "update:complete": null,
    "update:delay": null,
    "update:direction": null,
    "update:duration": null,
    "update:easing": null,
    "update:from": null,
    "update:staggerDelay": null,
    "update:start": null,
    "update:to": null,
    "update:type": null
  },
  props: {
    complete: Function,
    delay: Number,
    direction: String,
    duration: Number,
    easing: String,
    from: Object,
    staggerDelay: Number,
    start: Function,
    to: Object,
    type: String
  }
};
k(rP);
const aP = /* @__PURE__ */ A(rP);
aP.$_optionName = "show";
aP.$_expectedChildren = {
  from: { isCollectionItem: !1, optionName: "from" },
  to: { isCollectionItem: !1, optionName: "to" }
};
const lP = {
  emits: {
    "update:isActive": null,
    "update:hoveredElement": null,
    "update:left": null,
    "update:opacity": null,
    "update:position": null,
    "update:scale": null,
    "update:top": null
  },
  props: {
    left: Number,
    opacity: Number,
    position: Object,
    scale: Number,
    top: Number
  }
};
k(lP);
const dP = /* @__PURE__ */ A(lP);
dP.$_optionName = "to";
dP.$_expectedChildren = {
  position: { isCollectionItem: !1, optionName: "position" }
};
const uP = {
  emits: {
    "update:isActive": null,
    "update:hoveredElement": null,
    "update:cssClass": null,
    "update:disabled": null,
    "update:html": null,
    "update:locateInMenu": null,
    "update:location": null,
    "update:menuItemTemplate": null,
    "update:options": null,
    "update:showText": null,
    "update:template": null,
    "update:text": null,
    "update:toolbar": null,
    "update:visible": null,
    "update:widget": null
  },
  props: {
    cssClass: String,
    disabled: Boolean,
    html: String,
    locateInMenu: String,
    location: String,
    menuItemTemplate: {},
    options: {},
    showText: String,
    template: {},
    text: String,
    toolbar: String,
    visible: Boolean,
    widget: String
  }
};
k(uP);
const cP = /* @__PURE__ */ A(uP);
cP.$_optionName = "toolbarItems";
cP.$_isCollectionItem = !0;
/*!
 * devextreme-vue
 * Version: 24.2.7
 * Build date: Mon Apr 28 2025
 *
 * Copyright (c) 2012 - 2025 Developer Express Inc. ALL RIGHTS RESERVED
 *
 * This software may be modified and distributed under the terms
 * of the MIT license. See the LICENSE file in the root of the project for details.
 *
 * https://github.com/DevExpress/devextreme-vue
 */
const hP = {
  props: {
    accessKey: String,
    activeStateEnabled: Boolean,
    buttons: Array,
    disabled: Boolean,
    elementAttr: Object,
    focusStateEnabled: Boolean,
    height: [Function, Number, String],
    hint: String,
    hoverStateEnabled: Boolean,
    inputAttr: {},
    isDirty: Boolean,
    isValid: Boolean,
    label: String,
    labelMode: String,
    mask: String,
    maskChar: String,
    maskInvalidMessage: String,
    maskRules: {},
    maxLength: [Number, String],
    mode: String,
    name: String,
    onChange: Function,
    onContentReady: Function,
    onCopy: Function,
    onCut: Function,
    onDisposing: Function,
    onEnterKey: Function,
    onFocusIn: Function,
    onFocusOut: Function,
    onInitialized: Function,
    onInput: Function,
    onKeyDown: Function,
    onKeyUp: Function,
    onOptionChanged: Function,
    onPaste: Function,
    onValueChanged: Function,
    placeholder: String,
    readOnly: Boolean,
    rtlEnabled: Boolean,
    showClearButton: Boolean,
    showMaskMode: String,
    spellcheck: Boolean,
    stylingMode: String,
    tabIndex: Number,
    text: String,
    useMaskedValue: Boolean,
    validationError: {},
    validationErrors: Array,
    validationMessageMode: String,
    validationMessagePosition: String,
    validationStatus: String,
    value: String,
    valueChangeEvent: String,
    visible: Boolean,
    width: [Function, Number, String]
  },
  emits: {
    "update:isActive": null,
    "update:hoveredElement": null,
    "update:accessKey": null,
    "update:activeStateEnabled": null,
    "update:buttons": null,
    "update:disabled": null,
    "update:elementAttr": null,
    "update:focusStateEnabled": null,
    "update:height": null,
    "update:hint": null,
    "update:hoverStateEnabled": null,
    "update:inputAttr": null,
    "update:isDirty": null,
    "update:isValid": null,
    "update:label": null,
    "update:labelMode": null,
    "update:mask": null,
    "update:maskChar": null,
    "update:maskInvalidMessage": null,
    "update:maskRules": null,
    "update:maxLength": null,
    "update:mode": null,
    "update:name": null,
    "update:onChange": null,
    "update:onContentReady": null,
    "update:onCopy": null,
    "update:onCut": null,
    "update:onDisposing": null,
    "update:onEnterKey": null,
    "update:onFocusIn": null,
    "update:onFocusOut": null,
    "update:onInitialized": null,
    "update:onInput": null,
    "update:onKeyDown": null,
    "update:onKeyUp": null,
    "update:onOptionChanged": null,
    "update:onPaste": null,
    "update:onValueChanged": null,
    "update:placeholder": null,
    "update:readOnly": null,
    "update:rtlEnabled": null,
    "update:showClearButton": null,
    "update:showMaskMode": null,
    "update:spellcheck": null,
    "update:stylingMode": null,
    "update:tabIndex": null,
    "update:text": null,
    "update:useMaskedValue": null,
    "update:validationError": null,
    "update:validationErrors": null,
    "update:validationMessageMode": null,
    "update:validationMessagePosition": null,
    "update:validationStatus": null,
    "update:value": null,
    "update:valueChangeEvent": null,
    "update:visible": null,
    "update:width": null
  },
  model: { prop: "value", event: "update:value" },
  computed: {
    instance() {
      return this.$_instance;
    }
  },
  beforeCreate() {
    this.$_WidgetClass = ma, this.$_hasAsyncTemplate = !0, this.$_expectedChildren = {
      button: { isCollectionItem: !0, optionName: "buttons" }
    };
  }
};
io(hP);
const pie = /* @__PURE__ */ A(hP), pP = {
  emits: {
    "update:isActive": null,
    "update:hoveredElement": null,
    "update:location": null,
    "update:name": null,
    "update:options": null
  },
  props: {
    location: String,
    name: String,
    options: Object
  }
};
k(pP);
const YC = /* @__PURE__ */ A(pP);
YC.$_optionName = "buttons";
YC.$_isCollectionItem = !0;
YC.$_expectedChildren = {
  options: { isCollectionItem: !1, optionName: "options" }
};
const gP = {
  emits: {
    "update:isActive": null,
    "update:hoveredElement": null,
    "update:accessKey": null,
    "update:activeStateEnabled": null,
    "update:bindingOptions": null,
    "update:disabled": null,
    "update:elementAttr": null,
    "update:focusStateEnabled": null,
    "update:height": null,
    "update:hint": null,
    "update:hoverStateEnabled": null,
    "update:icon": null,
    "update:onClick": null,
    "update:onContentReady": null,
    "update:onDisposing": null,
    "update:onInitialized": null,
    "update:onOptionChanged": null,
    "update:rtlEnabled": null,
    "update:stylingMode": null,
    "update:tabIndex": null,
    "update:template": null,
    "update:text": null,
    "update:type": null,
    "update:useSubmitBehavior": null,
    "update:validationGroup": null,
    "update:visible": null,
    "update:width": null
  },
  props: {
    accessKey: String,
    activeStateEnabled: Boolean,
    bindingOptions: Object,
    disabled: Boolean,
    elementAttr: Object,
    focusStateEnabled: Boolean,
    height: [Function, Number, String],
    hint: String,
    hoverStateEnabled: Boolean,
    icon: String,
    onClick: Function,
    onContentReady: Function,
    onDisposing: Function,
    onInitialized: Function,
    onOptionChanged: Function,
    rtlEnabled: Boolean,
    stylingMode: String,
    tabIndex: Number,
    template: {},
    text: String,
    type: String,
    useSubmitBehavior: Boolean,
    validationGroup: String,
    visible: Boolean,
    width: [Function, Number, String]
  }
};
k(gP);
const $ne = /* @__PURE__ */ A(gP);
$ne.$_optionName = "options";
/*!
 * devextreme-vue
 * Version: 24.2.7
 * Build date: Mon Apr 28 2025
 *
 * Copyright (c) 2012 - 2025 Developer Express Inc. ALL RIGHTS RESERVED
 *
 * This software may be modified and distributed under the terms
 * of the MIT license. See the LICENSE file in the root of the project for details.
 *
 * https://github.com/DevExpress/devextreme-vue
 */
const mP = {
  props: {
    accessKey: String,
    activeStateEnabled: Boolean,
    disabled: Boolean,
    elementAttr: Object,
    enableThreeStateBehavior: Boolean,
    focusStateEnabled: Boolean,
    height: [Function, Number, String],
    hint: String,
    hoverStateEnabled: Boolean,
    iconSize: [Number, String],
    isDirty: Boolean,
    isValid: Boolean,
    name: String,
    onContentReady: Function,
    onDisposing: Function,
    onInitialized: Function,
    onOptionChanged: Function,
    onValueChanged: Function,
    readOnly: Boolean,
    rtlEnabled: Boolean,
    tabIndex: Number,
    text: String,
    validationError: {},
    validationErrors: Array,
    validationMessageMode: String,
    validationMessagePosition: String,
    validationStatus: String,
    value: Boolean,
    visible: Boolean,
    width: [Function, Number, String]
  },
  emits: {
    "update:isActive": null,
    "update:hoveredElement": null,
    "update:accessKey": null,
    "update:activeStateEnabled": null,
    "update:disabled": null,
    "update:elementAttr": null,
    "update:enableThreeStateBehavior": null,
    "update:focusStateEnabled": null,
    "update:height": null,
    "update:hint": null,
    "update:hoverStateEnabled": null,
    "update:iconSize": null,
    "update:isDirty": null,
    "update:isValid": null,
    "update:name": null,
    "update:onContentReady": null,
    "update:onDisposing": null,
    "update:onInitialized": null,
    "update:onOptionChanged": null,
    "update:onValueChanged": null,
    "update:readOnly": null,
    "update:rtlEnabled": null,
    "update:tabIndex": null,
    "update:text": null,
    "update:validationError": null,
    "update:validationErrors": null,
    "update:validationMessageMode": null,
    "update:validationMessagePosition": null,
    "update:validationStatus": null,
    "update:value": null,
    "update:visible": null,
    "update:width": null
  },
  model: { prop: "value", event: "update:value" },
  computed: {
    instance() {
      return this.$_instance;
    }
  },
  beforeCreate() {
    this.$_WidgetClass = Qs, this.$_hasAsyncTemplate = !0;
  }
};
io(mP);
const gie = /* @__PURE__ */ A(mP);
class XC extends pi {
  _getDefaultOptions() {
    return I({}, super._getDefaultOptions(), {
      preventScrollEvents: !1
    });
  }
  _getToolbarName() {
    return "dxToolbar";
  }
}
XC.defaultOptions = function(i) {
  pi.defaultOptions(i);
};
xe("dxPopup", XC);
/*!
 * devextreme-vue
 * Version: 24.2.7
 * Build date: Mon Apr 28 2025
 *
 * Copyright (c) 2012 - 2025 Developer Express Inc. ALL RIGHTS RESERVED
 *
 * This software may be modified and distributed under the terms
 * of the MIT license. See the LICENSE file in the root of the project for details.
 *
 * https://github.com/DevExpress/devextreme-vue
 */
const fP = {
  props: {
    accessKey: String,
    animation: Object,
    closeOnOutsideClick: [Boolean, Function],
    container: {},
    contentTemplate: {},
    deferRendering: Boolean,
    disabled: Boolean,
    dragAndResizeArea: {},
    dragEnabled: Boolean,
    dragOutsideBoundary: Boolean,
    enableBodyScroll: Boolean,
    focusStateEnabled: Boolean,
    fullScreen: Boolean,
    height: [Function, Number, String],
    hideOnOutsideClick: [Boolean, Function],
    hideOnParentScroll: Boolean,
    hint: String,
    hoverStateEnabled: Boolean,
    maxHeight: [Function, Number, String],
    maxWidth: [Function, Number, String],
    minHeight: [Function, Number, String],
    minWidth: [Function, Number, String],
    onContentReady: Function,
    onDisposing: Function,
    onHidden: Function,
    onHiding: Function,
    onInitialized: Function,
    onOptionChanged: Function,
    onResize: Function,
    onResizeEnd: Function,
    onResizeStart: Function,
    onShowing: Function,
    onShown: Function,
    onTitleRendered: Function,
    position: [Function, String, Object],
    resizeEnabled: Boolean,
    restorePosition: Boolean,
    rtlEnabled: Boolean,
    shading: Boolean,
    shadingColor: String,
    showCloseButton: Boolean,
    showTitle: Boolean,
    tabIndex: Number,
    title: String,
    titleTemplate: {},
    toolbarItems: Array,
    visible: Boolean,
    width: [Function, Number, String],
    wrapperAttr: {}
  },
  emits: {
    "update:isActive": null,
    "update:hoveredElement": null,
    "update:accessKey": null,
    "update:animation": null,
    "update:closeOnOutsideClick": null,
    "update:container": null,
    "update:contentTemplate": null,
    "update:deferRendering": null,
    "update:disabled": null,
    "update:dragAndResizeArea": null,
    "update:dragEnabled": null,
    "update:dragOutsideBoundary": null,
    "update:enableBodyScroll": null,
    "update:focusStateEnabled": null,
    "update:fullScreen": null,
    "update:height": null,
    "update:hideOnOutsideClick": null,
    "update:hideOnParentScroll": null,
    "update:hint": null,
    "update:hoverStateEnabled": null,
    "update:maxHeight": null,
    "update:maxWidth": null,
    "update:minHeight": null,
    "update:minWidth": null,
    "update:onContentReady": null,
    "update:onDisposing": null,
    "update:onHidden": null,
    "update:onHiding": null,
    "update:onInitialized": null,
    "update:onOptionChanged": null,
    "update:onResize": null,
    "update:onResizeEnd": null,
    "update:onResizeStart": null,
    "update:onShowing": null,
    "update:onShown": null,
    "update:onTitleRendered": null,
    "update:position": null,
    "update:resizeEnabled": null,
    "update:restorePosition": null,
    "update:rtlEnabled": null,
    "update:shading": null,
    "update:shadingColor": null,
    "update:showCloseButton": null,
    "update:showTitle": null,
    "update:tabIndex": null,
    "update:title": null,
    "update:titleTemplate": null,
    "update:toolbarItems": null,
    "update:visible": null,
    "update:width": null,
    "update:wrapperAttr": null
  },
  computed: {
    instance() {
      return this.$_instance;
    }
  },
  beforeCreate() {
    this.$_WidgetClass = XC, this.$_hasAsyncTemplate = !0, this.$_expectedChildren = {
      animation: { isCollectionItem: !1, optionName: "animation" },
      position: { isCollectionItem: !1, optionName: "position" },
      toolbarItem: { isCollectionItem: !0, optionName: "toolbarItems" }
    };
  }
};
io(fP);
const mie = /* @__PURE__ */ A(fP), _P = {
  emits: {
    "update:isActive": null,
    "update:hoveredElement": null,
    "update:hide": null,
    "update:show": null
  },
  props: {
    hide: [Object, Number, String],
    show: [Object, Number, String]
  }
};
k(_P);
const CP = /* @__PURE__ */ A(_P);
CP.$_optionName = "animation";
CP.$_expectedChildren = {
  hide: { isCollectionItem: !1, optionName: "hide" },
  show: { isCollectionItem: !1, optionName: "show" }
};
const vP = {
  emits: {
    "update:isActive": null,
    "update:hoveredElement": null,
    "update:x": null,
    "update:y": null
  },
  props: {
    x: String,
    y: String
  }
};
k(vP);
const Nne = /* @__PURE__ */ A(vP);
Nne.$_optionName = "at";
const xP = {
  emits: {
    "update:isActive": null,
    "update:hoveredElement": null,
    "update:x": null,
    "update:y": null
  },
  props: {
    x: Number,
    y: Number
  }
};
k(xP);
const Lne = /* @__PURE__ */ A(xP);
Lne.$_optionName = "boundaryOffset";
const yP = {
  emits: {
    "update:isActive": null,
    "update:hoveredElement": null,
    "update:x": null,
    "update:y": null
  },
  props: {
    x: String,
    y: String
  }
};
k(yP);
const Hne = /* @__PURE__ */ A(yP);
Hne.$_optionName = "collision";
const bP = {
  emits: {
    "update:isActive": null,
    "update:hoveredElement": null,
    "update:left": null,
    "update:opacity": null,
    "update:position": null,
    "update:scale": null,
    "update:top": null
  },
  props: {
    left: Number,
    opacity: Number,
    position: Object,
    scale: Number,
    top: Number
  }
};
k(bP);
const wP = /* @__PURE__ */ A(bP);
wP.$_optionName = "from";
wP.$_expectedChildren = {
  position: { isCollectionItem: !1, optionName: "position" }
};
const SP = {
  emits: {
    "update:isActive": null,
    "update:hoveredElement": null,
    "update:complete": null,
    "update:delay": null,
    "update:direction": null,
    "update:duration": null,
    "update:easing": null,
    "update:from": null,
    "update:staggerDelay": null,
    "update:start": null,
    "update:to": null,
    "update:type": null
  },
  props: {
    complete: Function,
    delay: Number,
    direction: String,
    duration: Number,
    easing: String,
    from: Object,
    staggerDelay: Number,
    start: Function,
    to: Object,
    type: String
  }
};
k(SP);
const EP = /* @__PURE__ */ A(SP);
EP.$_optionName = "hide";
EP.$_expectedChildren = {
  from: { isCollectionItem: !1, optionName: "from" },
  to: { isCollectionItem: !1, optionName: "to" }
};
const IP = {
  emits: {
    "update:isActive": null,
    "update:hoveredElement": null,
    "update:x": null,
    "update:y": null
  },
  props: {
    x: String,
    y: String
  }
};
k(IP);
const Wne = /* @__PURE__ */ A(IP);
Wne.$_optionName = "my";
const DP = {
  emits: {
    "update:isActive": null,
    "update:hoveredElement": null,
    "update:x": null,
    "update:y": null
  },
  props: {
    x: Number,
    y: Number
  }
};
k(DP);
const zne = /* @__PURE__ */ A(DP);
zne.$_optionName = "offset";
const TP = {
  emits: {
    "update:isActive": null,
    "update:hoveredElement": null,
    "update:at": null,
    "update:boundary": null,
    "update:boundaryOffset": null,
    "update:collision": null,
    "update:my": null,
    "update:of": null,
    "update:offset": null
  },
  props: {
    at: [Object, String],
    boundary: {},
    boundaryOffset: [Object, String],
    collision: [String, Object],
    my: [Object, String],
    of: {},
    offset: [Object, String]
  }
};
k(TP);
const OP = /* @__PURE__ */ A(TP);
OP.$_optionName = "position";
OP.$_expectedChildren = {
  at: { isCollectionItem: !1, optionName: "at" },
  boundaryOffset: { isCollectionItem: !1, optionName: "boundaryOffset" },
  collision: { isCollectionItem: !1, optionName: "collision" },
  my: { isCollectionItem: !1, optionName: "my" },
  offset: { isCollectionItem: !1, optionName: "offset" }
};
const AP = {
  emits: {
    "update:isActive": null,
    "update:hoveredElement": null,
    "update:complete": null,
    "update:delay": null,
    "update:direction": null,
    "update:duration": null,
    "update:easing": null,
    "update:from": null,
    "update:staggerDelay": null,
    "update:start": null,
    "update:to": null,
    "update:type": null
  },
  props: {
    complete: Function,
    delay: Number,
    direction: String,
    duration: Number,
    easing: String,
    from: Object,
    staggerDelay: Number,
    start: Function,
    to: Object,
    type: String
  }
};
k(AP);
const RP = /* @__PURE__ */ A(AP);
RP.$_optionName = "show";
RP.$_expectedChildren = {
  from: { isCollectionItem: !1, optionName: "from" },
  to: { isCollectionItem: !1, optionName: "to" }
};
const FP = {
  emits: {
    "update:isActive": null,
    "update:hoveredElement": null,
    "update:left": null,
    "update:opacity": null,
    "update:position": null,
    "update:scale": null,
    "update:top": null
  },
  props: {
    left: Number,
    opacity: Number,
    position: Object,
    scale: Number,
    top: Number
  }
};
k(FP);
const kP = /* @__PURE__ */ A(FP);
kP.$_optionName = "to";
kP.$_expectedChildren = {
  position: { isCollectionItem: !1, optionName: "position" }
};
const VP = {
  emits: {
    "update:isActive": null,
    "update:hoveredElement": null,
    "update:cssClass": null,
    "update:disabled": null,
    "update:html": null,
    "update:locateInMenu": null,
    "update:location": null,
    "update:menuItemTemplate": null,
    "update:options": null,
    "update:showText": null,
    "update:template": null,
    "update:text": null,
    "update:toolbar": null,
    "update:visible": null,
    "update:widget": null
  },
  props: {
    cssClass: String,
    disabled: Boolean,
    html: String,
    locateInMenu: String,
    location: String,
    menuItemTemplate: {},
    options: {},
    showText: String,
    template: {},
    text: String,
    toolbar: String,
    visible: Boolean,
    widget: String
  }
};
k(VP);
const PP = /* @__PURE__ */ A(VP);
PP.$_optionName = "toolbarItems";
PP.$_isCollectionItem = !0;
/*!
 * devextreme-vue
 * Version: 24.2.7
 * Build date: Mon Apr 28 2025
 *
 * Copyright (c) 2012 - 2025 Developer Express Inc. ALL RIGHTS RESERVED
 *
 * This software may be modified and distributed under the terms
 * of the MIT license. See the LICENSE file in the root of the project for details.
 *
 * https://github.com/DevExpress/devextreme-vue
 */
const MP = {
  props: {
    accessKey: String,
    activeStateEnabled: Boolean,
    alignItemLabels: Boolean,
    alignItemLabelsInAllGroups: Boolean,
    colCount: [String, Number],
    colCountByScreen: Object,
    customizeItem: Function,
    disabled: Boolean,
    elementAttr: Object,
    focusStateEnabled: Boolean,
    formData: {},
    height: [Function, Number, String],
    hint: String,
    hoverStateEnabled: Boolean,
    isDirty: Boolean,
    items: Array,
    labelLocation: String,
    labelMode: String,
    minColWidth: Number,
    onContentReady: Function,
    onDisposing: Function,
    onEditorEnterKey: Function,
    onFieldDataChanged: Function,
    onInitialized: Function,
    onOptionChanged: Function,
    optionalMark: String,
    readOnly: Boolean,
    requiredMark: String,
    requiredMessage: String,
    rtlEnabled: Boolean,
    screenByWidth: Function,
    scrollingEnabled: Boolean,
    showColonAfterLabel: Boolean,
    showOptionalMark: Boolean,
    showRequiredMark: Boolean,
    showValidationSummary: Boolean,
    tabIndex: Number,
    validationGroup: String,
    visible: Boolean,
    width: [Function, Number, String]
  },
  emits: {
    "update:isActive": null,
    "update:hoveredElement": null,
    "update:accessKey": null,
    "update:activeStateEnabled": null,
    "update:alignItemLabels": null,
    "update:alignItemLabelsInAllGroups": null,
    "update:colCount": null,
    "update:colCountByScreen": null,
    "update:customizeItem": null,
    "update:disabled": null,
    "update:elementAttr": null,
    "update:focusStateEnabled": null,
    "update:formData": null,
    "update:height": null,
    "update:hint": null,
    "update:hoverStateEnabled": null,
    "update:isDirty": null,
    "update:items": null,
    "update:labelLocation": null,
    "update:labelMode": null,
    "update:minColWidth": null,
    "update:onContentReady": null,
    "update:onDisposing": null,
    "update:onEditorEnterKey": null,
    "update:onFieldDataChanged": null,
    "update:onInitialized": null,
    "update:onOptionChanged": null,
    "update:optionalMark": null,
    "update:readOnly": null,
    "update:requiredMark": null,
    "update:requiredMessage": null,
    "update:rtlEnabled": null,
    "update:screenByWidth": null,
    "update:scrollingEnabled": null,
    "update:showColonAfterLabel": null,
    "update:showOptionalMark": null,
    "update:showRequiredMark": null,
    "update:showValidationSummary": null,
    "update:tabIndex": null,
    "update:validationGroup": null,
    "update:visible": null,
    "update:width": null
  },
  computed: {
    instance() {
      return this.$_instance;
    }
  },
  beforeCreate() {
    this.$_WidgetClass = Eh, this.$_hasAsyncTemplate = !0, this.$_expectedChildren = {
      ButtonItem: { isCollectionItem: !0, optionName: "items" },
      colCountByScreen: { isCollectionItem: !1, optionName: "colCountByScreen" },
      EmptyItem: { isCollectionItem: !0, optionName: "items" },
      GroupItem: { isCollectionItem: !0, optionName: "items" },
      item: { isCollectionItem: !0, optionName: "items" },
      SimpleItem: { isCollectionItem: !0, optionName: "items" },
      TabbedItem: { isCollectionItem: !0, optionName: "items" }
    };
  }
};
io(MP);
const fie = /* @__PURE__ */ A(MP), BP = {
  emits: {
    "update:isActive": null,
    "update:hoveredElement": null,
    "update:ignoreEmptyValue": null,
    "update:message": null,
    "update:reevaluate": null,
    "update:type": null,
    "update:validationCallback": null
  },
  props: {
    ignoreEmptyValue: Boolean,
    message: String,
    reevaluate: Boolean,
    type: String,
    validationCallback: Function
  }
};
k(BP);
const ZC = /* @__PURE__ */ A(BP);
ZC.$_optionName = "validationRules";
ZC.$_isCollectionItem = !0;
ZC.$_predefinedProps = {
  type: "async"
};
const $P = {
  emits: {
    "update:isActive": null,
    "update:hoveredElement": null,
    "update:buttonOptions": null,
    "update:colSpan": null,
    "update:cssClass": null,
    "update:horizontalAlignment": null,
    "update:itemType": null,
    "update:name": null,
    "update:verticalAlignment": null,
    "update:visible": null,
    "update:visibleIndex": null
  },
  props: {
    buttonOptions: Object,
    colSpan: Number,
    cssClass: String,
    horizontalAlignment: String,
    itemType: String,
    name: String,
    verticalAlignment: String,
    visible: Boolean,
    visibleIndex: Number
  }
};
k($P);
const Oh = /* @__PURE__ */ A($P);
Oh.$_optionName = "items";
Oh.$_isCollectionItem = !0;
Oh.$_predefinedProps = {
  itemType: "button"
};
Oh.$_expectedChildren = {
  buttonOptions: { isCollectionItem: !1, optionName: "buttonOptions" }
};
const NP = {
  emits: {
    "update:isActive": null,
    "update:hoveredElement": null,
    "update:accessKey": null,
    "update:activeStateEnabled": null,
    "update:bindingOptions": null,
    "update:disabled": null,
    "update:elementAttr": null,
    "update:focusStateEnabled": null,
    "update:height": null,
    "update:hint": null,
    "update:hoverStateEnabled": null,
    "update:icon": null,
    "update:onClick": null,
    "update:onContentReady": null,
    "update:onDisposing": null,
    "update:onInitialized": null,
    "update:onOptionChanged": null,
    "update:rtlEnabled": null,
    "update:stylingMode": null,
    "update:tabIndex": null,
    "update:template": null,
    "update:text": null,
    "update:type": null,
    "update:useSubmitBehavior": null,
    "update:validationGroup": null,
    "update:visible": null,
    "update:width": null
  },
  props: {
    accessKey: String,
    activeStateEnabled: Boolean,
    bindingOptions: Object,
    disabled: Boolean,
    elementAttr: Object,
    focusStateEnabled: Boolean,
    height: [Function, Number, String],
    hint: String,
    hoverStateEnabled: Boolean,
    icon: String,
    onClick: Function,
    onContentReady: Function,
    onDisposing: Function,
    onInitialized: Function,
    onOptionChanged: Function,
    rtlEnabled: Boolean,
    stylingMode: String,
    tabIndex: Number,
    template: {},
    text: String,
    type: String,
    useSubmitBehavior: Boolean,
    validationGroup: String,
    visible: Boolean,
    width: [Function, Number, String]
  }
};
k(NP);
const Kne = /* @__PURE__ */ A(NP);
Kne.$_optionName = "buttonOptions";
const LP = {
  emits: {
    "update:isActive": null,
    "update:hoveredElement": null,
    "update:lg": null,
    "update:md": null,
    "update:sm": null,
    "update:xs": null
  },
  props: {
    lg: Number,
    md: Number,
    sm: Number,
    xs: Number
  }
};
k(LP);
const Gne = /* @__PURE__ */ A(LP);
Gne.$_optionName = "colCountByScreen";
const HP = {
  emits: {
    "update:isActive": null,
    "update:hoveredElement": null,
    "update:comparisonTarget": null,
    "update:comparisonType": null,
    "update:ignoreEmptyValue": null,
    "update:message": null,
    "update:type": null
  },
  props: {
    comparisonTarget: Function,
    comparisonType: String,
    ignoreEmptyValue: Boolean,
    message: String,
    type: String
  }
};
k(HP);
const QC = /* @__PURE__ */ A(HP);
QC.$_optionName = "validationRules";
QC.$_isCollectionItem = !0;
QC.$_predefinedProps = {
  type: "compare"
};
const WP = {
  emits: {
    "update:isActive": null,
    "update:hoveredElement": null,
    "update:ignoreEmptyValue": null,
    "update:message": null,
    "update:reevaluate": null,
    "update:type": null,
    "update:validationCallback": null
  },
  props: {
    ignoreEmptyValue: Boolean,
    message: String,
    reevaluate: Boolean,
    type: String,
    validationCallback: Function
  }
};
k(WP);
const JC = /* @__PURE__ */ A(WP);
JC.$_optionName = "validationRules";
JC.$_isCollectionItem = !0;
JC.$_predefinedProps = {
  type: "custom"
};
const zP = {
  emits: {
    "update:isActive": null,
    "update:hoveredElement": null,
    "update:ignoreEmptyValue": null,
    "update:message": null,
    "update:type": null
  },
  props: {
    ignoreEmptyValue: Boolean,
    message: String,
    type: String
  }
};
k(zP);
const ev = /* @__PURE__ */ A(zP);
ev.$_optionName = "validationRules";
ev.$_isCollectionItem = !0;
ev.$_predefinedProps = {
  type: "email"
};
const KP = {
  emits: {
    "update:isActive": null,
    "update:hoveredElement": null,
    "update:colSpan": null,
    "update:cssClass": null,
    "update:itemType": null,
    "update:name": null,
    "update:visible": null,
    "update:visibleIndex": null
  },
  props: {
    colSpan: Number,
    cssClass: String,
    itemType: String,
    name: String,
    visible: Boolean,
    visibleIndex: Number
  }
};
k(KP);
const tv = /* @__PURE__ */ A(KP);
tv.$_optionName = "items";
tv.$_isCollectionItem = !0;
tv.$_predefinedProps = {
  itemType: "empty"
};
const GP = {
  emits: {
    "update:isActive": null,
    "update:hoveredElement": null,
    "update:alignItemLabels": null,
    "update:caption": null,
    "update:captionTemplate": null,
    "update:colCount": null,
    "update:colCountByScreen": null,
    "update:colSpan": null,
    "update:cssClass": null,
    "update:items": null,
    "update:itemType": null,
    "update:name": null,
    "update:template": null,
    "update:visible": null,
    "update:visibleIndex": null
  },
  props: {
    alignItemLabels: Boolean,
    caption: String,
    captionTemplate: {},
    colCount: Number,
    colCountByScreen: Object,
    colSpan: Number,
    cssClass: String,
    items: Array,
    itemType: String,
    name: String,
    template: {},
    visible: Boolean,
    visibleIndex: Number
  }
};
k(GP);
const Ah = /* @__PURE__ */ A(GP);
Ah.$_optionName = "items";
Ah.$_isCollectionItem = !0;
Ah.$_predefinedProps = {
  itemType: "group"
};
Ah.$_expectedChildren = {
  colCountByScreen: { isCollectionItem: !1, optionName: "colCountByScreen" }
};
const UP = {
  emits: {
    "update:isActive": null,
    "update:hoveredElement": null,
    "update:alignItemLabels": null,
    "update:badge": null,
    "update:buttonOptions": null,
    "update:caption": null,
    "update:captionTemplate": null,
    "update:colCount": null,
    "update:colCountByScreen": null,
    "update:colSpan": null,
    "update:cssClass": null,
    "update:dataField": null,
    "update:disabled": null,
    "update:editorOptions": null,
    "update:editorType": null,
    "update:helpText": null,
    "update:horizontalAlignment": null,
    "update:html": null,
    "update:icon": null,
    "update:isRequired": null,
    "update:items": null,
    "update:itemType": null,
    "update:label": null,
    "update:name": null,
    "update:tabPanelOptions": null,
    "update:tabs": null,
    "update:tabTemplate": null,
    "update:template": null,
    "update:text": null,
    "update:title": null,
    "update:validationRules": null,
    "update:verticalAlignment": null,
    "update:visible": null,
    "update:visibleIndex": null
  },
  props: {
    alignItemLabels: Boolean,
    badge: String,
    buttonOptions: Object,
    caption: String,
    captionTemplate: {},
    colCount: Number,
    colCountByScreen: Object,
    colSpan: Number,
    cssClass: String,
    dataField: String,
    disabled: Boolean,
    editorOptions: {},
    editorType: String,
    helpText: String,
    horizontalAlignment: String,
    html: String,
    icon: String,
    isRequired: Boolean,
    items: Array,
    itemType: String,
    label: Object,
    name: String,
    tabPanelOptions: Object,
    tabs: Array,
    tabTemplate: {},
    template: {},
    text: String,
    title: String,
    validationRules: Array,
    verticalAlignment: String,
    visible: Boolean,
    visibleIndex: Number
  }
};
k(UP);
const nv = /* @__PURE__ */ A(UP);
nv.$_optionName = "items";
nv.$_isCollectionItem = !0;
nv.$_expectedChildren = {
  AsyncRule: { isCollectionItem: !0, optionName: "validationRules" },
  buttonOptions: { isCollectionItem: !1, optionName: "buttonOptions" },
  colCountByScreen: { isCollectionItem: !1, optionName: "colCountByScreen" },
  CompareRule: { isCollectionItem: !0, optionName: "validationRules" },
  CustomRule: { isCollectionItem: !0, optionName: "validationRules" },
  EmailRule: { isCollectionItem: !0, optionName: "validationRules" },
  label: { isCollectionItem: !1, optionName: "label" },
  NumericRule: { isCollectionItem: !0, optionName: "validationRules" },
  PatternRule: { isCollectionItem: !0, optionName: "validationRules" },
  RangeRule: { isCollectionItem: !0, optionName: "validationRules" },
  RequiredRule: { isCollectionItem: !0, optionName: "validationRules" },
  StringLengthRule: { isCollectionItem: !0, optionName: "validationRules" },
  tab: { isCollectionItem: !0, optionName: "tabs" },
  tabPanelOptions: { isCollectionItem: !1, optionName: "tabPanelOptions" },
  validationRule: { isCollectionItem: !0, optionName: "validationRules" }
};
const jP = {
  emits: {
    "update:isActive": null,
    "update:hoveredElement": null,
    "update:alignment": null,
    "update:location": null,
    "update:showColon": null,
    "update:template": null,
    "update:text": null,
    "update:visible": null
  },
  props: {
    alignment: String,
    location: String,
    showColon: Boolean,
    template: {},
    text: String,
    visible: Boolean
  }
};
k(jP);
const Une = /* @__PURE__ */ A(jP);
Une.$_optionName = "label";
const qP = {
  emits: {
    "update:isActive": null,
    "update:hoveredElement": null,
    "update:ignoreEmptyValue": null,
    "update:message": null,
    "update:type": null
  },
  props: {
    ignoreEmptyValue: Boolean,
    message: String,
    type: String
  }
};
k(qP);
const iv = /* @__PURE__ */ A(qP);
iv.$_optionName = "validationRules";
iv.$_isCollectionItem = !0;
iv.$_predefinedProps = {
  type: "numeric"
};
const YP = {
  emits: {
    "update:isActive": null,
    "update:hoveredElement": null,
    "update:ignoreEmptyValue": null,
    "update:message": null,
    "update:pattern": null,
    "update:type": null
  },
  props: {
    ignoreEmptyValue: Boolean,
    message: String,
    pattern: [RegExp, String],
    type: String
  }
};
k(YP);
const sv = /* @__PURE__ */ A(YP);
sv.$_optionName = "validationRules";
sv.$_isCollectionItem = !0;
sv.$_predefinedProps = {
  type: "pattern"
};
const XP = {
  emits: {
    "update:isActive": null,
    "update:hoveredElement": null,
    "update:ignoreEmptyValue": null,
    "update:max": null,
    "update:message": null,
    "update:min": null,
    "update:reevaluate": null,
    "update:type": null
  },
  props: {
    ignoreEmptyValue: Boolean,
    max: [Date, Number, String],
    message: String,
    min: [Date, Number, String],
    reevaluate: Boolean,
    type: String
  }
};
k(XP);
const ov = /* @__PURE__ */ A(XP);
ov.$_optionName = "validationRules";
ov.$_isCollectionItem = !0;
ov.$_predefinedProps = {
  type: "range"
};
const ZP = {
  emits: {
    "update:isActive": null,
    "update:hoveredElement": null,
    "update:message": null,
    "update:trim": null,
    "update:type": null
  },
  props: {
    message: String,
    trim: Boolean,
    type: String
  }
};
k(ZP);
const rv = /* @__PURE__ */ A(ZP);
rv.$_optionName = "validationRules";
rv.$_isCollectionItem = !0;
rv.$_predefinedProps = {
  type: "required"
};
const QP = {
  emits: {
    "update:isActive": null,
    "update:hoveredElement": null,
    "update:colSpan": null,
    "update:cssClass": null,
    "update:dataField": null,
    "update:editorOptions": null,
    "update:editorType": null,
    "update:helpText": null,
    "update:isRequired": null,
    "update:itemType": null,
    "update:label": null,
    "update:name": null,
    "update:template": null,
    "update:validationRules": null,
    "update:visible": null,
    "update:visibleIndex": null
  },
  props: {
    colSpan: Number,
    cssClass: String,
    dataField: String,
    editorOptions: {},
    editorType: String,
    helpText: String,
    isRequired: Boolean,
    itemType: String,
    label: Object,
    name: String,
    template: {},
    validationRules: Array,
    visible: Boolean,
    visibleIndex: Number
  }
};
k(QP);
const Rh = /* @__PURE__ */ A(QP);
Rh.$_optionName = "items";
Rh.$_isCollectionItem = !0;
Rh.$_predefinedProps = {
  itemType: "simple"
};
Rh.$_expectedChildren = {
  AsyncRule: { isCollectionItem: !0, optionName: "validationRules" },
  CompareRule: { isCollectionItem: !0, optionName: "validationRules" },
  CustomRule: { isCollectionItem: !0, optionName: "validationRules" },
  EmailRule: { isCollectionItem: !0, optionName: "validationRules" },
  label: { isCollectionItem: !1, optionName: "label" },
  NumericRule: { isCollectionItem: !0, optionName: "validationRules" },
  PatternRule: { isCollectionItem: !0, optionName: "validationRules" },
  RangeRule: { isCollectionItem: !0, optionName: "validationRules" },
  RequiredRule: { isCollectionItem: !0, optionName: "validationRules" },
  StringLengthRule: { isCollectionItem: !0, optionName: "validationRules" },
  validationRule: { isCollectionItem: !0, optionName: "validationRules" }
};
const JP = {
  emits: {
    "update:isActive": null,
    "update:hoveredElement": null,
    "update:ignoreEmptyValue": null,
    "update:max": null,
    "update:message": null,
    "update:min": null,
    "update:trim": null,
    "update:type": null
  },
  props: {
    ignoreEmptyValue: Boolean,
    max: Number,
    message: String,
    min: Number,
    trim: Boolean,
    type: String
  }
};
k(JP);
const av = /* @__PURE__ */ A(JP);
av.$_optionName = "validationRules";
av.$_isCollectionItem = !0;
av.$_predefinedProps = {
  type: "stringLength"
};
const eM = {
  emits: {
    "update:isActive": null,
    "update:hoveredElement": null,
    "update:alignItemLabels": null,
    "update:badge": null,
    "update:colCount": null,
    "update:colCountByScreen": null,
    "update:disabled": null,
    "update:icon": null,
    "update:items": null,
    "update:tabTemplate": null,
    "update:template": null,
    "update:title": null
  },
  props: {
    alignItemLabels: Boolean,
    badge: String,
    colCount: Number,
    colCountByScreen: Object,
    disabled: Boolean,
    icon: String,
    items: Array,
    tabTemplate: {},
    template: {},
    title: String
  }
};
k(eM);
const lv = /* @__PURE__ */ A(eM);
lv.$_optionName = "tabs";
lv.$_isCollectionItem = !0;
lv.$_expectedChildren = {
  colCountByScreen: { isCollectionItem: !1, optionName: "colCountByScreen" }
};
const tM = {
  emits: {
    "update:isActive": null,
    "update:hoveredElement": null,
    "update:colSpan": null,
    "update:cssClass": null,
    "update:itemType": null,
    "update:name": null,
    "update:tabPanelOptions": null,
    "update:tabs": null,
    "update:visible": null,
    "update:visibleIndex": null
  },
  props: {
    colSpan: Number,
    cssClass: String,
    itemType: String,
    name: String,
    tabPanelOptions: Object,
    tabs: Array,
    visible: Boolean,
    visibleIndex: Number
  }
};
k(tM);
const Fh = /* @__PURE__ */ A(tM);
Fh.$_optionName = "items";
Fh.$_isCollectionItem = !0;
Fh.$_predefinedProps = {
  itemType: "tabbed"
};
Fh.$_expectedChildren = {
  tab: { isCollectionItem: !0, optionName: "tabs" },
  tabPanelOptions: { isCollectionItem: !1, optionName: "tabPanelOptions" }
};
const nM = {
  emits: {
    "update:isActive": null,
    "update:hoveredElement": null,
    "update:accessKey": null,
    "update:activeStateEnabled": null,
    "update:animationEnabled": null,
    "update:bindingOptions": null,
    "update:dataSource": null,
    "update:deferRendering": null,
    "update:disabled": null,
    "update:elementAttr": null,
    "update:focusStateEnabled": null,
    "update:height": null,
    "update:hint": null,
    "update:hoverStateEnabled": null,
    "update:iconPosition": null,
    "update:itemHoldTimeout": null,
    "update:items": null,
    "update:itemTemplate": null,
    "update:itemTitleTemplate": null,
    "update:loop": null,
    "update:noDataText": null,
    "update:onContentReady": null,
    "update:onDisposing": null,
    "update:onInitialized": null,
    "update:onItemClick": null,
    "update:onItemContextMenu": null,
    "update:onItemHold": null,
    "update:onItemRendered": null,
    "update:onOptionChanged": null,
    "update:onSelectionChanged": null,
    "update:onSelectionChanging": null,
    "update:onTitleClick": null,
    "update:onTitleHold": null,
    "update:onTitleRendered": null,
    "update:repaintChangesOnly": null,
    "update:rtlEnabled": null,
    "update:scrollByContent": null,
    "update:scrollingEnabled": null,
    "update:selectedIndex": null,
    "update:selectedItem": null,
    "update:showNavButtons": null,
    "update:stylingMode": null,
    "update:swipeEnabled": null,
    "update:tabIndex": null,
    "update:tabsPosition": null,
    "update:visible": null,
    "update:width": null
  },
  props: {
    accessKey: String,
    activeStateEnabled: Boolean,
    animationEnabled: Boolean,
    bindingOptions: Object,
    dataSource: [Array, Object, String],
    deferRendering: Boolean,
    disabled: Boolean,
    elementAttr: Object,
    focusStateEnabled: Boolean,
    height: [Function, Number, String],
    hint: String,
    hoverStateEnabled: Boolean,
    iconPosition: String,
    itemHoldTimeout: Number,
    items: Array,
    itemTemplate: {},
    itemTitleTemplate: {},
    loop: Boolean,
    noDataText: String,
    onContentReady: Function,
    onDisposing: Function,
    onInitialized: Function,
    onItemClick: Function,
    onItemContextMenu: Function,
    onItemHold: Function,
    onItemRendered: Function,
    onOptionChanged: Function,
    onSelectionChanged: Function,
    onSelectionChanging: Function,
    onTitleClick: Function,
    onTitleHold: Function,
    onTitleRendered: Function,
    repaintChangesOnly: Boolean,
    rtlEnabled: Boolean,
    scrollByContent: Boolean,
    scrollingEnabled: Boolean,
    selectedIndex: Number,
    selectedItem: {},
    showNavButtons: Boolean,
    stylingMode: String,
    swipeEnabled: Boolean,
    tabIndex: Number,
    tabsPosition: String,
    visible: Boolean,
    width: [Function, Number, String]
  }
};
k(nM);
const iM = /* @__PURE__ */ A(nM);
iM.$_optionName = "tabPanelOptions";
iM.$_expectedChildren = {
  item: { isCollectionItem: !0, optionName: "items" },
  tabPanelOptionsItem: { isCollectionItem: !0, optionName: "items" }
};
const sM = {
  emits: {
    "update:isActive": null,
    "update:hoveredElement": null,
    "update:badge": null,
    "update:disabled": null,
    "update:html": null,
    "update:icon": null,
    "update:tabTemplate": null,
    "update:template": null,
    "update:text": null,
    "update:title": null,
    "update:visible": null
  },
  props: {
    badge: String,
    disabled: Boolean,
    html: String,
    icon: String,
    tabTemplate: {},
    template: {},
    text: String,
    title: String,
    visible: Boolean
  }
};
k(sM);
const oM = /* @__PURE__ */ A(sM);
oM.$_optionName = "items";
oM.$_isCollectionItem = !0;
const rM = {
  emits: {
    "update:isActive": null,
    "update:hoveredElement": null,
    "update:comparisonTarget": null,
    "update:comparisonType": null,
    "update:ignoreEmptyValue": null,
    "update:max": null,
    "update:message": null,
    "update:min": null,
    "update:pattern": null,
    "update:reevaluate": null,
    "update:trim": null,
    "update:type": null,
    "update:validationCallback": null
  },
  props: {
    comparisonTarget: Function,
    comparisonType: String,
    ignoreEmptyValue: Boolean,
    max: [Date, Number, String],
    message: String,
    min: [Date, Number, String],
    pattern: [RegExp, String],
    reevaluate: Boolean,
    trim: Boolean,
    type: String,
    validationCallback: Function
  }
};
k(rM);
const dv = /* @__PURE__ */ A(rM);
dv.$_optionName = "validationRules";
dv.$_isCollectionItem = !0;
dv.$_predefinedProps = {
  type: "required"
};
/*!
 * devextreme-vue
 * Version: 24.2.7
 * Build date: Mon Apr 28 2025
 *
 * Copyright (c) 2012 - 2025 Developer Express Inc. ALL RIGHTS RESERVED
 *
 * This software may be modified and distributed under the terms
 * of the MIT license. See the LICENSE file in the root of the project for details.
 *
 * https://github.com/DevExpress/devextreme-vue
 */
const aM = {
  props: {
    accessKey: String,
    dataSource: [Array, Object, String],
    disabled: Boolean,
    elementAttr: Object,
    focusStateEnabled: Boolean,
    height: [Function, Number, String],
    hint: String,
    hoverStateEnabled: Boolean,
    iconPosition: String,
    itemHoldTimeout: Number,
    items: Array,
    itemTemplate: {},
    keyExpr: [Function, String],
    noDataText: String,
    onContentReady: Function,
    onDisposing: Function,
    onInitialized: Function,
    onItemClick: Function,
    onItemContextMenu: Function,
    onItemHold: Function,
    onItemRendered: Function,
    onOptionChanged: Function,
    onSelectionChanged: Function,
    onSelectionChanging: Function,
    orientation: String,
    repaintChangesOnly: Boolean,
    rtlEnabled: Boolean,
    scrollByContent: Boolean,
    scrollingEnabled: Boolean,
    selectedIndex: Number,
    selectedItem: {},
    selectedItemKeys: Array,
    selectedItems: Array,
    selectionMode: String,
    showNavButtons: Boolean,
    stylingMode: String,
    tabIndex: Number,
    visible: Boolean,
    width: [Function, Number, String]
  },
  emits: {
    "update:isActive": null,
    "update:hoveredElement": null,
    "update:accessKey": null,
    "update:dataSource": null,
    "update:disabled": null,
    "update:elementAttr": null,
    "update:focusStateEnabled": null,
    "update:height": null,
    "update:hint": null,
    "update:hoverStateEnabled": null,
    "update:iconPosition": null,
    "update:itemHoldTimeout": null,
    "update:items": null,
    "update:itemTemplate": null,
    "update:keyExpr": null,
    "update:noDataText": null,
    "update:onContentReady": null,
    "update:onDisposing": null,
    "update:onInitialized": null,
    "update:onItemClick": null,
    "update:onItemContextMenu": null,
    "update:onItemHold": null,
    "update:onItemRendered": null,
    "update:onOptionChanged": null,
    "update:onSelectionChanged": null,
    "update:onSelectionChanging": null,
    "update:orientation": null,
    "update:repaintChangesOnly": null,
    "update:rtlEnabled": null,
    "update:scrollByContent": null,
    "update:scrollingEnabled": null,
    "update:selectedIndex": null,
    "update:selectedItem": null,
    "update:selectedItemKeys": null,
    "update:selectedItems": null,
    "update:selectionMode": null,
    "update:showNavButtons": null,
    "update:stylingMode": null,
    "update:tabIndex": null,
    "update:visible": null,
    "update:width": null
  },
  computed: {
    instance() {
      return this.$_instance;
    }
  },
  beforeCreate() {
    this.$_WidgetClass = Sh, this.$_hasAsyncTemplate = !0, this.$_expectedChildren = {
      item: { isCollectionItem: !0, optionName: "items" }
    };
  }
};
io(aM);
const _ie = /* @__PURE__ */ A(aM), lM = {
  emits: {
    "update:isActive": null,
    "update:hoveredElement": null,
    "update:badge": null,
    "update:disabled": null,
    "update:html": null,
    "update:icon": null,
    "update:template": null,
    "update:text": null,
    "update:visible": null
  },
  props: {
    badge: String,
    disabled: Boolean,
    html: String,
    icon: String,
    template: {},
    text: String,
    visible: Boolean
  }
};
k(lM);
const dM = /* @__PURE__ */ A(lM);
dM.$_optionName = "items";
dM.$_isCollectionItem = !0;

export { Yne as DxButton, gie as DxCheckBox, VC as DxColumn, cie as DxDataGrid, hie as DxDropDownBox, fie as DxForm, Ah as DxGroupItem, dne as DxGroupPanel, Nk as DxGrouping, nv as DxItem, Une as DxLabel, vne as DxPager, xne as DxPaging, mie as DxPopup, Sne as DxSearchPanel, Ene as DxSelection, Rh as DxSimpleItem, Dne as DxStateStoring, _ie as DxTabs, pie as DxTextBox, MV as DxToolbar };
//# sourceMappingURL=index.es-c78a5977.js.map
